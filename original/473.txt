Searchable encryption facilitates cloud server to search over encrypted data without decrypting the data. Single keyword based searchable encryption enables a user to access a subset of documents, which contains the keyword of the user's interest. In this paper, we present a single keyword based searchable encryption scheme for the applications where multiple data owners upload their data and then multiple users can access the data. The scheme uses attribute based encryption that allows user to access the selective subset of data from cloud without revealing his/her access rights to the cloud server. The scheme is proven adaptively secure against chosen-keyword attack in the random oracle model. We have implemented the scheme on Google cloud instance and the performance of the scheme found practical in real-world applications.
SECTION 1Introduction
Outsourcing data on public cloud facilitates an attractive business strategy to many organizations because of on-demand data/service availability at cheaper rates in an efficient way. However, security and privacy of data have become important concern to the service provider and the service consumers while adopting cloud service, in particular for public cloud, for organization’s business goal. The outsourced data may contain sensitive information, such as financial records of an individual or organization, bids information submitted for a tender, Personal Health Records (PHRs) and so on, where the data can allow the cloud server or unauthorized users to access and/or infer sensitive information. To address the issue of data privacy and access control, one practical solution is to encrypt the documents before outsourcing them on cloud storage server. Let us consider the applications where multiple data owners use the public cloud storage services to upload their encrypted documents and multiple users can access the documents stored on the cloud storage server. In such applications, applying fine-grained access control policy will enable intended security control on document access.

Attribute Based Encryption (ABE) [1] is an interesting cryptographic algorithm that provides confidentiality of data along with owner-enforced fine-grained access control. With an ABE scheme a data owner can use a set of attribute values (e.g., access policy) for encrypting a message such that only authorized entity who possesses the required set of attribute values can decrypt the ciphertext. With encrypted data, one of the required functionality, searching over database, is a practical requirement for modern cloud storage data. In the area of searchable encryption, various techniques for searching over encrypted data have been introduced. Searchable encryption can help a receiver to securely and selectively retrieve the data from public cloud storage, which is of user’s interest and which is accessible to user. For example, a doctor wants to search for all the records of his patients who have been diagnosed with chronic kidney disease and for which doctor has been provided the access rights to patients medical records, where each report is encrypted and uploaded by the patient. The application of single-user searchable symmetric encryption schemes in such scenario is not an effective mechanism, as the patient requires to encrypt his medical reports with his secret key and then shares this secret key with doctor. Therefore, multi-user searchable symmetric encryption schemes [6], [7], [8] are most effective, as the requirement of search over encrypted data and enforcing access control policy, where a data owner such as patient can generate the shared secret key or search token from his master secret key and issue them to the authorized users (e.g., doctor in our example) for searching over encrypted data. Although these schemes can work in single-sender multi-receiver setup, they can not perform well in multi-sender multi-receiver scenario, because each data sender has to communicate with each of the data receiver in a secure manner to issue the secret key or search token, which will cost large communication overhead. As an alternative, keyword based searching over attribute based encrypted data fulfills both the objectives of searching over encrypted data and enforcing fine-grained access control policy. ABE scheme works well in multi-sender and multi-receiver scenario. It does not require a direct interaction between data owner and data receiver. Many schemes on keyword-based searching over attribute based encrypted data have been proposed in [9], [10], [11], [12] for providing single keyword search capability over attribute based encrypted data. Wang et al.’s scheme [9] provides single keyword based searching along with partial decryption task delegated to the cloud service provider. The scheme in [10] provides the verifiability of search results in addition to searching over encrypted data. The scheme in [11] provides verifiability of keyword search over key policy attribute based encryption. The authors of [12] provided a solution that addresses the issue of data sharing and keyword update in addition to keyword-based search operation over encrypted data. The scheme in [13] provides the disjunctive multi-keyword search facility. Dong et al. [14] presented a scheme that provides an efficient keyword-based searching operation over ABE via an online-offline approach. The scheme in [15] includes proxy re-encryption (PRE) and a secret sharing scheme (SSS) into ABKS. However, in all these schemes the access control policies are in clear form. To preserve the data confidentiality and/or the purpose of the service enquired for, protecting user privacy is an important requirement [2], [3], [4], [5]. The access policy attached with ciphertext in clear form can reveal the receiver attributes which helps adversary in identifying the receiver. For this concern, in many scenarios the access policy is considered as confidential information, as the ciphertext should not reveal the purpose of the contents inside the ciphertext. For example, in healthcare organization, from the access policy of a patient’s medical report, an adversary can guess the information about the disease of the patient. Therefore, in addition to data confidentiality, preserving privacy of data access is a practical requirement, as one could guess the purpose of the ciphertext by identifying the receiver of the ciphertext. If the access policy of an encrypted document is listed in clear form, then it helps the adversary to extract the receiver information, where the receiver information can in turn disclose the statistical information about the encrypted data. To overcome this problem, the access policy must be in hidden form. The hidden access policy preserves privacy of the purpose and target audience of the ciphertext.

1.1 Related Work
There exists many attribute based keyword-searchable encryption schemes [9], [10], [11], [12], [13], [14], [15] in literature. However, these schemes do not address the important issue of receiver anonymity. Koo et al. [16] proposed an author-based search over encrypted data anonymously. However, their scheme is found insecure in [17]. There are a few schemes [18], [19], which provide keyword based searching over attribute based encrypted data with hidden access policy. Shi et al. [18], have presented a scheme, authorized searchable public-key encryption (AS-PKE), in which a data owner decides the access policy for his encrypted data and keeps it hidden inside the ciphertext. The AS-PKE scheme uses the access structure in form of LSSS. If there are n attribute fields in the system, then only one value per attribute can be placed in the scheme to preserve the receiver anonymity. This is less effective when a ciphertext has multiple recipients with different attribute values for one attribute. For example, a patient can encrypt his report and uploads it so that two doctors practicing in two different hospitals can read it and give their opinions. In this case, one of the attributes “Hospital” can have different values for each doctor. The major limitation of the Shi et al.’s scheme is that the user has to acquire the search token from the trusted authority, which increases the per query interaction overhead for search operation on user side. Furthermore, the scheme works in the scenario, where there are fixed number of keyword fields for which the search should be carried out. A user can place a search query with multiple keywords, but the user has to reveal the information about which keyword fields the queried keywords belong to. For example, in a healthcare organization, one of the keyword field is identified as “Disease”. Then a search query for obtaining the reports of patients suffering from “Diabetes” has to reveal the information that the keyword inside the search query belongs to the field of “Disease”, which provides more leakage information to the adversary.

Wang et al. [19] proposed a scheme that supports only one value per attribute in the ciphertext access policy, where the access structure is formed with AND gate on multivalued attributes. However, we found a security flaw in Wang et al.’s scheme. The cipher components Ci, C^ and the public key component g0 reveals the access policy of the scheme in [19]. The flaw is summarized as follows. The public key component g0 is an element of a bilinear group G0 of prime order p. For encryption of a message, the data owner selects a random secret value s from Z∗p and computes C^ = gs0. Suppose that an attribute value vi,j for an attribute i is included in the access policy. The cipher component for the attribute i is created as Ci = H(vi,j)s, where H:{0, 1}∗→G0. In order to check whether vi,j is included in the access policy, the adversary has to verify if
e(g0,Ci)=?e(C^,H(vi,j)).
View SourceRight-click on figure for MathML and additional features.If there are n number of attributes in the system and each attribute is having valueset of maximum size m, then, the whole access policy of a ciphertext can be uncovered by the adversary with no more then (m+1)∗n bilinear pairing operations.

1.2 Our Contributions
We present a privacy preserving single keyword-based searchable encryption scheme (PSE) with fine-grained access control. The proposed PSE scheme provides a keyword based search facility over attribute based encrypted data with hidden access policy. The scheme is applicable in a scenario where there are multiple data owners and multiple data receivers. The scheme allows each user in the system with a set of attribute values, where a trusted authority verifies the user’s attributes and assigns him a secret key. One of the key features of the PSE scheme is that once the secret key obtained, the user can generate the search query himself in the form of a trapdoor using the secret key assigned to him. This is more practical in comparison to Shi et al.’s scheme [18], where for every search the user requires to obtain the search token from a data owner to generate the search query. In PSE scheme, the trapdoor generated by the user neither reveals the keyword used for the search nor the user’s attributes. Each data owner encrypts the index with the help of trusted authority. The trusted authority makes the index secure by using the master secret key elements inside the index. The inclusion of the master secret key elements in the index prevents adversary, who is capable of adaptively generated search queries for chosen keywords, not to learn the keywords from the index. After encryption, the index is uploaded along with the encrypted document on the cloud. When a user sends the trapdoor, the cloud server performs the search operation with the input of trapdoor and encrypted index. The search process is repeated for each encrypted index related to each separate document. The search operation returns true if (1) the keyword inside the trapdoor is included in the index, and (2) the access policy of encrypted index is fulfilled with user’s attributes. We note that despite of having access to encrypted index and trapdoor, the cloud server can only learn the search pattern (i.e., whether two search queries were for the same keyword or not) and access pattern (i.e., the number of indexes for which the search process returns true) from the results of search operation. At the same time, the trapdoor generated by the user neither reveals the keyword used for the search nor the user’s attributes. We show that the PSE scheme is adaptively secure in random oracle model against chosen-keyword attack. We have experimented the PSE scheme on Google cloud instance. We have considered the dataset of keywords included in the patients medical reports. Each index is for an individual report and it contains four keywords such as date of report, time of report, type of report and outcome of report. The evaluation is conducted over 10,000 encrypted indexes with different number of attribute values.

The remaining of the paper is organized as follows. We discuss some preliminaries in Section 2. The PSE scheme is presented in Section 3. Section 4 provides the security analysis and the experimental results of the scheme. We conclude the paper in Section 5.

SECTION 2Preliminaries
2.1 Bilinear Mapping
Let G0 and G1 be two multiplicative cyclic groups of a large prime order p. Let g be a generator of G0 and e be a bilinear map defined as e:G0×G0→G1, satisfying the following properties:

Bilinearity: e(ga,gb)=e(g,g)ab for all a,b,∈Z∗p.

Non-degeneracy: There exists g1, g2∈ G0 such that e(g1,g2)≠1.

There exists an efficient computable algorithm to compute e(g1,g2) for all g1, g2 ∈ G0.

We say that G0 is a bilinear group if it satisfies the above mentioned three properties.

2.2 Decisional Bilinear Diffie-Hellman (DBDH) Assumption
Let a,b,c,z∈Z∗p be chosen at random and g be a generator of G0. The decisional BDH assumption is that no probabilistic polynomial-time algorithm P can distinguish the tuple (A=ga, B=gb, C=gc, e(g,g)abc) from the tuple (A=ga, B=gb, C=gc, e(g,g)z) with more than a negligible advantage ϵdbdh. The advantage of P is Pr[P(A, B, C, e(g,g)abc) = 0] - Pr[P(A, B, C, e(g,g)z) = 0] = ϵdbdh.

2.3 Access Structure
An access structure depicts the access policy for a ciphertext elected by the encryptor. A user can decrypt a ciphertext if the attributes included in his secret key can satisfy the access structure of the ciphertext. We use the access structure built on the policy of “Single AND gate on Multivalued Attributes” as follows: Let there be n attributes in the universe and the attributes are denoted using the notation {A1,A2,…, An}. We use i to indicate the attribute Ai (1 ≤i≤n). Each valueset Vi = {vi,1,vi,2,…,vi,mi} is the set of possible values for an attribute i and mi is the size of set Vi. A ciphertext policy T is defined as T = [T1, T2, …, Tn]. Here, each Ti (Ti⊆ Vi) represents the set of permissible values of an attribute i in order to decrypt the ciphertext. Each user possesses an attribute value list L = [L1, L2, …, Ln], where Li (Li ∈ Vi) represents one value from the valueset Vi. An attribute list L satisfies an access structure T, if Li ∈ Ti for all 1≤i≤n. We define a binary relationship F(L, T), which gives output 1 if L satisfies an access structure T; else, it outputs 0.

SECTION 3PSE: Privacy Preserving Searchable Encryption
We present an attribute based searchable encryption with access policy enforced by the data owner and hidden inside the ciphertext. The scheme is designed with multi-sender and multi-receiver setup, aimed at facilitating a data owner(sender) to encrypt the index of keywords related to his document and uploads it along with the access policy and the encrypted document on cloud storage, where the access policy is decided by the data owner and kept hidden inside the ciphertext. The user(receiver) sends his search query in the form of trapdoor to the cloud storage server. The cloud server uses this trapdoor to search over all encrypted indexes uploaded on the cloud storage. The documents corresponding to the indexes for which the search operation returns true are sent back to the user as the result of his query.

3.1 System Model
The system model (shown in Fig. 1) of the PSE scheme comprises the following entities.

Attribute Center. The Attribute Centre (AC) is a trusted third party of the system. AC is responsible for generating system parameters and issuing keys to users of the system.

Token Generator. The Token Generator (TG) is a trusted third party of the system, which assists a data owner for generating encrypted index. TG is involved in the process of generating encrypted index. For a small system/organization the AC itself can play the role of the TG. However, in the case of a system with sufficiently large number of users, autonomous entities (e.g., TGs) should play this role.

Data Owner. Data owner encrypts and stores the data on cloud storage server. The encrypted data consists of two parts: (i) the index of encrypted keywords, and (ii) the encrypted document.

Cloud Service Provider. Cloud Service Provider(CSP) provides storage and computation services for the entities of the system.

Receiver (Data) User. Receiver user generates and submits a trapdoor to CSP. The CSP searches over the encrypted indexes using this trapdoor. The documents corresponding to the indexes for which the search operation returns true are returned to the user. Finally, the user decrypts the resultant documents.


Fig. 1.
System model of PSE scheme.

Show All

The data owner runs a protocol with TG to get the encrypted word tokens for creating encrypted index (explained below in Encrypt_Index phase). The involvement of TG is for the inclusion of the master secret key parameters inside the ciphertext components of encrypted index. This is done to make the scheme adaptively secure against chosen-keyword attack. We have chosen to place the TG on data owner side instead of data receiver side, which facilitates a user to generate a trapdoor from his secret key autonomously without waiting for the token from any trusted authority, which ultimately reduces the per-query interaction with the trusted third party and helps to gain efficient response time for search procedure. We note that although TG is involved in the process of encrypted index generation, it is not able to learn the keywords inside the index and the access policy enforced by the data owner for encrypted index.

3.2 Design Goals
Assumptions. It is assumed that AC and TG do not collude with any adversary. We consider the public cloud storage server is semi-trusted, who is honest to perform the work assigned to him, but curious to learn the information from the data stored in it.

Functional Goals. The keywords extracted from a document are encrypted with hidden access policy. After getting a secret key from AC, the user should be able to generate a trapdoor independently. The CSP should be able to perform the search operation efficiently.

Security Goals. The encrypted keyword preserves confidentiality of the keyword. It also preserves the receiver anonymity. The trapdoor and search operation do not disclose the contents of ciphertext or the hidden access policy. Any user in the system is not be able to modify the key allocated to him or to generate a new key himself.

3.3 Definition of the PSE Scheme
The scope of the PSE scheme is to generate the index of encrypted keywords for a document and to perform privacy preserving search over the encrypted index. It does not include the encryption and decryption of a document. We assume that an existing efficient AABE scheme [2], [3], [4], [5] can be used for the encryption and decryption of a document.

Definition 1.
The PSE scheme is a 5-tuple defined as follows:

Setup(1l): The Setup(1l) is run by the AC. It takes as input parameter a security parameter l and outputs the master private key MK, TG’s secret key TSK and public key PK.

KeyGen(MK, L): The KeyGen(MK, L) is a randomized algorithm and it is run by the AC. The algorithm takes as input the master key MK along with a set of attributes L of a user. It outputs a secret key SKs for that user. The key SK is used to generate a trapdoor for performing search operation.

Encrypt_Index(PK, W, T, TSK): This is a protocol run between data owner and TG, where W is the set of keywords associated with document M. The data owner starts the computation to generate the encryption for each keyword w included in keyword set W. The data owner gets an encrypted token for each w from TG to perform the encryption of keyword. To generate encrypted word tokens, TG uses his secret key TSK. Finally, the data owner outputs a set of encrypted words CTW, known as encrypted index for document M.

Trapdoor(PK, SK, w): Receiver user invokes this randomized algorithm to make a trapdoor for retrieving the documents from CSP whose associated index contains an encrypted entry for the word w and for which he possesses sufficient access rights. The algorithm outputs a trapdoor tw generated for w.

Search(tw, CTW): This is a deterministic algorithm run by the CSP. The algorithm takes as input the trapdoor tw sent by the user and encrypted index CTW. The algorithm returns true if the word in tw matches with any of the keyword included in CTW and user’s key satisfies the access policy of CTW.

3.4 Security Model
The goals of adversary A are listed below.

A can retrieve the information about underlying access policy.

A can learn the information about the word being search for.

We show that the PSE scheme is secure in indistinguishability against ciphertext policy and chosen-keyword attack (IND-CP-CKA) model. We consider the following Challenger-Adversary model:

Setup. A gives l as the security parameter to the Challenger C. C runs the setup algorithm and returns the public key PK is sent to A.

Phase 1. A is allowed to issue adaptively generated trapdoor queries with input keyword w and set of attribute values L. The C responds with tw← Trapdoor(PK, SK, w), where SK is the output generated from Key_Gen(MK,L).

Challenge. A submits two pairs (W0, T0) and (W1, T1). The input submitted by A must have to satisfy the below mentioned criteria. If either of them fails, then C aborts.

W0 and W1 are set of keywords with equal length.

A has not gained a trapdoor tw which can satisfy any of the challenge ciphertext.

C randomly chooses b ∈ {0, 1}, then gains CTWb as output from Encrypt_Index protocol. C submits CTWb to A.

Phase 2. Same as in Phase 1. A issues the adaptively generated queries with keyword w and a list of attribute values L, which follows at least one of the following criteria: (i) w is not included in W0 and W1, and (ii) F(L, T0) = F(L, T1) = 0. A is responded with tw corresponding to (w,L).

Guess. A outputs a guess b′ of b. A wins the game if b′=b. The advantage of A in this game is defined as AdvA(l) = |Pr[b′=b]−1/2|.

Definition 2.
The PSE scheme is secure in IND-CP-CKA secure, if no polynomially bounded adversary has a non-negligible advantage in the security parameter l with the above game.

3.5 Detailed Construction of the PSE Scheme
The PSE scheme supports AND gate on multivalued attributes and there are n attributes with maximum size of valueset for an attribute is m. The data owner chooses a subset of m∗n values for the access policy. Each user has a total n attribute values (one from each valueset). The user includes all attribute values in the generation of trapdoor. The search operation returns true if (1) the keyword inside the trapdoor is included in the index of document and, (2) if the user’s attributes are a subset of access policy. The CSP performs the search computation correctly without learning which subset of access policy matches with the user’s attributes, which preserves the receiver anonymity.

Setup(1l). AC chooses a security parameter l, and performs the following steps to generate system keys and public parameters.

choose two multiplicative cyclic groups G0 and G1 with a prime order p, where length of p is determined by the security parameter l.

select g1, g2 as two generators of group G0 and define a bilinear mapping e:G0 × G0 → G1.

choose two collision-resistant cryptographic hash functions H0: {0,1}∗→ Z∗p and H1: {0,1}∗→ G0.

choose ∑ni=1mi+3 random exponents {α, β, γ, {ri1, ri2, …, rimi}1≤i≤n} from Z∗p. These elements serve as the master private key MK of the system.

Next the AC computes TSK = ⟨ {{rijγ}1≤j≤mi}1≤i≤n⟩ and assigns these values to TG.

publish the public key as PK = ⟨ g1, g2, e(g1,g2)α, gαβ2, gαγ1, gγ2, {gri12, g_2^{r_{i2}}, \ldots, g_2^{r_{im}}}_{1 \leq i \leq n} \rangle.

KeyGen(MK, L). The user submits his set of attribute values to the AC. The AC runs this algorithm and generates a secret key for the user. This secret key is used to generate the trapdoor for conducting a search operation over encrypted data. Let the user possesses jth value v_{i,j} for an attribute i, 1\leq i\leq n. The AC chooses a random numbers r from \mathbb {Z}^*_p and generates the search key as follows: \begin{align*} & D_{0} = g_1^{r\beta }\\ &\Big\lbrace D_{i1}=g_1^{(H_0(i\Vert v_{i,j})+r)\frac{\alpha }{r_{i1}}}, D_{i2}=g_1^{(H_0(i\Vert v_{i,j})^2+r)\frac{\alpha }{r_{i2}}},\ldots,\\ &D_{im_i}=g_1^{(H_0(i\Vert v_{i,j})^{m_i}+r)\frac{\alpha }{r_{im_i}}}\Big\rbrace _{1\leq i \leq n} (v_{i,j} \in L). \end{align*}
View SourceThe output of the algorithm is the secret key SK = \langleD_{0}, {{D_{ij}} _{1 \leq j \leq m_i}} _{1 \leq i \leq n}\rangle

Encrypt_Index(PK, W, T, TSK). This is run between the data owner and TG to generate the final encrypted index of keywords. It is initiated by the data owner. It takes as input keyword set W associated with a document M, PK and T from data owner side. The data owner does the following.

chooses a random secret values s from \mathbb {Z}^*_p. Then randomly picks s_1, s_2, \ldots, s_{n-1} from \mathbb {Z}^*_p and calculates s _n = s - \sum _{i=1}^{n-1}s_i.

For every attribute field i, the data owner chooses random values a_i for 1 \leq i \leq n and then computes f(x_i) = a_i(x_i-H_0(i\Vert \hat{v}_{i,1}))(x_i-H_0(i\Vert \hat{v}_{i,2}))\cdots (x_i - H_0(i\Vert \hat{v}_{i,m_i}))+ s_i, where \hat{v}_{i,j} = v_{i,j}(jth value of attribute i) if v_{i,j} \in T_i; else, it will be a random value. The resultant equation is \begin{equation*} f(x_i) = a_{i0}+a_{i1}x+ a_{i2}x^2+\cdots + a_{im_i}x^{m_i}. \tag{2}\end{equation*}
View SourceAggregation of all coefficients except a_{i0} from all equations is calculated as A_1 = \sum _{i=1}^{n}{(\sum _{j=1}^{m_i}{a_{ij}})}.

To perform the encryption of each of the keyword w \inW, the data owner picks a random value \vartheta from \mathbb {Z}_p and computes {{H_1(w)^{a_{ij}\vartheta }}_{1 \leq j \leq m_i}}_{1 \leq i \leq n}. These values are sent to the TG for requesting the encryption token for keyword w. TG returns an encrypted token as \prod _{i=1}^{n}{(\prod _{j=1}^{m_i}{H_1(w)^{\frac{a_{ij}r_{ij}\vartheta }{\gamma }}})} = H_1(w)^{\frac{\sum _{i=1}^{n}{(\sum _{j=1}^{m_i}{a_{ij}r_{ij}})}\vartheta }{\gamma }}.

From this encrypted token the data owner remove the value of \vartheta. The use of \vartheta is to hide the coefficient values when the communication takes place between data owner and TG. Let us denote the term \sum _{i=1}^{n}{\sum _{j=1}^{m_i}{a_{ij}r_{ij}}} = A_2.

The data owner computes the encryption of keywords as {C_{w} = g_1^{\frac{(s -\sum _{i=1}^{n}{a_{i0}})\alpha }{\gamma }}\cdot H_1(w)^{\frac{A_2}{\gamma }}} for each w \in W, C_{1} = g_2^{\frac{A_1\alpha }{\beta }}, {C_{i1} = g_2^{a_{i1}r_{i1}}, C_{i2} = g_2^{a_{i2}r_{i2}}, \ldots, C_{im_i}=g_2^{a_{im_i}r_{im_i}}} for 1 \leq i \leqn.

The final output generated as encrypted index is CT_W = \langle {C_w}_{\forall w \in W}, C_{1}, {{C_{ij}} _{1 \leq j \leq m_i}} _{1 \leq i \leq n} \rangle.

Trapdoor(PK, SK, w). In order to search for the documents having the keyword w, a user picks a random value \psi from \mathbb {Z_{\vert}} and prepares a trapdoor for search operation using secret key components \begin{align*} -\ \ &D^\prime _{0} = D_{0}^\psi = g_1^{r\beta \psi }, D^\prime _{1} = g_2^{\psi \gamma }\\ & \lbrace D^\prime _{i1} = D_{i1}^\psi = g_1^{(H_0(i\Vert v_{i,j})+r)\frac{\alpha \psi }{r_{i1}}}H_1(w)^\psi,\\ & D^\prime _{i2} = D_{i2}^\psi = g_1^{(H_0(i\Vert v_{i,j})^2+r)\frac{\alpha \psi }{r_{i2}}}H_1(w)^\psi, \ldots\\ & D^\prime _{im_i} = D_{im_i}^\psi =g_1^{(H_0(i\Vert v_{i,j})^{m_i}+r) \frac{\alpha \psi }{r_{im_i}}}H_1(w)^\psi \rbrace _{1\leq i \leq n}. \end{align*}
View SourceThe outputs of Trapdoor(PK, SK, w) is the trapdoor tw = \langle D^\prime _{0}, D^\prime _{1}, {{D^\prime _{ij}} _{1 \leq j \leq m_i}} _{1 \leq i \leq n}\rangle, which is used in the Search algorithm.

Search(tw, CT_W). After receiving a trapdoor tw, the CSP initiates following procedure with each encrypted index (CT_W) to find a match \begin{align*} R_{s1} &= \prod _{i=1}^n\prod _{j=1}^{m_i}e(C_{ij},D^\prime _{ij}) \tag{3}\end{align*}
View Source\begin{align*} R_{s2} &= e(C_{1},D^\prime _{0}) = e(g_1,g_2)^{A_1\alpha r\psi }\\ R_s &= \frac{R_{s1}}{R_{s2}}\\ &= e(g_1,g_2)^{(s -\sum _{i=1}^{n}{a_{i0}})\alpha \psi }\cdot e(H_1(w),g_2)^{A_2\psi }. \tag{4}\end{align*}
View SourceRight-click on figure for MathML and additional features.The correctness of (3) is as follows: \begin{align*} R_{s1} &= \prod _{i=1}^n\prod _{j=1}^{m_i}e(g_1^{(H_0(i\Vert v_i)^j+r)\frac{\alpha \psi }{r_{ij}}}H_1(w)^{\psi },g_2^{a_{ij}r_{ij}})\\ &= (g_1,g_2)^{\sum _{i=1}^n{(s_i - a_{i0})\alpha \psi }}\cdot e(g_1,g_2)^{A_1 \alpha r\psi }\\ & \qquad\cdot e(H_1(w),g_2)^{A_2\psi }\\ &= {e(g_1,g_2)^{(s -\sum _{i=1}^{n}(a _{i0}))\alpha \psi }\cdot e(g_1,g_2)^{A_1\alpha r\psi }}\\ & \quad \cdot e(H_1(w),g_2)^{A_2\psi }. \end{align*}
View SourceRight-click on figure for MathML and additional features.Next the CSP computes for each encrypted keyword C_w included in CT_W as \begin{equation*} e(C_w,D^\prime _1) = e(g_1^{\frac{(s -\sum _{i=1}^{n}{a _{i0}})\alpha }{\gamma }}\cdot H_1(w)^{\frac{A_2}{\gamma }},g_2^{\psi \gamma }). \tag{5}\end{equation*}
View SourceIf the resultant value of (4) is equal to value of (5) for any C_w, then the algorithm returns true; else, abort.

SECTION 4Security and Performance Analysis
4.1 Security Analysis
Theorem 1.
The PSE scheme is IND-CP-CKA secure in random oracle model under DBDH assumption.

Proof.
The goal of an adversary is to retrieve information about the encrypted keyword or the underlying access policy. As defined in the security model discussed in Section 3.4, the adversary submits two access policies T^\prime _0, T^\prime _1 and two keyword sets W_0, W_1 such that \left|W_0\right| = \left|W_1\right|. The adversary gets the challenge ciphertext CT_{W_b} which is encryption of W_b with respect to T_b. To identify the value of b, \mathcal {A} needs to identify the encryption of a word w \in W_0 and w\notin W_1(or a word w \in W_1 and w \notin W_0). To get the knowledge of encrypted word from the ciphertext CT_{W_b}, the adversary computes the following for the word w \begin{align*} e(C_w,g_2^{\gamma }) & = e(g_1^{\frac{(s^\prime -\sum {a^\prime _{i0}})\alpha }{\gamma }}\cdot H_1(w)^{\frac{A_2}{\gamma }},g_2^{\gamma })\\ & = e(g_1,g_2)^ {(s^\prime -\sum {a^\prime _{i0}})\alpha } \cdot e(H_1(w),g_2)^{A_2}. \tag{6}\end{align*}
View SourceNext, the adversary computes the value of \begin{equation*} -e\left(H_1(w^\prime),{\prod }_{i=1}^n{\big\lbrace {\prod }_{j=1}^{m_i}{C_{ij}}\big\rbrace }\right) = e(H_1(w^\prime),g_2)^{A_2}, \end{equation*}
View Sourcefor a word w^\prime. To check whether w \stackrel{?}{=} w^\prime, the adversary is required to find the value of e(g_1,g_2)^{\alpha ({s - \sum _{i=1}^n{a_{i0}}})} from the ciphertext components \lbrace \lbrace C_{ij}\rbrace _{1 \leq j \leq m_i}\rbrace _{1 \leq i \leq n}, and C_1. We denote the result of Equation (6) as C^\prime _w. In the following game, we provide \mathcal {A} the values of C^\prime _w instead of C_w and show that the advantage of adversary in calculating the value of e(g_1,g_2)^{\alpha ({s - \sum _{i=1}^n{a_{i0}}})} is negligible. Remaining of the ciphertext components will be assigned as in the real scheme. The adversary is given as challenge to distinguish between e(g_1,g_2)^{\alpha ({s - \sum _{i=1}^n{a_{i0}}})} and a random element of group G_1. If the adversary is able to fulfill the challenge with non-negligible advantage, then we can build a simulator \mathcal {S} that can break the DBDH problem with non-negligible advantage. The DBDH challenger sets the group G_0 and G_1. Then the challenger flips a binary coin \mu outside of \mathcal {S} view. If \mu = 0 then the challenger sets (g, A, B, C, Z) = (g, g^a, g^b, g^c, e(g,g)^{abc}). Else, the challenger sets (g, A, B, C, Z) = (g, g^a, g^b, g^c, e(g,g)^{z}) for some random value z \in \mathbb {Z}^*_p. In the following game \mathcal {S} plays the role of \mathcal {C}.

Setup. \mathcal {S} assumes g_2 = B and g_1 = A. The remaining components of the masker key are chosen by \mathcal {S} as in the original scheme. \mathcal {S} calculates the PK with these chosen values and submits it to \mathcal {A}. Two random oracles \mathcal {O}_{H0} and \mathcal {O}_{H1} are defined to simulate the hash functions. \mathcal {O}_{H0}: {0,1}^* \rightarrow \mathbb {Z}^*_p and \mathcal {O}_{H1}: {0, 1}^* \rightarrow G_0 work as follows (LH_0 and LH_1 are list of pairs of (request, response) generated, respectively, for \mathcal {O}_{H0} and \mathcal {O}_{H1}).

To generate H_0(i\Vert v_{i,j}), \mathcal {O}_{H0} first makes a search in LH_0. If a tuple (i\Vert v_{i,j}, h_0) already exists in the LH_0, then h_0 is returned; else, pick h_0\in _R Z^*_p, add (i\Vert v_{i,j}, h_0) to LH_0 and return h_0.

To compute H_1(w), \mathcal {O}_{H1} searches in LH_1. If a tuple (w, h_1) already exists in the LH_1, then h_1 is returned; else, pick h_1 \in _R G_0, add (w,h_1) to LH_1 and return h_1.

Phase 1. \mathcal {A} issues adaptively generated queries to obtain trapdoors for keyword w and set of attribute values L. To generate a trapdoor tw, \mathcal {S} first runs the Key_Gen algorithm to generate the secret key SK. \mathcal {S} makes queries to \mathcal {O}_{H0} to obtain H_0(i\Vert v_{i,j}) for each value L_i = v_{i,j} (1 \leq i \leq n and 1 \leq j \leq m_i). \mathcal {S} performs following computation to derive a secret key SK. {D_0 = g_1^{r\beta } = A^{r\beta },{{D_{ij} = g_1^{(H_0(i\Vert v_{i,j})^j+r)\frac{\alpha }{r_{ij}}} = A^{(H_0(i\Vert v_{i,j})^j+r)\frac{a}{r_{ij}}} }_{1\leq j \leq m_i} }_{1\leq i \leq n}}. Then, \mathcal {S} runs Trapdoor algorithm with input PK, SK and w. The \mathcal {S} fires a query to the oracle \mathcal {O}_{H1} with input w and retrieve h_1 as a substitute for H_1(w). Next, it fetches \psi \in _R Z^*_p and then calculate value of tw as in the real scheme.

Challenge. \mathcal {A} submits two pairs (W_0,T_0) and (W_1,T_1), where \left|W_0\right| = \left|W_1\right| and \mathcal {A} has not gained any trapdoor tw in Phase 1, which can satisfy the challenge ciphertext. Consider c as the secret value used for encryption of keyword. The simulator \mathcal {S} flips a coin b \in {0, 1}. With the outputs obtained from oracles \mathcal {O}_{H0} and \mathcal {O}_{H1}, the simulator \mathcal {S} computes the challenge ciphertext.

For 1 \leq i \leq n-1 select a_i, z_i and build the equations for each attribute category as follows: \begin{align*} f(x_i) = a_i&(x - H_0(i\Vert \hat{v}_{ii}))\cdots (x - H_0(i\Vert \hat{v}_{im_i})) + z_i\\ &f(x_i) = a_{i0}+a_{i1}x+a_{i2}x^2+\cdots a_{im_i}x^{m_i}, \tag{7}\end{align*}
View Sourcewhere in (7) \hat{v_{ij}} = v_{ij} if v_{ij} \in T_b; else, if v_{ij} \notin T_b then \hat{v_{ij}} is some random value chosen from \mathbb {Z}^*_p for 1 \leq j \leqm_i. \mathcal {S} computes C_{i1} = B^{a_{i1}r_{i1}} = g_2^{a_{i1}r_{i1}}, C_{i2} = B^{a_{i2}r_{i2}} = g_2^{a_{i2}r_{i2}}, \ldots, C_{im_i} = B^{a_{im_i}r_{im_i}} = g_2^{a_{im_i}r_{im_i}} for 1 \leqi \leq n-1.

For the nth attribute category choose a random value a_n \in \mathbb {Z}^*_p and compute the following equation: \begin{align*} f(x_i) & = a_n(x - H_0(\hat{v}_{ni}))\cdots (x - H_0(\hat{v}_{nm_n}))\\ & = \acute{a}_{n0} + a_{n1}x + a_{n2}x^2 + \cdots a_{nm_n}x^{m_n}. \end{align*}
View SourceNote that \hat{v_{nj}} = v_{nj} if v_{nj} \in T_b; else, \hat{v_{nj}} is some random value chosen from \mathbb {Z}^*_p for 1 \leq j \leqm_n.

Now, \mathcal {S} computes e(g_1,g_2)^{\acute{a}_{n0}\alpha }, C_{n1} = B^{a_{n1}r_{n1}} = g_2^{a_{n1}r_{n1}}, C_{n2} = B^{a_{n2}r_{n2}} = g_2^{a_{n2}r_{n2}}, \ldots, C_{nm_n} = B^{a_{nm_n}r_{nm_n}} = g_2^{a_{nm_n}r_{nm_n}}.

Compute C_{1} = B^{\frac{A_1\alpha }{\beta }} = g_2^{\frac{A_1\alpha }{\beta }}, where A_1 = \sum _{i=1}^n{(\sum _{j=1}^{m_i}{a_{ij}})}.

Compute C^\prime _{w_b} = \frac{Z^\alpha \cdot e(H_1(w_b),\prod _{i=1}^{n}{\prod _{j=1}^{m_i}{C_{ij}}})}{e(A,B)^{\sum {a_{i0}\alpha }}} for each w_b \in W_b. This is valid, because as discussed before, without the correct tw, the adversary will try to discover the encrypted value of w_b with an attempt of recovering the value of e(g_1,g_2)^{s - \sum _{i=1}^{n}{a_{i0}}} from rest of the ciphertext components.

Now, \mathcal {S} gives ciphertext CT_{W_b} = \langle {C^\prime _{w_b}} for each w_b \in W_b, C_{1}, and {C_{i1}, C_{i2}, \ldots, C_{im_i}} for 1 \leq i\leq n \rangle.

Phase 2. \mathcal {A} can repeat the queries for keyword w and attribute values L, as it did in Phase 1 with the restrictions that either w is not included in any of W_0 and W_1 or F(L,T_0) = F(L,T_1) = 0.

Guess. \mathcal {A} outputs a guess b^\prime of b. If b^\prime = b, then \mathcal {S} outputs \mu = 1 to indicate that it was given a valid DBDH-tuple; else, it outputs \mu = 0 to indicate that the ciphertext is a random element. Therefore, \mathcal {A} gains no information about b, in turn, Pr[b \ne b^\prime | \mu = 0 ] = \frac{1}{2}. As the simulator guesses \mu ^\prime = 0 when b \ne b^\prime, Pr[\mu = \mu ^\prime | \mu =0 ] = \frac{1}{2}. If \mu = 1, then the adversary \mathcal {A} is able to view a valid encryption of message with advantage \epsilon _{dbdh}(l), a negligible quantity in security parameter l. Therefore, Pr[b=b^\prime | \mu =1] = \frac{1}{2} + \epsilon _{dbdh}(l). Similarly, the simulator \mathcal {S} guesses \mu ^\prime=1 when b = b^\prime, in turn, Pr[\mu ^\prime =\mu | \mu =1] = \frac{1}{2} + \epsilon _{dbdh}(l). The overall advantage of the simulator in DBDH game is \frac{1}{2}\times Pr[\mu = \mu ^\prime | \mu =0 ] + \frac{1}{2} \times Pr[\mu = \mu ^\prime | \mu =1 ] − \frac{1}{2} = \frac{1}{2} \times \frac{1}{2} + \frac{1}{2} \times (\frac{1}{2} + \epsilon _{dbdh}(l)) − \frac{1}{2} = \frac{\epsilon _{dbdh}(l)}{2}. Therefore, if the \mathcal {A} has advantage \epsilon _{dbdh}(l) in the above game instance, then we can build a simulator \mathcal (S) which can break the DBDH problem with negligible quantity \frac{\epsilon _{dbdh}(l)}{2}.

Leakage Analysis. The searchable encryption schemes have found not strong enough to resist leakage of access pattern resulted from search operation. Here, the search pattern implies whether any two queries are being made for same keyword or not. The access pattern may reveal the number of documents which have used the same keyword. It is expected that the minimum leakage of a searchable encryption scheme is acceptable in the form of search outcome which can reveal the search and access pattern [21], [22].

The proposed PSE scheme only leaks the information, which an adversary can obtain from the outcome of a search. The outcome of a search includes whether two different trapdoors are generated for the same keyword or not, and the number of documents containing common keyword. Other than the search outcome, the PSE scheme does not reveal any additional information to the adversary. The following corollary justifies our claim for leakage analysis.

Corollary. Let the trapdoor tw_i has underlying keyword w_i and user attributes L_i. The encrypted index collection for which the search operation with input tw_i returns true is denoted as I_i. Given an adversary the collection of {(tw_i,I_i)} for 1 \leq i \leq \tau, where \tau is the number of queries that the adversary is allowed to make, then the adversary can only reveal the information as, for which tw_i and tw_j (1\leq i,j \leq q, i \ne j), I_i = I_j.

Proof.
Each tw is generated with the input of keyword w and user’s secret key L, where L contains user’s attribute values. The trapdoor algorithm is probabilistic and the output domain of trapdoor is G_0. The order of group G_0 is a large prime number p. For two inputs (w_i,L_i) and (w_j,L_j), if w_i = w_j and L_i = L_j then, the probability that tw_i = tw_j is 1/p. This proves that for sufficiently large value of prime number p with bit length l \begin{equation*} Pr[(i\ne j),(w_i = w_j),(L_i = L_j);(tw_{i} = tw_{j})] \leq 1/2 + \epsilon (l), \end{equation*}
View Sourcewhere, \epsilon (l) is a negligible quantity.

Therefore, an adversary who has only view of trapdoors can not learn any information about the keyword and user’s attributes hidden inside the trapdoor.

Now let the adversary has access to trapdoors and encrypted index. As proved in the Theorem 1, the scheme is secure against chosen keyword attack and indistinguishability in ciphertext policy. Therefore, the advantage of an adversary in learning the keyword or the user’s attributes from tw_i and tw_j is negligible. This yields that other than search outcome, the adversary can not learn anything from the search operation.

4.2 Performance Analysis
In the Table 1 we compare our scheme with Shi et al.’s scheme [18]. We did not consider Wang et al.’s scheme [19] in Table 1, as their scheme is found not secure in achieving receiver anonymity. For ease of comparison we consider the parameters of Shi et al.’s scheme for making a single keyword search operation.

TABLE 1 Comparison of the PSE Scheme with Shi et al.’s Scheme [18]

As shown in Table 1, the size and time complexity of the PSE scheme is more than Shi et al.’s scheme. The major limitation of Shi et al.’s scheme is that the user has to acquire the search token from the trusted authority, which increases the per query interaction overhead for search operation on user side. Furthermore, the scheme works in an environment, where there are fixed number of keyword fields for which the search should be carried out. A user can place a search query with multiple keywords, but it also creates a drawback because the user has to reveal the information about which keyword fields the queried keyword belongs to. Other limitation of Shi et al.’s scheme is that at most one value per attribute can be placed in the ciphertext access policy, while in the PSE scheme multiple values for each attribute can be placed inside the ciphertext access policy. This feature is captured in the size of T_i in Table 1. In Shi et al.’s scheme, if a user wants to issue \tau different search queries, then he has to communicate \tau times with the trusted third party, which adds substantial communication overhead on user side. Whereas, in the PSE scheme, once the user obtains the secret key from the trusted third party, he can generate the search token independently without interacting with the trusted third party.

4.2.1 Experimental Results
We have implemented the PSE scheme using pairing based cryptography (pbc) library [24]. Bilinear pairings are constructed on the curve y^2 = x^3 + x over the field F_q for prime q = 3 mod 4, where the order of the groups G_0 and G_1 is a prime of size 160 bits and the length of q is 512 bits. We have evaluated the scheme with varying number of attributes(n) = 3, 5, 7 and 10 and their varying sizes of value-sets (m). The results shown in the graphs are taken from the experiments where we have taken the fixed size of value-set for each attribute as 5. Therefore, the total number of attribute values (m*n) are 15, 25, 35 and 50. The experiments are performed on a data-set available from [23]. The dataset contains the diabetes patient’s medical records. Each record is a separate document containing the information of patients who are suffering from diabetes. Each report is identified with four keyword values which represents (1) the date when the test was conducted, (2) the time at which the blood sample is taken for test, (3) the type of report(glucose level or insulin dose), and (4) the outcome of test. Assuming that each report belongs to a different patient and each patient has his own privacy policy; the index is encrypted with each report with a different access policy. A Doctor working in hospital-A is able to search for all the reports conducted on, say 5th Feb., 2018, and for which the doctor has access rights (i.e., the reports whose access policy includes the attributes of Doctor and Hospital-A). The search procedure does not reveal the doctor’s credentials and the keyword (in this case 5th Feb., 2018). In real life, the health reports also include the patients’ name in medical report and a doctor might want to search for the reports of a certain patient. In this case, the patient name will be one of the keywords which is included in the encrypted index of that report.

The Setup, KeyGen, Trapdoor algorithms, and Encrypt_Index protocol are implemented on a Linux system with Intel core-i5 processor running at 2.30 GHz with 8 GB RAM. The Setup and KeyGen algorithms are executed by the AC. The time complexity of Encrypt_Index protocol and Trapdoor algorithms are shown in Figs. 2 and 3. It is apparent from the results that the performance of the scheme operations linearly depends on the total number of attribute values. The Search algorithm is tested on a Google cloud computing instance of n1 series with 16 virtual CPUs. Each virtual CPU is implemented as a single hardware hyper-thread on a 2.6 GHz Intel Xeon E5. To provide the inputs to the search algorithm, the results obtained from Encrypt_Index and Trapdoor algorithms are uploaded on the Google cloud instance. Each index is for an individual report and it contains four keywords such as date of report, time of report, type of report and outcome of report. In Fig. 4, we have shown the time to search over 500 to 10,000 encrypted indexes with different number of total attribute values, where each index contains 4 keywords. The search operation time complexity is O(m*n), where m*n is the total number of attribute values in the system. Therefore, we have shown the results with different values of m*n.


Fig. 2.
Encrypt_Index time for an index of 4 keywords.

Show All


Fig. 3.
Trapdoor generation time for a keyword.

Show All


Fig. 4.
Search operation time over number of encrypted indexes with varying size of total attribute values. (m*n = total number of attribute values.)

Show All

SECTION 5Conclusion
We proposed a privacy preserving attribute based searchable encryption scheme. The proposed PSE scheme allows an authorized user to retrieve a subset of documents, over encrypted documents stored on CSP, pertaining to his chosen keyword and satisfying his access rights. The PSE scheme preserves the confidentiality of data and privacy of user’s access rights. The search functionality of the PSE scheme is proven adaptively secure against chosen-keyword attack under DBDH assumption in random oracle model. We have implemented the PSE scheme on Google cloud instance and the performance of the scheme is found practical in real-world applications.