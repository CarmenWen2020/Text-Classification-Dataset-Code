Cloud computing can provide a flexible way to effectively share data among multiple users since it can overcome the time and location constraints of computing resource usage. However, the users of cloud computing are still reluctant to share sensitive data to a cloud server since the cloud server should be treated as an untrusted entity. In order to support secure and efficient data sharing in a cloud computing environment, Wei et al. recently extended the concept of identity-based encryption (IBE) to support key revocation and ciphertext update functionalities, and proposed a revocable-storage identity-based encryption (RS-IBE) scheme. In this article, we show that the RS-IBE scheme of Wei et al. does not satisfy the correctness property of RS-IBE. We also propose a method to modify the existing RS-IBE scheme.
SECTION 1Introduction
Cloud computing is a new paradigm of computing system that provides computing resources such as computing power or data storage according to the need of users. The advantage of cloud computing is that cloud service users can use their computing resources as a service with low cost at any time from anywhere through the Internet. A typical application of cloud computing is to securely share data among a large number of users. In this system, the data confidentiality should be provided because the cloud service provider is no longer a trusted entity. In addition, if a user's credential is expired, then a proper revocation method should be provided to handle this user. Furthermore, even if a revoked user tries to access past data stored in the cloud server through collusion attacks, the security of data should be guaranteed.

Recently, an RS-IBE scheme for secure data sharing in cloud storage was proposed by Wei et al. [1]. The basic idea of this RS-IBE scheme is to modify an IBE scheme to additionally supports the key revocation and ciphertext update functionalities. In particularly, they used the IBE scheme of Waters for the underlying IBE scheme and the tree-based key revocation scheme of Boldyreva et al. [2] for key revocation. Additionally, they modified their scheme to support efficient ciphertext update by following the idea of forward-secure cryptographic systems.

In this paper, we show that the RS-IBE scheme of Wei et al. is not correct. That is, if a ciphertext generated at time T is updated to another ciphertext with time T+1 by the ciphertext update algorithm, this updated ciphertext with time T+1 cannot be decrypted by using a decryption key with time T+1. The reason of this decryption failure problem is that the decryption algorithm uses a random value which is different from the random value used to encrypt a message if a ciphertext is updated. To remedy this problem, we propose a method to modify the RS-IBE scheme of Wei et al. to be a secure scheme without the decryption failure problem.

SECTION 2Review of the RS-IBE Scheme
For key revocation, the RS-IBE scheme of Wei et al. [1] follows the tree-based revocation method of Boldyreva et al. [2]. Let BT be a binary tree. In this case, a private key SKID of a user ID is associated with path nodes Path(xID) where ID is assigned to a node xID, and a key update KUT at time T is associated with covering nodes KUNodes(BT,RL,T). If the private key of a user ID is not revoked at time T, then there is a common node x~ satisfying x~=Path(xID)∩KUNodes(BT,RL,T). The decryption of a ciphertext at time T can be possible by using the key elements corresponding to x~.

For ciphertext updates, this scheme uses the tree-based time management of forward-secure systems. This idea was widely used in other schemes [3], [4]. Let ET be a binary tree in a ciphertext. Each time is sequentially allocated to a leaf node in ET from left to right, and CTNodes(ET,T) is defined as RightSibling(Path(vT))∖Path(Parent(vT))∪{vT} where RightSibling(S) is a set of RightChild(Parent(v)) of any node v∈S [3], [4]. Note that Wei et al. wrongly defined CTNodes(ET,T)={v|Parent(v)∈Path(vT) and v∉Path(vT)}∪{vT} since this wrong set includes the left child node of Path(vT), which will allow access to a past time node. To support ciphertext updates, a ciphertext is constructed to have ciphertext elements with CTNodes(ET,T). The main property of CTNodes is that if T<T′, a ciphertext with CTNodes(ET,T) can be updated to a ciphertext with CTNodes(ET,T′) because for any v′∈CTNodes(ET,T′) there is v′′ that matches to CTNodes(ET,T)∩Path(v′) and the ciphertext component for v′′ can be delegated to be a ciphertext for v′.

The RS-IBE scheme of Wei et al. is described as follows:

Setup(1λ,Nmax,Tmax): Let Nmax=2n and Tmax=2ℓ. It chooses a bilinear group (p,G,GT,e) with a prime order p. It selects random g,g2∈G and α∈Z∗p, and sets g1=gα. It chooses random u0,u1,…,un,h0,h1,…,hℓ∈G and defines Fu(ID)=u0∏ni=1uID[i]i, Fh(T)=h0∏ℓj=1hT[j]j where ID[i] and T[i] are the ith bit of ID and T respectively. It sets BT with Nmax leaf nodes and sets a revocation list RL=∅, a state ST=BT. It outputs a master key MK=gα2, and public parameters PP=((p,G,GT,e),g,g1,g2,{ui}ni=0,{hi}ℓi=0).

GenKey(ID,MK,ST,PP): It assigns ID to a leaf node xID∈BT. For each node x∈Path(xID), it performs: 1) It fetches gx,0 from x. If gx,0 is not defined before, then it chooses random gx,0∈G and stores the pair (gx,0,gx,1=g2⋅g−1x,0) in x. 2) It chooses random rx,0∈Z∗p and obtains SKID,x=(Kx,0=gαx,0Fu(ID)rx,0,Kx,1=grx,0). It outputs a private key SKID=({(x,SKID,x)}x∈Path(xID)) and an updated ST=BT.

UpdateKey(T,RL,MK,ST,PP): For each x∈KUNodes(BT,RL,T), it performs: 1) It fetches gx,1 from x. If gx,1 is not defined, then it sets the value similarly. 2) It chooses random rx,1∈Z∗p and obtains KUT,x=(U0=gαx,1Fh(T)rx,1,U1=grx,1). It outputs a key update KUT=({(x,KUT,x)}x∈KUNodes(BT,RL,T)).

DeriveDK(SKID,KUT,PP): It finds a common node x in both SKID and KUT. If it fails to find, it returns ⊥. Note that if ID was not revoked until time T, then there is a node x∈Path(BT,xID)∩KUNodes(BT,RL,T). It retrieves SKID,x=(Kx,0,Kx,1) and KUT,x=(Ux,0,Ux,1) from SKID and KUT respectively. It chooses random r0,r1∈Z∗p and outputs a decryption key DKID,T=(D1=Kx,0⋅Ux,0⋅Fu(ID)r0⋅Fh(T)r1,D2=Kx,1⋅gr0,D3=Ux,1⋅gr1).

Encrypt(ID,T,M,PP): Let ET be a binary tree for time periods and vT be a leaf node associated with T. It chooses random s∈Z∗p and computes C0=e(g1,g2)s⋅M,C1=g−s,C2=Fu(ID)s. For each v∈CTNodes(ET,T), it performs: 1) It chooses random sv∈Z∗p and sets sv=s if v=vT. 2) It calculates CTv=(Cv,0=(h0∏|bv|j=1hbv[j]j)sv,Cv,|bv|+1=hsv|bv|+1,…,Cv,ℓ=hsvℓ). It outputs a ciphertext CTID,T=(ID,T,C0,C1,C2,{CTv}v∈CTNodes(ET,T)).

UpdateCT(CTID,T,T′,PP): Let vT,vT′ be leaf nodes in ET assigned to T,T′, respectively. If T′<T, then it returns ⊥. It chooses random s′∈Z∗p and computes C′0=C0⋅e(g1,g2)s′,C′1=C1⋅g−s′,C′2=C2⋅Fu(ID)s′. For each v′∈CTNodes(ET,T′), it performs: 1) It find a node v∈CTNodes(ET,T) such that bv is a prefix of bv′. 2) It chooses random sv′∈Z∗p and sets sv′=s′ if v′=vT′. 3) It calculates CTv′=(Cv′,0=Cv,0⋅∏|bv′|j=|bv|+1Cv,j⋅(h0∏|bv′|j=1hbv′[j]j)sv′,Cv′,|bv′|+1=Cv,|bv′|+1⋅hsv′|bv′|+1,…,Cv′,|bv′|+ℓ=Cv,ℓ⋅hsv′ℓ). It outputs an updated CTID,T′=(ID,T′,C′0,C′1,C′2,{CTv′}v′∈CTNodes(ET,T′)).

Decrypt(CTID,T,DKID,T′,PP): Let DKID,T′=(D1,D2,D3). If T′<T, it returns ⊥. Otherwise, it updates CTID,T to obtains CTID,T′=(ID,T′,C′0,C′1,C′2,{CTv′}v′∈CTNodes(ET,T′)) where CTv′=(Cv′,0,…,Cv′,ℓ) by running UpdateCT(CTID,T,T′,PP). It outputs M by computing C′0⋅e(C′1,D1)⋅e(C′2,D2)⋅e(CvT′,0,D3) where vT′ is a leaf node associated with T′.

Revoke(ID,T,RL,ST): It adds (ID,T) to RL and returns the updated RL.

SECTION 3Analysis of the RS-IBE Scheme
3Lemma 3.1.
Let ET be a binary tree for time periods and vT,vT′ be leaf nodes associated with time T,T′, respectively. If T+1≤T′, then there exists a node v~=CTNodes(ET,T)∩Path(vT′) but vT≠v~. That is, vT,v~∈CTNodes(ET,T), v is an ancestor node of vT′, and vT≠v~.

3Proof.
By the main property of CTNodes, we have that for any node v′∈CTNodes(ET,T′) there is a common node v′′ such that v′′=CTNodes(ET,T)∩Path(ET,v′) if T+1≤T′. Therefore, for both nodes vT and vT′ associated with time T and T′, there exists a node v~=CTNodes(ET,T)∩Path(ET,vT′). Now, let's show that vT and v~ are different. In the given condition, T+1≤T′ is established, and each time is sequentially assigned to a leaf node. Therefore, vT,vT′ are different nodes since T≠T′ and they are assigned to leaf nodes. Since v~ belongs to Path(ET,vT′), v~ can never be a leaf node if v~≠vT′. Therefore, v~≠vT is established, since vT≠vT′ and vT is a leaf node.

3Theorem 3.2.
Let CTID,T be a ciphertext associated with time T and DKID,T′ be a decryption key associated with time T′. If T+1≤T′, then the ciphertext CTID,T cannot be decrypted by using the decryption key DKID,T′.

3Proof.
The decryption algorithm takes a ciphertext CTID,T and a decryption key DKID,T′ as input. Then, it performs UpdateCT to derive an updated CTID,T′ since T<T′ . Next, it uses the updated element CvT′,0, which is related to a leaf node vT′ associated with T′, for the decryption. Here, UpdateCT finds v~ which is an ancestor node of vT′ and belongs to CTNodes(ET,T), and delegates Cv~,0 to obtain CvT′,0. From the Lemma 3.1, we have that v~ which belongs to CTNodes(ET,T) is not equal to vT if T+1≤T′.

Now, we analyze random exponents in CTID,T which are associated with CTNodes(ET,T). The encryption algorithm generates ciphertext elements for CTNodes(ET,T). According to the encryption algorithm, for each v∈CTNodes(ET,T), if v=vT, then the same random s which is used for message encryption is used to generate Cv,0. If v≠vT, then a new random sv is selected to generate Cv,0. However, since v~≠vT from the Lemma 3.1, sv~ is not equal to s with high probability where sv~ is used for v~.

The decryption algorithm calculates the following equation as C′0⋅e(C′1,D1)⋅e(C′2,D2)⋅e(CvT′,0,D3)=M⋅e(Fh(T),g)(sv~−s)r1. To correctly obtain the message, it is required that (sv~−s)≡0modp. However, this relation cannot be satisfied because the original ciphertext element with v~ uses a new random sv~. Thus, the decryption can be successful if T=T′, but it always fails if T+1≤T′.

SECTION 4Modification to the RS-IBE Scheme
A simple way to modify the RS-IBE scheme of Wei et al. [1] is to force the ciphertext elements with CTNodes(ET,T) to use the same random s which is used to encrypt a message in C0. However, this simple method does not lead to a secure scheme. The reason is that if multiple nodes are provided with ciphertext elements {hsj} with the same random s, it is possible for anyone to use these elements to modify the ciphertext element with current time to derive another ciphertext element with past time. For example, if Cv,0=(h0hbv[1]1hbv[2]2)s is given, an adversary easily derives C′=(h0hbv[1]1)s for past time by using hs2 since bv is known.

A secure and efficient method to modify the RS-IBE scheme is to use the self-updatable encryption (SUE) scheme of Lee et al. [4], [5]. We can modify the RS-IBE scheme of Wei et al. to use the SUE scheme for the ciphertext update components and key update components. The SUE scheme proposed by Lee et al. supports correct decryption although it uses different random exponents. Additionally, this scheme can reduce the number of ciphertext elements from O(log2Tmax) to O(logTmax). Note that the RS-ABE scheme of Lee [5] also implies an RS-IBE scheme since ABE implies IBE.

SECTION 5Conclusion
We showed that the RS-IBE scheme of Wei et al. is not correct. The problem of the RS-IBE scheme was that when a ciphertext for time T is updated to a ciphertext for time T+1, this updated ciphertext cannot be decrypted by using a decryption key with time T+1 because of random exponents in the ciphertext. This decryption problem cannot be solved in a simple way, so we proposed a method to modify the previous RS-IBE scheme to be a secure and efficient RS-IBE scheme using a SUE scheme