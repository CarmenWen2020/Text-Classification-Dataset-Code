Cloud storage enables users to outsource data to storage servers and retrieve target data efficiently. Some of the outsourced data are very sensitive and should be prevented for any leakage. Generally, if users conventionally encrypt the data, searching is impeded. Public-key encryption with keyword search (PEKS) resolves this tension. Whereas, it is vulnerable to keyword guessing attacks (KGA), since keywords are low-entropy. In this paper, we present a secure PEKS scheme called SEPSE against KGA, where users encrypt keywords with the aid of dedicated key servers via a threshold and oblivious way. SEPSE supports key renewal to periodically replace an existing key with a new one on each key server to thwart the key compromise. Furthermore, SEPSE can efficiently resist online KGA, where each keyword request made by a user is integrated into a transaction on a public blockchain (e.g., Ethereum), which allows key servers to learn the number of keyword requests made by the user without requiring a synchronization between them for per-user rate limiting. Security analysis and performance evaluation demonstrate that SEPSE provides a stronger security guarantee compared with existing schemes, at the expense of acceptable computational costs.

SECTION 1Introduction
With cloud storage services, users can outsource their data to the remote storage server and flexibly access them via the Internet [1], [2], [3]. Such services also provide users an efficient way to send their data to others. Typical applications include store-and-forward systems, such as cloud-based email systems [4], where multiple users (called senders) are willing to send data containing a small number of keywords to one user (called receiver). Senders are able to outsource the data as well as keywords to the storage server, and the receiver can retrieve target data from the storage server through searching by keywords. This can free senders and the receiver from heavy local storage costs, and allows the receiver to access the target data on other devices (e.g., smartphones) at a later point in time [5], [6].

While users (hereinafter, the senders and receiver are collectively referred to as “users”) enjoy great benefits from the cloud storage services, critical security concerns in data outsourcing have been raised seriously. One of the most important security issues is data confidentiality. From the perspective of users, contents of outsourced data are very sensitive, and should not be leaked for preserving privacy [7], [8], [9]. Therefore, senders always encrypt the data before outsourcing. This can be achieved by utilizing conventional encryption, but it makes efficient searches over ciphertexts by keyword impossible [10].

Public-key encryption with keyword search (PEKS) is a cryptographic primitive that addresses the above problem [11], [12]. In PEKS, both the data and the corresponding keywords are encrypted under the receiver’s public key, and the ciphertexts are outsourced to the storage server (i.e., cloud server). The receiver can generate a trapdoor on a keyword by using her/his secret key and the storage server can test whether the ciphertext of keyword matches the trapdoor for data retrieval [13]. However, PEKS is subject to an inherent security limitation: vulnerability against off-line keyword guessing attacks (KGA). Specifically, given a trapdoor, an adversary encrypts all keyword candidates by using the receiver’s public key and identifies the ciphertext which matches the targeted trapdoor, this enables the adversary to recover the keyword hidden in the trapdoor to violate the users’ privacy. Such attacks are based on the observation that keywords are always selected from a small space and receivers usually utilize well-known keywords for searches of files [14]. We stress that vulnerability of PEKS against off-line KGA is a major hindrance towards the broad adoption of PEKS, since searched data (e.g., emails with sensitive keywords) is considered as being highly secret by many individuals and organizations.

Recently, a practical PEKS scheme with resistance against off-line KGA was proposed [15]. The keyword to be encrypted is derived from a key server that is separate from the storage server. Such a server-derived keyword is generated by an oblivious protocol executed between a user and the key server, which enables the user to receive the server-derived keyword without leaking any information on the keyword to the key server. Adversaries, who cannot compromise the key server, cannot generate ciphertexts of keywords in an off-line manner. As such, PEKS with resistance against off-line KGA is achieved through the key server’s assistance. Actually, introducing a key server to resist such “brute-force attacks” has already shown great advantages in analogous topics, e.g., encrypted data deduplication [16], [17], [18].

Despite the great advantages of server-aided PEKS, such the mechanism bears a strong assumption that the key server is reliable. At this point, the key server becomes a single point of failure. However, compromising the key server is feasible and practical, because an adversary (e.g., an adversarial storage server) can perpetually attempt to break into the target key server over a long period of time (i.e., the entire life-time of the storage server). Once he succeeds, the security of affected keywords cannot be ensured. To address this problem, the generation of server-derived keyword can be distributed over multiple key servers via a threshold secret sharing protocol [19] such that compromising any single key server would not break the security of the scheme. Nonetheless, this is still vulnerable to the key compromise, where an adversary collects a threshold number of key servers’ secret shares over the entire life-time of the storage server. Thus, for long-lived data, the protection provided by secret sharing could be insufficient [20]. Furthermore, the server-aided PEKS [15] is also confronted with online KGA, where the adversarial cloud server is able to impersonate a sender to access the key server such that it obtains enough server-derived keywords to perform off-line KGA.

In this paper, we present a secure and efficient PEKS scheme called SEPSE to thwart both off-line and online KGA for secure cloud storage. In SEPSE, multiple key servers are employed to help users in encrypting keywords to resist off-line KGA without the single-point-of-failure problem. A secret used to protect keywords is shared among these key servers in a threshold way and users derive keywords from the key servers via an oblivious protocol. SEPSE supports efficient key renewal on key servers, i.e., each key server renews its secret periodically (a period is a fixed and pre-determined time-interval and is called an epoch), and it would not impact on searching existing ciphertexts under the “old” secret shares. Moreover, in regards to the case that the number of key servers is large while the threshold is small, SEPSE utilizes a blockchain-assisted rate-limiting mechanism to resist online KGA, where the number of servers-derived keywords requested by a user within an epoch is limited by the key servers. Specifically, the contributions of this paper are three-folded:

We propose SEPSE to resist off-line KGA without the single-point-of-failure problem, where multiple dedicated key servers are employed to assist users in encrypting keywords without learning any information about the keywords. SEPSE supports key renewal on key servers so as to fight against the key compromise. Compared with existing schemes [15], [21], SEPSE provides a stronger security guarantee.

We present a blockchain-assisted rate-limiting mechanism and integrate it into SEPSE to resist online KGA, where each request of servers-derived keyword made by the user is integrated into a transaction on a public blockchain (e.g., Ethereum [22]), the key servers are able to check the number of servers-derived keyword requests of a user by checking the number of transactions created by her/him, and stop responding after a bound is reached. The proposed mechanism does not require the synchronization between key servers, and thereby is highly efficient in terms of communication costs. Since the blockchain provides a distributed and publicly verifiable way to conduct transactions, the recorded number of servers-derived keyword requests of each user cannot be tampered with. The blockchain-assisted rate-limiting mechanism is economical and favorable in the case that the number of all key servers is large but the threshold is small.

We prove the security of SEPSE against keyword guessing adversaries (i.e., adversarial storage server), compromised key server(s), and malicious users. We provide a comprehensive performance evaluation, which demonstrates that SEPSE is efficient. Specifically, the key renewal on the key server takes less than 0.5 seconds in the case of 10 key servers, and generating one servers-derived keyword on the user side only takes within 48 milliseconds in the case of 10 key servers.

The remainder of this paper is organized as follows. The related work is reviewed in Section 2. The system model, adversary model, and design goals are defined in Section 3. Preliminaries are presented in Section 4 and the construction of SEPSE is presented in Section 5. Security proofs are provided in Section 6 and the performance is evaluated in Section 7. Finally, the conclusion and future work are provided in Section 8.

SECTION 2Related Work
The searchable encryption technique plays an important role in data outsourcing systems, such as cloud storage, where a user can submit a search query to a storage server (e.g., cloud server), and the server is able to respond with the corresponding data without learning anything more about the data content than the search result. The problem of searching on encrypted data is first introduced by Song et al. [23], in which the first scheme for searches on encrypted data was proposed. However, the scheme in [23] requires the server to linearly scan word-by-word of each file, which makes the scheme inefficient. Chang et al. [24] presented a searchable encryption scheme with enhanced security. To improve the efficiency, Goh [25] presented an index-based searchable encryption scheme. The security model of searchable encryption was first defined by Curtmola et al. [26], which requires a secure searchable encryption scheme to leak no more than the search pattern (i.e., whether a search query is repeated) and the access pattern (i.e., pointers to ciphertexts that satisfy search query). Subsequently, many searchable encryption schemes were proposed with different features [27], [28], [29], [30], [31], [32]. These schemes are based on symmetric cryptosystems and are typically applied in the scenario that a user outsources her/his data to the storage server, and later she/he searches the data by keywords.

Boneh et al. [11] investigated the problem of searching on encrypted data under public-key cryptosystems. Compared with its symmetric counterpart, PEKS is less efficient but more expressive. Since ciphertexts in PEKS are protected under the public key of a user who searches the data from the storage server, a PEKS scheme is typically used in store-and-forward systems, e.g., cloud-based email systems. Following the Boneh et al.’s work [11], several PEKS variants [12], [33], [34], [35], [36], [37] with different features were proposed. However, Byun et al. [14] observed that keywords are selected from small space and users usually utilize well-known keywords for searches of files, this increases the advantage of off-line KGA significantly. Actually, the vulnerability of PEKS against off-line KGA has become a critical security issue in practice.

Prior works on resisting off-line KGA in PEKS can mainly be classified into four categories.

PEKS with an authorized tester to resist off-line KGA. In this mechanism, testing matching between a ciphertext and a trapdoor only can be performed by an authority (i.e., authenticated cloud storage server) [38]. This protects keywords from KGA performed by outside adversaries. However, such the mechanism cannot resist malicious cloud storage servers, since the authenticated server can test whether a ciphertext matches a trapdoor without any limitation [39].

PEKS built on emerging cryptographic primitives to resist off-line KGA. In [40], Sun et al. presented a PEKS scheme with resistance against off-line KGA by using indistinguishability obfuscation (iO) [41], [42]. In this scheme, ciphertexts are generated by a signcryption scheme, and the cloud storage server cannot generate a legitimate ciphertext to test whether it matches a received trapdoor. To ensure the security, the keys used to unsigncryption are embedded into an obfuscated program generated by the receiver. Nevertheless, current iO constructions are inefficient to generate and execute, which makes the scheme presented in [40] inefficient.

PEKS with fuzzy keyword search to resist off-line KGA [21]. In such the mechanism, a keyword is related to an exact keyword search trapdoor and a fuzzy keyword search trapdoor. A fuzzy keyword trapdoor corresponds to two or more keywords. The cloud server only has the fuzzy keyword search trapdoor to retrieve data. As a result, a malicious cloud storage server would not learn the exact keyword. Nonetheless, the malicious cloud storage server still can narrow down the space of the target keyword, and thereby the keyword privacy is not well protected in such the mechanism. Furthermore, it requires the receiver to filter out the non-matching ciphertexts received from the cloud storage server, which incurs heavy communication and computation costs on the receiver side.

PEKS constructed on a new framework to resist off-line KGA. An independent trust party is employed to assist users in generating and searching ciphertexts. This mechanism is inspired by the Bellare et al.’s scheme [16] that resists brute-force attacks for secure deduplication, and was first proposed by Chen et al. [15]. Compared with the above three categories of solutions, this mechanism balances the trade-off between efficiency and security, and is more practical. Nevertheless, the Chen et al.’s scheme [15] bears a quite strong assumption that the key server is reliable and it well maintains its secret over the entire life-time of the storage server. Furthermore, the scheme is also vulnerable to online KGA, where the adversary (e.g., the malicious storage server) impersonates a valid sender to access the key server for performing KGA.

Recently works [43], [44], [45], [46], [47] have shown great potentials for enhancing cloud storage services in terms of security and privacy from blockchains. Due to the public verifiability of public blockchains, all transactions created by a user on a blockchain can be tracked and cannot be modified and forged. Therefore, a public log can be constructed by using public blockchains to keep track of what happens to the outsourced data [5]. The log is inherently resistant to modification or forgery, which can be utilized to thwart online KGA.

To protect PEKS against off-line KGA without the single-point-of-failure problem, we propose SEPSE, where multiple key servers are employed to jointly help users in producing keywords without learning any information about the keywords. SEPSE supports key renewal on the key servers to resist the key compromise on key servers. Furthermore, SEPSE resists online KGA by a blockchain-assisted rate-limiting mechanism, where the number of servers-derived keyword requests for each user is recorded to the blockchain, and the key servers stop responding after the bound is reached. Consequently, SEPSE achieves a stronger security guarantee than existing schemes [11], [12], [15].

SECTION 3Problem Statement
3.1 System Model
Fig. 1 depicts the system model. Five entities are involved in SEPSE.


Fig. 1.
System model.

Show All

Senders: Senders generate data files which contain a small number of keywords, and send the data files as well as the keywords to a target receiver securely by encrypting the data files and the selected keywords with the receiver’s public key. The ciphertexts are outsourced to the storage server.

Receiver: The receiver is the data (i.e., encrypted data files) owner, she/he receives the encrypted data from the storage server, and decrypts them locally. Furthermore, she/he would search her/his data stored on the storage server by keywords at a later point in time.

Key servers: The key servers are employed to assist senders and receivers in generating the keyword to be encrypted, which is able to resist KGA.

Storage server: The storage server (i.e., cloud server) receives encrypted data as well as the encrypted keywords. Later, it provides the receiver with an efficient and secure way to search the ciphertexts by keywords, and forwards the target ciphertexts to the receiver.

Gateway: The gateway is introduced to assist users in forwarding the request of keyword generation to key servers, and assist the key servers in collecting service charge from the users.

SEPSE consists of five algorithms, Setup, PEKS, Trapdoor, Test, and KeyRenew.

Setup. In this algorithm, necessary parameters utilized in the subsequent algorithms are generated.

PEKS. In this algorithm, the sender generates a servers-derived keyword with the aid of key servers, and encrypts the servers-derived keyword using the receiver’s public key.

Trapdoor. This algorithm enables the receiver to generate a servers-derived keyword with the aid of a random subset of all key servers, and to generate a corresponding search token (i.e., trapdoor).

Test. This algorithm enables the storage server to test whether a ciphertext of servers-derived keyword matches a given search token.

KeyRenew. This algorithm enables each key server to update its secret share without changing the secret shared among all key servers.

Time in SEPSE is divided into fixed intervals of predetermined length called epochs. Setup needs to be executed only once over the entire life-time, KeyRenew needs to be executed only once in an epoch, and PEKS, Trapdoor, and Test can be executed multiple times in an epoch.

3.2 Adversary Model
In a servers-aided PEKS scheme, threats are mainly from four angles: adversarial storage server, compromised key server(s), malicious sender, and malicious gateway.

Adversarial storage server. The adversarial storage server would perform KGA to break the confidentiality of the outsourced keywords.

Compromised key server(s). An adversary may compromise the key servers, where he may break into each key server multiple times, to retrieve the outsourced keywords. Here, we assume that the number of key servers that can be compromised by the adversary within one epoch is less than the threshold, a key server can be compromised until the end of the current epoch, and compromised key servers are allowed to deviate from the scheme arbitrarily as the adversary needed. When a new epoch begins, the key servers that are compromised by the adversary in the previous epoch are “released” by the adversary [20].

Malicious sender. Any adversary can become a sender to query the servers-derived keywords and perform KGA to retrieve the outsourced keywords.

Malicious gateway. The malicious gateway may collude with an online keyword guessing adversary (will be detailed in Section 5.1) to break the security.

To prove the security of SEPSE under the above adversary model, we follow the security notions of semantic-security against chosen keyword guessing attacks (SS-CKGA) and indistinguishability against chosen keyword attacks (IND-CKA) [11], [15]. Details will be provided in Section 6.

3.3 Design Goals
To design SEPSE, two challenges should be addressed:

How to resist KGA without the single-point-of-failure problem. Since the keywords are inherently low-entropy, when the receiver searches data from the storage server by keyword, the storage server can enumerate all possible keywords and test them one by one to retrieve the target keyword. Although the existing scheme [15] can resist such attacks, it faces the single-point-of-failure problem, and its security solely relies on the reliability of the key server.

How to periodically renew the secret shares on the key servers. In reality, an active adversary may break into a subset of key servers multiple times over the entire life-time of the storage server. As such, periodical renewal of secret share on each key server is an affordable and effective solution to resist the active adversary.

With the above model, SEPSE should accomplish the following objects.

Functionality: The storage server, who only holds the public parameters, can test that whether a trapdoor matches a ciphertext; Such the search operation over encrypted data should not be affected or stopped after the key renewal on key servers.

Security: The storage server cannot violate the privacy of receiver/sender by guessing keywords; Compromising one or more key servers cannot break the security; Each key server can periodically renew its secret share so as to resist the key compromise.

Efficiency: The computation and communication overhead on the sender/receiver side should be as soon as possible; The key renewal phase should solely require the participation of key servers.

SECTION 4Preliminaries
4.1 Notation
Suppose i and j are positive integers (i<j), [1,i] denotes the set {1,2,…,i} and i++ denotes the operation of i=i+1. Let S be a finite set, the number of its elements is denoted by |S|. For two bit-strings a and b, their concatenation is denoted by a||b.

4.2 Threshold Cryptography
A (t,n)-threshold cryptosystem enables n players to share a secret and each of them to hold a secret share. Any t players can pool their shares and complete certain cryptographic operations (e.g., signature generation, encryption/decryption, recovering the secret), but no coalition of fewer than t players can get any information on the secret from their collective shares. The first threshold cryptosystem was presented by Shamir [19].

4.3 Bilinear Maps
Suppose G is an additive group with a prime order p and GT is a multiplicative group with the same order. e: G×G→GT is a bilinear map if it has three properties:

e(uX,vY)=e(X,Y)uv, ∀X,Y∈G, u,v∈Z∗p.

∀X,Y∈G and X≠Y, e(X,Y)≠1.

e can be calculated efficiently.

Computational Diffe-Hellman (CDH) problem in G: given G and one of its generators P, for any unknown u,v∈Z∗p, given uP and vP to compute uvP.

4.4 Blockchain
A blockchain is a protocol executed by multiple participants to enable them to achieve a consensus on newly generated data components. Each data component is called a block. The data structure of a blockchain is a hash chain which is formed by all blocks and is secured using a cryptographic hash function. Consensus algorithms play a key role in constructing blockchains. Blockchains can be constructed on different consensus algorithms, e.g., proof of work (PoW) [48], proof of stake (PoS) [49], [50], etc. PoW-based blockchains are the most widely-used ones in reality. In a PoW-based blockchain, each block typically contains two categories of data fields as illustrated in Fig. 2. The first one is called the block header which mainly contains the following items.


Fig. 2.
A simplified graphical block on blockchain.

Show All

PreBlockHash. It is the hash value of the last block and serves as a pointer to form the chain.

Time. It is a timestamp and indicates when the block is appended.

Nonce. It is a solution of PoW puzzle.

MerkleRoot. It is a root value derived from all transactions in the current block via Merkle hash tree [51].

The second one is called transaction data which contain all transactions in the current block.

Blockchains can be broken down into two categories. The first one is private blockchains (includes consortium blockchains), in which the participants should be authorized by an authority or a set of authorities. The second one is public blockchains, in which anyone can participate in or leave the system without the delegation of any authority. A block can be appended to the blockchain, only if it is accepted by a majority of participants [52], [53].

A successful application of public blockchains is blockchain-based currencies, e.g., Bitcoin [48] and Ethereum [22], where the public blockchain serves as a publicly verifiable and distributed ledger to securely record transactions between participants. The ledger is secure against modification of appended blocks. The participants who verify blocks and maintain the blockchain are called miners. In this paper, SEPSE is constructed on Ethereum, since Ethereum is more expressive than other public blockchains.

An Ethereum transaction mainly includes five fields as shown in Fig. 3. The first two fields indicate the source account and the destination account. In the “Value” field, the payer who creates the transaction can set how many Ethers she/he transfers. Moreover, the payer is able to set the “attached data” as any binary string she/he generates. In other words, the data value can be considered as the attached data in traditional electronic transactions of banks. We stress that the size of the data is not limited in Ethereum and the data value cannot be modified or forged once the corresponding transaction is confirmed on the blockchain. This allows us to design the blockchain-assisted rate-limiting mechanism. More technical details on Ethereum can be found in [22].


Fig. 3.
A graphical transaction in Ethereum.

Show All

SECTION 5The Proposed SEPSE
5.1 Overview of SEPSE
In SEPSE, multiple key servers are employed to jointly help users in encrypting keywords to resist KGA, where the ability of keyword generation is distributed to these key servers, such that any single key server’s misbehavior cannot break the security. Furthermore, a secret is shared among the key servers in a distributed and threshold way. As a consequence, sharing the secret does not require a trusted dealer, which frees SEPSE from the single-point-of-failure problem.

SEPSE utilizes an oblivious protocol [54], [55] which is executed between users and the key servers to generate servers-derived keywords. Unlike current schemes [15], [16], SEPSE does not rely on RSA, and is based on the BLS signature [55], [56], [57], since the BLS signature is much shorter and is faster to compute by the key servers than the RSA counterpart.

To protect SEPSE from compromising key servers’ secret shares, time in SEPSE is divided into fixed and pre-determined time-intervals called epochs. At the end of an epoch, each key server is required to renew its secret share. The secret share renewal should not change the secret shared among all key servers, such that for the same keyword, the key servers would produce the same servers-derived keyword. It ensures the functionality of PEKS.

There is still a subtle security issue. Since anyone can become a sender in PEKS, an adversary (e.g., the adversarial cloud server) is able to try different keywords by requesting the corresponding servers-derived keywords. The adversary utilizes different identities of senders to perform this online attack,1 and then obtains all servers-derived keywords. Finally, the adversary can perform off-line KGA to recover the keywords. We call such attacks online keyword guessing attacks (online KGA).

To thwart online KGA, we employ a rate-limiting mechanism: the number of servers-derived keyword requests made by a user in an epoch is limited by key servers. Specifically, a bound ρ is determined with the security parameter, and key servers stop responding after the bound ρ is reached. To improve the communication efficiency on the user side, a gateway is utilized to help users in forwarding the servers-derived keyword queries. The servers-derived keyword request made by a user is first submitted to the gateway who then transfers to all key servers.

We further consider the case that the number of all key servers n is large but the threshold t is small (compared with n). In this case, submitting the request of the servers-derived keyword to n key servers incurs a heavy communication burden for users. We stress that requiring the user to submit the servers-derived keywords to only t key servers is confronted with a compromised gateway. Since the malicious gateway may omit the number of servers-derived keyword queries made by an adversary and always allows him to request servers-derived keywords, and a malicious user can select different t key servers for different queries to perform online KGA.

To resist the compromised gateway, the key technique used here is the public blockchain, e.g., Ethereum [22], where each servers-derived keyword query made by a user is converted to a transaction on the Ethereum blockchain, and the total number of keyword queries for a user in each epoch can be verified by checking the number of transactions created by the user in the epoch. This yields our blockchain-assisted rate-limiting mechanism which we prove that breaking the security by performing online KGA as hard as forking the Ethereum blockchain. As a result, integrating this mechanism into SEPSE can reduce the communication overhead significantly while achieving the same security guarantee.

5.2 Construction of SEPSE
A sender S, a set of key servers {KS1,KS2,…,KSn}, a cloud storage server C, a receiver R, and a manager of the gateway D are involved in SEPSE.

Setup.

With the security parameter ℓ, system parameters {p,P,G,GT,e,h,H,H1,H2,F,ρ,t} are generated, in which e:G×G→GT is a bilinear map, and P is the generator of G, h:G→Zp, H,H1:{0,1}∗→G, and H2:GT→{0,1}lgp are secure hash functions, F:Zp×{0,1}∗→{0,1}∗ is a pseudorandom function, ρ is a maximum number that each sender and the receiver can require the keyword in each epoch, and t is the threshold number.

For the receiver R, her/his secret key is α randomly choosen from Z∗p and the corresponding public key is QR=αP∈G.

For i=1,2,…,n, KSi randomly picks ai0∈Z∗p and a polynomial fi(x)∈Zp whose degree is t−1, s.t. fi(0)=ai0, where fi(x)=ai0+ai1x+…+ai,t−1xt−1.

KSi computes ai0P and aiϵP(ϵ=1,2,…,t−1), and publishes them. KSi computes fi(j) and sends it to KSj for j=1,2,…,n; j≠i via a secure channel.

KSi extracts fj(i) and checks if by verifying fj(i)P=∑t−1γ=0iγ⋅ajγP. If the checking passes, it accepts fj(i).

KSi’s secret share is si=∑nγ=1fγ(i), its public share is Qi=siP. The secret key shared among {KS1,KS2,…,KSn} is s=∑ni=1ai0, and the corresponding public key is Q=∑ni=1ai0P.

The gateway D and KSi maintain a log file to count the number of keywords requested by S (denoted by ρS) and R (denoted by ρR). Initially, ρS=0 and ρR=0.

PEKS. Given a keyword w, S computes the ciphertext as follows.

S randomly chooses r∈Z∗p, computes w′=rH(w).

S transfers a service charge and sends w′ to D.

D checks whether ρS<ρ. If yes, it transfers the corresponding service charge to KSk for each k∈{1,2,…,n}, sets ρS++, and informs S; Otherwise, it rejects.

S sends w′ to KSk (k=1,2,…,n).

After receiving the service charge, KSk (k=1,2,…,n) checks whether ρS<ρ. If yes, it generates a signature σk on w′ by using the secret share sk as σk=skw′, sets ρS++, and sends σk to S; Otherwise, it aborts.

S verifies σk by checking
e(σk,P) =? e(w′,Qk).
View SourceIf the checking fails, S rejects σk; Otherwise, S stores σk locally.

After receiving t valid signatures (these t signatures are denoted by {σi1,σi2,…,σit} and their indexes form a set T={i1,i2,…,it}), S computes
σw=r−1∑k=i1,k∈Titωkσk,(1)
View Sourcewhere ωk=∏i1≤j≤itj≠k,j∈Tjj−k. S verifies the correctness of σw by checking
e(σw,P) =? e(H(w),Q).
View Source

S computes sdw=F(h(σw),w) as the servers-derived keyword of w, randomly chooses χ∈Z∗p, computes τ=e(H1(sdw),χQR) and Csdw=(χP,H2(τ)). Finally, S sends Csdw to C.

Trapdoor. Given a keyword w, the trapdoor tdw used to retrieve data is generated by R as follows.

R interacts with the key servers to generate the servers-derived keyword of w (i.e., sdw), this process is the same as the one performed by S in PEKS, where R plays the role of U.

R computes tdw=αH1(sdw).

Finally, R sends tdw to C.

Test. C takes as input Csdw=(A,B)=(χP,H2(τ)) and tdw, and checks H2(e(tdw,A)) =? B. If the equation holds, C outputs True; Otherwise it outputs False.

KeyRenew. For each key server KSi (i∈[1,n]), it renews its secret share as follows.

KSi randomly selects a polynomial gi(x) over Zp with degree at most t−1 s.t. gi(0)=0, in which gi(x)=bi1x+bi2x2+…+bi,t−1xt−1.

KSi computes biϵP(ϵ=1,2,…,t−1) and publishes it. KSi sends gi(j)modp to KSj for j=1,2,…,n;j≠i via a secure channel.

KSi extracts gj(i) and checks gj(i)P =? ∑γ=1t−1iγbjγP. If the checking succeeds, KSi accepts gj(i).

KSi computes a new secret share s′i as
s′i=si+∑j=1ngj(i).
View Source

Note that the secret s has the form s=∑ni=1ai,0=∑ni=1fi(0). Assume the renewed secret distributed to all key servers is s′, it has the form s′=∑ni=1f′i(0). Since f′i(x)=fi(x)+gi(x), we have s′=∑ni=1f′i(0)=∑ni=1fi(0)+gi(0). Because gi(0)=0, we further have s′=∑ni=1fi(0)=s. Therefore, the renewal of secret shares would not change the secret s shared among all key servers. This ensures the proactive security of SEPSE: an adversary who breaks into multiple key servers cannot break the confidentiality of keywords by performing KGA.

5.3 Improvement on the Communication Efficiency
With the establishment of SEPSE, the total number of key servers n may be large while the threshold t may be small. The rate-limiting mechanism that requires a servers-derived keyword query to be submitted to all key servers can be tedious and inefficient. We assume that there are dozens of key servers and only a couple of them need to assist users in generating servers-derived keywords, e.g., n=30,t=3, it is more advantageous for both users and the gateway to only submit a servers-derived keyword request to t key servers rather than all of them. However, a malicious sender who compromises the gateway can request different servers-derived keywords from different t key servers. If the sender’s request is only submitted to t key servers rather than all of them, in the extreme case, he can obtain up to ⌊nt⌋⋅ρ servers-derived keywords in an epoch,2 which significantly increases the success probability of online KGA. Therefore, it is necessary to achieve the synchronization on the number of servers-derived keyword requests made by a user among all key servers without requiring the user to submit each request to all key servers. A straightforward method is to require each key server to broadcast each received request to all others. However, it requires key servers to interact with each other to generate one servers-derived keyword and causes a heavy communication burden for them. Actually, it is very challenging to achieve such the synchronization among all key servers without introducing heavy communication costs when the gateway is compromised by an adversary (i.e., a malicious sender). Therefore, we further propose a blockchain-assisted rate-limiting mechanism and integrate it into SEPSE to resist online KGA with high communication efficiency.

In Setup, the system parameters are the same as those in Section 5.2, with one difference. The sender S, the receiver R, and the manager of gateway D each create their own accounts in Ethereum, where their accounts are denoted by AS, AR, and AD, respectively. Only D is required to maintain ρS and ρR.

In PEKS, given a keyword w, S generates the servers-derived keyword sdw as the same as that in Section 5.2, with the following differences.

After computing w′=rH(w), S randomly picks a subset T of set {1,…,n}, in which |T|=t is the threshold. Support the selected key servers are {KSi1,KSi2,…,KSit}, i.e., T={i1,i2,…,it}. For each k∈T, S computes ωk=∏i1≤j≤itj≠k,j∈Tjj−k.

S creates a transaction shown in Fig. 4, where S plays the role of U to transfer the service charge to \mathcal {D}’s account (i.e., the service charge is transferred from A_{\mathcal {S}} to A_{\mathcal {D}}), and the selected key servers’ indexes are attached as the transaction information.


Fig. 4.
The transaction of transferring service charge.

Show All

\mathcal {D} checks whether \rho _{\mathcal {S}} < \rho, if yes, \mathcal {D} transfers the corresponding service charge to \mathcal {KS}_{k} for each k\in T, sets \rho _{\mathcal {S}}++, and informs \mathcal {S}; Otherwise, \mathcal {D} aborts.

\mathcal {S} only sends w^{{\prime }} to \mathcal {KS}_{i_{1}}, \mathcal {KS}_{i_{2}}, \ldots, \mathcal {KS}_{i_{t}}.

After receiving the service charge, \mathcal {KS}_{k} (k = i_{1}, i_{2}, \ldots, i_{t}) first obtains the account information of A_{\mathcal {S}} from Ethereum blockchain and obtains \rho _{\mathcal {S}} by extracting the number of transactions that A_{\mathcal {S}} creates (transferring service charge from A_{\mathcal {S}} to A_{\mathcal {D}}). \mathcal {KS}_{k} (k = i_{1}, i_{2}, \ldots, i_{t}) checks whether \rho _{\mathcal {S}} < \rho. If the checking fails, it aborts; Otherwise, it generates \sigma _{k} on w^{{\prime }} as \sigma _{k} = s_{k}w^{{\prime }}, and sends \sigma _{k} to \mathcal {S}.

In Trapdoor, given a keyword w, \mathcal {R} first generates the servers-derived keyword sd_{w} with the aid of only t key servers. This process is the same as the one performed by \mathcal {S} described above, where \mathcal {R} plays the role of \mathcal {U} (i.e., a service charge is transferred from A_{\mathcal {R}} to A_{\mathcal {D}}). With sd_{w}, \mathcal {R} generates the corresponding trapdoor td_{w} as the same as that in Section 5.2.

Test and KeyRenew are the same as those in Section 5.2, for the sake of brevity, we would not repeat them.

Efficiency Improvement. As shown before, the blockchain-assisted rate-limiting mechanism allows users to only communicate with t of key servers rather than all of them without sacrificing the security. This is because integrating each servers-derived keyword query into a transaction on the Ethereum blockchain enables each key server to obtain the total number of queries made by each user in one epoch without interacting with the user. We must stress again that the blockchain-assisted rate-limiting mechanism is favorable in the case that n is large but t is small. Since creating a transaction in Ethereum takes slight communication and computation costs, if n is slight more than t, the communication efficiency on users cannot be improved significantly.

5.4 Correctness
To prove the correctness of SEPSE, we need to prove two parts.

First, for the different choice of key servers, the same keyword has the same servers-derived keyword. This depends on the correctness of Eq. (1). In particular, for the sake of brevity, we assume that t valid signatures generated by t key servers are \lbrace \sigma _{1}, \sigma _{2}, \ldots, \sigma _{t}\rbrace and \sigma _{w} has the form \begin{align*} \sigma _{w} &= r^{-1}\sum \limits _{i=1}^{t}\omega _{i}\sigma _{i} \\ &= r^{-1}\left(\sum \limits _{i=1}^{t}s_{i}\prod \limits _{1\leq j\leq t, j\ne i}\frac{j}{j-i}\right)\cdot w^{\prime }\tag{2} \end{align*}
View SourceRight-click on figure for MathML and additional features.\begin{align*} &= r^{-1}\cdot r\cdot s\cdot H(w)\qquad\qquad\qquad\;\; \\ &= s\cdot H(w),\tag{3} \end{align*}
View Sourcewhere the derivation from Eqs. (2) to (3) is based on Lagrange interpolation.

Second, for the different epoches, the same keyword has the same servers-derived keyword. To prove this, we prove that renewing each key server’s secret (i.e., \lbrace s_{1}, s_{2}, \ldots, s_{n}\rbrace are renewed as \lbrace s_{1}^{{\prime }}, s_{2}^{{\prime }}, \ldots, s_{n}^{{\prime }}\rbrace) would not change servers-derived keyword. Given a keyword w, its servers-derived keyword has the form sd_{w} = F(h(\sigma _{w}), w), where \sigma _{w} = s\cdot H(w), and s is the secret distributed to all key servers. Since the renewal of each key server’s secret share would not change s, the correctness of SEPSE is ensured.

5.5 Remark and Further Discussion
Although we adopt the Boneh et al.’s PEKS scheme [11] as the underlying scheme of SEPSE, the mechanism that keywords are derived from multiple key servers is also well compatible with other PEKS schemes, such as [12], [33], to resist off-line KGA with retention the characteristics of underlying schemes. In Section 5.3, the rate-limiting mechanism is built on the Ethereum blockchain, in which the security of the rate-limiting mechanism is based on the public verifiability of Ethereum: the number of transactions created by a user cannot be modified or forged. It is possible to utilize other public blockchains to construct the rate-limiting mechanism, since public verifiability is an inherent property of any secure public blockchain. However, for a public blockchain system, the more participants are in it, the stronger the security guarantee it can provide [3]. As Ethereum is one of the most well-established and widely-used public blockchains in reality, we use the Ethereum blockchain to balance the trade-off between security and efficiency.

We also stress that the blockchain-assisted rate-limiting mechanism does not require the key servers, gateway, and users to become a full node in Ethereum, because a light wallet of Ethereum has been issued3 such that one can create transactions without maintaining the Ethereum blockchain. Moreover, the account information, as well as block content in Ethereum, is being released by multiple sites, platforms, and supernodes of Ethereum, such as Etherscan4 and Etherchain.5 It enables the key servers to efficiently extract the account information of senders and the receiver without bearing heavy computation and communication costs.

Note that the key observation of the success of KGA is that keywords are always selected from small space and users usually utilize well-known keywords for searches of data. In other words, the number of keywords that a user utilizes would not be too large, and most of the keywords can be predetermined. As such, a user can request her/his commonly used keywords from key servers when the keywords are determined. Furthermore, as discussed before, the same keyword would yield the same servers-derived keyword. Therefore, servers-derived keywords can be reused subsequently. Therefore, the generation of servers-derived keywords can be considered as a one-time operation.

SECTION 6Security Analysis
The security of SEPSE is analyzed from four aspects.

6.1 Malicious Storage Server
The malicious storage server may perform both off-line and online KGA to break the confidentiality of the ciphertext.

Intuitively, a keyword w is first protected under its signature \sigma _{w} generated by the key servers, while these key servers cannot learn any information about w. The sender then encrypts the protected keyword (i.e., sd_{w}) and the receiver generates the trapdoor td_{w} based on sd_{w}. Furthermore, in each epoch the number of keyword queries for each user is limited. Therefore the storage server cannot enumerate all servers-derived keyword candidates to perform KGA without the secret shared among all key servers.

Formally, we follow the security notion of semantic-security against chosen keyword guessing attack [15].

Definition 1.
The SS-CKGA game is defined by an interactive game between an adversary \mathcal {A} and a challenger \mathcal {B} as follows.

Setup. The environment initializes SEPSE, and sends pk_{\mathcal {R}}, sk_{\mathcal {R}}, Q to \mathcal {B} and sends pk_{\mathcal {R}}, Q to \mathcal {A}.

Query-1. \mathcal {A} can adaptively request the trapdoor/ciphertext of any keyword w from \mathcal {B}.

Challenge. \mathcal {A} submits two keywords w_{0}, w_{1} to \mathcal {B}, where w_{0}, w_{1} have not been requested before. \mathcal {B} randomly selects b\in \lbrace 0,1\rbrace and generates sd_{w_{b}}, C_{sd_{w_{b}}}, and td_{w_{b}}. \mathcal {B} sends C_{sd_{w_{b}}} and td_{w_{b}} to \mathcal {A}.

Query-2. \mathcal {A} continues the request on the trapdoor/ciphertext of any keyword except of w_{0} and w_{1}.

Output. \mathcal {A} outputs a guess b^{{\prime }}\in \lbrace 0,1\rbrace, if b^{{\prime }} = b, \mathcal {A} wins.

The advantage that \mathcal {A} wins this game is defined as \mathsf {Adv}_{\mathcal {A}}^{SS-CKGA}(\ell) = \Pr [b^{{\prime }}=b]- 1/2.

SEPSE is SS-CKGA secure due to the following theorems.

Theorem 1.
If a PPT adversary \mathcal {A} can break the SS-CKGA security of SEPSE, there is a PPT adversary \mathcal {B} who can break the security of underlying signature (i.e., the BLS signature [56]).

Proof.
This proof is identical to the proof of SS-CKGA security in Section III-C of [15]. Here we would omit it.

Theorem 2.
Assuming the Shamir’s secret sharing scheme [19] is secure, the distributed way to generate the signature of a given keyword in SEPSE would not reduce the SS-CKGA security.

Proof.
In SEPSE, the signature of w is generated by multiple key servers, in which the key servers share s using the Shamir’s secret sharing scheme, and sign w using s. This is different from the server-aided PEKS. However, from the view of \mathcal {A}, there is no difference between the distributed way (i.e., the case of multiple key servers) and the centralized way (i.e., the case of the single key server). Since in Query-1 and Query-2, when \mathcal {A} submits a ciphertext or/and trapdoor query to \mathcal {B}, \mathcal {B} interacts with the signing oracle, and all following operations are based this oracle’s output. In Challenge, \mathcal {B} cannot interact with the singing oracle, and randomly chooses an element which serves as the signature of w_{b} to generate the challenge ciphertext and trapdoor. Actually, all the above processes are transparent to \mathcal {A}, and it would not impact the advantage that \mathcal {A} wins the SS-CKGA game.

6.2 Compromised Key Server(s)
A compromised key server is the strongest adversary that attempts to extract any information on the user’s private input (i.e., keyword). Formally, such the security requirement is captured by the security notion of indistinguishability against chosen keyword attack [11].

Definition 2.
The IND-CKA game is defined as follows.

Setup. With the security parameter \ell, the challenger generates the secret and public parameter of a key server (without loss of generality, \mathcal {KS}_{1}), that is, s_{1} and Q_{1}, and sends them to the adversary.

Challenge. The adversary sends two keywords w_{0} and w_{1} to the challenger. The challenger randomly chooses b\in \lbrace 0,1\rbrace, and queries the signature \sigma _{1}.

Output. Finally, the adversary outputs its guess b^{{\prime }}\in \lbrace 0,1\rbrace on b. If b^{{\prime }} = b, the adversary wins.

The advantage of adversary that wins the IND-CKA game is defined as \mathsf {Adv}_{\mathcal {A}}^{IND-CKA}(\ell) = \Pr [b^{{\prime }} = b] - 1/2.

SEPSE is IND-CKA secure because of the theorem as follows.

Theorem 3.
If there is a PPT adversary \mathcal {A} who can break the IND-CKA security of SEPSE, then there is a PPT adversary \mathcal {B} who can break the blindness of the threshold blind signature scheme [55].

Proof.
Without loss of generality, we assume \mathcal {KS}_{1} as the adversary \mathcal {A}. \mathcal {B} runs \mathcal {A} as a subroutine, and is transparent to the challenger.

In Setup, \mathcal {B} receives s_{1} and Q_{1} from the challenger and forwards them to \mathcal {A}. In Challenge, \mathcal {B} receives w_{0} and w_{1} from \mathcal {A}, and forwards them to the challenger. The challenger random picks b\in \lbrace 0,1\rbrace and r\in Z_{p}, computes w_{b}^{{\prime }} = rH(w_{b}), and sends w_{b}^{{\prime }} to \mathcal {B}. \mathcal {B} forwards w_{b}^{{\prime }} to \mathcal {A}, computes \sigma _{1} = s_{1}w_{b}^{{\prime }}, and sends \sigma _{1} to the challenger. In Output, \mathcal {A} sends a guess b^{{\prime }} to \mathcal {B}, and \mathcal {B} outputs b^{{\prime }} as his guess on b.

In the above process, from the view of challenger, \mathcal {B} is an adversary who breaks the blindness of the scheme [55]. From the view of \mathcal {A}, \mathcal {B} is the challenger in the IND-CKA game against SEPSE. Furthermore, the above process is indistinguishable from the IND-CKA game. Therefore, the advantage that \mathcal {B} breaks the blindness of the signature [55] is greater than or equal to \mathsf {Adv}_{\mathcal {A}}^{IND-CKA}(\ell).

In SEPSE, even if some key servers’ secrets are leaked, the security of SEPSE is still ensured, since each key server’s secret is renewed at the end of each epoch. We prove that an adversary, who collects t (the threshold number of) secret shares from different epochs, cannot reconstruct the secret s shared among all key servers as follows.

For the sake of brevity, we assume the adversary collects t shares of s from t different key servers in two successive epochs. These shares are denoted by \lbrace s_{1}, s_{2}, \ldots, s_{\pi }, s_{\pi +1}^{{\prime }}, s_{\pi +2}^{{\prime }}, \ldots, s_{t}^{{\prime }}\rbrace, where 1<\pi <t, \lbrace s_{1}, s_{2}, \ldots, s_{\pi }\rbrace are shares of s in the first epoch and \lbrace s_{\pi +1}^{{\prime }}, s_{\pi +2}^{{\prime }}, \ldots, s_{t}^{{\prime }}\rbrace are shares of s in the second epoch.

Recall that \begin{align*} s &= \sum \limits _{i=1}^{t} \omega _{i}s_{i} = \sum \limits _{i=1}^{t} \omega _{i}s_{i}^{{\prime }}= \sum \limits _{i=1}^{t} \left(\prod \limits _{1\leq k\leq t\atop k\ne i} \frac{k}{k-i}\right)\left(\sum \limits _{j=1}^{n}f_{j}(i)\right) \\ &= \sum \limits _{i=1}^{t} \left(\prod \limits _{1\leq k\leq t\atop k\ne i}\frac{k}{k-i}\right)\left(\sum \limits _{j=1}^{n}(f_{j}(i)+g_{j}(i))\right), \tag{4} \end{align*}
View SourceRight-click on figure for MathML and additional features.where n is the number of all key servers.

With \lbrace s_{1}, s_{2}, \ldots, s_{\pi }, s_{\pi +1}^{{\prime }}, s_{\pi +2}^{{\prime }}, \ldots, s_{t}^{{\prime }}\rbrace and the above equations, the adversary can compute \begin{equation*} \sum \limits _{i=1}^{\pi } \omega _{i}s_{i} + \sum \limits _{i=\pi }^{t} \omega _{i}s_{i}^{{\prime }}\qquad\qquad\qquad\qquad\;\;\; \tag{5} \end{equation*}
View SourceRight-click on figure for MathML and additional features.\begin{align*} =& \sum \limits _{i=1}^{\pi } \left(\prod \limits _{1\leq k\leq \pi \atop k\ne i} \frac{k}{k-i}\right) \left(\sum \limits _{j=1}^{n} f_{j}(i)\right) \\ &+ \sum \limits _{i=\pi }^{t} \left(\prod \limits _{\pi \leq k\leq t\atop k\ne i} \frac{k}{k-i}\right) \left(\sum \limits _{j=1}^{n} f_{j}(i) + \sum \limits _{j=1}^{n} g_{j}(i)\right)\tag{6} \end{align*}
View Source\begin{align*} &= s + \sum \limits _{i=\pi }^{t} \left(\prod \limits _{\pi \leq k\leq t\atop k\ne i} \frac{k}{k-i}\right) \left(\sum \limits _{j=1}^{n} g_{j}(i)\right). \qquad\quad\;\;\tag{7} \end{align*}
View Source

Therefore, we have \begin{equation*} s = \sum \limits _{i=1}^{\pi } \omega _{i}s_{i} + \sum \limits _{i=\pi }^{t} \omega _{i}s_{i}^{{\prime }} - \sum \limits _{i=\pi }^{t} \left(\prod \limits _{\pi \leq k\leq t\atop k\ne i} \frac{k}{k-i}\right) \left(\sum \limits _{j=1}^{n} g_{j}(i)\right). \end{equation*}
View Source

To recover s, the adversary needs to compute \begin{equation*} \sum \limits _{i=\pi }^{t} \left(\prod \limits _{\pi \leq k\leq t\atop k\ne i} \frac{k}{k-i}\right) \left(\sum \limits _{j=1}^{n} g_{j}(i)\right). \tag{8} \end{equation*}
View Source

Since the adversary cannot compromise n key servers in an epoch, he cannot collect g_{j}(i) for j = 1, 2, \ldots, n. Therefore, he cannot compute Eq. (8) and cannot recover s.

6.3 Malicious Sender
For a malicious sender, he may forge a servers-derived keyword. Once it succeeds, he also can perform off-line KGA. In other words, the servers-derived keyword cannot be generated by anyone without a threshold number of key servers’ help. In fact, given a keyword w, its signature generated by the key servers has the form \sigma _{w} = sH(w). Essentially, it is the BLS signature [56], and is existentially unforgeable. If an adversary can generate the servers-derived keyword without interacting with key servers, the security of the BLS signature is broken. Actually, the attack performed by a malicious sender can be considered as the one performed by the malicious storage server who controls a registered sender, since attacks performed by the malicious sender can also be performed by the malicious storage server.

6.4 Malicious Gateway
The only attack a malicious gateway can launch is to collude with an adversary to stop counting the number of servers-derived keyword queries made by the adversary. This enables the adversary to perform online KGA.

In the basic scheme (SEPSE without blockchain described in Section 5.2), each servers-derived keyword query made by the user would be forwarded to all key servers. In other words, deriving a keyword requires all key servers’ participation. Therefore, the gateway cannot contribute to online KGA.

In the SEPSE with blockchain-assisted rate-limiting mechanism described in Section 5.3, deriving a keyword only requires any t key servers’ participation. If the gateway does not honestly follow the prescribed scheme, the number of servers-derived keyword queries made by the adversary can be increased significantly, which enables the adversary to break the security of SEPSE by performing online KGA. However, note that each query made by the user is integrated into a transaction in Ethereum, the number that each user queries the key servers with keywords can be extracted by the key servers efficiently. Due to the security of Ethereum (i.e., the security of public blockchain), it is computationally infeasible to cover up or delete existing transactions that have been recorded into the blockchain. Furthermore, it is also computationally infeasible to modify the number of transactions created by the adversary. Hence, the security of SEPSE cannot be broken by the malicious gateway.

A comparison between SEPSE and existing schemes (e.g., the Boneh et al.’s scheme [11], the Bellare et al.’s scheme [12], and the Chen et al.’s scheme [15]) in terms of security is provided in Table 1, where “Y” denotes that the security is achieved, “N” denotes that the security is not achieved, and “\bot” denotes the scheme does not focus on the property. From Table 1, we can observe that SEPSE provides a stronger security guarantee than those in [11], [12], [15].

TABLE 1 Security Comparison

SECTION 7Performance Evaluation
The performance of SEPSE is evaluated via experiments. All experiments and implemented by using C language and MIRACL Library, and run on a computer with Window 10 system, an Intel Core 2 i5 CPU and 8 GB DDR 3 of RAM. The security level is selected to be 80 bits, it corresponds to the MNT curve.6

7.1 Communication Overhead
In the Setup algorithm, key servers need to share the secret, and in the KeyRenew algorithm, key servers need to renew their secret shares. These two processes require each key server to interact with each other. Setup only needs to be run once during the life-time of SEPSE and KeyRenew only needs to be run once during an epoch. These costs could be amortized over lots of subsequent requests on servers-derived keywords. Here, we do not analyze the communication overhead on each key server side.

In the generation of servers-derived keyword, the blockchain is introduced to thwart online KGA and reduce the communication overhead on the user side. Fig. 5 shows the efficiency improvement on the communication overhead brought by the blockchain.


Fig. 5.
Communication overhead.

Show All

7.2 Computational Overhead
In Table 2, basic cryptographic operations are estimated. We set the number of all key servers n = 30 for simplicity.

TABLE 2 Basic Cryptographic Operations

Compared with the Boneh et al.’s scheme [11], SEPSE does not cause additional costs on the storage server.

7.2.1 Computational Overhead on Key Server Side
In the Setup algorithm, a key server’s computational costs are (nt+n-1)\cdot Mult_{G} + t(n-1)\cdot Exp_{Z_{p}} + t(n-1)\cdot Mult_{Z_{p}} + n\cdot Add_{Z_{p}}. In the PEKS algorithm, the key server’s computational costs are Mult_{G}. In the KeyRenew algorithm, the key server’s computational costs are (nt-1)\cdot Mult_{G} + (t-1)(n-1)\cdot Exp_{Z_{p}} \;+\;(t-1)\;(n-1)\cdot Mult_{Z_{p}} \!\;+\;\! (n+1)\cdot Add_{Z_{p}}. We show the computational delay of the key server in Fig. 6. The computational delay on the key server is within 0.5 seconds if t = 10.


Fig. 6.
Computational delay of a key server.

Show All

7.2.2 Computational Overhead on User Side
In SEPSE, the sender needs to generate a servers-derived keyword and ciphertexts. The computational costs on the sender side are 3 Pair_{G_{T}} + 5 Mult_{G} + t\cdot Add_{G} + 2 Hash_{G} + t(2t-1)\cdot Mult_{Z_{p}} + t(t-1)\cdot Add_{Z_{p}} + 2 Hash_{Z_{p}} + C_{F}. The receiver needs to generate a servers-derived keyword and a trapdoor. The computational costs on the receiver side are 2 Pair_{G_{T}} + 4 Mult_{G} + t\cdot Add_{G} + Hash_{G} + t(2t-1)\cdot Mult_{Z_{p}} + t(t-1)\cdot Add_{Z_{p}} + Hash_{Z_{p}} + C_{F}. Fig. 7 shows the computational delay on the sender and receiver sides of SEPSE.

Fig. 7. - 
Computational delay on the user side.
Fig. 7.
Computational delay on the user side.

Show All

7.3 Simulations on the Ethereum Blockchain
We conduct transactions over Ethereum to demonstrate the practicality of the blockchain-assisted rate-limiting mechanism. In a blockchain system, a block and its transactions are deemed to be confirmed if \varphi successive blocks are mined following it. In Ethereum, we recommend \varphi \geqslant 12. As of Feb. 2019, the time to confirm a transaction in Ethereum is about 3.3 minutes.

We also measure the monetary costs of the blockchain-assisted rate-limiting mechanism. The mechanism does not rely on smart contracts. Hence, the only monetary costs are transaction fee in Ethereum. As of Feb. 2019, conducting a transaction averagely takes within 5 US cents.7 This can be acceptable in respect of the value of the data protected by SEPSE.

As discussed before, the generation of servers-derived keywords is a one-time operation. Both the senders and receiver can reuse the servers-derived keywords. Therefore, it only requires the user to conduct one transaction in Ethereum for a keyword. The costs to generate servers-derived keywords can be amortized over plenty of future encryption or trapdoor generation operations. Recall the communication improvement (shown in Fig. 5) brought by the blockchain-assisted rate-limiting mechanism in the case that n (i.e., the number of key servers) is large but t (i.e., the threshold) is small, the latency and monetary costs to conduct transactions for rate-limiting can be acceptable in reality.

According to the performance evaluation, we can observe that communication costs between the key server and the user in the Chen et al.’s scheme [15] is constant and is less than that in SEPSE, due to the fact that SEPSE employs multiple key servers to address the single-point-of-failure problem. Furthermore, compared with the Boneh et al.’s scheme [11], users need to generate servers-derived keywords, which brings slight computational overhead. However, the security is surely enhanced at the expensive of this slight computational overhead.

SECTION 8Conclusion
In this paper, a secure and efficient PEKS scheme called SEPSE has been presented to resist off-line KGA, where multiple key servers are employed to help in encrypting keywords so as to free SEPSE from the single-point-of-failure problem. SEPSE supports key renewal on each key server, where key servers’ secret shares are periodically renewed so as to thwart the key compromise. SEPSE can thwart online KGA by utilizing the proposed blockchain-assisted rate-limiting mechanism, where the number of servers-derived keyword requests for each user is limited in each epoch. We have proved the security of SEPSE and conducted the efficiency evaluation. It has been demonstrated that SEPSE is efficient in respect of communication and computation costs. For the future work, we will study the potentials for enhancing the security, efficiency, and functionality of data outsourcing systems.