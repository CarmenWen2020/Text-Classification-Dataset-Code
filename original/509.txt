Crowdsourcing systems which utilize the human intelligence to solve complex tasks have gained considerable interest and adoption in recent years. However, the majority of existing crowdsourcing systems rely on central servers, which are subject to the weaknesses of traditional trust-based model, such as single point of failure. They are also vulnerable to distributed denial of service (DDoS) and Sybil attacks due to malicious users involvement. In addition, high service fees from the crowdsourcing platform may hinder the development of crowdsourcing. How to address these potential issues has both research and substantial value. In this paper, we conceptualize a blockchain-based decentralized framework for crowdsourcing named CrowdBC, in which a requester's task can be solved by a crowd of workers without relying on any third trusted institution, users' privacy can be guaranteed and only low transaction fees are required. In particular, we introduce the architecture of our proposed framework, based on which we give a concrete scheme. We further implement a software prototype on Ethereum public test network with real-world dataset. Experiment results show the feasibility, usability, and scalability of our proposed crowdsourcing system.
SECTION 1Introduction
Over the past few years, crowdsourcing has gained considerable interest and adoption since it is coined in 2006 by Jeff Howe [1]. It is a distributed problem-solving model through an open call for solutions. Nowadays, many large companies choose crowdsourcing as a problem-solving method, ranging from web and mobile development to t-shirt designs. There are numerous famous crowdsourcing applications such as Upwork, Amazon Mechanical Turk and UBER. We can expect that this field will change the working style of people significantly.

Generally, the human intelligence-based crowdsourcing consists of three groups of roles: requesters, workers and a centralized crowdsourcing system (Fig. 1). Requesters submit tasks which are challenging for computers but easy for human to complete through the crowdsourcing system. A set of workers who are interested in this task compete and submit solutions to the crowdsourcing system, while requesters will then select a proper solution (usually the first or the best one that solves the task) and grant the corresponding workers the reward. Taking the current world's largest freelancer marketplace, Upwork, for example, it requires “clients” (requesters) to deposit a milestone payment into the escrow account before work begins. Then “clients” could interview or hire “freelancers” (workers) to design or write. “Freelancers” who focus on the area of expertise compete for the job and the winners will obtain the reward.


Fig. 1.
The system model of traditional crowdsourcing.

Show All

However, despite the prosperity of the crowdsourcing systems, they are subject to the weaknesses of traditional trust-based model, which brings about some inevitable challenges. First, traditional crowdsourcing systems are vulnerable to DDoS attacks, remote hijacking and mischief attacks, which makes the services unavailable. Elance and oDesk, operated by Upwork presently, downed services for many workers due to be hit by DDoS attacks in May 2014 [2]. Second, the majority of crowdsourcing systems run business on a centralized server, which suffers from single point of failure inherently. In April 2015, a service outage emerged due to hardware failure in Uber China, which caused passengers can't stop the order at the end of services [3]. Third, user's sensitive information (e.g., name, email address and phone number) and task solutions are saved in the database of crowdsourcing systems, which has the risk of privacy disclosure and data loss. For example, one of the most prevalent crowdsourcing systems Freelancer [4] was reported to breach the Privacy Act for uncovering a user's true identity which contains IP addresses, active account and dummy accounts by Office of the Australian Information Commissioner (OAIC) in December 2015. Fourth, when requesters and workers are in dispute, they need help from the crowdsourcing system to give a subjective arbitration, which may lead to a behavior known as “false-reporting” [5]. Lastly, crowdsourcing companies are interested in maximizing their own benefits and require requesters paying for services, which in turn increases user's costs. Currently, most of the crowdsourcing systems could demand a sliding services fee for 5 to 20 percent [6].

There have been many works to deal with part of the above mentioned issues in crowdsourcing systems. Encryption and differential privacy (DP) are used to protect data privacy [7], [8], [9], [10], [11], [12]. Reputation-based mechanisms are proposed to address “false-reporting” and “free-riding” behavior [13], [14], [15]. Distributed architectures are designed to prevent single point of failure and bottleneck problem [16], [17], [18]. However, the majority of these researches are built on the traditional triangular structure crowdsourcing models which suffer from breakdown of trust. Up to now, none of existing works has solved all of the above issues simultaneously. Thus, this research is motivated by this: Can we design a decentralized crowdsourcing system with reliability, fairness, security and low services fee? To answer this question, we propose a blockchain-based decentralized framework for crowdsourcing. The framework has many advantages such as increasing user security and service availability, enhancing the flexibility of crowdsourcing with Turing-complete programming language and lowering cost. Therefore, our framework has the potential to disrupt the traditional model in crowdsourcing. In a nutshell, our specific contributions are in the following:

We conceptualize a blockchain-based decentralized framework for crowdsourcing named CrowdBC, which does not depend on any central third party to accomplish crowdsourcing process. CrowdBC guarantees privacy by allowing users to register without true identity and storing encrypted solutions in the distributed storage. Each identity makes a deposit before participation, which can effectively thwart many attacks such as DDoS, Sybil and “false-reporting” attacks. Moreover, users don't need to pay the costly service fees to traditional crowdsourcing platform anymore, only required to pay a small amount of transaction fees. Our framework also enhances the flexibility of crowdsourcing by using Turing-complete programming language to depict complex crowdsourcing logics.

We present a concrete scheme based on the proposed framework. Smart contract is used to perform the whole process of crowdsourcing task which contains task posting, task receiving, reward assignment, etc. We introduce three standard smart contracts in the scheme: User Register Contract (URC), User Summary Contract (USC), Requester-Worker Relationship Contract (RWRC), by which crowdsourcing functionalities can be achieved such as posting and receiving a task without relying on any central authority. In particular, compared with the traditional systems, the most useful feature lies in the evaluation of tasks to be completed via smart contract rather than a subjective third party. We expect that this construction will be proved quite impactful and useful in practice.

We implement the proposed scheme to verify the feasibility through a software prototype based on Ethereum public test network with real-world dataset. Experiment results show the usability and scalability of our proposed crowdsourcing system. Furthermore, we illustrate a discussion of future improvements to this scheme.

The remainder of the paper is organized as follows. In section 2, we present the related work. The preliminaries of blockchain and smart contract are given in section 3. In section 4 we present the system model, threat model, security assumptions and technical challenges. In section 5, the description of our proposed framework is given. Next, we present a concrete crowdsourcing scheme under the framework and analyze the security properties in section 6. A series of experiments are demonstrated in section 7 and finally we conclude and discuss the future work of the paper in section 8.

SECTION 2Related Work
Research on crowdsourcing has become an emerging trend with the explosive growth of the internet and mobile devices. We mainly review some state-of-art works in three primary areas: centralized crowdsourcing system, distributed crowdsourcing system and blockchain-based crowdsourcing system.

Centralized Crowdsourcing System. Several crowdsourcing systems are developed in a centralized way [6], [19], [20], [21], [22]. The crowdsourcing services, like worker selection, incentive mechanism and truth discovery, are provided by these centralized crowdsourcing systems. Upwork and WAZE [20], as two famous crowdsourcing platforms, allow requesters to efficiently hire workers to obtain task solutions (e.g., traffic jams, accidents in WAZE). However, they required users’ detailed information (e.g., WAZE and Freelancer [21]) and stored user information, task data in the centralized platform, which may suffer from privacy leakage [4], DDoS/Sybil attacks [2] and the issue of single point of failure [3]. [5] proposed auction-based mechanisms EFT and DFT, and [13] proposed reputation-based incentive mechanism to tackle free-riding and false-reporting attacks in crowdsourcing. But their methods are based on the traditional three parities model, which is different from our scheme. Besides, there exist a number of incentive mechanisms relying on crowdsourcing system to save task reward, which has the risk of bankrupt inherently [23].

Distributed Crowdsourcing System. There also exist several researches on designing the distributed crowdsourcing system. [17] presented D2 protocol to design a distributed crowdsourcing system in Delay Tolerant Network (DTN). The authors aimed to complete a computation task in a collaborative way and achieve the minimal makespan. [24] proposed a task allocation scheme by utilizing social relationship in crowdsourcing system. They concentrated on loading balancing in distributed model. [25] introduced an asynchronous and distributed task selection in mobile crowdsensing. While [17], [24] and [25] focused on task completion in a distributed way, they actually had a centralized system to provide services, which is not consistent with the requirement of our idea that builds the crowdsourcing system in a decentralized way.

Blockchain-Based Crowdsourcing System. [26] proposed CrowdJury which is a blockchain-based crowdsourcing application for court processing of adjudication. This is most related to our approach, but the details about the design of crowdsourcing protocols are not provided. [27] and [28] presented a blockchain-based crowdfunding which is a specific type of crowdsourcing. [29] raised an alternative protocol employing blockchain to tackle the issue of small-value transactions in crowdsourcing. In addition, the research on blockchain-based crowdsourcing has also gained considerable interest in industry recently, such as microwork[30] and Gems [31]. The above mentioned works are limited to their specific applications (i.e., CrowdJury with court adjudication), whilst in comparison, we conceptualize a blockchain-based decentralized framework with much broader goals, such as providing a direction for system designers to design a class of decentralized protocols in crowdsourcing.

SECTION 3Background
3.1 Blockchain
Bitcoin [32] is the first idea of a decentralized currency which has attracted lots of attentions. A set of time-ordered transactions are recorded in files called “blocks”. Each block contains the hash value of the previous block, and they eventually form a hash chain called “blockchain” which is essentially a public, immutable and ordered distributed ledger. Users offer computing resources to compete for the right of recording transactions into blockchain, and the winner will be rewarded with coins and transaction fee. Blockchain technology provides a new direction for us to reduce the role of the middleman in current society [33]. And we can easily associate blockchain with the financial sector (e.g., Bitcoin), but the innovative potential of blockchain applications is much more than this. The applications in different areas, such as Micropayment schemes [34], naming and storage system [12], [35], and health records sharing [36], are based on blockchain technology.

Transaction. Defined as a data structure, transaction consists of three segments: inputs, outputs and digital signature. For a valid coin transaction, the input must be an unspent of a previous transaction. All transactions during a period of time are linked together as a structure (e.g., Merkle tree) and filled into a block by a miner. Once the block is confirmed for a certain period, these transactions will not be able to be changed anymore.

Consensus Protocol. Consensus protocol aims to determine which miner's block will be appended on the blockchain. Generally, the miner gets the recording right by affording a valid proof which can be confirmed correct by other miners, such as a challenging computational puzzle in Bitcoin. In particular, the consensus blockchain is also the longest chain, which refers to the largest work to be produced. There exist several kinds of consensus protocol, such as proof of work (PoW) [32] and proof of stake (PoS) [37].

Network. Blockchain uses a peer-to-peer (P2P) network, which is a distributed application architecture [38]. Unlike the traditional client/server mode, nodes in P2P network have equal privilege without a central coordination by servers or stable hosts, i.e., they are both suppliers and consumers of resources.

Blockchain Paradigm. Blockchain can be viewed as a transaction-based state machine [39]. Each state includes information like a nonce, account balances, data expressing information of the physical world, etc. It is updated from a genesis state to a final state after each transaction. In this scheme, we focus on smart contract execution and state transition. Let's give a description of blockchain paradigm by describing a simplified transaction that depicts a smart contract execution here. A transaction Tx could activate the code execution of smart contract. Then, a valid state transition from σ to σt+1 via Tx is denoted as: σt+1=F(σ,Tx), where F refers to arbitrary computation which is carried out by blockchain, and σ can store arbitrary state between transactions.

3.2 Smart Contract
Smart contract, which refers to the Blockchain 2.0 space [40], is proposed by Nick Szabo in 1994 [41]. It depicts complex logics by programming common process into code and represents the implementation of contract-based agreement. It is essentially a self-executing digital contract in a secure environment with no intervention and verified through network peers. The main reason for difficult to realize smart contract before is that it's hard to find a secure environment which is decentralized, unalterable and programmable. The advent of blockchain technology could solve this problem perfectly. Currently, there exist several blockchain platforms supporting smart contract, two famous of which are Ethereum [39] and Hyperledger [42]. They are designed to run smart contract without frauds, downtime or any third party interference.

SECTION 4System Model
In this section, we present the system model and the workflow for blockchain-based crowdsourcing. Based on the system model, we formulate the threats and analyze the technical challenges. Before formulating the problem, we show the notations within this paper as in Table 1.

TABLE 1 The Notations of Explanation

4.1 Decentralized Crowdsourcing System Model
As shown in the Fig. 2, there exist four roles in the model of the proposed framework: Requester, Worker, CrowdBCClient, and Miner.


Fig. 2.
The system model of CrowdBC.

Show All

Requesters, identified by R={R1,…,Ri,…,Rn}, post a task by transferring task descriptions into programs. To stimulate workers participating in and prevent any unfair event, a certain amount of reward v and a monetary penalty πR are required as the deposit (i.e., depositR=v+πR) which cannot be redeemed before deadline.

Workers, identified by W={W1,…,Wj,…,Wm}, are the community who have certain skills and compete for tasks to get rewards. Worker Wj is selected depending on a tuple of reliability value {βWj, categoryk(εk, φk)}, where βWj refers to the reputation value, and categoryk(εk, φk) denotes that worker Wj has received the task of categoryk and submitted solutions to this category task for εk times and got φk high evaluation. We require that each worker makes a deposit πWj on blockchain to thwart DDoS and Sybil attack. Upon the evaluation of the solution, Wj is assigned with corresponding rewards vR. Note that we define the solutions submitted by workers as s={s1,…,sj,…,sm}.

CrowdBC Client, served as a medium for R and W, is not controlled by any third party, just like Bitcoin Core. It could run locally on user's personal computer. R and W reach to the agreement by transactions in CrowdBC.

Miners mainly add past transactions into a block and provide a valid proof to claim the block reward and transaction fees (i.e., mining). The security of the underlying blockchain is built on top of these miners. Note that R and W can also be viewed as miners if they participate in the mining work.

In our scheme, we require that R and W register to get the credentials before obtaining services from our system, i.e., Ri=(KpRi,KsRi,KaRi) and Wj=(KpWj,KsWj,KaWj) (private key is kept by user). Then, Ri can post a special category task T by utilizing CrowdBCClient which sends a transaction to the blockchain. There have many category of tasks (e.g., JAVA software development, logo design) which are pre-defined in program, category={category1,…,categoryk}. The authenticated worker whose reliability value satisfies the minimum condition can receive the task. Using the Turing-complete programs in blockchain, W can reach agreements with R. Upon the evaluation of the solution, W are assigned with corresponding rewards.

4.2 Threat Models
The potential malicious requesters and workers have specifically different goals to maximize their own profits. We first define the threat model which illustrates potential threats and malicious behaviors as follows:

Malicious Requesters. Malicious requesters aim to collect useful solutions without losing the deposit, which is false-reporting attack in essential. To achieve this goal, they may misreport the evaluation solution as low level even if workers contribute high-quality of solution. In addition, they may even deny they have obtained the solutions. Besides, we require requesters make a deposit in our protocol, while they may benefit from not following or even breaking the protocol, which means that malicious requesters may attempt to create a fork chain after they receive the solutions.

Malicious Workers. Malicious workers attempt to obtain rewards without paying sufficient effort, which is free-riding attack. The same as the malicious requesters, they may benefit from not following or even breaking time-locked deposit protocol, which means malicious workers may try to create a fork chain if they receive low level evaluation. They may receive the task but not submit solutions on time, which could discourage requesters from participating in the crowdsourcing system. In particular, they may deny the low-quality solution because there does not exist a third party to audit it, which is a trust problem. Besides, since their reputation and expertise data play a vital role in verifying the qualification when receiving the task, they may improve these data with posting a task by themselves.

Malicious Miners. The malicious miners attempt to earn much virtual coins by forking a chain or colluding with malicious requesters or workers to break the normal execution of program on blockchain.

We formalize a security property as fully fraud resistant and give the definition as follows:

Definition. (Fully Fraud Resistant) The crowdsourcing system is fully fraud resistant if none of the following condition happens:

Requesters can bring back their rewards for workers if they get effective solutions.

Workers can redeem their deposits if they do not submit solutions on time or contribute low-quality solutions.

4.3 Security Assumption
Majority Honest Security. The security of crowdsourcing task in CrowdBC is related with the security of blockchain. Considering that requesters and workers can take part in mining, we assume that the attacker (including malicious requesters, workers and miners) cannot break the fundamental security of blockchain, namely, the attacker does not have the majority of power or resource to control the blockchain network and the majority of miners are honest. The network has low latency and messages are synchronous between honest miners.

Assume that there exist n total miners in crowdsourcing system (including requesters and workers who participate in maintaining the system as miners), and α be percentage of malicious miners who try to create a fork chain to their own advantage. Each miner tries to find a block (e.g., provides a PoW solution) with probability p for every hash computation, and for the total number of q computations in a round (which can be viewed as a function of current time T, r=r(T)). The parameter that reflects the hashing power of the honest miners can be denoted by X=(1−α)npq, and similarly Z=αnpq represents the hashing power of malicious miners. For malicious miners, they may violate the blockchain protocol by withholding blocks and not broadcasting them to the network, while for honest miners they can only accept one block in a round no matter how many blocks were generated. Thus the probability that honest miners find at least one block in a round is 1−(1−p)(1−α)nq, and the probability that honest miner find only one block is (1−α)nqp(1−p)((1−α)nq−1). We denote Y the lower bound of the probability, that for p<0.1 and θ∈(p,2), we have:
1−(1−p)(1−α)nq≥(1−α)nqp(1−p)((1−α)nq−1)≥θe(−θ−p)=Y.(1)
View Source

Secure Transfer with Wallet. Compared with traditional crowdsourcing system in money reward or exchange, we use virtual coins in blockchain. Coins can be obtained by mining or transferring with others. We assume that each user who has the secret key can securely possess and transfer it with the client wallet.

Secure Encryption Algorithm. We assume that the solution is encrypted by leveraging a secure public key encryption algorithm. Workers use the corresponding requester's public key to encrypt the solutions. Requesters could decrypt the solutions successfully by the secret key. Specifically, the solutions are saved as cipher text in distributed database.

4.4 Technical Challenges
Traditional crowdsourcing relies on a centralized system to post and receive tasks, which is essentially a three-party system model. The blockchain technology has provided a promising way to solve the trust issue among multiple parties. One may simply adopt the blockchain technology in crowdsourcing by using smart contract to depict the process of task crowdsourcing: requester posts a task with the task reward by smart contract and workers can receive it by operating the contract. When the task is finished, workers give solutions to requester in off-chain. However, as pointed out in the threat model, requesters and workers may benefit from not following this process. Requesters may evaluate the solution to be low-quality even if workers pay high effort, or deny obtaining workers’ solutions for short of the arbiters. Workers may pay low effort to submit solutions for the sake of task reward, or even receive the task but not submit solution. Different from the digital currency transfer in Bitcoin, it could be more complicated that numerous malicious behaviors may discourage requesters and workers from participating in the blockchain-based crowdsourcing system. Therefore, how to ensure the fairness between requesters and workers under the decentralized crowdsourcing system is our first challenge:

Challenges 1. Utilizing the blockchain technology to enhance crowdsourcing, while lacking an efficient scheme to ensure the fairness between requesters and workers under the fully decentralized framework.

The blockchain is an infinite extended ledger that new blocks will be created continuously. It is improper to put too much data on blockchain. However, crowdsourcing task may contain huge size of data. Taking image tagging task for example, there may be thousands of images to be labeled, which is impossible to put these data in block. What's worse, huge block data has an effect on the message synchronization and takes too much disk size. For example, at 29 May 2018, a full mining node of bitcoin needs to occupy 156G total disk space to synchronize with the network. Thus, how to store the large-scale crowdsourcing data under blockchain-based crowdsourcing system is our second challenge:

Challenges 2. Performing large scale crowdsourcing process atop on blockchain technology while limited data storage on block.

SECTION 5CrowdBC: Blockchain-Based Decentralized Framework for Crowdsourcing
5.1 Overview of CrowdBC
Combining the advantages of blockchain, we formalize a decentralized crowdsourcing framework named CrowdBC. It allows users to finish a crowdsourcing process in the logic plane and store their encrypted solutions in the data plane. First and foremost, CrowdBCClient is designed as the user interface in the logic plane, and it runs locally on user's personal computer without depending on any central server. More importantly, CrowdBCClient allows workers and requesters to interact with the underlying blockchain. Requesters and workers reach an agreement on top of blockchain which is used to achieve eventual consensus on the state of each task. It supports all operations for the crowdsourcing, such as registration, posting task and receiving task.

Three Layers Architecture. Inspired by [35], we divide CrowdBC into three layers: the application layer, blockchain layer and storage layer. As shown in Fig. 3, two layers (application and blockchain layer) lie in the logic plane and one layer (storage layer) lies in the data plane. Workers with special skills could query and compete tasks which are posted by requesters in the application layer. The blockchain layer uses the task state changes as input to achieve consensus between workers and requesters. Notice that, there exist lots of data collected from requesters and workers, because of the limited data storage capacity in blockchain. We separate the logic layer and the data layer and believe this separation can improve CrowdBC's data storage significantly. We put the task metadata (such as data size, owner, hash value, pointer) in the blockchain layer and raw data in the storage layer. Thus, users do not need to trust the data saved in the data layer and they can verify the integrity and authenticity of data in the logic layer.


Fig. 3.
The architecture of CrowdBC.

Show All

Underlying Blockchain. Without loss of generality, the blockchain we adopt supports execution of any arbitrary “program” which is short for Turing-complete program (e.g., smart contract). We assume that each blockchain platform has a “Compiler” to compile the “program”. And how to build a compiler is out of the scope of this paper and we do not depict here. We design a user interface module in the client for workers and requesters to interact with the “program” and the blockchain.

State Machine Construction. Our framework constructs a state machine to depict task processing. It depicts the task life cycle, and each state represents the global status of the task. The task is triggered from the current state to the next state with users’ valid input in the application layer. Fig. 4 shows the different states that a task can be in and how the state transfers. Each task generates a new state machine and the global state of the task is updated successfully when a new block is created. There exist six states: Pending, Unclaimed, Claimed, Evaluating, Canceled, Completed. Users can query task's current state at any time by themselves.


Fig. 4.
State machine model for task.

Show All

5.2 CrowdBC Layers
Now, we present the architecture of CrowdBC which contains two planes: the logic plane and the data plane. The logic plane, which consists of the application layer and blockchain layer, is used as providing user management and task management for requesters and workers. The data plane which is responsible for task data or solution storage mainly refers to the storage layer.

5.2.1 Application Layer
The application layer mainly refers to CrowdBCClient. It provides users with entrance to finish a crowdsourcing task and contains three main modules: User Manager (UM), Task Manager (TM) and Program Compiler. The client runs correctly without relying on a central server, even there exist some failed nodes, the services for crowdsourcing are not affected in CrowdBC. This design can improve the security of crowdsourcing system.

To make it more clearly, we introduce each module's function respectively. UM acts as the registration and user information management. Users should first register before starting the crowdsourcing task. They do not need to provide true identities and just register with public key and address. Meanwhile, each identification is related with a default reputation value. The value is changed upon the worker's behavior and cannot be updated by himself/herself. A new user fills personal information which refers mainly on key pair and description with the client, and creates a new “program” in the blockchain. A middle module “Program Compiler” is built to convert the new creating “program” into executable language of the blockchain layer. Once the “program” is written into the blockchain, the user registers successfully. Then, he/she can post or receive a task based on TM which is the task management module. Crowdsourcing tasks are depicted into “program” and run in the blockchain, including task posting, task receiving, solution submission and reward assignment. Remarkably, in order to get satisfactory results, the requester only allows qualified workers who reach a minimum reputation value to receive the task. We will give the detailed description about the decentralized crowdsourcing protocol in section 6.4.

5.2.2 Blockchain Layer
The blockchain layer is the middle tier and serves two purposes: 1) providing consensus on the order in which “program” is written and 2) running state machine. The “program” is sent to the blockchain layer after being compiled, then they are written to the blockchain after being confirmed by miners. The proposed framework defines the logic of state transition by the “program” via cryptographically-secured transactions. State machine uses valid input from the application layer and triggers task state changes in the blockchain layer ultimately.

Generally speaking, blocks in blockchain layer should not hold too much data. Otherwise, it will have an effect on the network synchronization and take too much disk space. In order to reduce the data size stored on blockchain, we separate the metadata (including owner, time stamp, pointer, data hash value, etc.) from the actual storage of data. In detail, the task attachments and solution data are stored off-blockchain in the distributed database. A data pointer which consists of a query string is saved in the blockchain and can be used to find the data in the storage layer. Besides, the hash value of the data is saved in the blockchain, which can guarantee the data have not been changed in the storage layer. By this way, the data storage capacity of our framework increases obviously.

5.2.3 Storage Layer
The storage layer is the lowest tier, which is mainly used to store the actual data values of tasks and solutions. We do not adopt any particular storage in the framework, instead allowing multiple storage providers to coexist, such as S3, IPFS [43] or a distributed Hashtable (e.g., Kademilia [44]). The data values are signed by private keys of the owners. Users do not need to believe the data stored in the storage layer, and they could check the authenticity and integrity of the data values by data's hash and digital signature in the blockchain layer. In addition, worker submits a solution to the system and use requester's public key to encrypt the solution, which means only requester can decrypt it. In this way, we can ensure data security and prevent data from being leaked to irrelevant users. In particular, by storing task data outside of the blockchain, CrowdBC allows values of arbitrary size and satisfies actual demands for crowdsourcing.

5.3 The Crowdsourcing Process in CrowdBC
In this section, we describe the general process of our framework. Based on CrowdBCClient, our framework consists of six steps as follows:

Step1. In the first step, requesters and workers register in CrowdBC. CrowdBCClient transfers users’ information into the input of “program” which is written into a transaction and will be sent to blockchain. Each registered user is assigned with a public key pair.

Step2. Updating “program” can be seen as a transaction which needs to be confirmed by miners. The following steps are all related with this step and it depicts that the data and status are recorded on the blockchain permanently.

Step3. It is performed by requester to post tasks. Requesters are required to pay reward in advance and payments are deposited on the blockchain. Meanwhile, a rule for workers is set by requesters to ensure that qualified workers could ultimately receive the task. An evaluation function is also required, and thus the solution can be evaluated by miners on the blockchain instead of the requester or the crowdsourcing system.

Step4. Registered workers receive the posted task by interacting with CrowdBCClient. Each worker receives a task should deposit some coins or a reputation value to ensure the quality of the task.

Step5. Workers submit solutions before the task deadline when they finish the task. The solutions are encrypted with the requester public key and sent to the distributed storage. Meanwhile, a hash value and pointer are stored on the blockchain. Requester could find the solutions by the pointer and decrypt them with his private key.

Step6. The last step is about solution collection, reward assignment and task evaluation. Workers or requesters can complete this step initiatively by publishing a transaction to the blockchain. Rewards are automatically assigned to workers according to the evaluation results which determine how many rewards they can obtain and are related to their efforts. High efforts and good performances will get more reward and improve the reputation.

SECTION 6A Concrete Implementation of CrowdBC
6.1 Crowdsourcing Smart Contracts
In this section, we present a concrete scheme of CrowdBC. The blockchain which supports smart contracts is adopted in the design. From here on, we denote the “program” as smart contract. We implement three types of smart contracts: User Register Contract, User Summary Contract, Requester-Worker Relationship Contract. Fig. 5 shows the contract structures and relationships.


Fig. 5.
The structure of smart contracts in CrowdBC and data references.

Show All

Basically, user (R or W) information is divided into two parts: basic information and detailed information. The basic information which contains name, address and type are saved in the global URC contract. The latter, including one user's profile, expertise, reputation and task list, are saved in USC and updated with the task processing. Notice that USC is created simultaneously when a user successfully registers in URC. Besides, R and W reach the agreement in RWRC which depicts the constraint condition in the task processing.

Specially, there exist three important algorithms: coin processing algorithm lockUtil(⋅), reputation updating algorithm updateReputation(⋅) and solution evaluation algorithm solutionEvaluate(⋅). The first algorithm is to lock the deposits on the blockchain before the deadline and assign reward to the workers upon the last algorithm result. The second algorithm is to manage workers’ reputation. The value of reputation and expertise are automatically updated only with the completed task. CrowdBC evaluates the solution on blockchain with the automatically executed smart contract. With respect to the last algorithm, we assume that there exists a trustful truth discovery algorithm that can evaluate the solutions submitted by a well-defined function solutionEvaluate(⋅) in the programs. There exist some emerged technologies supporting this process [45], [46], [47], [48], such as indistinguishability obfuscation [49], homomorphic encryption [50]. How to design an appropriated evaluation mechanism in the decentralized crowdsourcing framework is an important issue and we will extend this work in the future. The reward assignment and reliability value updating rely on the output of solutionEvaluate(⋅). For simplicity, the output will be “H” (high level of effort) or “L” (low level of effort).

Traditional crowdsourcing systems focus on detecting cheating or malicious behaviors after workers have submitted results. In contrast, CrowdBC selects trustworthy workers based on reputation and reliability value in smart contract, which can effectively improve the quality of results. In order to achieve this goal, we combine expertise-aware with reputation to choose workers in RWRC. Each worker Wj is associated with an attribute Lists[] which contains the crowdsourcing task in special type that they have received and finished. In particular, Lists[]={category1(ε1,φ1),…,categoryk(εk,φk)}. The reliability relk of Wj in category categoryk task can be calculated by relk=εk/φk. It can be used to verify if a worker is somehow topic expert in special category.

6.1.1 User Register Contract (URC)
Upon registration, each requester or worker does not need to submit his/her true identity, and will be assigned with a key pair: a “public key” and a “private key”. The global URC contract produces a user's address by generating a hash with the public key. The address contains no information about the user, which provides users with much higher-level privacy than users in traditional crowdsourcing systems. Meanwhile, an USC contract corresponding to the new registered user will be created.

As mentioned above, users are allowed to use pseudonyms to finish transactions. However, some workers may register with true identity that can be authenticated in certified institutions, which can increase the probability of receiving task in CrowdBC. Besides, we set rules into the URC contract that registering new identities will be recognized and the mapping of the total user list could be updated. Notice that updating or creating a contract need transaction fee which is paid by the party who publishes it. Transaction fee is given to miners who confirm the transaction and support CrowdBC running persistently.

6.1.2 User Summary Contract (USC)
This contract stores the personal statistics information and evaluation for requesters and workers according to their past behavior. We establish multi-metrics to evaluate workers and requesters in USC for the sake of reducing any subjective judgment, including profile, reputation, task general description and activity. Profile mainly describes user basic information, including skills, profession, etc. Specially, if users register with true identities, profile also contains a digital signature signed by a certificate authority, and users can authenticate identities by their public keys. This metric is set up when users register at the first time and can be updated by themselves. Reputation βW is an important parameter which is initialized with default value and updated with the completion of the task. In our framework, we build the reputation-based incentive mechanism based on [13], which will be described in Section 6.3. High reputation value reflects a user's good performance in the past. Task general description refers to the summary information about task statistics, including total receiving task lists and high evaluation task list (i.e., (ε,φ)). Activity describes the level of activity and working extent for users, including proportion of task-delay, biding number. High activity level depicts hard working with tasks. It is worth noting that these metrics cannot be changed easily by any single third party and are automatically updated only with the related completed task.

Workers find an uncompleted task by querying requester's task list in USC. Each task in USC has a status. Tasks in the state of Pending or Unclaimed illustrate that they still accept solutions and the qualified workers can receive the task and verify the task signature with requester's public key. USC also contains a list of task addresses which can point to user's previous task in the Requester-Worker Relationship Contract.

6.1.3 Requester-Worker Relationship Contract (RWRC)
Requester-Worker Relationship Contract depicts the agreement between requesters and workers, which is about the process of task posting, task receiving, solution evaluation, and reward assignment. It is created when requester posts a task T and publishes the task information, T={desc,KpR,coins(v+πR),(βk,εk,φk),λ,TIdeadline,TIconfirm,soluationEvaluation(⋅)}. Requester posts the task T in a transaction with his/her private key and other workers could check it by the corresponding public key.

When Wj wants to receive task, RWRC contains a validation function checkWorkerQualification(⋅) and checks if worker's reputation and reliability value satisfy the minimum limited. Generally, a minimum reputation and reliability value is set to avoid low level workers. Meanwhile, requester defines a fixed worker pool Wpool to store workers’ addresses, the size of workers pool λ is corresponding to required workers, and each worker who satisfies the validation function would add his/her address to Wpool. If workers are qualified, they update RWRC by publishing it to the blockchain, which represents they receive a task successfully. RWRC contract cannot receive workers if the size of Wpool exceeding λ. Requester cannot assign the task to workers more than he/she could pay, because smart contract is published on the network and each miner would verify.

As mentioned before, the data saved on the blockchain should not be too large due to the limited storage. Thus, we put only the task metadata on the blockchain by RWRC and other detail information to the distributed storage layer. Moreover, in order to prevent requesters from behaving as “false-reporting” and workers from behaving as “free-riding” in pursuit of self-interest maximization, a timed-locked deposit protocol is constructed, which will be depicted in Section 6.2. Making a deposit before processing crowdsourcing task is a unique feature which is necessary under our framework to guarantee the fairness of the users. Note that if worker submits an effective solution which is confirmed by a miner, the deposit will be returned back to him/her; otherwise, the coin will be deducted by requester and worker's reputation value will be reduced.

Different from the traditional model in which solutions are evaluated by requester or the crowdsourcing system, the solutions in CrowdBC are evaluated by miners. The evaluation function solutionEvaluate(⋅) is posted with RWRC by requester and miners could verify the solutions without knowing the solution details.

As to data storage, a particular space is allocated for each RWRC in the storage layer. Task attachments and solutions are stored in the space, and the corresponding hash values are recorded in the blockchain to guarantee solutions unaltered at the source. Especially, to protect data privacy, workers use requester's public key to encrypt the solutions. Requester can decrypt them and verify the integrity of the data values in the blockchain layer. On the other hand, a pointer is created once worker submits the solution successfully. It is also written in RWRC and can be used to find the solution for requester.

6.2 Time-Locked Deposit Protocol for Crowdsourcing
Our key idea is letting requesters and workers obtain fair results atop on blockchain without relying on central crowdsourcing platform. To prevent false-reporting and free-riding attacks, participants are required to make a time-locked deposit as a guarantee to regulate their behavior. The deposit which can be funds or reputation value (only for workers) will be assigned to designated entities according to the pre-defined smart contract. Some works have been done to achieve time-locked blockchain deposit protocol [51], [52], [53]. These protocols enable one party (payer) to exchange with other parities (payee) to lock a certain coins as a guarantee on blockchain. To prevent equivocation attack, the party cannot redeem the deposit until deadline even if he/she has the secret key. However, these protocols cannot be directly applied to crowdsourcing scenario with two reasons: one is that workers are not explicit when requester makes the deposit. The other is that they assume that payees are honest and may not perform malicious behavior, while this is not always the case in CrowdBC.

Inspired by [54], [55], we illustrate F∗RR (RR stands for “refund-or-reward”), a time-locked deposit protocol for crowdsourcing. The adversary will be punished with monetary or reputation penalty when he/she aborts or breaks the task crowdsourcing protocol which is pre-defined in F∗RR. The other honest party will be compensated with adversary's deposit. F∗RR allows requester to send coins to worker under some condition. In special, the condition is to verify if the solutions submitted by workers satisfy pre-defined requirements (i.e., solutionEvaluate(⋅)). We define F∗RR scheme to be a tuple of phases as shown in Fig. 6.


Fig. 6.
The time-locked deposit protocol for crowdsourcing.

Show All

6.3 Reputation Management
CrowdBC builds the incentive mechanism based on users’ past behavior. Requesters are demanded to pay money before they post task, so we mainly focus on workers’ reputation. Each worker is assigned with a reputation which can be viewed as one of the important references for requesters when they choose workers. A high reputation reflects their good behaviors on solving tasks in the past; otherwise, they will be limited to participate in some tasks.

Unlike traditional crowdsourcing systems where the reputation management is implemented by the third party, we define the protocols and implement them in the decentralized blockchain. Each worker is tagged with a reputation βW. βW is an integer number from the finite set set(0,1,…,βMaxW), where βMaxW represents the max size of this set. hk is the average reputation of the whole workers. Updating βW depends on the outcome of solutionEvaluation(⋅) in RWRC. If a miner confirms a solution and gives the positive evaluation, worker's reputation will be increased and recorded in blockchain. Note that worker cannot update the reputation by himself, because miners will not confirm this type of transactions. Let “a” refer to the output of the evaluation function. “a=H” stands for high effort of action and “a=L” stands for low effort of action. Thus, the reputation βW can be computed as follows:
βW=⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪min(βMaxW,βW+1),βW−1,0,βW+1,if a=H and βW≥hkif a=L and βW≥hk+1if a=L and βW=hkif βW<hk+1,(2)
View Sourcewhere hk denotes the threshold of the selected social strategy, which is a method of using social norms to control workers’ behaviors [13]. If the worker's reputation falls to hk and receives an “L” feedback by using the evaluation function, his/her reputation will fall to 0 and cannot receive most of the tasks. He/she needs to receive enough simple tasks and get positive feedback until his reputation value reaching hk again.

6.4 The Proposed Decentralized Crowdsourcing Protocol
In the section, to formalize the decentralized crowdsourcing protocols, we adopt a designed notational system such that readers may understand our constructions without understanding the precise details of our formal modeling. It consists of six algorithms: Register,TransactionConfirmation,TaskPosting,TaskReceiving,SolutionSubmitting,SolutionEvaluation,RewardAssignment. Users interact with the blockchain by CrowdBCClient. To make it clearer, we elaborate the general contract flow of CrowdBC in Fig. 7.


Fig. 7.
The process of crowdsourcing in CrowdBC and smart contract updating.

Show All

6.4.1 Register
We require that requesters and workers register in CrowdBC to get their identities (mainly refer to public key, private key and public address) via URC contract, i.e., Ri=(KpRi,KsRi,KaRi),i=1,…,n and Wj=(KpWj,KsWj,KaWj),j=1,…,m. Worker's initial reputation value βW is the average reputation value of all workers.

6.4.2 TransactionConfirmation
The processes of creating and updating a contract can be seen as a transaction which needs to be confirmed in the blockchain. Miners can verify the effectiveness of transactions. Workers and requesters can participate in the blockchain as a “miner” and contribute their resources to achieve a trustworthy chain. To model the confirmation of the transaction and the execution of blocks, we define the blockchain state as a pair (BCσ,BC), where BCσ is the previous block and BC is the current one. BC={Maddr,(Tx1,…,Txc,…,Txk),timestamp,blockid,preblockhash}, where Maddr is the address of a miner, and Txc is the contract which needs to be confirmed. Users need to wait for several blocks to ensure that the contract is recorded immutably in blockchain.

Algorithm 1. Post Task
Input: requester Ri, task description T, task reward coins(vRi+πRi), the limited condition of workers (βk,εk,δk), finish time TIdeadline, confirm time TIconfirm, maximum workers number λ, USC address USCaddrRi

Output: RWRC contract RWRCT, result validation function solutionEvaluation(⋅), update USCRi

if Ri is unregistered then

Ri has not been registered;

goto final;

if lockUtil(KpRi,coins(vRi+πRi),TIdeadline+TIconfirm) is not success then

Ri deposits the reward on blockchain failed ;

goto final;

checkWorkerQualification(⋅) ← (βk,εk,δk) ;

solutionEvaluation(⋅) ← T ;

WlistT(1,...,λ) ← λ ;

receivedWorkerNumT ← 0 ;

RDepositR ← {T,WlistT(1,...,λ),(βk,εk,δk),coins(vRi+πRi),TIdeadline,TIconfirm,solutionEvaluation(⋅))} ;

USCTpoolRi put RWRCaddrT ;

updateUSCContract(RWRCaddrT,USCRi) ;

final ;

return RWRCT, solutionEvaluation(⋅);

6.4.3 TaskPosting
After registration, requester could post a task T to CrowdBC, T={sid,T,TIdeadline,TIconfirm,KpR,(βk,εk,δk),λ,coins(v+πR)TI,solutionEvaluate(⋅)}. For each task, there is a limited condition (βk,εk,δk) which means the minimum corresponding value of workers who can receive the task. It is worth noting that setting these data too large will have an affect on the number of participants. λ refers to the number of workers required to complete the task. In order to avoid denial of payment by requester, we specify that requester makes a deposit by following F∗RR. Algorithm 1 illustrates the implementation of posting task.

6.4.4 TaskReceiving
Worker finds uncompleted tasks in requester's USC contract and receives a task if he/she satisfies the condition set by requester. The condition function checkWorkerQualification(T,βWj,relWj) means that a task T can be received by a worker Wj with the value βWj≥βT, relWj≥relT. Besides, for the sake of making workers do the job industriously, worker deposits a coin or certain reputation value before receiving the task. If he/she chooses coin coins(v) as the deposit, we still use the function lockUtil(KpWj,coins(v),TIdeadline+TIconfirm). Otherwise, reputation is reduced by βWj within the process of this task and added after completing the task if the worker submits solution on time. Worker signs on T with the KsWj, which can ensure the correctness for task reward assignment in the end. Algorithm 2 illustrates the implementation of receiving task.

Algorithm 2. Receive Task
Input: RWRC contract RWRCT, worker Wj, worker deposit coin coin(πWj), worker deposit reputation RepT, worker USCWj

Output: update RWRC contract RWRCT and USC contract USCWj

if Wj is unregistered then

Wj has not been registered;

goto final;

if checkWorkerQualification(T,βWj,relWj) is dissatisfactory then

Wj does not satisfy the condition;

goto final;

if receivedWorkerNumT>=Wnum then

Task T cannot be accepted anymore;

goto final;

if coin(πWj)≠0&lockUtil(KpWj,coin(πWj),TIdeadline+TIconfirm−now) is success then

Wj deposits reward on blockchain succeeded ;

else if βWj≠0&updateUSCContract(USCWj,KpWj,(βWj−RepT)) is success then

Wj deposits reputation on blockchain succeeded ;

else

Wj makes a deposit in blockchain failed ;

goto final;

SignWj ← Digital signature on T with Sign(T)KsWj;

WlistT(1...Wnum)(T) add SignWj ;

USCTpoolW put RWRCaddrT ;

receivedWorkerNumT++ ;

WDepositWj ← {T,TIdeadline,TIconfirm,KpRi,KpWj,coins(vRi)TI,coins(πWj)TI,redeem(⋅)};

updateUSCContract(RWRCaddrT,USCWj) ;

final ;

return RWRCT and USCWj;

6.4.5 SolutionSubmitting
Worker could submit solution to requester if he/she completes the task (Algorithm 3). The task solution, encrypted by requester's public key KpR and signed by worker's private key KpW, is stored on the distributed database (e.g., IPFS). The hash and pointer of the solution is stored on the blockchain. Requester could get the solution by the pointer and decrypt it using his/her private key.

Algorithm 3. Submit Solution
Input: RWRC contract RWRCT, task solution sj, worker Wj, requester Ri

Output: solution pointer sponiterj, solution hash value shashj

if now>TIdeadline then

sj cannot be submitted for timeout;

goto final;

Sign_{s_j} \leftarrow Digital signature on s_j with \mathsf{Sign}(s_j)_{K_{W_j}^s} ;

s^{encrypted}_j \leftarrow Encrypt the solution \lbrace s_j, Sign_{s_j})\rbrace with K_{R_i}^p ;

s_j^{hash} \leftarrow \mathsf{H}(s^{encrypted}_j) ;

s_j^{poniter} \leftarrow \mathsf{sendDataToIPFS}(s^{encrypted}_j) ;

TI_{submit} \leftarrow now ;

RWRC_T^{s_{list}} \leftarrow \lbrace s_j^{hash}, s_j^{poniter}, TI_{submit}\rbrace ;

\mathsf{updateUSCContract}(RWRC_T^{addr}, USC_{W_j}) ;

\mathsf{updateUSCContract}(RWRC_T^{addr}, USC_{R_i}) ;

final ;

return s^{poniter}_j and s^{hash}_j;

6.4.6 RewardAssignment
After submitting the solution, workers could demand for the process of task evaluation and reward payment, or requesters initiatively finish them when the finish time is on. In our design, we assume that the evaluation result is given under the evaluation function and miners on the blockchain could confirm. As shown in Algorithm 4, the task reward paid to workers is quality-contingent payment (i.e., better performance will get more reward). The evaluation result will be automatically synchronized with worker's USC contract to update his/her reputation.

6.5 Security Analysis
In our design, CrowdBC fulfills several security properties and we discuss them here.

Fully Fraud Resilient. With the majority honest security assumption in Section 4.3, we discuss the fully fraud resilient property in CrowdBC.

Theorem. Assume that Y\geq (1+\delta)Z with \delta \in (0, 1), then the probability that CrowdBC-based system violates fully fraud resilient property with parameter t is at most e^{-\Omega (\delta ^3 t)}.

Proof. The event that CrowdBC does not meet fully fraud resilient property happens if either a malicious requester or a malicious worker succeeds in building a fork chain which was finally accepted by honest miners in the system. We first define C1 and C2 as follows:

C1: the malicious chain that requesters or workers violate fully fraud resilient property.

C2: the normal chain that requesters or workers follow.

We show that for any t, the probability that C1 and C2 diverge at time (T-t) is at most e^{-\Omega (\delta ^3 t)}. First, we show the probability that malicious miners can use blocks mined before time T-(1+\delta /8)t to compensate is at most e^{-\Omega (\delta ^3 t)}. Let t^{\ast }\leq T-(1+\delta /8) be the time that the latest block was found by honest miner in adversary's chain C1. If at time t^{\prime }\geq T-t, the malicious chain C1 is accepted by honest miner, then malicious miners must find more blocks than honest miners during [t^\ast, t^{\prime }] where all honest blocks become orphans. Let \hat{X} denote the total number of rounds when honest miners find blocks, and \hat{Z} denote the number of all block that are mined by the adversary during [t^\ast, t^{\prime }]. Since t^{\prime }-t^\ast \geq (\delta /8)t, according to Chernoff bounds [56], we have: \begin{align} Pr[\hat{X}& \leq (1-\delta /5)Y\cdot r(\delta t/8)]\leq e^{-\Omega (Y\delta ^2 r(\delta t/8))}=e^{-\Omega (\delta ^3 t)}\nonumber\\ Pr[\hat{Z}]& \geq (1+\delta /3)Z\cdot r(\delta t/8)]\leq e^{-\Omega (Z\delta ^2 r(\delta t/8))}=e^{-\Omega (\delta ^3 t)}. \end{align}
View SourceRight-click on figure for MathML and additional features.

Algorithm 4. Evaluate Task and Send Reward
Input: RWRC contract RWRC_T, requester {R_i}, workers list W_{list}, selected social strategy h_k

Output: update RWRC contract RWRC_T and USC contract USC_{R_i}, USC_{W_j}, send reward to related worker W_j

rewardNeedSend \leftarrow coins(v) / \lambda;

for each W_j in W_{list} do

if TI_{submit} \leq TI_{deadline} then

if \mathsf{Verify}(s_j^{hash})_{K_{W_j}^p} is not success then

Check K_{W_j}^p signature failed ;

continue ;

evaluationResult_j \leftarrow \mathsf{solutionEvaluation}(T, s_j^{poniter}, s_j^{hash}) ;

oldRep \leftarrow \beta _{W_j} + Rep_{T} ;

if oldRep \geq h_k \& evaluationResult_j\equiv H then

\beta _{W_j} \leftarrow min\lbrace \beta _{W_j}^{Max}, oldRep + 1\rbrace ;

rewardNeedSend \leftarrow coins(v_{R_i}+\pi _{W_j}) ;

else if oldRep \geq h_k \& evaluationResult_j\equiv L then

\beta _{W_j} \leftarrow oldRep - Rep_T ;

rewardNeedSend \leftarrow coins(\pi _{W_j}) ;

else if oldRep \equiv h_k \& evaluationResult_j\equiv L then

\beta _{W_j} \leftarrow 0 ;

rewardNeedSend \leftarrow coins(\pi _{W_j}) ;

else if oldRep < h_k then

\beta _{W_j} \leftarrow oldRep + 1 ;

rewardNeedSend \leftarrow coins(\pi _{W_j}) ;

else

evaluationResult_j \leftarrow L ;

rewardNeedSend \leftarrow 0 ;

\beta _{W_j} \leftarrow \beta _{W_j} - Rep_T ;

isSendRewardSuc \leftarrow \mathsf {sendReward}(K_{W_j}^p, rewardNeedSend) ;

\mathsf{updateReputation}(USC_{W_j}, K_{W_j}^p, \beta _{W_j}) ;

\mathsf{updateUSCContract}(RWRC_T^{addr}, USC_{W_j}) ;

\mathsf{updateUSCContract}(RWRC_T^{addr}, USC_{R_i}) ;

\mathsf{updateAvgReputation}(\cdot)

final ;

return RWRC_T, USC_{R_i}, USC_{W_j},isSendRewardSuc;

Then with overwhelming probability that: \begin{align} \hat{X}&\geq (1-\delta /5)Y\cdot r(\delta t/8)\geq (1-\delta /5)(1+\delta)Z\cdot r(\delta t/8)\nonumber\\ &>(1+\delta /4)(1+\delta /3)Z \cdot r(\delta t/8)>(1+\delta /4) \hat{Z}, \end{align}
View Sourcewhich contradicts the assumption. During time t, malicious miners will try to obtain a large number of blocks to maintain the advantages of C1 over C2. However, whenever only one block was found by honest miner, it would be a chance for honest miners to consent. Let \tilde{Z} denote the number of all block that are mined by the adversary during (1+\delta /8)t, and \tilde{Y} denote the number of rounds in which only one honest miner find a block. By Chernoff bounds, we have: \begin{align} &Pr[\tilde{Z}\geq (1+\delta /9)(1+\delta /8)Z\cdot r(t)]\leq e^{-\Omega (Z\delta ^2 r(t))}\nonumber\\ &Pr[\tilde{Y}\leq (1-\delta /4)Y\cdot r(t)]\leq e^{-\Omega (Y\delta ^2 r(t))}. \end{align}
View SourceWith overwhelming probability that: \begin{align} \tilde{Y}&\geq (1-\delta /4)Y\cdot r(t)\geq (1-\delta /4)(1+\delta)Z\cdot r(t)\nonumber\\ &>(1+\delta /9)(1+\delta /8)Z\cdot r(t)>\tilde{Z}. \end{align}
View SourceFinally, we could conclude that the probability C1 catching up with C2 is exponentially small in t.

Security against False-reporting and Free-riding Attacks. In CrowdBC, solutions are evaluated with the automatically pre-defined smart contract. Under the assumption that the majority of miners are honest, malicious requesters cannot tamper the results of smart contract to launch false-reporting attack. In addition, we have proved that malicious requesters have limited probability to create a fork chain which is in their favor. With respect to free-riding attack, workers are required to make deposits in F_{RR}^* before receiving tasks. They are automatically assigned rewards according to the results of evaluation function. Thus, if they contribute low-quality solutions, they will not get rewards.

No Single Point of Failure (SPOF). No single point of failure is obvious with the blockchain-based decentralized architecture. If there are k (k\geq 3) miners in crowdsourcing, more than \lfloor k/2 \rfloor miners are honest and available in CrowdBC with the majority honest security assumption. According to the peer-to-peer architecture, even though there remains only one miner, requesters and workers can access the crowdsourcing service normally. Thus, CrowdBC is exempted from SPOF.

Pseudonymity. Unlike traditional crowdsourcing systems with some true identity in registration phase, which has the risk of user sensitive information leakage, CrowdBC utilizes the pseudonymous Bitcoin-like addresses to denote requesters and workers, which enables privacy-preserving without submitting true identity to finish a crowdsourcing task.

No Trusted Third Party. Requesters and workers could directly finish the crowdsourcing task and share their data without the intervention of any third party. CrowdBC stores task data and solutions in the distributed storage system, and utilizes time-locked deposit protocol and monetary penalty to ensure fairness between requesters and workers. Users are authorized to post or receive task under the tamper-resistant smart contract, which means that they cannot refute these behaviors even there is no third party.

DDoS and Sybil Attack Resistant. CrowdBC requires deposits from requesters and workers to thwart DDoS and Sybil attacks. In addition, users need to pay transaction fees (even though it's few) for miners who maintain the blockchain network. Therefore, malicious attackers may pay a huge cost to launch these attacks under the deposit-based mechanism (the main threat is that attackers have enough coins to launch attacks, which is not this paper concern currently).

Trustworthy Worker Selection. Reputation and expertise statistic value are important factors for workers receiving a task. High reputation and reliability mean high probability to receive the task. In CrowdBC, updating these values can only happen when worker really completes a crowdsourcing task in RWRC contract. USC contract cannot be created by workers themselves and \mathsf{updateReputation(\cdot)} function in USC can only be invoked by RWRC contract. In particular, RWRC contract needs to make the deposit and pay transaction fee. Therefore, if a malicious worker wants to brush his reputation or reliability, he needs to pay a high cost. In this way, we can anticipate that requesters can select proper workers by setting the reputation and reliability value and workers would work honestly and diligently.

SECTION 7Evaluation Results And Analysis
7.1 System Design
The primary goal of CrowdBC is to design a secure and decentralized crowdsourcing system. We implemented a software prototype on Ethereum public test network to test our proposed scheme and depicted the complex process of crowdsourcing by smart contract1 We evaluated the accuracy of CrowdBC by asking the workers to tag images with labels, which was a type of multi-labeling tasks. Extensions to other arbitrary tasks are also possible, requiring to change the evaluation function to evaluate the result accordingly.

CrowdBC was implemented on official Ethereum public test network Ropsten with program language including solidity, java and javascript with roughly 9963 lines of codes, among which, only about 950 lines are for implementing smart contracts in solidity. Solidity is an object-oriented programming language designed for writing smart contracts in Ethereum. Besides, CrowdBC interacts with Ethereum based on web3j, a lightweight library for java applications on the Ethereum network. Especially, we constructed BCCompiler based on web3j. As above mentioned, each new registering of a user and new task could create a new contract. The task information was input by \mathsf{CrowdBC\; Client} which was developed based on javascript. Then it was transformed into the contract, and compiled by BCCompiler. In order to reduce the storage requirement, we build the local IPFS proxy and store these images IPFS. There are 168 connected peers in IPFS currently.

7.2 Time Complexity
To evaluate the utility, security and performance of CrowdBC, we conducted 20 sets of experiments to process image tagging task on the CIFAR-10 dataset which consists of ten classes of images, such as airplane, automobile, bird and cat. The CIFAR-10 dataset contains five training batches and one test batch, each batch with 10000 images. For each set of experiment, we randomly choose images from the training batch to recognize images. Furthermore, 5 workers and 1 requester are registered and each registered user is assigned with 20 ETH coins. Each task is finished by 3 workers. We randomly selected 500, 1000, 1500, 2000, 2500 images from the training batch, which are identified by task_500, task_1000, task_1500, task_2000, task_2500. Further, task solutions are encrypted with requester's public key and saved in the data storage, thus no malicious users can decrypt and read them. In particular, we design evaluation function by majority voting to verify if the solutions belong to the ten classes of images. Moreover, the gas price is set at the average market price, about 20000000000 Wei[57] (Wei is the smallest subdenomination of ETH [39]). The cost of ETH is computed under the Ethereum gas rules by the formula: COST_{ETH} = COST_{gas} * GAS_{price}/10^{18}.

We deployed URC, USC, RWRC contract in Ropsten. The average block time for mining in Ropsten is 10s. In our experiments, it consisted of 700 transactions, each of which was mined into one block with block number ranging from 3,213,538 to 3,219,692. As shown (a), (b) and (c) in Fig. 8, the average transaction confirmation time (including the execution time in \mathsf{CrowdBC\; Client}) on task posting, task receiving and solution submission were about 37.35s, 32.28s and 36.82s, respectively. Namely, each transaction was confirmed in about 3\sim 4 block time.


Fig. 8.
The time complexity of task crowdsourcing in Ropsten.

Show All

If we did not provide enough transaction fees for our contracts, these transactions were waiting to be confirmed in the transaction pool. As shown in Fig. 8d and 8f, the average data uploading time (including the execution time in \mathsf{CrowdBC\; Client}) in Ropsten on task posting and solution submission were the positive correlation with the data size. However, if the data size was small enough (e.g., solution submission), the uploading time was almost the same (about 246.57 ms). In addition, data was downloaded from multiple nodes simultaneously in IPFS, which made the data download very fast (about 13.27 ms in task receiving). In particular, there existed some large points at task_2000 in Fig. 8f. We found that it was relevant with the uploading data size in the specified time within the whole IPFS system.

We completed part of set experiments to tag images and recorded the accuracy of image tagging by workers with different number of images in each task. The average accuracy was 93.22 percent on 7500 images, among the error results, these images were really unclear. This indicated the good utility of CrowdBC. Besides, we found that part of miners were offline in the experiments, but it did not affect the process of crowdsourcing and users could still normally post or receive the task, which demonstrates the feature of decentralization in our framework.

7.3 Task Cost
In our experiments, the average transaction fee was 0.011 ETH per 100 images. According to AMT reward policy, about 0.45\\$ is paid for each 100 images tagging or identifying task. It's worth noting that when we first designed the experiment in February 2017, 1 ETH price was about 12\\$ , and the cost was acceptable (i.e., 0.14$). As the sharp rise of ETH price in May 2018, 1 ETH was up to 784.21\\$ according to the ETH market price [57], which was unpractical in real life. We can see that the cost was general lower than AMT platform by using the ETH price in February 2017, and the more image quantities had, the cheaper the cost was. Note that the cost (including transaction fee and gas) in CrowdBC has not changed a lot with the image number increased to 2500, while the cost in AMT added about 400 percent (Fig. 9). Therefore, we can conclude that CrowdBC is applicable for the task with large reward.

Fig. 9. - 
The comparison of growth rate of cost in CrowdBC and AMT.
Fig. 9.
The comparison of growth rate of cost in CrowdBC and AMT.

Show All

In sum, we conducted the whole crowdsourcing process with a practical example in CrowdBC, which illustrates that the blockchain-based framework is feasible. However, we realize that a more low-cost and public blockchain for CrowdBC is necessary. Hyperledger as a well known blockchain fabric might be a solution, which is also a future work of our framework.

TABLE 2 Time Consumption on Data Uploading and Downloading in IPFS

SECTION 8Conclusion and Future Work
In this paper, we presented the design of CrowdBC, a blockchain-based decentralized framework for crowdsourcing. We analyzed that the traditional centralized crowdsourcing system suffers from privacy disclosure, single point of failure and high services fee. We formalized CrowdBC to handle these centralized problems. Meanwhile, we enhanced the flexibility of crowdsourcing by smart contract to depict complex crowdsourcing logic. A series of design algorithms based on smart contract were proposed to construct a concrete scheme under the framework. Besides, we evaluated our approach on Ethereum by implementing components providing decentralized crowdsourcing services.

We are still in the early stage of blockchain technology and identify several meaningful future works. First, we only implemented the basic process of crowdsourcing currently, but there exist much more complex scenes to handle. Second, designing an efficient evaluation mechanism is crucial in CrowdBC. We resume that requester could provide an evaluation function when posting the task. However, we should also consider that requester does not know about the solution, and thus giving an efficient evaluation function is becoming difficult.