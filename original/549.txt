Multi-access Edge Computing (MEC), as an extension of cloud computing, provides storage resources at the network edge to enable low-latency data retrieval for users. Due to limited physical sizes and constrained storage resources, individual edge servers cannot store a large amount of data when operating independently. They often need to offload data to other edge servers to serve users collaboratively. Operated by different edge infrastructure providers, edge servers usually work in a distrusted environment. Incentive and trust are the two main challenges in facilitating collaborative edge storage. This article proposes CSEdge, a novel decentralized system that tackles these challenges to enable collaborative edge storage based on blockchain. On CSEdge, edge servers can submit data offloading requests for others to contend for. Winners are selected based on their reputations. They will store the offloaded data and receive rewards for successfully finishing data offloading tasks. Via a distributed consensus, their performance will be recorded on blockchain for future reputation evaluation. A prototype of CSEdge is built on Hyperledger Sawtooth and experimentally evaluated against a baseline system and two start-of-the-art systems in a simulated MEC environment. The results demonstrate that CSEdge can effectively and efficiently facilitate collaborative edge storage among edge servers.

SECTION 1Introduction
Mobile computing and Internet-of-Things (IoT) are changing the world rapidly. Cisco has predicted that there will be 29.3 billion IoT devices and mobile devices by 2023 [1]. Many mobile and IoT app vendors have embraced the software-as-a-service (SaaS) model and deployed applications in the cloud to serve their users. However, the cloud computing paradigm struggles to fulfil many applications’ needs for low end-to-end latency, e.g., online gaming [2], virtual reality [3], etc. It is difficult for the cloud computing paradigm to ensure low latency due to long physical distance from users to the remote cloud [4]. To tackle this challenge, Multi-access Edge Computing (MEC) has emerged to extend cloud computing by offering computing and storage capabilities at base stations or access points within users’ close geographic proximity [5], [6]. It is one of 5G’s key enabling technologies. By storing popular data on edge servers, app vendors like YouTube and Facebook enable low-latency data retrieval for their users [7]. Data generated by end-devices, e.g., smart vehicles and VR devices, can also be stored on edge servers to be shared with other end-devices [8].

While offering unique benefits, MEC also raises many new challenges. Unlike cloud servers that have access to virtually unlimited storage resources, edge servers’ storage capacities are constrained by their limited physical sizes [9]. Individual edge servers cannot fulfil app vendors’ data storage needs, especially in areas with high data demands. Fortunately, adjacent edge servers deployed in a specific area can transmit data via high-speed links [10], forming an edge server network [11]. Over this network, edge servers can retrieve data from other edge servers to serve users within their own coverage areas. Thus, edge servers can offload data to each other to leverage their storage resources collaboratively [12], [13]. Taking Fig. 1 for example, at the moment, edge server es1’s storage capacity is exhausted. It can offload some of its existing or incoming data to other edge servers with sufficient resources in the same area, e.g., es4 or es6. Edge servers es2, es3 and es5 may not be suitable because they are also fully loaded. At the next moment, if es1’s storage capacity is freed up, it can store data offloaded from other edge servers to serve users. In this way, edge servers can leverage their storage capacities over time through collaborative edge storage.

Fig. 1. - 
Example MEC environment.
Fig. 1.
Example MEC environment.

Show All

However, without proper incentives, edge servers may not be willing to store offloaded data, especially when they do not have sufficient storage resources. Intuitively, edge servers would choose to reserve available storage resources to accommodate future data demands. This is the incentive challenge. In the meantime, edge servers are usually operated by different infrastructure providers such as Amazon and Google [14]. Therefore, they operate in an untrusted environment [15], [16] and lack the motivation to store data for others. Trust needs to be established for edge servers to facilitate collaborative edge storage. From the perspective of individual edge servers, they want their data to be offloaded to edge servers that can provide data storage services reliably with a low latency guarantee. Taking Fig. 1 for example, let us assume that both es2 and es3 are willing to store data for es1. Now es1 needs to evaluate their reliability based on their historic performance in storing offloaded data, i.e., data offloaded from other edge servers. In addition, es1 wants data integrity ensured, i.e., its data offloaded to other edge servers must not be compromised. This is the trust challenge. High efficiency is another critical challenge to collaborative edge storage. In the MEC environment, app vendors expect low latency. Data offloading between edge servers must be carried out efficiently. Thus, data offloading must not be coordinated from the remote cloud because it would incur inevitable high latency. In addition, there is a lack of global information about edge servers’ storage capacities or data offloading demands in the MEC environment where edge servers are geographically distributed. In the past few years, researchers are seeking decentralized solutions to a variety of problems in the MEC environment [17], [18], [19]. Similarly, edge servers must coordinate data offloading in a decentralized manner. This is the decentralization challenge.

To facilitate collaborative edge storage, this paper proposes CSEdge, a novel system based on blockchain that tackles the above three correlated challenges systematically. On CSEdge, an edge server, as a data offloader, can publish a data offloading task with promised rewards. Other edge servers, as candidate data offloadee, contend for the task. The most reliable edge server will be selected based on the candidates’ reputation and response time guarantees. It will store the data to serve users for an agreed period of time, and receive rewards for completing the data offloading task as promised. Then, edge servers reach a consensus on the data offloadee’s performance in terms of ensuring data integrity and response time, and record it on the blockchain for reputation calculation in the future. To our best knowledge, this paper is the first attempt to enable collaborative edge storage and its main contributions are:

CSEdge utilizes an incentive mechanism that motivates edge servers to compete for and accomplish data offloading tasks. They will receive base rewards from data offeloaders for finishing data offloading tasks as promised. When their performance exceeds expectations, they will receive bonus rewards from the system. In turn, when they need help with data storage, they can publish data offloading tasks with promised rewards on CSEdge. This tackles the incentive challenge by driving collaboration among edge servers.

CSEdge maintains a reputation mechanism for evaluating reputation of edge servers based on their data offloading performance in the past recorded on the blockchain. In general, an edge server has a better chance to win data offloading tasks if it has a higher reputation. This tackles the trust challenge by helping data offloaders find reliable data offloadees.

CSEdge utilizes a new consensus mechanism named ER-BFT (edge reputation based Byzantine fault tolerance) that enables edge servers to reach an agreement on data offloadees’ performance to be recorded on the blockchain for future reputation evaluation.

CSEdge coordinates collaborative edge storage by implementing the above three mechanisms in a decentralized manner This addresses the decentralization issue.

CSEdge is implemented and evaluated comprehensively against state-of-the-art methods in a simulated MEC environment.

The reminder of the paper is organized as follows. Section 2 overviews CSEdge. Section 3 introduces CSEdge’s incentive mechanism. Section 4 presents its reputation mechanism and Section 5 presents its consensus mechanism. Section 6 discusses the results of the experiments conducted to evaluate the performance of CSEdge. Section 7 discusses the related work. Finally, Section 8 summarizes this paper and points out the future work.

SECTION 2CSEdge Overview
The general framework of CSEdge is shown as Fig. 2. The incentive module implements the incentive mechanism that offers a base reward and a bonus reward to data offloadees based on their performance. The base reward is provided by the data offloader based on its requirement and the bonus reward is calculated based on the offloadee’s performance. It will be discussed in detail in Section 3. The reputation module implements the reputation mechanism to support offloadee selection. It also supports the selection of leaders who record data offloadees’ performance on the blockchain. The general idea is to calculate reputation scores based on edge servers’ historic data offloading performance. Details can be found in Section 4. The consensus module implements CSEdge’s algorithm that allows edge servers to reach an agreement on offloadees’ performance. Details can be found in Section 5.

Fig. 2. - 
CSEdge framework.
Fig. 2.
CSEdge framework.

Show All

Edge servers may play five roles on CSEdge:

Offloader. A data offloader publishes a data offloading task with data size, expiry time, and selects an appropriate offloadee.

Candidate Offloadee. Upon receiving a published data offloading task, an edge server might become a candidate offloadee by expressing its interest in storing the offloaded data.

Offloadee. One of the candidates is selected to store the offloaded data, and becomes a data offloadee.

Tester. During the data offloading period, other edge servers on the system become testers and test the data offloadee’s performance.

Leader. A leader is elected via a consensus among edge servers, who will propose a block to record the offloadee’s performance on the blockchain for future reputation evaluation.

Fig. 3 overviews the workflow of CSEdge for a data offloading task:

When an edge server has excessive data to be offloaded, it broadcasts a task request with data size, response time requirement, expiry time and base reward on CSEdge and becomes an offloader.


Fig. 3.
CSEdge workflow.

Show All

Upon receiving a published task request, each edge server inspects its own storage capacity and may become a candidate offloadee by expressing its interest in storing the offloaded data with a promised maximum response time.

Having received candidate offloadees’ responses, the offloader selects the most reliable one, based on candidate offloadees’ response time guarantees and reputation, as the offloadee.

Offloader broadcasts its decision and offloads data to offloadee.

A leader is elected based on reputation. It assigns a series of non-overlapping time periods before the expiry time to the edge servers in the system, one each, except the offloadee. These edge servers become testers.

Testers test the offloadee’s response time and the integrity of the offloaded data within their corresponding time periods, and return the results to the leader.

When the offloaded data expires, the leader packages the testing results into a transaction and creates a block and broadcasts it.

Upon the receipt of the block, testers validate it and vote for it. The leader collects the votes and receives a fixed amount of bookkeeping rewards from the system if a consensus is reached. Finally, it adds the proposed block to the blockchain.

Key symbols and notations used in this paper are summarized in Table 1.

TABLE 1 Key Notations and Symbols

SECTION 3Incentive Mechanism
Different from cloud servers with virtually unlimited storage capacities, edge servers usually have constrained storage resources. In the MEC environment, data demands vary at different locations over time [20]. Some edge servers may be fully loaded while their nearby edge servers have spare storage resources. As discussed in Section 1, edge servers need to be incentivized to help each other with data storage so that their storage resources can be utilized collaboratively. This motivates CSEdge’s incentive mechanism. The main idea is to provide rewards to edge servers that participate in collaborative edge storage such that they can also use the received rewards to seek help in the future.

On CSEdge, an edge server can acquire rewards in two ways: 1) as an offloadee, perform a data offloading task to earn transaction rewards; and 2) as a leader, commits a transaction to the blockchain to earn bookkeeping rewards. There are two types of transaction rewards, i.e., base rewards and bonus rewards. The former are advertised by data offloaders with data offloading task. They are awarded to data offloadees if they store offloaded data with satisfactory response time and data integrity throughout the transaction. Bonus rewards are awarded when the offloadees offer extra low response time - this is to encourage edge servers to fully leverage their spare storage resources.

A data offloader (denoted by esp generically) publishes a new data offloading task T by broadcasting requirements about T, including data size, denoted by sd, expiry time, denoted by te, response time requirement, denoted by ξr, and the base reward Rb. The amount of Rb is decided by esp based on its urgency. For example, if esp wants the data to be offloaded as soon as possible, it will offer a high Rb. Upon the receipt of T, candidates may respond based on their own situation, e.g., the availability of spare storage resources, the ability to fulfil the latency guarantee, etc. If they are interested in T, they can send a response to esp with a response time guarantee, denoted by ξg.

When T is finished, the total rewards R awarded to the offloadee (denoted by esr generically) is calculated as follows
R=⎧⎩⎨⎪⎪Rb+ Re,0,if task is completed successfullyotherwise(1)
View Sourcewhere Re is calculated based on the offloadee’s performance in performing T
Re=⎧⎩⎨⎪⎪⎪⎪⎪⎪θ⋅(ξti−ξg)ξg,0,ξti<ξgξti≥ξg(2)
View Sourcewhere θ is the baseline bonus reward, ξti is the response time testing result obtained by the ith tester. The detail about validating an offloadee’s response time will be discussed in Section 5.2.

With the incentive mechanism, CSEdge encourages edge servers to participate in collaborative edge storage. It also encourages offloadees to go beyond their response time guarantees when they can. This is the short-term incentive. CSEdge also motivates offloadees to perform in the long term. CSEdge will record offloadees’ performance on the blockchain. Edge servers with good reputations are more likely to win data offloading tasks and be selected as the leader. This is the long-term incentive. The details can be found in Section 4.2.

SECTION 4Reputation Mechanism
To help offloaders find reliable offloadees, edge servers’ reputations will be evaluated based on their reputations. In this section, we demonstrate CSEdge’s reputation mechanism in detail, including its use in offloadee selection. Its use in leader selection will be discussed in Section 5.3. In this section, we also discuss the potential security threats to CSEdge’s reputation mechanism.

4.1 Calculation of Reputation
On CSEdge, the reputation of an edge server es, denoted as repes, is calculated based on its data offloading performance in the past. In general, edge servers that have completed data offloading tasks (sometimes referred to as transactions for simplicity hereafter) with consistently high performance will obtain good reputations, and vice versa. Similar to peer-to-peer (P2P) collaborative systems’ reputation systems [21], [22], CSEdge’s reputation mechanism must achieve two main goals. First, an edge server cannot acquire a high reputation through only a few transactions. This prevents edge servers from overriding its poor historic performance easily. Second, a high reputation should only be acquired through consistently-high performance. This stops edge servers from hiding misbehaviours among a large volume of transactions.

Different edge servers have performed different sets of transactions in the past, some more than the others. CSEdge utilizes a window w to determine the number of the most recent transactions performed by an edge server for evaluating its reputation. It applies to all the edge servers. A large w will include many transactions and is suitable for edge servers deployed in high user density areas. This achieves the first goal discussed above. To achieve the second goal above, CSEdge applies a penalty to edge servers with unstable or fluctuating performance.

In traditional P2P reputation systems, e.g., PowerTrust [23], PeerTrust [22] and EigenTrust [21], a peer’s performance relies on peers’ unregulated ratings. The common security issue that challenges such reputation systems is that a malicious peer can easily inject arbitrarily high or low rating. To tackle this security threat, CSEdge evaluates the performance of an edge server on a data offloading task T based on Re, i.e., the bonus reward it received after finishing T, computed with Eq. (2). The calculation of bonus reward Re received by a data offloadee esr for T relies on its response time experienced by the testers, without involvement of the data offloader. In this way, a malicious data offloader cannot give false ratings to boost other malicious edge servers’ reputations or jeopardize genuine edge servers’ reputations.

Compared with old transactions, recent transactions are often more valuable in indicating an edge server’s future data offloading performance. Given w most recent transactions accomplished by an edge server es. The widely-used exponential moving average (EMA) technique [24] is employed by CSEdge to give higher weights to more recent transactions:
repmes={0α⋅Rme+(1−α)⋅repm−1esm=0m>0(3)
View SourceRight-click on figure for MathML and additional features.where m (m≤w) is the number of recent transactions, repmes is an edge server es’s reputation from its m past transactions, α∈[0,1] indicates how fast the weight of a transaction decreases over time. In general, a higher α assigns more weights on recent transactions and discounts old weights faster. This ensures that an edge server can only acquire a high reputation with consistently-high data offloading performance.

As discussed before, an edge server es should receive a penalty for unstable performance. Let me denote the number of transactions within window w where es’s actual response time ξ is shorter than the response time guarantee ξg. The final reputation of es is calculated as follows:
repes = repmes ⋅ me m(4)
View SourceIn this way, edge servers with relatively fewer (a low repes) but consistently-high performance transactions (a high  me m) can still participate in competition for data offloading tasks.

4.2 Offloadee Selection
Low data retrieval latency is a fundamental requirement in the MEC environment. In addition to reputation, the offloader also considers the response guarantees promised by candidate offloadees because it is the main I/O performance indicator. As introduced in Section 2, when a data offloader broadcasts a data offloading request, candidate offloadees respond with their response time guarantees. Candidate offloadees that promise low response times should be prioritized in the selection process. Their reputations indicate their ability to fulfil response time guarantees or go beyond the guarantees. Thus, candidate offloadees with high reputations should also be prioritized.

Given a set of candidate offloadees, denoted as C=c1,…,cm, each candidate offloadee ci∈C has a score sci:
sci=w1⋅repu′i+w2⋅ξ′g(5)
View Sourcewhere rep′i and ξ′g are ci’s reputation and guaranteed response time, respectively, normalized using the min-max technique, w1 and w2 (w1+w2=1.0) are weights that indicate the significance of reputation and response time in offloadee selection. For example, the setting w1<w2 means reputation is considered less significant.

Lastly, the candidate data offloadee with the highest score is chosen as the offloadee.

4.3 Security Threats
A very common attack against reputation systems is the injection of false ratings. In the context of this research, malicious edge servers, as offloaders, may give false ratings to offloadees. To tackle this threat, an offloadee’s performance in ensuing response time and data integrity will be tested by the edge servers on CSEdge. It needs to be acknowledged by the majority of edge servers through a distributed consensus algorithm before it can be added on blockchain. The details will be presented in Section 5. In this way, malicious edge servers cannot inject false ratings arbitrarily.

Another possible and common attack against distributed reputation systems is the malicious modification to transaction ratings. On CSEdge, transaction information, including offloadees’ performance, will be recorded on the blockchain. Thus, CSEdge is immune to this attack.

A main drawback of many reputation systems, e.g., PeerTrust [22], EigenTrust [21] and PowerTrust [23], is the lack of a globally accessible storage for transaction ratings. On these reputation systems, peers rely on adjacent peers’ ratings in reputation evaluation. CSEdge employs a blockchain to store offloadees’ transaction performance to ensure its traceability and immutability - all edge servers can evaluate each other’s reputation based on their historic performance.

Collusion attack is another potential threat to CSEdge, i.e., a malicious edge server might try to continuously offload data to a particular edge server to increase its reputation. This is a common attack against conventional decentralized systems and e-commerce platforms. On CSEdge, an edge server must have a high reputation to win data offloading tasks. A high reputation can only be earned through consistently-high performance, as discussed in Section 4. This takes time and efforts, and boosts the cost of launching such an attack.

SECTION 5Consensus Mechanism
In this section, we first present the distributed consensus mechanism used by CSEdge called edge reputation based Byzantine fault tolerance (ER-BFT), then present the consensus process and the validation process in detail.

5.1 Overview
CSEdge employs the blockchain technology to facilitate collaborative edge computing. The consensus mechanism is the core of a blockchain-based system. In general, the members must reach a consensus on the information in the blocks before it can be added to the blockchain. A block can be added to the blockchain only when the majority of participants consider that it is valid. On CSEdge, three types of contents about a transaction need to be validated to reach a consensus. First, it must be validated that the offloader owns enough rewards to support the transaction as the base reward. Second, the offloadee’s response time during the data offloading period must be validated. The bonus reward is calculated based on the offloadee’s actual response time against its response time guarantee, as discussed in Section 3. To validate the offloadee’s actual response time, testers must test its response time during the data offloading period and reach a consensus after that. Finally, testers must also test the integrity of the offloaded data stored by the offlodee. This will prevent malicious offloadees from compromising or dropping offloaded data.

CSEdge is designed to facilitate collaborate edge storage in the MEC environment where the edge servers deployed at access points or base stations in a specific area are stable. In this study, we consider a classic adversary model widely employed in studies of distributed systems, i.e., the total number of edge servers N is at least 3f+1, where f is the maximum number of adversarial edge servers. More details about this adversary model can be found in [25].

5.2 Collaborative Validation
On CSEdge, a leader will be elected to coordinate the validation process, as will be discussed in Section 5.3. To ensure that the offloadee fulfils its response time guarantee and ensure in data integrity during its data offloading period, the leader assigns an equal-length time period ttest to each tester. Each tester picks a random time during its assigned time period to perform response time testing and data integrity testing. The primary notations used for the discussion of the testing process are summarized in Table 2. The collaborative validation goes through three phases.

TABLE 2 Data Integrity Testing Notations

Phase 1 Prepare. After the offloadee is determined, the offloader partitions the data to be offloaded into n data blocks, represented by F={f1,f2,…,fj,…,fn} with corresponding messages {m1,m2,…,mj,…,mn} produced following the PDP (Provable Data Possession) scheme [26]. After that, it randomly selects a private key sk∈Zp, picks generators g1,g2∈G, and generates a public key pk=gsk1. Then, a data tag τj is generated for each data block mj:
τj=(h(idF⊕j)⋅gmj2)sk(6)
View Sourcewhere idF is the identifier of data file, h:{0,1}∗→G is a keyed secure hash function that maps to a point in G, ⊕ is the concatenation operator. These data tags are also sent to the offloadee to facilitate data validation during the data offloading period.

Phase 2 Testing. As discussed in Section 5.1, the elected leader will assign non-overlapping time periods to testers. During the assigned time period, each individual tester will validate three pieces of information, including base reward, response time and data integrity. To ensure that the offloader has adequate rewards to advertize a data offloading task, individual testers will inspect the leader’s balance based on its revenues and expenditures recorded on the blockchain. To test the offloadee’s response time, testers will try to retrieve the offloaded data from the offloadee during their assigned time periods. The offloadee’s response time is measured by the time duration from the moment when the data request is sent to the moment when the first data block is received. It is an important indicator of a server’s performance in responsiveness [27]. When they receive the first data block, the testers will cancel their data requests to minimize the validation overhead. They will record the testing results locally.

In the cloud computing environment, data stored on cloud servers is subject to corruption because of servers’ inability or unwillingness to ensure data integrity [26]. This issue applies to edge servers [16]. For example, data offloadees may compromise the data intentionally or unintentionally, or discard offloaded data to save space, similar to cloud servers. To address this issue, CSEdge employs the widely-used PDP method [26], [28] to test the integrity of offloaded data. In the cloud computing environment, data integrity is usually tested by the data owner [26] or trusted third-party auditors [28]. The former opens the door to fraudulence and the latter may not always be available. To overcome these limitations, data integrity testing is carried out by testers collaboratively on CSEdge. Specifically, individual testers follow Procedure 1 to challenge the integrity of the offloaded data. The first tester will challenge the offloadee to prove the integrity of a set of randomly-specified data blocks (Lines 2-4). Then, it will broadcast the IDs of these data blocks (Line 5). Subsequent testers will select data blocks to be tested from untested data blocks and those challenged by the previous tester (Lines 7-9), and broadcast the IDs of the challenged data blocks (Line 10). In this way, a tester’s false testing results will probabilistically conflict with those obtained and reported by other testers. Through this collaborative testing, CSEdge significantly increases the difficulty for testers to fake testing results. Upon the receipt of a challenge request, the data offloadee follows Procedure 2 to generate the corresponding tag proofs (Line 3) and data proofs (Line 4), and send the proof to the tester as the answer to its challenge (Line 6). The tester follows Procedure 3 to verify the proof returned by the offloadee. Briefly speaking, it will use the same bilinear map as the offloadee to find out whether their data proofs and tag proofs can be mapped to the same value [26]. Finally, it sends the testing result to the leader.

Phase 3 Validation. The testing results obtained by individual testers will be validated via a consensus process. It will be discussed in detail in Section 5.3.

Procedure 1. Challenge
as First Tester

select data blocks Fclg randomly to challenge

construct challenge clg⟵{(j,rj)|fj∈Fclg,rx∈Zp}

send challenge clg to data offloadee

broadcast {j|fj∈Fclg}

as Other Testers

select data blocks Fclg from untested data blocks and data blocks tested by previous tester

construct challenge clg⟵{(j,rj)|fj∈Fclg,rx∈Zp}

send challenge clg to data offloadee

broadcast {j|fj∈Fclg}

Procedure 2. Proof
as Offloadee

for all challenged data blocks fj∈Fclg do

generate tag proof: prooft⟵∏fj∈Fclgτrjj

generate data proof: proofd⟵∑fj∈Fclgrj⋅mj

end for

return proof (prooft,proofd)

Procedure 3. Check
as Testers

for all challenged data blocks fj∈Fclg do

compute: DIj⟵e(h(idF⊕j),pk)

end for

aggregate DIj (fj∈Fclg): DI⟵∏fj∈FclgDIj

check proof: e(prooft,g1)=DI⋅e(gproofd2,pk)

return check result to leader

Remark. Via collaborative testing, CSEdge offers a probabilistic data integrity guarantee. Let bc be the number of corrupted data blocks out of all the n data blocks, bs be the number of data blocks challenged by each individual tester. The probability pb that at least one of the bc corrupted data blocks will be detected by an individual tester is:
pb=1−(n−bcn)⋅(n−1−bcn−1)⋅(n−2−bcn−2)⋅⋅⋅(n−bs−bc+1n−bs+1)(7)
View SourceFor an arbitrary integer x<n, there is n−bc−xn−x≥n−bc−x−1n−x−1. Therefore, based on Eq. (7), there is
pb≥&1−(n−bcn)bs(8)
View Source

Through collaborative validation, CSEdge can ensure the integrity of offloaded data with a much lower sampling rate than PDP [26]. For example, let us assume a corruption rate of 1%, i.e., 1% of the data blocks of an offloaded are corrupted. When 25 testers perform collaborative data integrity testing, they each only need to sample 1.6% of the data blocks to collectively achieve a detection rate of 95%. With PDP, a sampling rate of 3.0% is needed to achieve the same detection rate, 46.67% higher than CSEdge. To achieve a detection rate of 99%, CSEdge requires a sample rate of 2.16%, 53.04% lower than PDP’s 4.6%. This indicates that through collaborative validation, CSEdge reduces the overheads incurred on edge servers without compromising the detection rate. The performance of ESEdge in ensuring data integrity will be evaluated experimentally in Section 6.2.

5.3 Consensus Process
On PBFT [25] and Hotstuff [29], two popular consensus mechanisms, leaders are elected randomly. This opens the door to malicious attacks when malicious participants get their turns. To tackle this threat, on CSEdge, the edge server that has highest reputation will be elected as the leader to propose new blocks and coordinate the consensus process. After adding blocks to the blockchain, the leader will receive bookkeeping rewards. As discussed in Section 4, edge servers have to earn good reputations through consistently-high performance over the long term. Thus, edge servers with better reputations are less likely to jeopardize the system. This is similar to the rationale behind the proof of stack (PoS) mechanism [30]. As presented in Section 2, when a transaction is completed, the leader will package transaction information into a block and broadcast the block on CSEdge at Step 7. This kick-starts the consensus process, which consists of 3 phases, i.e., Phase 1 Prepare, Phase 2 Pre-commit and Phase 3 Commit. Table 3 summarizes the notations used to introduce ER-BFT below.

TABLE 3 Notations for ER-BFT

TABLE 4 Parameter Settings and Experiment Sets

Phase 1 Prepare. As shown in Fig. 4, the leader starts with packing transaction tx to generate a block that contains information about rewards, offloadee’s response time and data integrity. The distance between testers and the data offloadee impact their response time testing results. Thus, the leader L will select the median value of testers’ testing results to be packed into the block. And the data integrity agreed on by the majority of the testers is packed into the block. Then, it sends a prepare message with the block to testers for validation, denoted by ⟨PREPARE,vL,seqL,blockID⟩L, where vL is leader’s view number and seqL is the proposed block’s sequence number, and blockID is the unique identifier of the block. Upon receiving the prepare message, testers will check whether the message is sent by the leader in the current view and the block sequence number is correct. Then, they validate the block by checking the information about reward, response time and data integrity stored in the block. On CSEdge, each tester has two kinds of information towards a transaction: (i) its response time testing result ξti; (ii) the data integrity verification result ϕi. The response time ξ recorded in the block is compared against ξti. If their difference is lower than the message transmission delay upper bound1 η between edge servers, ξ is considered valid. The tester compares ϕi and ϕ in the block. If they are equal, the block is considered valid. The details of the validation can be found in Section 5.2. If the transaction is considered valid, the tester sends a vote message, denoted by ⟨VOTE,v,seq,blockID⟩i to the leader to confirm its successful validation. Otherwise, the tester will not send the vote message.


Fig. 4.
Prepare phase.

Show All

Phase 2 Pre-Commit. As shown in Fig. 5, the leader needs to wait for testers’ votes. When 2f+1 votes or more are received, the leader notifies all testers of the entrance to the next phase by broadcasting a pre-commit message with the voting results, denoted as ⟨PRE−COMMIT,vL,seqL,blockID⟩L. Upon the receipt of the pre-commit message, testers enter the Pre-commit phase and send a ready message to the leader, denoted as ⟨READY,v,seq,blockID⟩i, to indicate that they can commit the block to the blockchain.


Fig. 5.
Pre-commit phase.

Show All

Phase 3 Commit. Upon receiving 2f+1 ready messages, the leader will broadcast a commit message to notify all testers to commit the block, denoted as ⟨COMMIT,vL,seqL,blockID⟩L and commit the block. Upon receiving the commit message, testers will commit by adding the block on the blockchain. In the meantime, all edge servers (including the leader) increase seq by 1. As shown in Fig. 6,

Remark. Similar to other blockchain-based systems, CSEdge may also suffer from leader failures. CSEdge utilizes a fast view-change protocol when a leader failure occurs. A new leader will be elected to continue proposing blocks and coordinate consensus [31]. Unlike PBFT that chooses a new leader randomly, ER-BFT selects the edge server with the second-highest reputation as the new leader L′ when the current leader L fails. This view-change process is presented in Fig. 7. It starts by broadcasting a view-change message, denoted by ⟨VIEW−CHANGE,v+1,seq⟩Lv+1 and waiting for other edge servers’ responses. When edge servers receive the view-change message, they check whether it was sent by the new leader. If it was, they return their votes to L′. Upon the receipt of 2f+1 such votes, L′ updates the view number v+1 and broadcasts a new-view message, denoted by ⟨NEW−VIEW,v+1,seq⟩Lv+1 to notify edge servers to finalize view-change. When an edge server receives the new-view message, it updates the view number to v+1 and waits for new block proposals.

Fig. 6. - 
Commit phase.
Fig. 6.
Commit phase.

Show All

Fig. 7. - 
View change.
Fig. 7.
View change.

Show All

Both ER-BFT and PBFT go through three main phases to reach a consensus. With PBFT, all N participants broadcast to communicate, leading to a communication complexity of O(N2). With ER-BFT, only the leader broadcasts messages and the other edge servers send messages directly to the leader. Its communication complexity is O(N), much lower than PBFT’s. This is one of ER-BFT’s main advantages over PBFT. In addition, when a leader failure occurs, ER-BFT’s view-change process (demonstrated in Fig. 7) takes O(N) time to elect a new leader while PBFT takes O(N3) time [29]. This is ER-BFT’s second main advantage over PBFT.

SECTION 6Experiment Evaluation
To verify its usefulness, we build up a prototype of CSEdge to access its performance in a simulated MEC environment.

6.1 Experiment Setup
Implemented with Rust 1.50.0 and Python 3.7, the prototype is built on Hyperledger Sawtooth, a widely-used open-source solution for building, deploying, and running blockchain systems.

6.1.1 Simulation Setup
A total of N virtual machines are deployed in a private data center as edge servers in each experiment to form an edge server network with a density of D. Each edge server is equipped with 2 vCPUs, 4GB RAM and 30GB storage. The round-trip latency between any two virtual machines ranges between 5 to 20ms.

6.1.2 Benchmark Systems
In the experiments, the performance of CSEdge is evaluated against a baseline approach and two state-of-the-art approaches for peer-offloading [18], including a game-theoretical approach and a Lyapunov optimisation approach:

NON-COL: On this system, edge servers store all data individually and do not offload any data. This is the baseline system.

GT-D [32], [33], [34]: GT-D is the decentralized system that employs game theory to find peer-offloading solutions. In each time slot, edge servers play a game to reach a Nash equilibrium as the peer-offloading solution. In the experiments, their optimization objective is to the system throughput, i.e., the number of dispatched tasks.

LY-C [18], [35], [36]: LY-C is a centralized system that schedule peer-offloading tasks based on Lyapunov optimisation. Its objective is to find the minimum overall response time as optimal peer-offloading solution in each time slot.

6.1.3 Task Generation
Data size does not impact the performance of CSEdge. In the experiments, the size of offloaded data is fixed at 10 MB with a block size of 4 KB. In each experiment, 2,000∗N tasks are generated and randomly assigned to edge servers following a Poisson process with an arrival rate of r (r∈[0,5]) tasks per second over 30 minutes. An edge server will store the assigned data when its disk utilization rate is below the pre-specified threshold μ; otherwise, it publishes a task to offload the data with a base reward.

6.1.4 Performance Metrics
In the experiments, we evaluate the performance of CSEdge from three perspectives: 1) effectiveness measured by edge servers’ disk utilization rates and system output; 2) efficiency measured by task dispatch time and consensus time; and 3) security measured by corruption detection rate. The details of these performance metrics can be found below:

Disk Utilization Rate. Disk utilization rate indicates how busy an edge server is with accommodating data demands. Ideally, there should not be a significant imbalance between edge servers’ disk utilization rate.

System Throughput. System throughput is measured by the number of data offloading tasks dispatched per time slot, the higher the better.

Task Dispatch Time. Task dispatch time is the average time taken to dispatch a data offloading task to an edge server. This is an important efficiency indicator because low latency is critical in the MEC environment. A long task dispatch time will delay data provisioning.

Consensus Time. Consensus time is the average time taken to reach a consensus, i.e., to add a block to the blockchain successfully. On CSEdge, edge servers communicate with each other to reach a consensus, as discussed in Section 5.3. This takes time and is the main communication overheads incurred by blockchain to CSEdge. This is another efficiency indicator because it determines how fast transaction information is synchronized on the system after data offloading transactions complete, including data offloadees’ performance and reward recipients, as well as leaders’ reward recipients.

Corruption Detection Rate. Corruption detection rate is the percentage of detected corrupted data. It indicates the ability of CSEdge to detect corrupted offloaded data.

In the existing studies of computation task offloading, sophisticated algorithms have been proposed to find optimal or sub-optimal solutions, taking a lot of factors into account, e.g., computing and communication factors [37]. Algorithmic complexity, measured by the time taken to find a solution, is the key performance indicator and it is often impacted by the communications and computing environment. CSEdge aims to drive collaborative edge storage by enabling data offloading between edge servers by addressing the incentive, trust and decentralization issues that challenge data offloading between individual edge servers, as discussed in Section 1. Thus, rather than algorithmic complexity, the efficiency evaluation of CSEdge focuses on its task dispatch time and consensus time from the system perspective.

6.1.5 Parameter Settings
To evaluate CSEdge comprehensively, we conduct four sets of experiments with different parameter settings. In Set #1, CSEdge is compared with NON-COL to demonstrate the importance of collaborative edge storage. In Sets #2-#4, CSEdge is compared with NON-COL, GT-D and LY-C. In Sets #2-#4, we vary one of the following three parameters while fixing the other two to simulate various MEC environments, as summarized in Table 4. Every time the value of a parameter varies, the experiment is repeated 100 times and the average results are reported.

Number of Edge Servers (N). The number of edge servers in the simulated MEC environment as testers.

Graph Density (D). The edge servers in an MEC environment form an edge server network, as introduced in Section 1. It is modelled as a graph in the experiments. Calculated by D=|E|N, where E is the number of edges in the graph, graph density is the average number of edge servers that each edge server is connected to.

Offloading Threshold (μ). Edge servers need certain free drive spaces to maintain basic operations and thus will not leverage all its spare storage resources to store offloaded data. Taking this into account, in the experiments, we employ a threshold μ to decide whether an edge server will offload data. Specifically, when an edge server’s disk utilization rate exceeds μ, it will offload the incoming data on CSEdge, GT-D and LY-C. Similarly, an edge server will only contend for and perform a data offloading task when its disk utilization rate is below μ.

As discussed in Section 3, CSEdge employs three types of rewards in its incentive mechanism, i.e., base rewards, bonus rewards and bookkeeping rewards. In the experiments, the base rewards of a data offloading task is randomly selected from [1/10, 1/5] of the data offloader’s total rewards, the bonus rewards is calculated with Eq. (2), and the bookkeeping reward is fixed at 20 per block. The data offloading period of a task, specified by its expiry time, is randomly selected from [30, 90] seconds.

6.2 Experimental Results
6.2.1 Disk Utilization
Figs. 8a and 8b present edge servers’ disk utilization rates on CSEdge and NON-COL, respectively, in experiment Set #1. Fig. 8a shows that on NON-COL, edge servers’ disk utilization rates differ largely all the time, ranging from 9.8% to 100%. Over the 30 1-minute time slots, the disk utilization rates of four edge servers exceed 80% for a total of 38 times. Their disk utilization rates also fluctuate significantly over the 30 minutes, especially those with high average disk utilization rates. The average standard deviation of individual edge servers’ disk utilization rates over 30 minutes is 13.5. Fig. 8b shows that CSEdge can effectively balance data offloading workloads across edge servers, stabilizing their disk utilization rates at between 25.24% to 80.38%, mostly at 49.85% to 80.38%. In particular, all edge servers’ disk utilization rates remain below the offloading threshold of 80%. These indicate that CSEdge can prevent edge servers from being overloaded or underutilized. In the meantime, edge servers’ disk utilization rates remain relatively stable over time, with an average standard deviation of 8.13, 66.05% lower than that of NON-COL. This shows the ability of CSEdge to balance data storage workloads within the system. Overall, the observations in Set #1 indicate that CSEdge can effectively facilitate collaborate edge storage.


Fig. 8.
Disk utilization (Set #1).

Show All

6.2.2 System Throughput
Fig. 9 compares the throughputs of CSEdge, GT-D, LY-C and NON-COL in Sets #2 - #4, and shows the impacts of the three parameters on their throughput. It is clear that CSEdge achieves the highest system throughput in all the cases and unsurprisingly, NON-COL achieves the worst. On average, CSEdge outperforms GT-D, LY-C and NON-COL by 44.9%, 7.5% and 66.3% in Set #2, 96.1%, 8.6% and 48.4% in Set #3, and 58.1%, 6.6% and 37.3% in Set #4. LY-C outperforming GT-D shows the advantage of centralized scheduling of data offloading tasks based on Lyapunov optimization over decentralized scheduling based on game theory. CSEdge, as a decentralized system, can still outperform LY-C. The main reason is that LY-C replies on centralised control which incurs high communication latency and consequently lowers the system throughput. Fig. 9a shows that the systems’ throughput increases with the number of edge servers (N). This is expected because more edge servers on the system can perform more data offloading tasks. Fig. 9b shows that the throughputs of CSEdge, GT-D and LY-C with the graph density (D). A larger D connects an individual edge server to more other edge servers on the system and shortens their average distance. This decreases the time taken by edge servers to coordinate data offloading transactions, accelerating task dispatch (shown in Fig. 10b) and increasing the system throughout. Fig. 9c shows that an increase in the pre-specified offloading threshold (μ) reduces throughput of CSEdge, GT-D, LY-C and NON-COL’. A high μ allows edge servers to utilize their own storage resources to store data. This reduces the overall demand for data offloading measured by the number of data offloading tasks, and consequently the system throughout.


Fig. 9.
System throughput.

Show All


Fig. 10.
Task dispatch time.

Show All

6.2.3 Task Dispatch Time
Fig. 10 shows the average times taken by different systems to dispatch data offloading tasks and the impacts of the three parameters. NON-COL is not included because it does not dispatch any data offloading tasks. The figures show that CSEdge takes the minimum time to dispatch tasks, outperforming GT-D and LY-C by 29.8% and 12.3% in Set #2, by 39.1% and 11.1% in Set #3, and by 24.1% and 6.3% in Set #4. GT-D takes the most time because it takes many iterations in a game to find the Nash equilibrium in the game. This requires excessive interactions among edge servers and consequently takes GT-D more time to dispatch tasks. LY-D dispatches data offloading tasks centrally and does not require interactions among edge servers. However, the high complexity in its task dispatch algorithm and high communication latency caused by centralized controller contribute significantly to its long task dispatch time. When N increase, the size of system increases, as well as the average distance between the edge servers. It takes more time for messages to travel between them. As a result, CSEdge takes more time to complete the interactions among edge servers for dispatching tasks, as shown in Fig. 10a. This is also the reason for the increase in GT-D’s task dispatch time. The reason for the increase in LY-C’s task dispatch time is different - a larger system leads to a large solution space for LY-C to explore and thus requires more time for LY-C to dispatch tasks. The increase in graph density (D) impacts the task dispatch time conversely, as shown in Fig. 10b, because it decreases the average distance between edge servers and shortens the time needed for CSEdge and GT-D to complete the decentralized coordination among edge servers to dispatch tasks. An increase in D makes it easier for LY-C to find a nearby edge server to offload data, and thus accelerate its task dispatching. Unlike N or D, the increase in μ does not impact on CSEdge, GT-D or LY-C’s task dispatch times, as shown in Fig. 10c, because μ impacts the task offloading timing. The observations from Fig. 10 show that CSEdge can dispatch offloading tasks rapidly.

6.2.4 Consensus Time
Fig. 11 compares the consensus times CSEdge’s ER-BFT and the classic PBFT [25] in normal scenarios (without leader failures) and view-change scenarios (with one leader failure per time slot). Compared with PBFT (normal) and PBFT (view-change), ER-BFT (normal) and ER-BFT (view-change) take edge servers less time to reach a consensus, specifically, 32.8% and 38.1% less in Set #2, 47.5% and 45.9% less in Set #3, and 28.6% and 33.4% less in Set #4. As shown in Fig. 11a, the same reason for the increment in N increases consensus time in the same way it does on task dispatch time, i.e., through increasing the average distance and communication latency between edge servers, as discussed in Section 6.2.3. Compared with PBFT, ER-BFT is less sensitive to N because PBFT demands that all the participants in the system communicate with each other all the time to reach an agreement while ER-BFT elects a leader to manage the consensus process. Upon leader failures, ER-BFT’s consensus time increases less significantly than PBFT’s because its leader re-election takes less time than PBFT’s, as discussed in Section 5.1. ER-BFT and PBFT’s consensus times are also impacted by D, but not μ, similar to their time dispatch time, as compared between Figs. 10b and 10c and Figs. 11b and 11c. The reasons underneath are also similar and thus are omitted here. These observations evidence that ER-BFT can quickly synchronize transaction information across edge servers on CSEdge.


Fig. 11.
Consensus time.

Show All

6.2.5 Data Corruption Detection Rate
Fig. 12 shows CSEdge’s data corruption detection rate in the experiments with a corruption rate of 1% and different numbers of edge servers in the system (N). Employing a sampling-based method for data integrity validation, CSEdge’s detection rate depends on the sampling rate. Fig. 12 confirms the analysis presented at the end of Section 5.2 - with more edge servers participating in the validation, a lower sampling rate is needed to ensure a high detection rate. For example, when N=7, a 4.96% sampling rate is needed to achieve a 99% detection rate. When N=19, a sampling rate of only 2.2% is needed to achieve the same detection rate. In Fig. 12, we can also observe that the detection rate improvement obtained by the increase in the sampling rate is more significant when there are more edge servers in the system. For example, with N=7, each individual tester needs to sample 1.76% (4.96%-3.20%) extra data blocks to improve the overall detection rate from 0.91 to 0.99. With N=19, only 0.68% (2.20%-1.52%) extra data blocks need to be sampled by each individual tester to achieve the same detection rate improvement.

Fig. 12. - 
Data corruption detection rate.
Fig. 12.
Data corruption detection rate.

Show All

SECTION 7Related Work
7.1 Edge Computing
A large number of devices connected to the Internet, such as Internet-of-Things (IoT) devices, smart phones, tablets and wearable devices, has been increasing rapidly in the last decade and is not slowing down. Many existing and new mobile and IoT applications demand low latency, such as oneline gaming [2], Virtual Reality [3] and autonomous vehicles [38]. The traditional cloud computing paradigm with high latency and unpredictable congestion [39] cannot satisfy these applications’ requirement for low latency. To cope with this challenge, the multi-access edge computing (MEC) was proposed [40]. It moves computing and storage resources from the central cloud to the network edge. In an MEC environment, edge servers are attached to access points or base stations. Computation tasks can be offloaded from mobile devices to edge servers for processing, partially or completely [41]. A variety of approaches have been proposed to allocate tasks to edge servers, e.g., integer programming [42], game theory [43], Lyapunov optimization [44], reinforcement learning [45]. App vendors like Netflix and Facebook can also hire computing and storage resources on edge servers for storing data to provide low service latency for users [46]. This is often referred to as edge data storage, which raises a series of relevant research problems, e.g., edge data distribution [11], edge data caching [13], edge data integrity [16], etc. CSEdge complements the studies of collaborative edge data storage by tackling the incentive and trust issues in the MEC environment.

7.2 Collaborative Edge Computing
Edge servers usually suffer from storage constraints, because of their limited physical sizes [47]. Individual edge server may easily be overwhelmed by the data coming from app vendors and end-devices. This is one of MEC’s main limitations that has attracted lots of attention from both academia and industry in the past few years. Fortunately, adjacent edge servers are connected with high-speed links that allow them to transmit data [11], [18]. Instead of offloading to the remote cloud, an edge server can offload tasks to other edge servers. This is known as peer-offloading [10], [14], [18]. Collaborative edge computing provides many new opportunities and at the same time, raises a lot of new challenges, such as data caching [13], service caching [12], data distribution [11] and video distribution [48]. However, most existing studies of collaborative edge computing, e.g., [13], [49], [50], have not considered the trust issue among edge servers. In real-world MEC environments, edge servers deployed and operated by different stakeholders lack mutual trust for collaboration [15]. In addition, they lack the incentive to drive collaboration. Thus, incentive and trust are vital to collaborative edge computing.

7.3 Edge Computing With Blockchain
The blockchain technology offers a promising solution to dealing with the incentive and trust issues faced in collaborative edge computing. In addition, blockchain’s decentralized architecture is perfect for the MEC environment where centralized control is too slow to be practical [51]. A series of blockchain-based systems have been built in recent years to support specific applications in the MEC environment. To name a few, a video streaming system at the network edge based on blockchain technology was proposed by Liu et al. [52], which aims to support cooperation among content creators, consumers, video transcoders. Xu et al. [15] proposed a blockchain-based big data sharing platform for applications deployed in the MEC environment. Xu et al. [53] developed a blockchain-based platform named BeCome that ensures data integrity during task offloading from edge devices to edge servers. Yuan at al. [54] proposed a blockchain-based system named CoopEdge to enable reliable collaborative computation offloading among edge servers. Unlike these studies, CSEdge is specifically and innovatively designed to coordinate and support collaborative edge storage among edge servers by offering incentives and building trust. To our best knowledge, it is the first attempt at enabling collaborative edge storage based on blockchain.

7.4 Main Studies Relevant to CSEdge
The three main components of CSEdge, including the incentive mechanism, the reputation system and the consensus mechanisms, are inspired by the key features of blockchain and existing reputation systems. On CSEdge, rewards are offered to edge servers who perform data offloading tasks. Then, they can use the rewards to incentive other edge servers to help them later on. This is the main idea of CSEdge’s incentive mechanism. Adadi et al. [55] proposed a system named AnyLog to facilitate data sharing. It offers financial credits to participants that upload or process data. In general, AnyLog provides a similar incentive mechanism, but does not provide any reputation mechanism to evaluate the performance of participants like CSEdge. On CSEdge, edge servers’ reputations are evaluated based on their historic data offloading performance. This is the main idea of CSEdge’s reputation system that is inspired by reputation systems designed for P2P sharing systems, including EigenTrust [21], PeerTrust [22] and PowerTrust [23]. The main difference between CSEdge’s reputation system and these reputation systems is that it is built on top of edge servers’ historic performance accessible to all the edge servers on CSEdge, thanks to the underneath blockchain. To tackle the common threats to reputation systems, CSEdge employs a collaborative validation mechanism to validate edge servers’ performance. This unique feature is also inspired by blockchain and made possible by CSEdge’s blockchain. Proof of Work (PoW) and Proof of Stake (PoS) are the most representative consensus mechanisms for blockchains. The former is adopted by Bitcoin and selects miners from members based on their computing power [56]. The latter selects miners based on stakes, i.e., the amount of coin members hold [30]. Inspired by PoS, ER-BFT selects the edge server with the reputation as the leader, i.e., the one that has achieved high performance consistently in data offloading tasks.

SECTION 8Conclusion and Future Work
In this paper, we proposed a system named CSEdge to support and drive collaborative edge storage. We discussed the trust, incentive and decentralization issues, and CSEdge’s mechanisms for addressing these issues in an integrated manner based on blockchain, including an incentive mechanism, a reputation mechanism and a consensus mechanism. Extensive experiments were conducted in a simulated MEC environment to evaluate the performance of CSEdge. The results show that CSEdge can facilitate collaborative edge storage effectively and efficiently. In the future, more possible attacks against CSEdge and corresponding defense mechanisms will be explored and investigated.