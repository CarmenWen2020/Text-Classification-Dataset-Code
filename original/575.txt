Abstract
In the Attribute-Based Encryption (ABE) scheme, patients encrypt their electronic health record (EHR), attach the appropriate attributes with it, and outsource them over the cloud. Doctors get the encrypted EHR corresponding to their area of interest (attributes) from the cloud. To decrypt the received encrypted EHR, doctors get the secret keys from the key generation center (KGC). Since the KGC knows the secret keys of all the encrypted EHRs, it may decrypt patients’ records. A decentralized ABE scheme overcomes this issue but requires high computation and communication costs. Moreover, in this scheme, any unauthorized doctor can access the patients’ EHR. Besides, the KGC’s secret keys privacy and the doctor’s attribute privacy are also serious concerns. In this paper, we have proposed a comprehensive privacy-preserving e-health (CP2EH) scheme over the cloud that overcomes the problems of both unauthorized access of patient records by a doctor and a doctor’s attribute privacy in an ABE scheme. In the CP2EH scheme, we have incorporated oblivious transfer (OT) and zero-knowledge proof (ZKP) protocols into the centralized ABE scheme. The OT protocol preserves KGC’s secret keys privacy and the doctor’s attribute privacy. The ZKP protocol preserves the patient’s EHR privacy from unauthorized doctors. Results show that the CP2EH scheme is able to meet all the privacy requirements of e-health applications over the cloud at a lower computation and communication cost as compared to the existing ABE schemes.

Introduction
To improve the efficiency and effectiveness of the conventional medical system, patients store, share, and track their personal health information on the cloud. Patients share their health information with the cloud. Authorized doctors query patients’ health information from the cloud, collect medical data, and update the patients’ cure information over the cloud. If the cloud server is malicious, then it may reveal sensitive information about the patients. Therefore, to protect confidential information from the cloud, the patients must encrypt their health information before sending them to the cloud [25, 34].

The range query is a crucial technique for the doctor in collecting the medical queries from the cloud. In this scenario, the cloud server is an honest but curious party; therefore, patients hesitate to share their EHR over the cloud. Moreover, in range query, any unauthorized entities can get access to the cloud, and by searching operation, they may leak the content of the sensitive EHR [23]. To overcome this, Order Preserving Encryption (OPE) schemes have been introduced [1, 4]. These schemes encrypt the entire EHR of the cloud server database. They provide the same order for all the ciphertexts. In other words, they make two encrypted EHR indistinguishable. Hence any unauthorized entities cannot gain any information from encrypted EHR [28, 40]. These schemes are only used for a single data source framework, in which only one cloud and one data owner are involved [27, 32]. Single data source framework cannot fulfill the requirement of multiple patients (data owners) in the current e-health applications [15,16,17]. Multi-source OPE schemes efficiently and securely provide e-health services over the cloud for multiple patients [40, 41]. But, these schemes suffer from the frequency analysis attack [5]. This issue is overcome in cloud-based e-health systems [20]. However, it depends on weak security assumptions. In other words, it only provides security under the indistinguishability chosen-plaintext attack (IND-CPA) [20].

The decentralized ABE techniques depend on strong security assumptions but require high communication and computational costs [21, 30, 43, 45]. In other words, they provide security under the indistinguishability chosen-ciphertext attack (IND-CCA), which is more secure against the IND-CPA.

In ABE schemes, the patient encrypts his EHR, attaches a set of attributes, and outsources them to the cloud. The doctor queries the cloud with a set of attributes. The cloud fetches the encrypted EHR corresponding to the received attributes and replies to the doctor. To decrypt the encrypted received EHR, the doctor needs a set of secret keys corresponding to those attributes from the KGC. These schemes suffer from the following drawbacks: any illegitimate doctor (or user) can get the secret keys from the KGC and extract the patients’ encrypted EHR to reveal sensitive information about the patients. Therefore, KGC needs to authenticate the doctors before providing secret keys. Moreover, to get the secret keys, the doctor needs to send a set of attributes to the KGC. If the doctor sends his attributes without hiding them to KGC, a malicious KGC may also decrypt the encrypted EHR of corresponding attributes and reveal sensitive information about the patients. Therefore, the doctors need to send the encrypted attributes to the KGC so that the patient’s privacy is preserved. If the KGC received encrypted attributes, it does not know which secret keys to be sent to the doctor. Therefore, KGC needs to send all the secret keys to the doctor. If the doctor gets all the secret keys, he may decrypt all the encrypted EHR, which also violates the patients’ privacy. Therefore, KGC needs to send all the secret keys to the doctor in such a way that the doctor can only extract the secret keys corresponding to the requested attributes. Apart from privacy issues, using a smartphone or lightweight device requires the scheme to be efficient. The scheme overcomes these challenges through the following contributions:

We propose a CP2EH scheme over the cloud. The CP2EH scheme provides EHR privacy of the patient over the cloud using the combination of ABE scheme and OT protocol.

We invoke two ZKP protocols in the CP2EH scheme. The advantage of the first ZKP (ZKP1) protocol is that only authorized doctors can decrypt the encrypted EHR of the patient. However, the second ZKP (ZKP2) protocol provides the authentication of secret keys received by the doctor from the KGC.

We propose an OT protocol using OPRF and invoke it into the ABE scheme. The OT protocol preserves the attributes’ privacy of the doctor from the KGC. Moreover, it also preserves the secret keys’ privacy of the KGC from the doctor.

In order to protect the attribute privacy of the doctor from KGC, multiple KGCs are required to place in the existing ABE schemes. These schemes require huge communication and computational costs. The CP2EH scheme requires only one KGC due to the invocation of the OT protocol. As a result, it requires less communication and computation costs than the existing ABE schemes.

Organization: In Sect. 2, we described the literature review of the existing schemes and the problem definition of the proposed scheme. The background information about the proposed scheme is described in Sect. 3. The system model and privacy requirements of the proposed scheme are described in Sect. 4. The construction of the proposed scheme and their security analysis are described, respectively, in Sects. 5 and 6. In Sect. 7, we described the implementation and results of the proposed scheme. We conclude the proposed scheme in Sect. 8.

Related work
The development in cloud computing has transformed the personal information of millions and millions of users being stored. The sensitive information includes social network data [22, 26], electronic health record [14, 23], and location data [9, 13, 24], which can be outsourced to the public cloud. These outsourced data on the public could [39] are highly vulnerable to the risk of a data breach, especially the EHR [10, 35, 36] of the patients. The core cause of this EHR data breach is that once it is uploaded to the cloud, the content of this EHR is directly revealed to the server. The cloud may leak this information. Therefore, the data privacy [42, 44] issues are most important aspect in the cloud-based e-health system [19, 44]. Thus, in order to access the content of the EHR while preserving patient privacy is of principal importance.

A range query was the first privacy-preserving technique used in the cloud-based e-health system [23]. In this technique, any malicious entity uses the searching strategies and can easily distinguish between two encrypted EHRs. This scheme was computationally and communicationally efficient, but it is vulnerable to unauthorized user access. To ensure privacy preservation in the range query-based model, an order-preserving encryption-based scheme has been introduced [1, 4]. This scheme uses the encryption technique so that any malicious adversary cannot distinguish between two encrypted EHRs. However, this scheme is still vulnerable to IND-CPA. In other words, any malicious adversary using the IND-CPA technique can distinguish between two encrypted EHRs and gain sensitive information about the patients.

In order to protect the cloud data from the effect of IND-CPA, another OPE has been proposed [4]. It enhanced the security of OPE scheme. This improved OPE scheme has the limitation that it reveals the order of the data but preserves the privacy of the data content. In order to secure data order, an order-preserving encoding technique is invoked into OPE scheme [27]. This technique is based on the binary search tree and successfully preserves the privacy of data order but incurs huge communication overhead. The schemes proposed in [4] and [27] suffer from the frequency analysis attack. A frequency hiding OPE technique has been proposed to resolve this attack [15]. This technique uses strong security assumptions to resolve the attack. Even though it is secure against the frequency analysis attack and privacy leakage, but it requires huge communication costs.

In order to reduce the communication overhead, a multi-linear map technique is used in order-revealing encryption scheme [7]. Order revealing encryption is a symmetric key encryption technique that takes two encrypted plaintexts as inputs and produces output in lexicographic ordering [17]. The multi-linear map-based technique is only suitable for single data source frameworks. In other words, in this technique, only one patient at a time can use the e-health services from the cloud. However, in real-world scenarios, multiple patients want to use e-health services. Moreover, various authorized doctors also provide e-health services over the cloud. In order to deal with real-world problems, a multi-source OPE scheme has been proposed [38]. This scheme uses a set of key agents to achieve distributed encryption. However, this scheme is vulnerable to threats like frequency analysis and privacy leakage. Another multi-source OPE scheme has been introduced that employed a monotone minimal perfect hash function [41]. Its security depends on one-way OPE, i.e., its security is assured by the random order-preserving function. However, it was found that the one-way OPE scheme leaks the content of encrypted plaintext and reveals the distance between two encrypted plaintexts [5]. It means this scheme is based on weak security assumptions. In other words, it only provides security under the IND-CPA [20].

In order to overcome the weak security assumption, the ABE scheme has been proposed [3]. In this scheme, patients encrypt their EHR and collect the attributes (like X hospital, Y-types of a doctor, etc.) regarding their EHR and send both of them to the cloud server. The doctors request the encrypted EHR corresponding to their (attributes) area of interest from the cloud. The cloud server collects the encrypted EHR and sends them to the doctors. The doctor received the encrypted EHR from the cloud, and he takes the secret keys from the KGC, decrypts the encrypted EHR, and provides the e-health services to the patients. This scheme is vulnerable to collusion attacks where doctors collude with each other and decrypt the patient’s encrypted EHR without permission. In order to prevent this attack, a decentralized ABE scheme has been proposed [30]. In this scheme, they invoke anonymous key issuing protocol into a decentralized ABE scheme to prevent collusion attacks. However, later it was found that the scheme [30] has still vulnerable to collusion attacks [43]. In [43], they improved the scheme’s [30] security and proposed a collusion-resistant decentralized ABE scheme at high computation and communication costs. Another decentralized ABE scheme has been proposed using a fuzzy access control mechanism [45]. This scheme uses the secret sharing technique to prevent the collusion attack and reduce the computation costs. However, in this scheme, any malicious entity can access the encrypted EHR. In other words, it does not provide the authentication of doctors. Moreover, this scheme does not provide attributes privacy of the doctors from KGC. In order to overcome these problems, a one-way anonymous key exchange mechanism is invoked into a decentralized ABE scheme [21]. This scheme provides the attribute privacy of the doctor from KGC, but it fails to provide unauthorized access to encrypted EHR records of the patients from malicious entities. Apart from privacy issues, it requires high communication and computation costs. Another decentralized ABE scheme has been proposed to improve the scheme’s efficiency [29]. In this scheme, they applied blockchain technology into the decentralized ABE scheme to improve the scheme’s efficiency, but they can not prevent unauthorized access to encrypted EHR. A privacy-preserving decentralized ABE scheme has been proposed [18]. This scheme only provides the attribute privacy of the doctor but requires high communication and computational costs. Moreover, it is unable to provide authentication of the doctor and secret keys privacy of the KGC. Table 1 summarizes the literature review of the existing privacy-preserving e-health schemes over the cloud.

Table 1 Summary of the literature review of the existing privacy-preserving e-health scheme over the cloud
Full size table

Motivation and problem description
In an ABE technique, patients encrypt EHR, generate corresponding attributes of that record, and upload both of them to the cloud. The doctor sends a set of attributes as per his/her field of interest to the cloud. The cloud chooses all the encrypted EHR corresponding to those attributes set and sends them to the doctor. To decrypt the patient’s records, the doctor requests secret keys for the corresponding attributes of that document from the KGC. Two problems occur in this situation: 1) An illegitimate doctor can request secret keys of the corresponding attributes from the KGC and decrypts the EHR and may reveal patients’ sensitive information. 2) When the legitimate doctor requests a set of secret keys of corresponding attributes of the encrypted EHR from the KGC, which is malicious, it may reveal the sensitive information to the KGC. The existing ABE schemes are also unable to provide privacy-preserving e-health applications over the cloud. To preserve privacy

The KGC must check the legitimacy of the doctor before providing the secret key to the doctor. In other words, doctor authentication is required so that only the authorized doctor can decrypt the patients’ EHRs.

The doctor needs to send a set of attributes to the KGC in this way that the KGC is unable to recognize those attributes. In return, the KGC sends all the secret keys corresponding to the universe attributes to the doctor in this way that the doctor is only able to extract the secret keys corresponding to the requested attributes.

The doctor also must check the authentication of the KGC before the extraction of the secret keys corresponding to the requested attributes. Therefore, authentication of the KGC is required.

Preliminaries
This section first defines the used notations. Then it describes the definitions of bilinear pairing and linear secret sharing. After that, it describes the hardness problems under which the security of the CP2EH scheme is based. Next, it describes the CP-ABE scheme and the Camenisch-Shoup encryption scheme.

The frequently used notations and acronym of this paper is given in Table 2. We denote {\mathcal {Z}}^{*}_N∗𝑁 as a multiplicative group over the finite field N. The notation r \leftarrow _R {\mathcal {Z}}^{*}_N𝑟←𝑅∗𝑁, denoted as selection of a random element r from the group {\mathcal {Z}}^{*}_N∗𝑁.

Table 2 Frequently used notations, acronym and their meaning
Full size table

Definition 1
(Negligible Function) A function f :{\mathbb {N}} \rightarrow {\mathbb {R}}𝑓:ℕ→ℝ is said to be negligible, if it satisfies the following conditions, for every positive polynomial poly(.) there exists an integer polynomial N^{poly} > 0𝑁𝑝𝑜𝑙𝑦>0 such that \forall \ c> N^{poly}∀ 𝑐>𝑁𝑝𝑜𝑙𝑦, |f (c)| < { \frac{1}{{\text {poly}} (c)} }|𝑓(𝑐)|<1poly(𝑐) [11].

Definition 2
(Bilinear Map) Assume that, {\mathcal {G}} and {\mathcal {G}}_T𝑇 be multiplicative cyclic groups of order p. A map e: {\mathcal {G}} \times {\mathcal {G}} \rightarrow {\mathcal {G}}_T𝑒:×→𝑇 is said to be bilinear map, if it satisfies the following properties [6]:

e(\mathrm {u}^a,\mathrm {v}^b) = e(\mathrm {u},\mathrm {v})^{ab}𝑒(u𝑎,v𝑏)=𝑒(u,v)𝑎𝑏, for all \mathrm {u},\ \mathrm {v} \in {\mathcal {G}}u, v∈ and a,\ b \in {\mathcal {Z}}_p𝑎, 𝑏∈𝑝.

e(g, g) is a generator of {\mathcal {G}}_T𝑇.

Non-degeneracy: e(g, g) \ne 1𝑒(𝑔,𝑔)≠1.

Symmetric: e(\mathrm {u}^a,\mathrm {v}^b) = e(\mathrm {u}^b,\mathrm {v}^a) = e(\mathrm {u},\mathrm {v})^{ab}𝑒(u𝑎,v𝑏)=𝑒(u𝑏,v𝑎)=𝑒(u,v)𝑎𝑏.

e(\mathrm {u},\mathrm {v})𝑒(u,v) is efficiently computable, \forall \ \mathrm {u},\mathrm {v} \in {\mathcal {G}}.∀ u,v∈.

Definition 3
(Linear Secret-Sharing Scheme (LSSS)) The CP2EH scheme uses the LSSS. We use this definition from [2]. A secret-sharing scheme \pi𝜋 over a set of parties {\mathcal {P}} is called linear (over {\mathcal {Z}}_p𝑝) if

1.
The shares of each party are in the form of a vector over {\mathcal {Z}}_p𝑝.

2.
There exists a matrix {\mathbf {M}}𝐌 with order l \times n𝑙×𝑛 called the share-generating matrix for \pi𝜋. Let the function \rho𝜌 defined the party label row i as \rho (i)𝜌(𝑖), for all i = 1,2,..,l𝑖=1,2,..,𝑙 the ith row of {\mathbf {M}}𝐌. Let V = \{s, y_2,y_3,...,y_n\} \in {\mathcal {Z}}^n_p𝑉={𝑠,𝑦2,𝑦3,...,𝑦𝑛}∈𝑛𝑝 be a column vector, where s \in {\mathcal {Z}}^{*}_p𝑠∈∗𝑝 be a shared secret, and y_2,y_3,...,y_n \leftarrow _R {\mathcal {Z}}^{*}_p𝑦2,𝑦3,...,𝑦𝑛←𝑅∗𝑝, then {\mathbf {M}} \times V𝐌×𝑉 be the vector of l shares of the secret s according to \pi𝜋. The share ({\mathbf {M}}_{(i)} \times V)(𝐌(𝑖)×𝑉) belong to party \rho (i)𝜌(𝑖), where {\mathbf {M}}_{(i)}𝐌(𝑖) is the ith row of the matrix {\mathbf {M}}𝐌.

The above definition satisfies the linear reconstruction properties [2]. Assume that \pi𝜋 be an LSSS for access structure {\mathcal {A}} =({\mathbf {M}},\rho )=(𝐌,𝜌). Let us assume that, set S fulfill the criteria of access structure (M,\rho )(𝑀,𝜌) , and we further assume that I = \{i_1,i_2,\dots ,i_k\}𝐼={𝑖1,𝑖2,…,𝑖𝑘} be the subset of \{1, 2,...,l\}{1,2,...,𝑙} for which, I = \{i_c \in \rho (i_c) \in S \}^{k}_{c =1}𝐼={𝑖𝑐∈𝜌(𝑖𝑐)∈𝑆}𝑘𝑐=1. After that, we consider that \{\omega _{i_c} \in {\mathcal {Z}}_p\}_{i_c\in I}{𝜔𝑖𝑐∈𝑝}𝑖𝑐∈𝐼 are the set of constants such that if \lambda _{i_c}𝜆𝑖𝑐 belong to the valid shares of s with respect to the access structure, then it satisfies the expression \sum _{i_c\in I}\omega _{i_c}\lambda _{i_c} = s∑𝑖𝑐∈𝐼𝜔𝑖𝑐𝜆𝑖𝑐=𝑠. Where \omega _{i_c} = {\mathbf {M}}_{(i)} \times \omega𝜔𝑖𝑐=𝐌(𝑖)×𝜔 and \omega \in {\mathcal {Z}}_p^n𝜔∈𝑛𝑝 are randomly generated column matrix of order n\times 1𝑛×1, whose first entry is zero. Moreover, the constants \omega _{i_c}𝜔𝑖𝑐 found in polynomial time with respect to size of the matrix {\mathbf {M}}𝐌.

The security of the CP2EH scheme depends on the following hardness problem: The security of the ABE scheme is based on the hardness of decisional q-parallel Bilinear Diffie-Hellman Exponent (BDHE) assumptions. However, the security of the OT scheme depends on Rivest-Shamir-Adleman (RSA) factorization problem.

Decisional q -parallel BDHE problem [37]: This problem states that the probability of distinguishing between the tuple (\overrightarrow{y},e(g,g)^{b^{p+1}.s} )(𝑦→,𝑒(𝑔,𝑔)𝑏𝑝+1.𝑠) and the tuple (\overrightarrow{y}, R )(𝑦→,𝑅) is negligible by any Probabilistic Polynomial Time (PPT) adversary. Where e(g,g)^{b^{p+1}.s} \in {\mathcal {G}}_T𝑒(𝑔,𝑔)𝑏𝑝+1.𝑠∈𝑇, R is randomly chosen from {\mathcal {G}}_T𝑇, and the following values s,b,a_1,a_2,...,a_p𝑠,𝑏,𝑎1,𝑎2,...,𝑎𝑝 also randomly generated from {\mathcal {Z}}_p𝑝 and \overrightarrow{y} =𝑦→=

\begin{aligned}&g, g^s, g^b,...,g^{b^q},...,g^{b^{q+2}},...,g^{b^{2q}} \\&\forall _{1 \le i \le p},g^{s.a_i}, g^{b/a_i},..,g^{b^{q}/a_i},...,g^{b^{q+2}/a_i},...,g^{b^{2q}/a_i}\\&\forall _{1 \le i, k \le p, i\ne k}, g^{({b.s.a_k})/a_i},...,g^{({b^{q}.s.a_k})/a_i}. \end{aligned}

𝑔,𝑔𝑠,𝑔𝑏,...,𝑔𝑏𝑞,...,𝑔𝑏𝑞+2,...,𝑔𝑏2𝑞∀1≤𝑖≤𝑝,𝑔𝑠.𝑎𝑖,𝑔𝑏/𝑎𝑖,..,𝑔𝑏𝑞/𝑎𝑖,...,𝑔𝑏𝑞+2/𝑎𝑖,...,𝑔𝑏2𝑞/𝑎𝑖∀1≤𝑖,𝑘≤𝑝,𝑖≠𝑘,𝑔(𝑏.𝑠.𝑎𝑘)/𝑎𝑖,...,𝑔(𝑏𝑞.𝑠.𝑎𝑘)/𝑎𝑖.

RSA Factorization Problem [31]: If N = p*q𝑁=𝑝∗𝑞, where p and q are two large prime numbers. \phi (N) = (p-1)*(q-1)𝜙(𝑁)=(𝑝−1)∗(𝑞−1), and there exists an element e, such that 1< e < \phi (N)1<𝑒<𝜙(𝑁), and gcd(e,\phi (N)) = 1𝑔𝑐𝑑(𝑒,𝜙(𝑁))=1. After that, computes d that satisfies the condition ed \equiv 1\ mod\ \phi (N)𝑒𝑑≡1 𝑚𝑜𝑑 𝜙(𝑁). Then the factorization problem states that the probability of finding the factor of the composite number N is negligible by any PPT adversary, if both p and q are unknown to the adversary.

CP-ABE
A CP-ABE comprises of four algorithms:

ABE. Setup (\lambda𝜆, U): The KGC executes this algorithm. It takes inputs, security parameter \lambda𝜆, and a universe of attributes U and produces the public parameter PK and a master secret key (MSK) as outputs. Later, KGC uses this MSK and generates the secret keys for the doctor. The doctor uses these secret keys and decrypts the encrypted EHR of the patients.

ABE.Encryption (PK, M, {\mathcal {A}}): In this algorithm, the data owner takes a public parameter PK, message M, and access structure {\mathcal {A}} with respect to the universe of attributes U as inputs. After that, he encrypts the message M and produces an output ciphertext CT and sends it along with an access structure {\mathcal {A}} to the cloud.

ABE. KeyGen (MSK,\ S𝑀𝑆𝐾, 𝑆): The KGC executes this algorithm on its input master secret key MSK and a set of attributes S of the doctor. It generates a set of secret keys SK corresponding to attributes S and sends it to the doctor.

ABE. Decryption (PK,\ CT,\ SK𝑃𝐾, 𝐶𝑇, 𝑆𝐾): In this algorithm, the doctor takes the inputs public parameter PK, ciphertext CT, and the secret key SK. As the ciphertext, CT contains the access structure {\mathcal {A}}. If a set of attributes S of the doctor satisfies the access policy ( Name of hospital: X, type of doctor: cardiologist, etc.) of the access structure {\mathcal {A}}, then the doctor uses the secret key SK to decrypt the ciphertext CT and obtains the message M from the ciphertext CT.

Camenisch-shoup encryption
The proposed OT protocol is based on the Camenisch-Shoup encryption scheme [8]. This encryption scheme uses the following public parameters such as two prime numbers p and q, generator g of the group {\mathcal {G}}, and h = N+1ℎ=𝑁+1 (the value of h is used during the encryption and decryption process of the Camenisch-Shoup encryption scheme), where N = pq𝑁=𝑝𝑞.

KeyGen (g, N): Chooses a random value x \in [0,N/4]𝑥∈[0,𝑁/4], computes y = g^{x}𝑦=𝑔𝑥, and sets secret key sk = x𝑠𝑘=𝑥, and public key pk^{'}= y𝑝𝑘′=𝑦.

Encryption ({\mathcal {M}},\ y, 𝑦): Chooses a random value r \in [0,N/4]𝑟∈[0,𝑁/4] and computes the ciphertext {\mathcal {C}}_{{\mathcal {M}}} = E_y({\mathcal {M}}) = (u,v) = (g^r,y^rh^{{\mathcal {M}}})=𝐸𝑦()=(𝑢,𝑣)=(𝑔𝑟,𝑦𝑟ℎ).

Decryption (u,\ v,\ x𝑢, 𝑣, 𝑥): Computes D_x({\mathcal {C}}_{{\mathcal {M}}}) = \hat{{\mathcal {M}}} = (v/u^x)^{2{\mathbf {t}}}𝐷𝑥()=̂ =(𝑣/𝑢𝑥)2𝐭. where {\mathbf {t}} = 2^{-1}mod N𝐭=2−1𝑚𝑜𝑑𝑁. There exist {\mathcal {M}} \in {\mathcal {Z}}_N∈𝑁 for which \hat{{\mathcal {M}}}̂  has the form of h^{{\mathcal {M}}}ℎ, then output {\mathcal {M}}; otherwise, abort the scheme.

The advantage of this encryption scheme is that, it provides the following homomorphic properties over the encrypted data: 1) E_{y}(m_0)*E_{y}(m_1) = {\mathcal {C}}_{m_0} * {\mathcal {C}}_{m_1} = E_{y}(m_0 + m_1) = {\mathcal {C}}_{m_0+m_1}𝐸𝑦(𝑚0)∗𝐸𝑦(𝑚1)=𝑚0∗𝑚1=𝐸𝑦(𝑚0+𝑚1)=𝑚0+𝑚1. 2) E_{y}(m_0)/E_{y}(m_1) = {\mathcal {C}}_{m_0} / {\mathcal {C}}_{m_1} = E_{y}(m_0 - m_1) = {\mathcal {C}}_{m_0-m_1}𝐸𝑦(𝑚0)/𝐸𝑦(𝑚1)=𝑚0/𝑚1=𝐸𝑦(𝑚0−𝑚1)=𝑚0−𝑚1, and 3) E_{y}(m_0)^{{\mathbf {a}}} = ({\mathcal {C}}_{m_0} )^{a} = E_{y}({\mathbf {a}}.m_0) = {\mathcal {C}}_{{\mathbf {a}}.m_0}𝐸𝑦(𝑚0)𝐚=(𝑚0)𝑎=𝐸𝑦(𝐚.𝑚0)=𝐚.𝑚0. Where m_0, m_1𝑚0,𝑚1 are the message space, and {\mathbf {a}}𝐚 is any integer.

We use the notations E and D, respectively, as encryption and decryption algorithm under Camenisch-Shoup encryption scheme [8]. Suppose that pk is the joint public key of the KGC, and pk_d𝑝𝑘𝑑 is the ephemeral public key of the doctor. i.e., pk = pk_t.pk_d𝑝𝑘=𝑝𝑘𝑡.𝑝𝑘𝑑. The advantage of this scheme is, it allows shared decryption of the ciphertext which has encrypted under public key pk. The joint public key pk is the combination of two public keys pk_t𝑝𝑘𝑡 and pk_d𝑝𝑘𝑑. sk_t𝑠𝑘𝑡 and sk_d𝑠𝑘𝑑 are the secret keys corresponding to the, respectively, public keys pk_t𝑝𝑘𝑡 and pk_d𝑝𝑘𝑑. If we encrypt any message with the help of a joint public key pk, then that encrypted message is only decrypted by two secret keys sk_t𝑠𝑘𝑡 and sk_d𝑠𝑘𝑑. However, if we encrypt any message with the help of public key pk^{'}𝑝𝑘′, then that encrypted message is only decrypted by the secret key sk. We have used the following expressions like {\mathcal {C}}^{(d)}_{m} = E_{pk_d}(m)(𝑑)𝑚=𝐸𝑝𝑘𝑑(𝑚), {\mathcal {C}}^{(t)}_{m} = E_{pk_t}(m)(𝑡)𝑚=𝐸𝑝𝑘𝑡(𝑚), and {\mathcal {C}}_{m} = E_{pk}(m)𝑚=𝐸𝑝𝑘(𝑚), which denote the ciphertexts which are encrypt the message m using Camenisch-Shoup encryption scheme under, respectively, pk_d𝑝𝑘𝑑, pk_t𝑝𝑘𝑡, and pk. The partial decryption of {\mathcal {C}}_{m}𝑚 under sk_d𝑠𝑘𝑑 creates {\mathcal {C}}^{(t)}_{m} = D_{sk_d}({{\mathcal {C}}_m}) = E_{pk_t}(m)(𝑡)𝑚=𝐷𝑠𝑘𝑑(𝑚)=𝐸𝑝𝑘𝑡(𝑚). Similarly, partial decryption of {\mathcal {C}}_{m}𝑚 under sk_t𝑠𝑘𝑡 creates {\mathcal {C}}^{(d)}_{m} = D_{sk_t}({{\mathcal {C}}_m}) = E_{pk_d}(m)(𝑑)𝑚=𝐷𝑠𝑘𝑡(𝑚)=𝐸𝑝𝑘𝑑(𝑚). In order to get the message m, from ciphertext {{\mathcal {C}}^{(d)}_m}(𝑑)𝑚, one can compute m = D_{pk_d}({\mathcal {C}}^{(d)}_m)𝑚=𝐷𝑝𝑘𝑑((𝑑)𝑚). Similarly, in order to get the message m, from ciphertext {{\mathcal {C}}^{(t)}_m}(𝑡)𝑚, one can compute m = D_{pk_t}({\mathcal {C}}^{(t)}_m)𝑚=𝐷𝑝𝑘𝑡((𝑡)𝑚).

System model and privacy requirements
System model
The system model of the CP2EH scheme is given in Fig. 1. The following entities are involved in this model:

Fig. 1
figure 1
System Model of the CP2EH scheme

Full size image

Patient: The patient encrypts his documents (EHR), collects attributes corresponding to EHR, and outsources them to the cloud.

Doctor: The doctor requests the private keys of the intended attributes from the KGC. After that, the doctor requests the ciphertext of all the intended attributes from the cloud. After getting the ciphertext from the cloud, the doctor decrypts the encrypted document and provides services to the patients.

KGC: The KGC initially generates the public parameters for the patients and the doctors. The patient uses these parameters to encrypt the medical documents.

Cloud: It is an intermediary between the doctor and the patient. It stores the encrypted documents of the patient and then provides data access and search services to the doctor. When the doctor requests the ciphertext of the intended attributes, then the cloud transfers a collection of matching encrypted documents to the doctor.

Privacy requirements
The CP2EH scheme provides the following privacy requirements:

Data Privacy: The patients need to outsource their documents to the cloud in such a way that even the malicious cloud server cannot extract sensitive information from that document.

Doctor Privacy: To provide the services to the patient, the doctor requests the private keys of corresponding attributes from the KGC. In this case, if the KGC is compromised with the cloud, then it may reveal sensitive information about the patient. Therefore, the attributes privacy of the doctor is a serious concern for e-health applications.

KGC: It sends all the private keys corresponding to the universe attributes to the doctor, but the doctor can extract the private keys corresponding to the requested attributes.

Doctor Authentication: Suppose that any malicious doctor requests a set of private keys for the particular set of attributes from the KGC. In return, the KGC sends the collection of private keys for the corresponding attributes. The malicious doctor uses those keys to decrypt the encrypted documents of the patients, and he may reveal sensitive information about the patients. Therefore, the authentication of the doctor is necessary. Moreover, before getting the private keys, the doctors also verify whether these keys are coming from a legitimate authority. Therefore, authentication of the KGC is also required.

The CP2EH scheme
Overview
The CP2EH scheme is shown in Fig. 2. In the CP-ABE method, patients send the encrypted EHR and some attributes to the cloud so that it will be easy for the cloud to search the encrypted EHR. If any doctor requests the encrypted EHR from the cloud for a particular set of attributes, then the cloud sends that encrypted EHR to that doctor. For the decryption of that encrypted EHR, the doctor requests secret keys for the corresponding attributes from the KGC. If the doctor does this without hiding those attributes, then any eavesdropper may take that secret keys and decrypt the EHR of the patients. Moreover, if the KGC is compromised with the cloud, then the KGC may also reveal information about the patient. Therefore, to overcome these problems, the CP2EH scheme uses the OT protocol. The doctor uses the ZKP2 protocol to verify the legitimacy of the KGC. Similarly, the KGC uses the ZKP1 protocol to verify whether the doctor is legitimate.

Construction Of CP2EH scheme
In stage \textcircled {1}\textcircled1, KGC generates the public parameter PK using ABE.Setup algorithm and sends it to the patient and doctor. In stage \textcircled {2}\textcircled2, the patient encrypts EHR using ABE.Encryption algorithm and outsources it to the cloud. In stage \textcircled {3}\textcircled3, the doctor sends a set of attributes S to the cloud and gets encrypted EHR corresponding to S in stage \textcircled {4}\textcircled4. In stage \textcircled {5}\textcircled5, KGC executes the ZKP1 protocol to check the legitimacy of the doctor. However, in stage \textcircled {6}\textcircled6, the doctor executes the ZKP2 protocol to check the legitimacy of the KGC. To decrypt the encrypted EHR, the doctor requires a set of secret keys SK corresponding to the encrypted EHR. To get those keys securely from the KGC, the doctor executes stages \textcircled {7}\textcircled7 and \textcircled {8}\textcircled8. Stages \textcircled {7}\textcircled7 to \textcircled {8}\textcircled8 execute in ABE.KeyGen. We invoke OT protocol in the key generation algorithm. In this protocol, the doctor hides a set of attributes and sends them to the KGC. The KGC sends all the secret keys SK to the doctor in such a way that the doctor can only extract the secret keys SK corresponding to the requested set of attributes S. In order to do this, KGC and doctor execute the OT protocol. This protocol uses the OPRF algorithm. In order to preserve the secret keys privacy of the KGC and the attributes privacy of the doctor, the OPRF algorithm uses the Camenisch-Shoup encryption scheme [8].The doctor executes the ABE.Decryption algorithm on the received secret keys and decrypts the encrypted EHR of the patient. Note that in this work, we have used two encryption techniques, ABE and Camenisch-Shoup encryption. The ABE scheme is a broadcast encryption technique, and it provides the privacy of EHR. Moreover, in this scheme, any doctor who satisfies the access policy of the encrypted EHR can decrypt the EHR. In other words, the patients want to send their encrypted HER to more than one doctor because sometimes it happens that if the specified doctor is not available, then the patient can go for another doctor. We have used the Camenisch-Shoup encryption scheme in the OPRF algorithm. This scheme has special properties called homomorphic properties. It is generally used between two parties; therefore, it is not suitable for encrypting a patient’s information. The OPRF algorithm uses these properties to preserve the secret keys privacy of the KGC and the attributes privacy of the doctor.

Fig. 2
figure 2
The CP2EH scheme

Full size image

Detailed description
All the participating entities agree on common public parameters. The common parameters are: U is the total number of attributes, {\mathcal {G}} be a group of prime order p, and g is the generator of the group {\mathcal {G}}. The CP-ABE scheme takes inputs as an LSSS access matrix {\mathbf {M}}𝐌 and a uniformly distributed random share s \in {\mathcal {Z}}^{*}_p𝑠∈∗𝑝 for {\mathbf {M}}𝐌. To avoid the collusion attack, the scheme uses the uniformly distributed share s. It is noted that the value of s is only known to the patient.

ABE. Setup (\lambda ,\ U𝜆, 𝑈): In this phase, the KGC takes U as input and produces the public parameter PK = {g,\ e(g,g)^{\alpha },\ g^{a},\ h_1,\ h_2, ..., h_{U}𝑔, 𝑒(𝑔,𝑔)𝛼, 𝑔𝑎, ℎ1, ℎ2,...,ℎ𝑈} and the master secret key MSK = g^{\alpha }𝑔𝛼, where a\ \text {and}\ \alpha𝑎 and 𝛼 are randomly generated from the multiplicative group {\mathcal {Z}}^{*}_p∗𝑝 and h_1,\ h_2, ..., h_{U}ℎ1, ℎ2,...,ℎ𝑈 are also randomly generated from the group {\mathcal {G}}.

ABE. Encryption (PK,\ M,\ {\mathcal {A}}𝑃𝐾, 𝑀, ): In this phase, the patient computes an LSSS access structure {\mathcal {A}} = ({\mathbf {M}},\ \rho )=(𝐌, 𝜌) as per his requirements and uses the public parameter PK as input to encrypt the message (EHR) M. Where \rho𝜌 is a function that map row of the matrix {\mathbf {M}}𝐌 to an attribute. Let us consider that the matrix {\mathbf {M}}𝐌 has order l\times n𝑙×𝑛. In order to encrypt the message M, the patient first of all chooses a random vector V = \{s, y_2,y_3,...,y_n\}𝑉={𝑠,𝑦2,𝑦3,...,𝑦𝑛}, (where every element of the vector is uniformly generated from \in {\mathcal {Z}}^n_p∈𝑛𝑝) and computes \lambda _i = V \times {\mathbf {M}}_i𝜆𝑖=𝑉×𝐌𝑖, for all i = 1𝑖=1 to l. Where {\mathbf {M}}_i𝐌𝑖 is the i_{th}𝑖𝑡ℎ row of the matrix {\mathbf {M}}𝐌, and s is the share. Patient outsources the ciphertext CT and {\mathcal {A}} to the cloud, where CT = \{C,\ C^{'},\,C_i,\ D_i\}𝐶𝑇={𝐶, 𝐶′,𝐶𝑖, 𝐷𝑖}, and C = M*e(g,g)^{s\alpha }𝐶=𝑀∗𝑒(𝑔,𝑔)𝑠𝛼, C^{'} = g^s𝐶′=𝑔𝑠, and C_i = g^{a.\lambda _i}\ * \ h^{-r_i}_{\rho (i)}𝐶𝑖=𝑔𝑎.𝜆𝑖 ∗ ℎ−𝑟𝑖𝜌(𝑖), D_i = g^{r_i}𝐷𝑖=𝑔𝑟𝑖, where r_i𝑟𝑖 is randomly generated, i.e., r_i \leftarrow _R {\mathcal {Z}}^{*}_p𝑟𝑖←𝑅∗𝑝, for all i = 1𝑖=1 to l and \{h_{\rho (1)}, h_{\rho (2)},...,h_{\rho (l)}\} \subseteq \{h_1,h_2,...,h_U\}{ℎ𝜌(1),ℎ𝜌(2),...,ℎ𝜌(𝑙)}⊆{ℎ1,ℎ2,...,ℎ𝑈}.

ABE. KeyGen (MSK, S): The KGC executes the ZKP1 protocol to verify the legitimacy of the doctor. This ZKP1 protocol is similar to the baseline ZKP protocol [11], but the only difference is that instead of addition, the ZKP1 protocol uses a subtraction operation. Moreover, instead of an inverse exponential operation, it uses exponential operation. The execution time of inverse modulus exponential requires high execution time than the modulus exponential operation [12]. This strategy makes the ZKP1 protocol faster than the baseline ZKP protocol. In ZKP1 protocol, the doctor and the KGC agree on the standard parameters. The following standard parameters for the ZKP1 protocol: A large prime number q and another large prime number p, which is a divisor of q-1𝑞−1. {\mathcal {G}}_p𝑝 is a subgroup of {\mathcal {Z}}^{*}_q∗𝑞 with order p, and g is a generator of {\mathcal {G}}. In the setup phase of this protocol, all the doctors generate their private and public key pairs and register their public key with the KGC. For example, the doctor d chooses a secret key sk_d = x_d𝑠𝑘𝑑=𝑥𝑑 randomly from {\mathcal {Z}}^{*}_p∗𝑝 and computes the public key pzk_d = g^{sk_d}\ mod\ q𝑝𝑧𝑘𝑑=𝑔𝑠𝑘𝑑 𝑚𝑜𝑑 𝑞 and registers it with the KGC. The doctor convinces the KGC that he is a legitimate doctor, by claiming that he knows the secret key sk_d𝑠𝑘𝑑 of the corresponding public key pzk_d𝑝𝑧𝑘𝑑. To prove this claim, the doctor and the KGC execute the following steps of ZKP1 protocol: The ZKP1 Protocol:

The doctor generates a random value r \leftarrow _R {\mathcal {Z}}^{*}_p𝑟←𝑅∗𝑝 and computes A = g^r\ mod\ q𝐴=𝑔𝑟 𝑚𝑜𝑑 𝑞 and sends it to the KGC.

In return, it chooses a random challenge c \in [0,\ 2^{160}-1] and sends it to the doctor. (The 160-bit challenge preserves security in the presence of malicious adversaries under discrete log assumptions [11]).

The doctor computes, msg = r-x_d*c (\ mod\ p) and sends it to the KGC.

To verify the legitimacy of the doctor, the KGC performs the following tests: (1) Validity of the doctor public key pzk_d, (2) (pzk_d)^p \equiv \ 1\ mod\ q, and A \equiv g^{msg}*(pzk_d)^c mod\ q. If these tests are positive, then the KGC continues the protocol; otherwise, it aborts the protocol.

Once the KGC agrees that it is interacted with the legitimate doctor, then it proceeds the scheme. The doctor executes the ZKP2 protocol [11] with KGC to check the legitimacy of the KGC before the execution of the OT protocol. In this protocol, both parties agree on standard parameters similar to the previous case of the ZKP1 protocol. Recall that, in the setup phase of CP-ABE the KGC announced its public key g^a. We denote the KGC’s secret key as sk_t = a and computes its public key pk_t = g^a. The KGC convinces the doctor that it is a genuine authority, by claiming that it knows the secret key sk_t = a of the corresponding public key pk_t. In order to prove this claim, the KGC and the doctor execute the following steps of ZKP2 protocol: The ZKP2 Protocol:

The KGC generates a random value r^{'} \leftarrow _R {\mathcal {Z}}^{*}_p and computes A^{'} = g^{r^{'}}\ mod\ q and sends it to the doctor.

In return, he chooses a random challenge c^{'} \in [0,2^{160}-1] and sends it.

The KGC computes msg^{'} = r^{'}-a*c^{'}(\ mod\ p) and sends it to the doctor.

The doctor performs the following tests to verify the legitimacy of the KGC: (1) Validity of public key pk_t, (2) (pk_t)^p \equiv 1\ mod\ q, and A^{'} \equiv g^{msg^{'}}*(pk_t)^{c^{'}} mod\ q.

If all the tests performed by the doctor are positive, then the doctor continues the scheme; otherwise, it aborts the protocol. The doctor and the KGC execute the OT protocol. The description of the OT protocol is as follows: The OT protocol: In this protocol, the KGC uses public parameter, PK = {g,\ e(g,g)^{\alpha },\ g^{a},\ h_1,\ h_2, ..., h_{U}}, and computes, {\mathcal {K}} = g^{\alpha }g^{at}, {\mathcal {L}} = g^{t}. Moreover, it computes the following secret keys \{{\mathcal {K}}_i = h^t_i\}^{U}_{i = 1 }, corresponding to the values of \{h_1,\ h_2, ..., h_{U}\}, and stores them, where t \leftarrow _R {\mathcal {Z}}_p. To decrypt the encrypted EHR, the doctor needs to require a set of secret keys corresponding to a set of attributes. For example, suppose that if the doctor has the following set of attributes S = \{\rho (i_1),\rho (i_2),...,\rho (i_k) \}, then the doctor needs to require the following set of secret keys \{ {\mathcal {K}}_{\rho (i_1)} = h^{t}_{\rho (i_1)}, {\mathcal {K}}_{\rho (i_2)} = h^{t}_{\rho (i_2)},...,{\mathcal {K}}_{\rho (i_k)} = h^{t}_{\rho (i_k)} \} to decrypt the encrypted EHR. For convenience, we denote a set of attributes \{\rho (i_1),\rho (i_2),...,\rho (i_k) \} , respectively, \{j_1,j_2,...,j_k\}. The doctor has a set of attributes J = \{j_1,j_2,...,j_k\} as inputs of the OT protocol. At the end of OT protocol, the doctor receives outputs {\mathcal {K}}_{j_1},\ {\mathcal {K}}_{j_2},...,{\mathcal {K}}_{j_k}. However,the KGC receives nothing. The KGC encrypts all the values of secret keys {\mathcal {K}}_i = h^t_i, where i = 1 to U using OPRF. In order to encrypt the values of secret keys {\mathcal {K}}_i, the KGC computes {\mathcal {K}}^{'}_i = g^{1/a+i}.{\mathcal {K}}_i for all i = 1 to U and sends these values, SK = \{{\mathcal {K}}^{'}_i,\ {\mathcal {K}},\ {\mathcal {L}}\} to the doctor. In order to extract the values from {\mathcal {K}}_{j_1},\ {\mathcal {K}}_{j_2},...,{\mathcal {K}}_{j_k} from {\mathcal {K}}^{'}_i, the doctor computes {\mathcal {K}}_{j_1} = {\mathcal {K}}^{'}_{j_1}/(f_a(j_1)),...,{\mathcal {K}}_{j_k} = {\mathcal {K}}^{'}_{j_k}/(f_a(j_k)). Where f_a(j_1) = g^{1/a+j_1},...,f_a(j_k) = g^{1/a+j_k}. The doctor evaluates these function f_a(j_1), f_a(j_2),...,f_a(j_k) using OPRF evaluation algorithm. The OPRF Evaluation Algorithm: In this algorithm for simplicity, we assume that the doctor has only one attribute J, for which \rho (J) \in S. The doctor computes a ephemeral public key pk_d for that attribute J. In other words, pk_d = g^{J}. The KGC already announces its public key pk_t = g^a. The KGC and the doctor interchange public key pk_t and pk_d , respectively, and encrypt their inputs a and J under the combined key pk = pk_t.pk_d as {\mathcal {C}}_a and {\mathcal {C}}_J. As we know that from homomorphic property of the Camenisch-Shoup Encryption scheme [8], if {\mathcal {C}}_a.{\mathcal {C}}_J = C_{\psi }, then \psi = a + J (described in Sect. 3.2). Now, the doctor picks a value w \leftarrow _R {\mathcal {Z}}^{*}_N, and computes {\mathcal {C}}_{\beta } = ({\mathcal {C}}_{\psi })^{w} to randomize the value of \psi. By homomorphic property, the ciphertext of {\mathcal {C}}_{\beta } is equal to {\mathcal {C}}_{w.\psi }. Hence, \beta = w.\psi (described in Sect. 3.2). Moreover, the doctor encrypts w using the joint public key pk. In other words, {\mathcal {C}}_w = E_{pk}(w) and partially decrypts {\mathcal {C}}_{\beta }. i.e., C^{(t)}_{\beta } = D_{J}({\mathcal {C}}_{\beta }) and sends ({\mathcal {C}}_w,C^{(t)}_{\beta }) to the KGC. The doctor wants to send the value of \beta to the KGC, but the value \beta is encrypted under the joint public key pk of the KGC and doctor. Therefore, the doctor first partially decrypts the value of {\mathcal {C}}_{\beta } with secret key sk_d = J, then sends it to the KGC so that the KGC can use its secret key sk_t = a and extracts the value of \beta. To decrypt the ciphertext C^{(t)}_{\beta } the KGC uses its secret key sk_t = a, and computes \beta = D_a(C^{(t)}_{\beta }) = w.\psi, {\mathcal {C}}_{\sigma } = ({\mathcal {C}}_w)^{1/\beta }. Here, we can see that, from the homomorphic property, \sigma = w/\beta = w/(w.\psi ) = 1/\psi = 1/(a+J). The ciphertext {\mathcal {C}}_{\sigma } contains the encryption of \sigma = 1/(a+J), under joint public key pk, where a and j are the secret keys of the KGC and doctor, respectively. The KGC has encrypted all the secret keys with the help of f_a(J) = g^{1/a+J}. Therefore, it wants to send its encrypted secret keys SK in such a way that the doctor cannot know the secret key sk_t = a of the KGC. Moreover, the doctor can only get the secret keys SK of the requested attributes. Hence, the KGC hides the value of \sigma and sends it to the doctor as follows: it picks a random value \sigma _t \leftarrow _R {\mathcal {Z}}^{*}_N and computes v_t = g^{\sigma _t}, {\mathcal {C}}_{\sigma _t} = E_{pk}(\sigma _t), {\mathcal {C}}_{\sigma _d} = {\mathcal {C}}_{\sigma }/{\mathcal {C}}_{\sigma _t}, and {\mathcal {C}}^{(d)}_{\sigma _d} = D_a({\mathcal {C}}_{\sigma _d}). Sends (v_t,{\mathcal {C}}^{(d)}_{\sigma _d}) to the doctor. In order to compute the OPRF the doctor computes \sigma _d = D_J({\mathcal {C}}^{(d)}_{\sigma _d}), v = v_t.g^{\sigma _d} = g^{\sigma _d +\sigma _t} = g^{\sigma } = g^{1/a+J} = f_a(J). Similarly, the doctor evaluates all the functions that are required for the extraction of the secret keys SK of the required attributes.

ABE.Decryption (PK,\ CT,\ SK): To decrypt the ciphertext CT and gets the message M, the doctor uses public parameter PK and received secret key SK as inputs. The doctor can only be able to decrypt the ciphertext CT, if the secret key SK for the set S satisfies the access structure {\mathcal {A}} = ({\mathbf {M}},\ \rho ). Let us assume that, set S full fill the criteria of (M,\rho ) , and we further assume that J = \{\rho (i_1),\rho (i_2),...,\rho (i_k) \} be the subset of \{{\rho (1)}, {\rho (2)},...,{\rho (l)}\}. In other words, I = \{i_1,i_2,...,i_k\} \subset \{1,2,...,l\}, for which, I = \{i_c \in \rho (i_c) \in S \}^{k}_{c =1}. After that, we consider that \{\omega _{i_c} \in {\mathcal {Z}}_p\}_{i_c\in I} are the set of constants such that if \lambda _{i_c} belong to the valid shares of s with respect to the access structure, then it satisfies the expression \sum _{i_c\in I}\omega _{i_c}\lambda _{i_c} = s. To decrypt the ciphertext CT, the doctor first computes, temp = e(C^{'}, {\mathcal {K}})/(\prod _{i_c\in I}(e(C_{i_c},{\mathcal {L}}).e(D_{i_c},{\mathcal {K}}_{\rho ({i_c})}))^{\omega _{i_c}}) = e(g,g)^{s\alpha }.e(g,g)^{sat}/(\prod _{i_c\in I}e(g,g)^{at\omega _{i_c}\lambda _{i_c}}) = e(g,g)^{s\alpha }. After that, the doctor computes M = C/temp = M.e(g,g)^{s\alpha }/e(g,g)^{s\alpha }.

Security analysis
The CP2EH scheme uses CP-ABE, ZKP protocol, and OT protocol. We prove the security of every used scheme one by one. The security of the CP-ABE scheme is based on the hardness of the q-parallel BDHE assumption. To analyse the security of the CP-ABE scheme, we consider the following theorem.

Theorem 1
If the decisional q-parallel BDHE problem is hard, then the probability of breaking the security of CP-ABE scheme by any PPT adversary is negligible.

Proof
Proof of this theorem 1 is given in [37]. \square

The CP2EH scheme uses the Schnoor ZKP1 and ZKP2 protocols for the mutual authentication between the KGC and doctor. Both ZKP1 and ZKP2 protocols provide the following security features, such as completeness, soundness, and zero-knowledge with the honest verifier. The proof of these security features is described in [33]. We prove the security of the proposed OT protocol. The proposed OT protocol is based on the OPRF algorithm. So, first, we prove the security of the OPRF algorithm, then we prove the security of the OT protocol. To prove the security of the OPRF algorithm, we have considered the following theorem.

Theorem 2
If the encryption technique used in the CP2EH scheme during the evaluation of the OPRF is semantically secure; moreover, the used ZKP1 and ZKP2 protocols provide the soundness property, then the proposed OPRF algorithm securely evaluates the functionalities f_a(j_i), for all i = 1 to k.

Proof
In order to prove the above theorem, we consider two cases:

1. KGC is malicious: We construct an ideal-world simulator Sim_t, from a malicious KGC T^{*}. Now, we show the case where both the real-world KGC T^{*} and honest party functionality f_a(j_i) are interact with the ideal-world simulator Sim_t. The simulator Sim_t proceeds as follows: Recall that, before the execution of the OT protocol both the doctor and the KGC execute the ZKP protocol. Suppose that name of the ZKP protocol executed by the doctor and the KGC are ZKP_2 and ZKP_1, respectively. If T^{*} successfully executes the ZKP_1 protocol, then the simulator Sim_t executes an extractor algorithm with T^{*} to extract the private key a from the public key pk_t = g^a. In order to simulate the real-world doctor, Sim_t proceeds as follows:

(pk_d, sk_d)\leftarrow KeyGen(g, N)

w \leftarrow _R {\mathcal {Z}}^{*}_N, {\mathcal {C}}^{(d)}_{w} \leftarrow E_{pk}(w)

\beta \leftarrow _R {\mathcal {Z}}^{*}_N, {\mathcal {C}}^{(t)}_{\beta } \leftarrow E_{pk}(\beta )

Sends (pk_d,{\mathcal {C}}^{(d)}_{w},{\mathcal {C}}^{(t)}_{\beta }) honest party functionality f_a(j_i) and simulates the ZKP_2.

After that, the simulator Sim_t sends the secret key a to the trusted party functionality f_a(j_i). It is noted that a trusted party on the input a of the simulator Sim_t and the ideal-world doctor input J produces an output f_a(J) to the doctor. We construct a distinguisher W, which controls the KGC T^{*}. The distinguisher W grabs the input of the doctor and analyses the output of the doctor. To prove the theorem 2, we need to show the views of the distinguisher in the real-world and the ideal-world are indistinguishable. In order to show the indistinguishability between both of the worlds, we begin with the sequence of the following hybrid games hb_0,\ hb_1,...,hb_5. We analyse the views of W by slightly modify the game hb_i to hb_{i+1} and argue that the views of the distinguisher W in hb_i and hb_{i+1} are identical.

hb_0: In this game, the malicious authority T^{*} executes the algorithm with honest doctor.

hb_1: Strategy about this game is similar to the previous game, but the only difference is ZKP_2 protocol. Due the soundness property of the ZKP_2 protocol, the doctor simulates the scheme. Hence, the views of W in hb_0 and hb_1 are identical.

hb_2: This game is similar to the hb_1 except that the following: (a) If T^{*} successfully executes the ZKP_1 protocol, then hb_2 executes an algorithm with T^{*} to extract the secret key a from the public key pk_t = g^a. (b) In this game, hb_2 either produces the output f_a(J) = g^{1/a+J} or \perp (if gcd(a+J,N) \ne 1) as a final output. It is noted that the hb_2 knows the input of the doctor and the KGC. From above item (a), the probability of extracting the secret key a from pk_t is negligible due to the soundness property of the ZKP_1 protocol [11]. From above item (b), it also holds the soundness property of the ZKP_2 protocol. Hence, the views of W in hb_1 and hb_2 are indistinguishable.

hb_3: This game is same as hb_2, except that it chooses gcd(a+J,N) = 1 instead of gcd(a+J,N) \ne 1 , and it does the following.

1.
(pk_d, sk_d)\leftarrow KeyGen(g, N)

2.
\beta \leftarrow _R {\mathcal {Z}}^{*}_N, {\mathcal {C}}^{(t)}_{\beta } \leftarrow E_{pk}(\beta )

3.
w \leftarrow \beta /(a+J), {\mathcal {C}}^{(d)}_{\omega } \leftarrow E_{pk}(w)

4.
Sends (pk_d,{\mathcal {C}}^{(d)}_{w},{\mathcal {C}}^{(t)}_{\beta }) trusted party functionality f_a(j_i) and simulates the ZKP_2.

The views of W in the tuple (pk_d,{\mathcal {C}}^{(d)}_{w},{\mathcal {C}}^{(t)}_{\beta }) of game hb_2 and hb_3 are indistinguishable. Because, the probability of finding such value for which the expression gcd(a+J,N) = 1 satisfied is negligible if the RSA factorization problem is hard.

hb_4: This game is similar to the hb_3, except that w is chosen randomly. i.e., w^{'} \leftarrow _R {\mathcal {Z}}^{*}_N. As we know that the used encryption scheme in OPRF is semantically secure, therefore the views of the distinguisher in game hb_3 and hb_4 are indistinguishable.

hb_5: This game is a real game where trusted party functionality f_a(j_i), simulator Sim_t, and the ideal-world doctor are participate. In this game, the simulator follows the game hb_4 till the computation of f_a(J) = g^{1/a+J}, after that it sends a to the KGC functionality. In return, trusted party computes f_a(J) = g^{1/a+J}, by using the input of the doctor and the KGC and sends it. Therefore, the views W in games hb_4 and hb_5 are indistinguishable. This completes the proof of OPRF algorithm, when the KGC is malicious. Now, we prove the second case, where the doctor is malicious.

2. Doctor is malicious: We construct a simulator Sim_d from a malicious doctor D^{*}. The simulator Sim_d proceeds as follows:

(pk_t,sk_t) \leftarrow KeyGen(g, N), picks a random number a^{'} \leftarrow _R {\mathcal {Z}}^{*}_N, computes {\mathcal {C}}_{a^{'}} \leftarrow E_{pk}(a^{'}), and sends (pk_t,{\mathcal {C}}_{a^{'}}) to the malicious doctor D^{*} and simulates the ZKP_1 protocol.

If the ZKP_2 protocol successfully executes, then the simulator Sim_d runs an algorithm with D^{*} to extract the value of J from g^J, and sends it to the trusted party functionality f_a(j_i). In return, it sends v = g^{1/a+J} to the simulator Sim_d. Where the inputs a and J are getting from the ideal-world KGC and the simulator Sim_d , respectively.

After getting the value v, the simulator Sim_d proceeds as follows:

1.
if f_a(J) = 1, then Sim_d sends abort message to the doctor D^{*}.

2.
\sigma _d \leftarrow _R {\mathcal {Z}}^{*}_N

3.
v_t \leftarrow v/g^{\sigma _d}

4.
{\mathcal {C}}^{(d)}_{\sigma _d} \leftarrow E_{pk}(\sigma _d)

5.
Sends (v_t,{\mathcal {C}}^{(d)}_{\sigma _d} ) trusted party functionality f_a(j_i) and simulates.

Similar to the previous case, here we also construct a distinguisher W that controls the the doctor D^{*}. The distinguisher W collects input of the doctor, executes the OPRF algorithm and observes the output of the doctor. Similar to the previous case here we also construct a series of games, modify these and argue the views of distinguisher W in the previous game and the current game. Let us consider that hb_0 be the real-world hybrid game in which real-world KGC executes the OPRF algorithm. However, hb_4 be an ideal-world game in which ideal-world KGC executes the OPRF algorithm.

hb_1: It is similar to hb_0, except that it simulates the ZKP_1 proof. Due the soundness property of the ZKP_1, views of the distinguisher W in hb_0 and hb_1 are indistinguishable.

hb_2: This game is similar to hb_1, except that ZKP_2 protocol. This game extracts J from the doctor ephemeral public key pk_d = g^J. As we know that, the probability of extracting the value of J from g^J is negligible. So the views of W in hb_1 and hb_2 are identical.

hb_3: This game is similar to the previous game hb_2 except that after the extracting the value of J from g^J, Sim_d does the following:

1.
v = f_a(J), if v =1, then it sends abort message to the doctor D^{*}.

2.
\sigma _d \leftarrow _R {\mathcal {Z}}^{*}_N

3.
v_t \leftarrow v/g^{\sigma _d}

4.
{\mathcal {C}}^{(d)}_{\sigma _d} \leftarrow E_{pk}(\sigma _d)

5.
Sends (v_t,{\mathcal {C}}^{(d)}_{\sigma _d} ) trusted party functionality f_a(j_i) and simulates.

It is noted that g^{1/a+J} =1 if and only if gcd(a+J,N) \ne 1, and if gcd(a+J,N) \ne 1, then \beta = w(a+J), where gcd(w,N) \ne 1. Therefore, the KGC in this game also sends abort message to the doctor D^{*}. If g^{1/a+J} \ne 1, then the values (v_t, {\mathcal {C}}^{d}_{\sigma _d}) are distributed uniformly. So, the views of W in hb_2 and hb_3 are indistinguishable.

hb_4: The Sim_d sequentially follows the previous game before v is computed. The simulator applies an algorithm and extracts the value of J from g^J and sends it to the KGC functionality f_a(J). The functionality f_a(J) gets an input a from the KGC and computes g^{1/a+J} and sends it the Sim_d. It is clear from the output of the previous game and the output distribution of the current game are indistinguishable by the distinguisher W. This completes the proof of OPRF algorithm.

\square

Now, we prove the set of attributes privacy of the doctor and the privacy of the universe of attributes of the KGC. To show the mutual privacy of both the parties, we propose the following theorem.

Theorem 3
The proposed OT protocol provides the attribute privacy of both the doctor and the KGC, if the probability of determining the output of the OPRF algorithm by any PPT adversary is negligible.

Proof
In order to prove the above theorem, we consider two cases:

1. KGC is malicious: We construct a simulator Sim_t from the malicious KGC T^{*}. The simulator Sim_t extracts an input a from the malicious KGC T^{*}, computes v_i = f_a(i) for all i = 1,2,...,U, and sends \hat{{\mathcal {K}}_i} = {\mathcal {K}}^{'}_i/v_i to the trusted party. In return, after the getting the inputs j_1,j_2,...,j_k from the doctor, the KGC computes \hat{{\mathcal {K}}_J} for all J = \{j_1,j_2,...,j_k\}, and sends it to the ideal-world doctor. However, in the real-world the output of the doctor is {\mathcal {K}}^{'}_J/v_J, for all J = \{j_1,j_2,...,j_k\}, which is similar to the ideal-world output. Therefore, the malicious authority T^{*} does not get any information from the OT protocol either it is interacting with the real-world doctor or interaction with the ideal-world simulator Sim_t. Hence, we say that the views any PPT distinguisher W in the real-world and the ideal-world are identical.

2. Doctor is malicious: We construct a simulator Sim_d from the malicious doctor D^{*}. The simulator Sim_d chooses a random public key pk^{'}_t \leftarrow _R {\mathcal {Z}}^{*}_N, a set of random numbers \{\mathrm {r}_1,\ \mathrm {r}_2,...,\mathrm {r}_U\} in such a way that it belong to the output of OPRF and sends it to the malicious doctor D^{*}. In return, D^{*} sends J = \{j_1,\ j_2,...,j_k\}. After getting the values of J, the Sim_d sends it to the trusted party and gets {{\mathcal {K}}_{j_i}} for all i = \{1,2,...,k\} from the trusted party. After that, the simulator Sim_d computes \mathrm {r}_J/{{\mathcal {K}}_{j_i}}, for all i = \{1,2,...,k\}, and sends it to the doctor D^{*}. Under the assumption of OPRF the views of D^{*} in the real-world OT protocol \{{\mathcal {K}}^{'}_i,f_a(i)\} for all i = 1,2,...,U is indistinguishable from \{\mathrm {r}_i, \mathrm {r}_{j_c}/{{\mathcal {K}}_{j_c}}\}, for all i = 1,2,...,U and c = \{1,\ 2,...,k\}. Therefore, the malicious doctor D^{*} does not get any information from the OT protocol either it is interacting with the real-world KGC or interacting with the ideal-world simulator Sim_d. Hence, it proves that any PPT distinguisher W cannot distinguish between the output of the real-world game and the ideal-world game. \square

Implementation and results
We analyse the performance of the CP2EH scheme with current state-of-the-art schemes in a theoretical and experimental way. Moreover, in the theoretical analysis, we also compare the various security features of the CP2EH scheme with current-state-of-the art schemes.

Theoretical performance
To evaluate the performance of the CP2EH scheme, we derived the time and the space complexity of the CP2EH scheme and compared it with the following existing schemes, Rahulamathavan [30], Liang [21], Zhong [45], Zhang [43], Li [18], and Pournaghi [29]. For the evaluation of space complexity, we compute ciphertext’s size and secret key’s size. However, for the evaluation of time complexity, we derive the time complexity of the setup, encryption, decryption, and key generation. In Table 3 and Table 4, respectively, we compared the space and the time complexity required by the CP2EH scheme and existing schemes. In both of the tables, we denoted E_e, E_m, and E_p, respectively, as exponential, multiplication, and pairing operation.

Table 3 Space complexity and communication round of the CP2EH scheme vs. existing schemes
Full size table

Table 4 Time complexity of the CP2EH scheme versus existing schemes
Full size table

Besides, we denoted {\mathcal {S}} and {\mathcal {T}}, respectively, as communication cost (size) and execution time. Furthermore, we denoted T, A, K, and l, respectively, the minimum number of attributes required to satisfy the access structure, total number of attributes present in the system, number of trusted authorities, and number of rows present in the LSSS matrix. It is well known that the computation time of the pairing function is significantly greater than the exponential operation. Recall that, the value of |l|<< |A|,\ \text {where}\ (U = A). Moreover, the number of attributes present in the system is significantly greater than the number of attributes required to satisfy the access structure. In other words, |T|<< |A|. In order to measure the space complexity, we counted the number of group elements exchange between the sender and receiver. For example, in the key generation phase of the CP2EH scheme, the sender (KGC) sends all the private keys to the receiver (Doctor). Therefore, the total number of group elements exchange between the doctor and KGC is A. Hence, the space complexity required in this process is {\mathcal {O}}(A)|{\mathcal {G}}|. Similarly, we computed the space complexity for ciphertext. Table 3 shows that the CP2EH scheme requires significantly less space than the existing schemes in both scenarios (private key’s size and ciphertext’s size). Apart from space complexity, this table also compares the number of communication rounds required by the CP2EH scheme and existing schemes. In the key generation phase of the CP2EH scheme, mutual authentication between KGC and doctors requires ZKP protocols. This authentication causes one more round of communications in the CP2EH scheme. Hence, the CP2EH scheme requires one more round of communication than the existing schemes.

The computational complexity of any cryptographic scheme depends on the number of mathematical operations such as modulus multiplication, exponential, pairing, etc., operations. We cannot determine the exact time complexity of these operations because their complexity depends on various factors such as order of a group, length of security parameter, types of an elliptic curve, etc. Therefore, we measure the time complexity of the schemes with respect to the above mathematical operations. For example, the setup phase of the CP2EH scheme requires only two exponential and one pairing operations. Therefore, the time complexity of the CP2EH scheme in the setup phase is {\mathcal {O}}(2E_e+E_p). Similarly, we computed the time complexity of the encryption, decryption, and key generation. It is noted that we included the time complexity of OT, ZKP1, and ZKP2 protocols in the key generation phase. Table 4 demonstrates that the CP2EH scheme requires only one extra exponential operation in the setup phase than the existing schemes. However, in the encryption and decryption phase, the CP2EH scheme requires significantly fewer operations than the existing schemes. In the key generation phase, Pournaghi [29] scheme is the best performer scheme among all the schemes. The CP2EH scheme is the second-best performer among all the existing schemes. However, if we combine the time complexity of setup, encryption, decryption, and key generation, then it is found that the CP2EH scheme performs significantly better than the existing schemes. Hence, in both scenarios (time and space complexity), the CP2EH scheme performs better than the existing schemes.

Now, we analyse the various security features of the CP2EH scheme with the current state-of-the-art schemes in Table 5. In this table, \mathbf {F_1}, \mathbf {F_2}, \mathbf {F_3}, \mathbf {F_4}, \mathbf {F_5}, and \mathbf {F_6} , respectively, represent the patients’ data privacy from cloud, collusion-resistant, doctor’s attribute privacy, secret keys privacy of the KGC, authentication of the KGC, and authentication of the doctor.

Table 5 Comparison of various security features of the CP2EH scheme vs. existing schemes
Full size table

The CP2EH scheme uses the OT protocol to preserve the attributes’ privacy of the doctor. Therefore, any doctor does not know the attributes of the other doctor. Therefore, only a legitimate doctor (who has all the attributes corresponding to the patient attributes) can access the patient record. Hence, the CP2EH scheme is secure against collusion-resistant attacks. This table demonstrates that the only CP2EH scheme fulfills the current security requirement of the e-health applications over the cloud.

Experimental analysis
In this analysis, to check the performance of the CP2EH scheme with the other existing schemes, we used three desktop machines in which one is used for the cloud, and the other two are used for the patient and the doctor. The configuration of the used machine is Intel(R) Core(TM) i3-3220 CPU @ 3.30GHz with 6 GB RAM and Ubuntu 18.04 LTS operating system. We implemented all the e-health techniques in Python 3.0 language and executed them on the cryptography library SageMath 8.0 version. In this experiment, we sent the information (attributes, EHR, etc.) from one entity to another via the internet. To get accurate results, we executed all the e-health schemes thousand times and took their average time in milliseconds (ms). All the schemes use the elliptic curve, which has embedding degree 2, base field size is 512-bit, and the elliptic curve has 160-bit group order. We compare each CP2EH algorithm’s execution time like key generation, encryption, decryption, total execution time (sum of setup, encryption, decryption, and key generation time), setup time, with the existing e-health schemes. In all the algorithms, we fix the value of K = 4 because, in the existing schemes, they have chosen the value of K = 4 [18, 21, 30]. We compared the execution time of all the algorithms of the CP2EH scheme with the current schemes like Rahulamathavan [30], Liang [21], Zhong [45], Zhang [43], Li [18], and Pournaghi [29].

In Fig. 3a, for the key generation algorithm, we plotted the execution time of the CP2EH scheme with the current state-of-the-art schemes for different values of attributes. According to the existing schemes [18, 21, 30], for the values of attributes A = 50, we have chosen T = 5, similarly, for A = 100, we have chosen T = 10, and so on. The Pournaghi [29] scheme performs 1.04-1.20x, 1.45-1.75x, 1.45-1.75x, 3.81-4.5x and 4.37-5.23x times faster than, respectively, CP2EH, Li [18], Rahulamathavan [30], Zhang [43], Liang [21], and Zhong [45] schemes. The figure shows that the Pournaghi [29] scheme performs significantly better than among all the schemes because Pournaghi [29] scheme requires only a few numbers of cryptographic operations than among all the schemes. However, the CP2EH scheme is the second performer among all the schemes.

Fig. 3
figure 3
a Comparison of the average execution time of key generation algorithm between CP2EH scheme and existing schemes for different values of attributes. b Comparison of the average execution time of encryption algorithm between CP2EH scheme and existing schemes for different values of attributes. \ddagger denotes the standard deviation of the average execution time

Full size image

Fig. 4
figure 4
a Comparison of the average execution time of decryption algorithm between CP2EH scheme and existing schemes for different values of attributes. b Comparison of the average execution time of all the algorithms between CP2EH scheme and existing schemes for different values of attributes. c Comparison of the average execution time of setup algorithm between CP2EH scheme and existing schemes for different values of attributes

Full size image

For the encryption algorithm, we draw a bar graph of the execution time of the CP2EH scheme with the existing schemes for different values of attributes in Fig. 3b. In this figure, we have chosen the values of A and T similarly to the key generation scheme. The CP2EH scheme performs 2.14-2.20x, 2.14-2.20x, 3.21-3.30x, 3.64-3.74x, 4.28-4.41x, and 6.42-6.61x times faster than, respectively, Rahulamathavan et al. [30], Zhong et al [45], Pournaghi [29], Li [18], Liang et al. [21], and Zhang et al. [43] schemes. The figure demonstrates that the CP2EH scheme outperforms the existing schemes because the CP2EH scheme requires only a few exponential and pairing operations than the existing schemes.

In Fig. 4a, for the decryption algorithm, we plotted the average running time of the CP2EH scheme with the current state-of-the-art schemes for different values of attributes. The figure demonstrates that the CP2EH scheme performs 28.57-103.53x, 42.85-155.35x, 57.14-207.14x, 60.14-210.40x, 602.14-2402.141x, and 714.28-2509.28x times faster than, respectively, Pournaghi [29], Li [18], Liang [21], Rahulamathavan [30], Zhong [45], and Zhang et [43] schemes. In this figure, the average running time of the CP2EH scheme is comparably much lesser than the existing schemes because the CP2EH scheme requires only a few pairing operations than the existing schemes. Therefore, the bar graph of the CP2EH scheme is invisible as compared to current state-of-the-art schemes. This algorithm has considered the values of A and T, similar to the previous algorithm.

In order to check the overall performance of the CP2EH scheme, we compare the total running time of the CP2EH scheme and existing schemes. We added the following running time, setup, encryption, decryption, and key generation and computed the total running time of the schemes. Fig. 4b shows the total average running time (for different values of attributes) between the CP2EH scheme and existing schemes. In this figure also, for A = 50 we have chosen T = 5, similarly, for A = 100, T = 10, and so on. The CP2EH scheme performs 5.39-14.94x, 7.3-16.84x, 40.98-155.42x, and 48.33-162.62x times faster than, respectively, Pournaghi [29], Li [18], Rahulamathavan [30], Liang [21], Zhong [45], and Zhang [43] schemes.

The figure shows that the CP2EH scheme performs significantly better than existing schemes because if we combine the total number of operations required in setup, encryption, decryption, and key generation, then we found that the CP2EH scheme requires only a few numbers of operations than the existing schemes. Fig. 4c compares the average setup time between the CP2EH scheme and the existing schemes. Fig. 4c shows that both schemes Liang [21] and Li [18] perform 1.64x, 2.23x, 2.35x, and 3.05x times faster than the, respectively, schemes, CP2EH, Zhang [43], Zhong [45], Pournaghi [29], and Rahulamathavan et al. [30]. This figure demonstrates that schemes Liang [21] and Li [18] perform better than among all the schemes because both schemes require only a few numbers of pairing and exponential operations than the existing schemes. Moreover, this figure shows the same average execution time for different values of attributes because the setup time of every scheme is independent of the attributes.

Discussion
We analyzed the performance of the CP2EH scheme theoretically and experimentally. In theoretical analysis, we determined the exponential, pairing, and multiplication operations of each algorithm (setup, encryption, decryption, and key generation) and compared these operations with the existing schemes. In the setup phase, all the schemes require approximately the same numbers of exponential and pairing operations. The setup time of all the schemes is independent of attributes; therefore, for the different values of attributes, the average execution setup time remains the same. In the encryption phase, the proposed scheme uses the centralized cloud server, and the rest of the schemes uses the decentralized cloud server. In decentralized cloud server-based e-health schemes, the share of ciphertext is distributed among all the cloud servers; however, a single ciphertext is shared in the centralized cloud server-based scheme. The distribution of the share ciphertext is a time-consuming operation in decentralized cloud server-based schemes. Thus, in theoretical analysis, the CP2EH scheme requires fewer exponential and pairing operations than the existing schemes. In the decryption phase of the CP2EH scheme, the doctor needs to collect the ciphertext from the centralized cloud server, in the existing schemes, the doctor collects the share of ciphertexts from the decentralized server, and the doctor needs to combine them into the actual ciphertext and decrypts them. This operation requires high computation cost. The CP2EH requires only a few exponential and pairing operations than the existing schemes and, therefore, requires less execution time than the existing schemes. In the key generation phase of the CP2EH scheme, the doctor needs to preserve the secret keys of the corresponding encrypted EHR from KGC. However, the KGC also wants to share only those secret keys required for the doctor to decrypt encrypted EHR. In order to preserve these privacies, both the doctor and the KGC are required to execute the combination of ZKP and OT protocols. This combination causes high exponential and modulus operations than the blockchain-based e-health scheme, but it requires fewer operations than the decentralized cloud server-based e-health schemes. This is also observed during the experiments. The CP2EH scheme requires only a few numbers of cryptographic operations during the encryption and decryption process; this result significantly impacts the overall computation costs of the CP2EH scheme.

The CP2EH scheme also requires low communication costs because sharing a single encrypted EHR with the centralized cloud server requires low communication costs. The existing decentralized cloud server-based e-health schemes require sending shares of ciphertext over the various cloud servers that cause high communication cost. The CP2EH scheme suffers from single point failure in a centralized private cloud-based system. In the future, we aim to enhance the CP2EH scheme and resolve this issue without violating the privacy requirements of the patients at low communication and computation costs. The CP2EH scheme preserves all the privacy requirements of the patients along with it requires low communication and computation costs; therefore, it is a viable option for the resource constraints devices like the Internet of medical things. The patient’s EHR is valuable and sensitive information. Patients may want to use their smartphone to get services corresponding to their EHR from the hospital. Hospitals may derive financial benefits by providing EHRs. In the next stage, we plan to add value-added services to this CP2EH scheme. Patients can send their EHR to the hospital, and get value-added privacy-preserving services from the hospital.

Conclusion
In this work, we proposed a comprehensive privacy-preserving e-health (CP2EH) scheme over the cloud that allowed privacy preserving sharing of electronic health records of patients. The scheme used a combination of attribute-based encryption, oblivious transfer, and zero-knowledge proof protocols to meet the privacy requirements of the e-health applications over the cloud. The scheme is more efficient and yielded significantly better performance in comparison to existing schemes. It meets all the necessary privacy requirements of cloud-based sharing of health records. CP2EH scheme has low communication and computation overheads. This makes it a viable option for the Internet of medical things (IoMT) in which the scheme can be implemented on resource constraint devices. The CP2EH scheme suffers from single point failure if the cloud is a centralized private cloud. The electronic health records are valuable for patients, doctors and other health related establishments and can be an attractive business proposition. We can add value added services, which can be availed by patients in lieu of sharing their records.