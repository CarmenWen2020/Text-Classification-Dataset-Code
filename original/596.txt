Abstract
The focus of extracting colossal closed itemsets from high dimensional biological datasets has been great in recent times. A massive set of short and average sized mined itemsets do not confine complete and valuable information for decision making. But, the traditional itemset mining algorithms expend a gigantic measure of time in mining a massive set of short and average sized itemsets. The greater interest of research in the field of bioinformatics and the abundant data across the variety of domains paved the way for the generation of the high dimensional dataset. These datasets are depicted by an extensive number of features and a smaller number of rows. Colossal closed itemsets are very significant for numerous applications including the field of bioinformatics and are influential during the decision making. Extracting a huge amount of information and knowledge from the high dimensional dataset is a nontrivial task. The existing colossal closed itemsets mining algorithms for the high dimensional dataset are sequential and computationally expensive. Distributed and parallel computing is a good strategy to overcome the inefficiency of the existing sequential algorithm. Balanced Distributed Parallel Frequent Colossal Closed Itemset Mining (BDPFCCIM) algorithm is designed for high dimensional datasets. An efficient closeness checking method to check the closeness of the rowset and an efficient pruning strategy to snip the row enumeration mining search space is enclosed with the proposed BDPFCCIM algorithm. The proposed BDPFCCIM algorithm is the first distributed load balancing algorithm to mine frequent colossal closed itemsets from high dimensional biological datasets. The experimental results demonstrate the efficient performance of the proposed BDPFCCIM algorithm in comparison with the state-of-the-art algorithms.

Previous
Next 
Keywords
Distributed and parallel computing

Load balancing

Bioinformatics

High dimensional datasets

Closeness checking

1. Introduction
Itemset mining is the main and fundamental part of Association Rule Mining (ARM). The applications of itemset mining are great and spread across a variety of domains. Customer analysis, text analysis, chemical compound prediction, web analysis, toxicological analysis, spatiotemporal analysis, Ribo Nucleic Acid (RNA) analysis, detecting the events and software bugs are some of the applications [1], [4], [5], [9], [12], [21], [29], [31], [37], [41], [45], [49]. The highly accurate prediction of the subcellular location of proteins can be achieved by the combination of ARM and classification, which is known as associative classification [21], [46]. The crucial motifs useful in various chemical and biological applications are extracted with the help of itemset mining [1], [21]. Extensive utilization of ARM in gene expression data analysis helps to disclose the gene networks [21].

The initial research compiled for the designing of efficient Frequent Itemset Mining (FIM) algorithms [2], [10], [14], [34], [35], [44] to extract the frequently occurring itemsets from transaction datasets. These FIM algorithms are sequential algorithms, which are computationally expensive in extracting the frequently occurring itemsets from large transaction datasets. Parallel and distributed FIM algorithms [13], [15], [33], [47], [50] were proposed to overcome the inefficiency of the sequential FIM algorithms. The researchers further focused on mining frequent closed itemsets due to the redundant rules, which are generated by a large number of mined frequent itemsets. The researchers concentrated on designing a sequential [18], [30], [36], [39], [48] and parallel algorithms [6], [19], [22], [40] for mining Frequent Closed Itemsets (FCI) from transaction datasets, which are depicted with an expansive set of rows (samples) and a small set of attributes (features). The itemset space searching approach adopted by these sequential and parallel algorithms to mine FCI from transaction dataset makes these algorithms as feature enumeration-based algorithms. The running time of traditional sequential and parallel algorithms exponentially increases during the mining of FCI from transaction datasets. The increase in average transaction length is the main reason for the inefficiency of the traditional feature enumeration-based sequential and parallel algorithms. The availability of huge amount of data in various fields and bioinformatics persuaded for the new mode of datasets. These datasets are high dimensional datasets, which are depicted with an expansive set of features (attributes) and a small set of rows (samples). The data characteristics of these high dimensional datasets and transaction datasets differ from each other. Extracting colossal measure of information and knowledge from high dimensional datasets is a nontrivial job. The traditional feature enumerated FCI mining sequential [18], [30], [36], [39], [48] and parallel algorithms [6], [19], [22], [40] are inefficient in extracting FCI from high dimensional datasets.

The researchers designed the sequential row enumerated algorithms like Carpenter [27], TD-Close [16], and TDD-Close [17] to overcome the inefficiency of feature enumerated algorithms in extracting FCI from high dimensional datasets. The hybrid row and feature enumeration-based COBBLER algorithm [28] mine the FCI from a dataset with an expansive set of features and an expansive set of rows. These row enumerated and hybrid enumerated algorithms are designed to extract FCI from high dimensional datasets sequentially. The parallel and distributed row enumerated algorithms can solve the inefficiency of the featured enumerated FCI mining algorithms to a greater extent. The parallel and distributed row enumerated FCI mining algorithms have not been designed till date, to the best of our knowledge. But, an extensive number of short and average sized itemsets extracted by featured and row enumerated FCI mining algorithms do not confine complete and valuable information in numerous applications [3], [8], [11], [20], [21], [23], [24], [25], [26], [32], [46], [51], [52]. ARM provides higher interest to large cardinality itemsets called as colossal itemsets, especially for the applications dealing with High Dimensional Biological Datasets (HDBD) [3], [21], [23], [24], [25], [26], [32], [51], [52]. For many applications, the colossal itemsets are prominently significant and very influential during decision making [8], [11], [20], [46]. The significance of mining colossal itemsets from high dimensional biological datasets was demonstrated by S Naulaerts et al. [21] and R Alves et al. [3]. The exponential amount of time spent by existing sequential, parallel feature enumerated and row enumerated FCI mining algorithms [6], [16], [17], [18], [19], [22], [27], [28], [30], [36], [38], [39], [40], [48] in extracting short and average sized itemsets makes them inefficient in extracting Frequent Colossal Closed Itemsets (FCCI) from HDBD.

Pattern Fusion algorithm by Zhu et al. [51] was the first algorithm which proposed the idea of colossal itemsets. The approximation of extracted colossal closed itemsets helps the Pattern Fusion algorithm to mine the large cardinality itemsets. This acts as a bottleneck for the Pattern Fusion algorithm, which fails to extract a significant set of FCCI. This eventually affects decision making as a partial set of association rules are generated. The BVBUC algorithm [32] also fails to extract a significant set of FCCI and frequent colossal itemsets from HDBD. This leads to the generation of a partial set of association rules, which eventually affects decision making. Even the support information regarding the majority of the mined FCCI is wrongly provided by the BVBUC algorithm. This affects decision making as an incorrect set of association rules are generated. Zulkurnain et al. [52] proposed a DisClose algorithm, which utilizes CompactRowtree (CR-tree) to mine FCCI from HDBD. The existing works lack the capability of pruning the complete set of insignificant features and insignificant rows before undertaking the process of mining FCCI from HDBD. This causes the algorithm to be inefficient in mining FCCI as the row enumerated mining search space exponentially increases. The existing FCCI mining algorithms [32], [51], [52] are sequential and lacks the capability of enclosing an efficient pruning approach to snip the row enumerated search space and an efficient rowset closeness checking method.

Traversing the row enumerated tree is the best solution for extracting the FCCI from HDBD. The intrinsic nature of the row enumerated tree is typically unbalanced, as the number of nodes in each row enumerated tree branch vary. It is very important to properly distribute the branches of the row enumerated tree among the compute nodes to traverse it and mine the FCCI. The load of traversing the branches of row enumerated tree among the compute nodes should be balanced. The first balanced distributed parallel algorithm was designed to solve the inefficiency problem of existing works. The Balanced Distributed Parallel Frequent Colossal Closed Itemset Mining (BDPFCCIM) algorithm was proposed to mine FCCI from HDBD. Before the mining of FCCI from HDBD, the complete set of insignificant features and insignificant rows from HDBD are removed by the proposed algorithm, which is one of the drawbacks of the existing works. Minimum support threshold is effectively utilized to remove the insignificant features and minimum cardinality threshold to remove insignificant rows. The proposed BDPFCCIM algorithm efficiently distributes the branches of row enumerated tree to the computing nodes for traversing and mining FCCI. The branches of the row enumerated tree assigned to the computing nodes are traversed using the parallel bottom-up approach. The proposed algorithm is enclosed with an efficient rowset closeness checking method. If the closeness checking method indicates that the rowset is closed, then the itemset mined from that rowset is also closed. The proposed rowset closeness checking method utilizes the updated cardinality of the rsid(s) at that particular rowset. The proposed algorithm is also enclosed with the pruning strategy to efficiently spin the nodes of the row enumerated tree which do not produce FCCI. Without traversing the descendant nodes, the proposed pruning strategy gets the cardinality information of the itemsets to be mined from these nodes, which is one of the drawbacks of the existing works. Computationally fast bitset approach is utilized by the proposed algorithm. The proposed work is the first balanced distributed parallel algorithm to mine FCCI from HDBD. The results highlight that existing algorithms is outperformed by the proposed BDPFCCIM algorithm with the benefit of an efficient rowset closeness checking method and pruning strategy.

2. Related work
The detailed research across the field of itemset mining was carried out. The problems of various data domains are solved using frequent itemset mining and association rule mining [1], [4], [5], [9], [12], [21], [29], [31], [37], [41], [45], [49]. The group of genes’ relationships is captured by association rule mining with the help of gene interaction networks [21]. FIM is used to solve the phrase based approach’s disadvantages in the field of text mining [49]. The text analysis has more benefits from larger patterns, and these larger patterns are very specific concerning taxonomy. Pattern taxonomy helps to significantly improve the information filtering performance during the text analysis. The gene ontology annotations accommodate abundant knowledge and are discovered with the help of ARM [20]. The strong associations among the combinations of allele related to diseases and structural features’ combination are identified by FIM [1], [21].

The frequent itemsets are sequentially mined from the transaction dataset by the numerous efficiently designed sequential algorithms [2], [10], [14], [34], [35], [44]. The sequentially FIM algorithms are inefficient as the running time exponentially increases due to the increase in average transaction length. Parallel FIM algorithms [13], [15], [33], [42], [43], [47], [50] were designed as the large transaction dataset were inefficiently handled by the sequential FIM algorithms. Frequent Closed Itemsets (FCI) were proposed by Nicolas Pasquier et al. [30] as the redundant rules are generated by the huge set of frequent itemsets mined from transaction dataset. This led to the designing of sequential [18], [30], [36], [39], [48] and parallel feature enumeration-based FCI mining algorithms [6], [19], [22], [40]. The mining of FCI from High Dimensional Biological Datasets (HDBD) by the feature enumeration-based algorithms are computationally expensive due to the data characteristics of HDBD. The computational complexity of mining FCI from HDBD was handled by designing the row enumeration-based algorithms [16], [17], [27], [28], [38]. These row enumeration-based algorithms sequentially traverse the rowset space to extract the FCI from HDBD. The top-down or bottom-up search strategy is used by the row enumerated FCI algorithms to traverse the rowset mining search space.

Transposed table approach is adopted by the rowenumeration-based algorithms to mine FCI from HDBD. Huge number of conditional transposed tables are generated due to the adoption of transposed table approach. The combination of feature and row enumeration methods was used by F Pan at el. [28] to design a switching FCI mining algorithm (COBBLER). The COBBLER algorithm extracts FCI from a dataset with extensive number of features and extensive number of rows. The existing state-of-the-art row enumeration-based algorithms sequentially mine FCI from HDBD, unfortunately till date there has not been a single parallel and distributed row enumeration-based FCI mining algorithms designed. The FCI from HDBD are more efficiently mined by the parallel and distributed row enumeration-based algorithms and provide better solution to the computationally expensive problem. An extensive set of small and mid-sized FCI are mined from HDBD by existing row enumeration-based FCI algorithms. The extensive set of small and mid-sized itemsets consist of limited information for various applications. Colossal itemsets provide very important information for various applications and also have great importance during decision making [3], [21], [23], [24], [25], [32], [51], [52].

Row enumeration and feature enumeration based approach is utilized by the existing FCCI [32], [51], [52] and frequent colossal itemsets mining algorithms [23], [24], [25], [26], [32], [51]. The data characteristics of transaction datasets make the feature enumeration-based approach as best suited to mine frequent colossal itemsets and FCCI. The existing feature enumeration-based algorithms designed to mine FCCI and frequent colossal itemsets are sequential and also unsuccessful in pruning the complete set of insignificant features and insignificant rows. Pattern Fusion algorithm by Zhu et al. [51] was the first algorithm which proposed the idea of colossal itemsets. The Pattern Fusion algorithm utilizes the feature enumeration-based method, hence inefficient in handling high dimensional biological datasets. NL Nguyen et al. [25] proposed the row enumeration-based CP-Miner and PCP-Miner algorithms to sequentially mine frequent colossal itemsets from HDBD. The FCCI was proposed as frequent colossal itemsets generates redundant rules. The CP-Miner and PCP-Miner utilize sequential row enumeration-based approach, hence inefficient compared to parallel and distributed approach. The CP-Miner and PCP-Miner do not mine FCCI from HDBD as it only mines frequent colossal itemsets. The BVBUC algorithm by MK Sohrabi et al. [32] and DisClose algorithm by NF Zulkurnain et al. [52] utilizes row enumeration-based approach to sequentially mine FCCI from HDBD. The mining search space after the minsup level in row enumerated tree is pruned by the BVBUC algorithm and FCCI are mined from the rowset belonging to only minsup level. The complete set of FCCI is not mined by the BVBUC algorithm, which affects the decision making as incomplete set of association rules are generated. The support information of various FCCI mined from BVBUC algorithm is incorrect, which affects the decision making as incorrect set of association rules are generated. In prior to the mining of FCCI from HDBD, the complete set of insignificant features and insignificant rows has to be pruned. The existing row enumeration-based FCCI mining algorithms fail to do the same, which leads to an exponentially increase in the row enumerated mining search space. An efficient pruning strategy to snip the row enumeration mining search space and an efficient rowset closeness checking is not enclosed by the existing row enumeration-based algorithms to mine FCCI from HDBD.

3. Preliminaries
Let the High Dimensional Biological Dataset, HDBD (GR,GF) consist a set of m gene rows (samples), GR  {, , …., } and a set of n gene features GF  {, , …, }. Table 1 highlights the set of notations and their description. A unique row (sample) identifier (rsid) is provided for each row  of HDBD and a set of features is present in each row. A collection of gene features is termed as an itemset, X  GF. An itemset with d number of gene features is called as d-itemset. Rows consisting of th feature of the HDBD are indicated by gr(). A collection of rsid(s) is termed as a rowset (row enumerated node), Y  GR. A rowset with d number of rsid is called as d-rowset. The gene features present in the th row of the HDBD are indicated by gf(). Table 2 shows an example of HDBD, which consists of 11 gene features, GF  {, , , , , , , , , , } and 8 gene rows, GR  {1, 2, 3, 4, 5, 6, 7, 8}. The support of an itemset X is defined as the occurrence of X in a number of rows from the dataset and is denoted as sup(X). For example, the support of an itemset X  {, }, sup(()()) in Table 2 is 3. The cardinality of an itemset X is defined as the number of gene features present in that itemset and is denoted as card(X). For example, the cardinality of an itemset X  {, }, card(()()) in Table 2 is 2. Table 3 highlights the bitTable of the HDBD as shown in Table 2. The rs in Table 3 represents the cardinality (card) of the respective row. The cs in Table 3 represents the support (sup) of the respective gene feature.


Table 1. Set of notation and their description.

Notations	Description
rsid	A unique row (sample) identifier
gr()	Rows consisting of th feature of the HDBD
gf()	The gene features present in the th row of the HDBD
d-itemset	An itemset with d number of gene features
d-rowset	A rowset with d number of rsid
sup(X)	Number of rows from the dataset, in which an itemset X has occurred.
card(X)	Number of gene features present in an itemset X.
i(Z)	If Z is the bitset result at rowset Y, then i(Z) provides the indexes of 1 occurring in Z
An itemset X, having the support equal to or greater than the minimum support threshold (minsup), sup(X)  minsup and which do not have proper superset X with the same support as that of itemset X, sup(X)  sup(X) is termed as Frequent Closed Itemset (FCI). For example, an itemset X  {, , } from Table 1 is frequent closed itemset with the minsup set to 2, as it does not have a proper superset with the support same as that of an itemset X  {, , }. An itemset X, having the cardinality equal to or greater that the minimum cardinality threshold (mincard), card(X)  mincard and also frequently closed is termed as Frequent Colossal Closed Itemset (FCCI). For example, with 4 as mincard and 2 as minsup, an itemset X  {, , , } from Table 1 is frequent colossal closed itemset as it is frequently closed and having cardinality equal to or greater than the mincard, card(()()()())  mincard.


Table 2. High dimensional biological dataset HDBD.

Row (sample) id (rsid)	Features
1	, , , , 
2	, , , , 
3	, , , 
4	, , , , , 
5	, , , , , 
6	, , 
7	, 
8	, 

Table 3. bitTable corresponding to high dimensional biological dataset HDBD.

rsid												rs
1	1	1	0	1	0	1	0	0	0	1	0	5
2	1	1	0	1	0	0	1	1	0	0	0	5
3	0	1	0	1	0	0	1	1	0	0	0	4
4	1	1	0	0	0	1	0	1	1	1	0	6
5	1	0	1	1	0	0	1	1	0	1	0	6
6	0	1	0	1	0	0	0	0	1	0	0	3
7	0	0	0	0	1	0	1	0	0	0	0	2
8	0	0	0	0	1	0	0	0	0	0	1	2
cs	4	5	1	5	2	2	4	4	2	3	1	
Definition 1 Closure

Given an itemset X  GF and a rowset Y  GR in a High Dimensional Biological Dataset HDBD (GR, GF), we define (1)(2)

The closure of an itemset X, C(X) and closure of a rowset Y, C(Y) is defined as follows (3)(4)

Example 1

Given an itemset   and rowset 23 from HDBD, as shown in Table 2, then gr( )  124, the rows of HDBD in which an itemset   is present. gf(23)    
 
, the gene features of HDBD present in rowset 23. The closure of an itemset 
 
, C(
 
) and rowset 23, C(23) are as follows (5)
(6)

4. The proposed work
The High Dimensional Biological Datasets (HDBD) have to be preprocessed before proceeding with the mining of Frequent Colossal Closed Itemsets (FCCI). The complete set of insignificant features and insignificant rows are not pruned by the existing row enumeration-based FCCI mining algorithms. To overcome this drawback, the preprocessing of HDBD should involve in pruning the complete set of insignificant features and insignificant rows. The gene features of HDBD which do not fulfill the criteria of minimum support threshold are the insignificant features. These insignificant features have to be pruned from the HDBD as they do not contribute to the final set of FCCI and also deteriorates the performance of the algorithm. (7)

Pruning the set of insignificant features is highlighted inEq. (7), with GF
 being the set of insignificant features. A couple of existing algorithms [32], [51] prune the insignificant features and do not prune the insignificant rows. As shown in Table 4, pruning of only insignificant features is done by a couple of existing algorithms. The insignificant features in HDBD are 
 and 
 when the minsup is set to 2. The pruning of insignificant features from the HDBD as shown in Eq. (7) affects the cardinality of rows (card(srid),  rsid  GR) in HDBD. The rows of HDBD which do not fulfill the criteria of minimum cardinality threshold are the insignificant rows. These insignificant rows have to be pruned from HDBD as the itemsets mined from the rowset involving the insignificant rows do not contribute to the final set of FCCI and also exponentially increases the row enumerated mining search space. Pruning of insignificant rows is performed by a couple of existing algorithms [23], [24], [25], [52] after pruning the insignificant features. (8)

Pruning the set of insignificant rows is highlighted in Eq. (8), with GR
 being the set of insignificant rows. A couple of existing row enumeration-based FCCI mining algorithms prune the set of insignificant features just once. A couple of existing row enumeration-based algorithms prune set of insignificant rows just once after pruning the set of insignificant features. The pruning of the set of insignificant features and insignificant rows by these algorithms is performed just once, hence the complete set of insignificant features and insignificant rows are not pruned. As shown in Table 5, pruning of insignificant rows is performed by a couple of existing algorithms after pruning the insignificant features. The insignificant row in HDBD is (srid, 8) when the mincard is set to 2. Pruning the set of insignificant rows from HDBD affects the support of features (sup(
),  
  
) in 
 and may convert the set of features from remaining features of the HDBD to insignificant. If the set of features from the remaining features of the HDBD is converted to insignificant, then the pruning process has to continue until all the remaining features, and rows of HDBD are significant. As shown in Table 5, the pruning of insignificant row 8 affects the support of gene feature 
 and eventually converting it to insignificant. Hence the pruning process has to be continued.


Table 4. bitTable after pruning insignificant features {
, 
}. Couple of existing algorithms [32], [51] prune only insignificant features.

rsid	
rs
1	1	1	1	0	1	0	0	0	1	5
2	1	1	1	0	0	1	1	0	0	5
3	0	1	1	0	0	1	1	0	0	4
4	1	1	0	0	1	0	1	1	1	6
5	1	0	1	0	0	1	1	0	1	5
6	0	1	1	0	0	0	0	1	0	3
7	0	0	0	1	0	1	0	0	0	2
8	0	0	0	1	0	0	0	0	0	1
cs	4	5	5	2	2	4	4	2	3	

Table 5. bitTable after pruning insignificant row 8, couple of existing algorithms [23], [24], [25], [52] prune insignificant features and insignificant rows just once.

rsid	
rs
1	1	1	1	0	1	0	0	0	1	5
2	1	1	1	0	0	1	1	0	0	5
3	0	1	1	0	0	1	1	0	0	4
4	1	1	0	0	1	0	1	1	1	6
5	1	0	1	0	0	1	1	0	1	5
6	0	1	1	0	0	0	0	1	0	3
7	0	0	0	1	0	1	0	0	0	2
cs	4	5	5	1	2	4	4	2	3	
The advantage of the decrease in support of remaining features from HDBD due to the pruning of set of insignificant rows and the advantage of the decrease in cardinality of remaining rows from HDBD due to the pruning of set of insignificant features is not utilized by the existing FCCI mining algorithms. The proposed work prunes the set of insignificant features and set of insignificant rows consecutively, one after the other until all the remaining set of features and rows from HDBD are significant. The proposed work successfully utilizes the advantage of the decrease in support of remaining features from HDBD due to the pruning of set of insignificant rows and the advantage of the decrease in cardinality of remaining rows from HDBD due to the pruning of set of insignificant features. The proposed work utilizes both the advantages to prune the complete set of insignificant features and insignificant rows from HDBD. Table 6 shows the bitTable after pruning a complete set of insignificant features and insignificant rows by the proposed work. It is evident from Tables 4, 5, and 6 that the proposed work prunes complete set of insignificant features and insignificant rows from HDBD, which exponentially reduces the row enumerated mining search space. After pruning the complete set of insignificant gene features and gene rows, let the final set of significant gene rows be 
, final set of significant gene features be 
, 
 be the final number of gene rows and 
 be the final number of gene features.


Table 6. bitTable after pruning complete set of insignificant features and insignificant rows by the proposed work.

rsid	
rs
1	1	1	1	1	0	0	0	1	5
2	1	1	1	0	1	1	0	0	5
3	0	1	1	0	1	1	0	0	4
4	1	1	0	1	0	1	1	1	6
5	1	0	1	0	1	1	0	1	5
6	0	1	1	0	0	0	1	0	3
cs	4	5	5	2	3	4	2	3	

Download : Download high-res image (492KB)
Download : Download full-size image
Fig. 1. Bottom-up traversal of row enumerated tree.

It is very important to choose the efficient enumerationmethod to mine the FCCI from the HDBD. It is rational from the data characteristics of the HDBD to design an algorithm to efficiently traverse the row enumerated mining space rather than feature enumerated mining space. The decisive traversal method of row enumeration space is adapted to mine FCCI efficiently. Starting the traversal of the row enumerated tree from smaller rowset to the larger rowset is described as bottom-up traversal of row enumerated tree. The bottom-up traversal of the row enumerated tree indicates that the colossal itemsets are highly accessible at its foremost levels. This accomplishes that the bottom-up traversal of the row enumerated tree is efficient to mine the FCCI. The bottom-up row enumerated tree corresponding to Table 6 is described in Fig. 1. Each node represents the rowset with the corresponding bitset result mentioned under each node. The bitset result at row enumerated node helps to mine FCCI and is obtained by performing bitwise AND operation of bitset that corresponds to the rows in the rowset (node). The row enumerated mining search space is slashed with the help of anti-monotone property of mincard. This indicates that the descendant nodes of the rowset which do not mine the colossal itemset are pruned. For example, the rowset 134 do not mine the colossal itemset when the minsup is fixed to 2, and mincard is fixed to 2. Hence the descendant nodes of rowset 134 is slashed.


Table 7. Rowset cardinality table of 12, 13, 14 and 23.

(a) Rowset(13)	(b) Rowset(24)	(c) Rowset(25)	(d) Rowset(46)
rsid	rs	rsid	rs	rsid	rs	rsid	rs
2	2	1	2	1	2	1	1
4	1	3	2	3	3	2	1
5	1	5	2	4	2	3	1
6	2	6	1	6	1	5	0
(e) Rowset(124)	(f) Rowset(125)	(g) Rowset(234)	(h) Rowset(245)
rsid	rs	rsid	rs	rsid	rs	rsid	rs
3	1	3	1	1	1	1	1
5	1	4	1	5	1	3	1
6	1	6	1	6	1	6	1
The proposed Balanced Distributed Parallel Frequent Colossal Closed Itemset Mining (BDPFCCIM) algorithm is enclosed with efficient rowset closeness checking method and pruning strategy to slash the row enumeration search space. Rowset closeness checking method utilizes the updated cardinality at the respective rowset. The updated cardinality plays a vital role in checking the closeness of the rowset without referring to the earlier mined FCCI. At a rowset Y, the rs (cardinality) as shown in Table 6 is updated for the rsid(s) of the preprocessed bitTable, except for the rsid(s) occurring in the rowset. The cardinality is updated by considering the mined itemset cardinality at a rowset Y. If Z is the bitset result at rowset Y, then i(Z) provides the indexes of 1 occurring in Z. At rowset Y, the updated rs will be the number of 1’s from the respective rsid occurring at the indexes obtained from i(Z). The updated rs for nodes 13, 24, 25, 46, 124, 125, 234 and 245 is shown in Table 6.

At rowset 13, the rs is updated for the rsid(s) {2, 4, 5, 6} of the preprocessed bitTable, except for the rsid(s) {1, 3} occurring in rowset 13. The bitset result (Z  01100000) is obtained at rowset 13, i(01100000)  {2, 3} provides the indexes of 1 occurring in Z. The updated rs at rowset 13 as shown in Table 7a, will be the number of 1’s {2, 1, 1, 2} from the respective rsid(s) {2, 4, 5, 6} occurring at indexes obtained from i(Z)  {2, 3}. At rowset 124, the rs is updated for the rsid(s) {3, 5, 6} of the preprocessed bitTable, except for the rsid(s) {1, 2, 4} occurring in rowset 124. The bitset result (Z  11000000) is obtained at rowset 124, i(11000000)  {1, 2} provides the indexes of 1 occurring in Z. The updated rs at rowset 124 as shown in Table 7e, will be number of 1’s {1, 1, 1} from respective rsid(s) {3, 5, 6} occurring at indexes obtained from i(Z)  {1, 2}.

4.1. Closeness checking method
The itemset X mined at a rowset in closed if and only if the rowset is also closed. The rowset closeness checking is performed with the help of updated rs at that particular rowset. The closure property explained in Definition 1 (Eqs. (1), (2)) and Example 1 (Eqs. (3), (4)) highlights that the closure of rowset Y indicates that Y  gr(X). Hence, the rowset is closed if and only if the updated rs of rsid(s) is less than the cardinality of the bitset result obtained at that particular rowset. The rowset 24 is closed because the updated rs {2, 2, 2, 1} of respective rsid(s) {1, 3, 5, 6} is less than the cardinality of bitset result (11000100). The rowset 46 is closed because the updated rs {1, 1, 1, 0} of respective rsid(s) {1, 2, 3, 5} is less than the cardinality of bitset result (01000010).

4.2. Pruning strategy
The pruning strategy enclosed in the proposed BDPFCCIM algorithm utilizes the updated rs at the rowset to efficiently slash the row enumeration mining space. The updated rs provides the cardinality information of the itemsets to be mined from the descendant nodes of a rowset. This cardinality information acts as prior information to slash the row enumeration space, while the existing FCCI mining algorithms do not enjoy the benefit of cardinality information in prior. The itemset cardinality information about the nodes 134, 135, and 136 is provided by the updated rs at rowset 13 as shown in Table 7a. For example, the updated rs of rsid 4 and rsid 5 as shown in Table 7a is less than mincard when the mincard is set to 2. This indicates that the nodes 134, 1345, 13456, 1346, 135 and 1356 do not contribute for the generation of colossal itemsets. Hence these descendant nodes will be pruned.

4.3. The proposed algorithm
The data characteristics of the HDBD is the reason to choose a row enumerated mining space to mine FCCI. Fig. 1 highlights that the intrinsic nature of the row enumerated tree is unbalanced. The number of row enumerated nodes that needs to be traversed without any pruning of row enumerated mining space with respect to mincard is shown in Fig. 1 and it is clear that the number nodes in each tree branch vary. Fig. 2a shows the number of nodes generated in each branch of row enumerated tree when 
 is 6 and Fig. 2b shows the number of nodes generated in each branch of the generalized row enumerated tree. It is very important to properly distribute the branches of row enumerated tree among the compute nodes to mine the FCCI. The load of traversing the branches of row enumerated tree among the compute nodes should be balanced. (9)
 (10)

Eq. (9) shows that the number of nodes generated from the first branch (rowset 1) of the row enumerated tree will be more than the collective number of nodes generated from second branch (rowset 2) to last branch (rowset 6) of the row enumerated tree. Eq. (10) shows that the number of nodes generated from the second branch (rowset 2) of the row enumerated tree is more than the collective number of nodes generated from third (rowset 3) to the last branch (rowset 6) of the row enumerated tree. Let ‘C’ be the number of compute nodes available. The job of traversal of first branch (rowset 1) of row enumerated tree will be distributed to ‘C/2’ number of compute nodes and remaining ‘C/2’ number of nodes will be assigned the job of traversal of second branch (rowset 2) to last branch (rowset n) of the row enumerated tree. For example, if number of compute nodes available are 2 as shown in Fig. 3, then the number of compute nodes assigned to traverse the first branch (rowset 1) of row enumerated tree will be 1 and the number nodes assigned to traverse the second branch (rowset 2) to last branch (rowset 6) of row enumerated tree will be 1.


Download : Download high-res image (414KB)
Download : Download full-size image

Download : Download high-res image (190KB)
Download : Download full-size image
Fig. 2. Number of nodes generated in each branch of row enumerated tree.

The branch distribution of row enumerated tree is shown in Fig. 4, when the available number of compute nodes are 4. Fig. 4 highlights that the first branch (rowset 1) of the row enumerated tree is distributed to two compute nodes and a second branch (rowset 2) to the last branch (rowset 6) of the row enumerated tree is distributed to two computing nodes. The traversal of the first branch (rowset 1) of the row enumerated tree should be scheduled among the two assigned compute nodes with load balancing. The number of nodes generated by the first branch (rowset 12) of the rowset 1 will be more than the collective number of nodes generated from the second branch (rowset 13) to last branch (rowset 16) of the rowset 1. The load of traversing the branches should be balanced among the two assigned compute nodes. To balance the load among the compute nodes, the number of compute nodes assigned to traverse the first branch (rowset 12) of the rowset 1 will be one and number of compute nodes assigned to traverse the remaining branches (rowset 13 to rowset 16 of the rowset 1) will be one as shown in Fig. 4. The traversal of the second branch (rowset 2) to the last branch (rowset 6) of the row enumerated tree should be scheduled among the two assigned compute nodes with load balancing. The number of nodes generated from the second branch (rowset 2) of the row enumerated tree is more than the collective number of nodes generated from third branch (rowset 3) to the last branch (rowset 6) of the row enumerated tree. The load of traversing the branches should be balanced among the two assigned compute nodes. To balance the load among the compute nodes, the number of compute nodes assigned to traverse the second branch (rowset 2) of the row enumerated tree will be one and number of compute nodes assigned to traverse the remaining branches (rowset 3 to rowset 6 of the row enumerated tree) will be one as shown in Fig. 4. The branches of the row enumerated tree assigned to the compute nodes are traversed using the parallel bottom-up approach as shown in Fig. 3, Fig. 4. The branches of the row enumerated tree assigned to the compute nodes are traversed parallelly by the team of threads forked by the master thread.


Download : Download high-res image (207KB)
Download : Download full-size image

Download : Download high-res image (471KB)
Download : Download full-size image
Fig. 3. The branch distribution of row enumerated tree, when the available number of compute nodes are 2.


Download : Download high-res image (598KB)
Download : Download full-size image
Fig. 4. The branch distribution of row enumerated tree, when the available number of compute nodes are 4.

Algorithm 1 shows the proposed Balanced Distributed Parallel Frequent Colossal Closed Itemset Mining (BDPFCCIM) algorithm. The rowset closeness checking method and an efficient pruning strategy are enclosed in BDPFCCIM procedure as shown in Procedure 1. The proposed BDPFCCIM algorithm distributes the branches of the row enumerated tree between the compute nodes with load balancing and then traverses the scheduled branches parallelly to mine the FCCI. The proposed algorithm is the first balanced distributed parallel algorithm for HDBD. The input for the proposed BDPFCCIM algorithm is the High Dimensional Biological Dataset HDBD, mincard, minsup. The mined FCCI from the HDBD is the output provided by the proposed algorithm. The initial part of the algorithm preprocesses the HDBD by pruning the insignificant features and insignificant rows until the remaining features and rows satisfy the criteria minsup and mincard respectively. 
 and 
 are the final set of significant gene features and rows respectively, 
 and 
 are the final number of gene features and rows respectively. The distributed approach of the proposed BDPFCCIM algorithm is achieved by using Message Passing Interface (MPI), the standardized message passing library and parallel approach of the proposed BDPFCCIM algorithms is achieved by using the Open Multi-Processing (OpenMP) application programming interface.

The proposed BDPFCCIM algorithm initializes the MPI environment. The MPI communicator helps in identifying the number of compute nodes. Each node has a unique rank associated with the communicator, numbered from 0 to (n  1). The MPI communicator also helps in knowing the identity of the sender and receiver. The scheduling of branch traversal of the row enumerated tree between the compute nodes with load balancing is done by the master node. The master node sends rsid(s) to the respective compute nodes. The compute node receives the respective rsid(s) to be enumerated from the master node. Let rsidcomb be the initial row to be enumerated. The compute nodes traverse the scheduled branch of the row enumerated tree parallelly by the team of threads forked by the master thread. The procedure 1 highlighting the BDPFCCIM procedure is parallelly invoked by the team of threads. The BDPFCCIM procedure is enclosed with an efficient pruning strategy which utilizes the updated rs at the rowset to slash the row enumerated mining search space and an efficient closeness checking method to check the closeness of the rowset without accessing the previously mined FCCI.

5. Results and discussions
The results and discussion section emphasizes on the efficiency and speedup of the proposed BDPFCCIM algorithm. The results were noted by conducting the experiments in a cluster consisting of a master node and compute nodes. The master node and compute nodes have an Intel Xeon Phi processor with 128 GB of RAM. The DisClose algorithm is chosen as representative for the experimental evaluation and the proposed BDPFCCIM algorithm is compared with it, as DisClose algorithm outperforms other existing frequent colossal closed itemset mining algorithms with respect to runtime. The failure to mine the entire set of FCCI from HDBD by the BVBUC and Pattern Fusion algorithm is one of the reasons to not consider both the algorithm for the runtime comparison with the proposed BDPFCCIM algorithm. The support information of most of the FCCI mined from HDBD by the BVBUC algorithm is wrong and an another reason to not consider BVBUC algorithm for the runtime comparison with the proposed BDPFCCIM algorithm. Frequent colossal itemsets from the HDBD are mined by the CP-Miner and PCP-Miner algorithm; these two algorithms are not designed to mine the FCCI from HDBD. Hence CP-Miner and PCP-Miner are not considered for the runtime comparison with the proposed BDPFCCIM algorithm. The DisClose algorithm and the proposed BDPFCCIM algorithm were implemented in C++. The distributed approach of the proposed BDPFCCIM algorithm is achieved by using Message Passing Interface (MPI), the standardized message passing library and parallel approach of the proposed BDPFCCIM algorithms is achieved by using the Open Multi-Processing (OpenMP) application programming interface. The proposed BDPFCCIM algorithm is the first distributed parallel algorithm to mine FCCI from HDBD with load balancing.

Three real datasets were considered for the experimental evaluation: Mixed Lineage Leukemia (MLL), Diffuse Large B-Cell Lymphoma (DLBCL) and Central Nervous System embryonal tumor [7]. The data characteristics of the MLL dataset are 72 samples (rows) and 12 582 gene features. The data characteristics of the DLBCL are 77 samples (rows) and 7129 gene features. The data characteristics of the Central Nervous System embryonal tumor are 60 samples and 7129 gene features. Fig. 5, Fig. 6, Fig. 7 represent the runtime comparison between the DisClose algorithm and the proposed BDPFCCIM algorithm with a number of compute nodes set to 2 and number of threads forked from the master thread set to 2 for MLL, DLBCL, and Central Nervous System embryonal tumor datasets respectively. Fig. 8, Fig. 9, Fig. 10 represent the runtime comparison between the proposed BDPFCCIM (2 threads), BDPFCCIM (4 threads) and BDPFCCIM (8 threads) with a number of compute nodes set to 2 for MLL, DLBCL, and Central Nervous System embryonal tumor datasets respectively.


Download : Download high-res image (229KB)
Download : Download full-size image
Fig. 5. Runtime of BDPFCCIM (2 Compute Nodes) (2 threads) and DisClose for MLL dataset.


Download : Download high-res image (223KB)
Download : Download full-size image
Fig. 6. Runtime of BDPFCCIM (2 Compute Nodes) (2 threads) and DisClose for DLBCL dataset.


Download : Download high-res image (213KB)
Download : Download full-size image
Fig. 7. Runtime of BDPFCCIM (2 Compute Nodes) (2 threads) and DisClose for CNS dataset.

Fig. 11, Fig. 12, Fig. 13 represent the runtime comparison between the DisClose algorithm and the proposed BDPFCCIM algorithm with a number of compute nodes set to 4 and number of threads forked from the master thread set to 2 for MLL, DLBCL, and Central Nervous System embryonal tumor datasets respectively. Fig. 14, Fig. 15, Fig. 16 represent the runtime comparison between the proposed BDPFCCIM (2 threads), BDPFCCIM (4 threads) and BDPFCCIM (8 threads) with a number of compute nodes set to 4 for MLL, DLBCL, and Central Nervous System embryonal tumor datasets respectively. Fig. 17, Fig. 18, Fig. 19 represent the runtime comparison between the DisClose algorithm and the proposed BDPFCCIM algorithm with a number of compute nodes set to 8 and number of threads forked from the master thread set to 2 for MLL, DLBCL, and Central Nervous System embryonal tumor datasets respectively. Fig. 20, Fig. 21, Fig. 22 represent the runtime comparison between the proposed BDPFCCIM (2 threads), BDPFCCIM (4 threads) and BDPFCCIM (8 threads) with a number of compute nodes set to 8. The runtime in Fig. 5, Fig. 6, Fig. 7, Fig. 8, Fig. 9, Fig. 10, Fig. 11, Fig. 12, Fig. 13, Fig. 14, Fig. 15, Fig. 16, Fig. 17, Fig. 18, Fig. 19, Fig. 20, Fig. 21, Fig. 22, has been recorded for different values of minsup and mincard. The varying mincard represents the x-axes, and the runtime represents the y-axes in Fig. 5, Fig. 6, Fig. 7, Fig. 8, Fig. 9, Fig. 10, Fig. 11, Fig. 12, Fig. 13, Fig. 14, Fig. 15, Fig. 16, Fig. 17, Fig. 18, Fig. 19, Fig. 20, Fig. 21, Fig. 22. It is observed from the experimental results that the runtime of the proposed BDPFCCIM algorithm reduces as the mincard and minsup increases. The experimental results as shown in Fig. 5, Fig. 6, Fig. 7, Fig. 8, Fig. 9, Fig. 10, Fig. 11, Fig. 12, Fig. 13, Fig. 14, Fig. 15, Fig. 16, Fig. 17, Fig. 18, Fig. 19, Fig. 20, Fig. 21, Fig. 22 indicate that the proposed BDPFCCIM algorithm is not obligatory to gauge the final results when the number of significant gene features and significant rows are zero after the complete pruning of insignificant gene features and insignificant rows for given HDBD, minsup, and mincard.


Download : Download high-res image (276KB)
Download : Download full-size image
Fig. 8. Runtime of BDPFCCIM (2 Compute Nodes) (2 threads), BDPFCCIM (2 Compute Nodes) (4 threads) and BDPFCCIM (2 Compute Nodes) (8 threads) for MLL dataset.


Download : Download high-res image (268KB)
Download : Download full-size image
Fig. 9. Runtime of BDPFCCIM (2 Compute Nodes) (2 threads), BDPFCCIM (2 Compute Nodes) (4 threads) and BDPFCCIM (2 Compute Nodes) (8 threads) for DLBCL dataset.


Download : Download high-res image (261KB)
Download : Download full-size image
Fig. 10. Runtime of BDPFCCIM (2 Compute Nodes) (2 threads), BDPFCCIM (2 Compute Nodes) (4 threads) and BDPFCCIM (2 Compute Nodes) (8 threads) for CNS dataset.


Download : Download high-res image (227KB)
Download : Download full-size image
Fig. 11. Runtime of BDPFCCIM (4 Compute Nodes) (2 threads) and DisClose for MLL dataset.


Download : Download high-res image (221KB)
Download : Download full-size image
Fig. 12. Runtime of BDPFCCIM (4 Compute Nodes) (2 threads) and DisClose for DLBCL dataset.


Download : Download high-res image (210KB)
Download : Download full-size image
Fig. 13. Runtime of BDPFCCIM (4 Compute Nodes) (2 threads) and DisClose for CNS dataset.


Download : Download high-res image (274KB)
Download : Download full-size image
Fig. 14. Runtime of BDPFCCIM (4 Compute Nodes) (2 threads), BDPFCCIM (4 Compute Nodes) (4 threads) and BDPFCCIM (4 Compute Nodes) (8 threads) for MLL dataset.


Download : Download high-res image (269KB)
Download : Download full-size image
Fig. 15. Runtime of BDPFCCIM (4 Compute Nodes) (2 threads), BDPFCCIM (4 Compute Nodes) (4 threads) and BDPFCCIM (4 Compute Nodes) (8 threads) for DLBCL dataset.


Download : Download high-res image (256KB)
Download : Download full-size image
Fig. 16. Runtime of BDPFCCIM (4 Compute Nodes) (2 threads), BDPFCCIM (4 Compute Nodes) (4 threads) and BDPFCCIM (4 Compute Nodes) (8 threads) for CNS dataset.


Download : Download high-res image (226KB)
Download : Download full-size image
Fig. 17. Runtime of BDPFCCIM (8 Compute Nodes) (2 threads) and DisClose for MLL dataset.


Download : Download high-res image (221KB)
Download : Download full-size image
Fig. 18. Runtime of BDPFCCIM (8 Compute Nodes) (2 threads) and DisClose for DLBCL dataset.


Download : Download high-res image (210KB)
Download : Download full-size image
Fig. 19. Runtime of BDPFCCIM (8 Compute Nodes) (2 threads) and DisClose for CNS dataset.


Download : Download high-res image (270KB)
Download : Download full-size image
Fig. 20. Runtime of BDPFCCIM (8 Compute Nodes) (2 threads), BDPFCCIM (8 Compute Nodes) (4 threads) and BDPFCCIM (8 Compute Nodes) (8 threads) for MLL dataset.


Download : Download high-res image (272KB)
Download : Download full-size image
Fig. 21. Runtime of BDPFCCIM (8 Compute Nodes) (2 threads), BDPFCCIM (8 Compute Nodes) (8 threads) and BDPFCCIM (8 Compute Nodes) (8 threads) for DLBCL dataset.


Download : Download high-res image (254KB)
Download : Download full-size image
Fig. 22. Runtime of BDPFCCIM (8 Compute Nodes) (2 threads), BDPFCCIM (8 Compute Nodes) (4 threads) and BDPFCCIM (8 Compute Nodes) (8 threads) for CNS dataset.


Download : Download high-res image (232KB)
Download : Download full-size image
Fig. 23. Speedup of BDPFCCIM (2 Compute Nodes) (2 threads), BDPFCCIM (2 Compute Nodes) (4 threads) and BDPFCCIM (2 Compute Nodes) (8 threads) with respect to DisClose algorithm for MLL dataset.


Download : Download high-res image (206KB)
Download : Download full-size image
Fig. 24. Speedup of BDPFCCIM (2 Compute Nodes) (2 threads), BDPFCCIM (2 Compute Nodes) (4 threads) and BDPFCCIM (2 Compute Nodes) (8 threads) with respect to DisClose algorithm for DLBCL dataset.


Download : Download high-res image (201KB)
Download : Download full-size image
Fig. 25. Speedup of BDPFCCIM (2 Compute Nodes) (2 threads), BDPFCCIM (2 Compute Nodes) (4 threads) and BDPFCCIM (2 Compute Nodes) (8 threads) with respect to DisClose algorithm for CNS dataset.


Download : Download high-res image (232KB)
Download : Download full-size image
Fig. 26. Speedup of BDPFCCIM (4 Compute Nodes) (2 threads), BDPFCCIM (4 Compute Nodes) (4 threads) and BDPFCCIM (4 Compute Nodes) (8 threads) with respect to DisClose algorithm for MLL dataset.


Download : Download high-res image (209KB)
Download : Download full-size image
Fig. 27. Speedup of BDPFCCIM (4 Compute Nodes) (2 threads), BDPFCCIM (4 Compute Nodes) (4 threads) and BDPFCCIM (4 Compute Nodes) (8 threads) with respect to DisClose algorithm for DLBCL dataset.


Download : Download high-res image (209KB)
Download : Download full-size image
Fig. 28. Speedup of BDPFCCIM (4 Compute Nodes) (2 threads), BDPFCCIM (4 Compute Nodes) (4 threads) and BDPFCCIM (4 Compute Nodes) (8 threads) with respect to DisClose algorithm for CNS dataset.


Download : Download high-res image (230KB)
Download : Download full-size image
Fig. 29. Speedup of BDPFCCIM (8 Compute Nodes) (2 threads), BDPFCCIM (8 Compute Nodes) (4 threads) and BDPFCCIM (8 Compute Nodes) (8 threads) with respect to DisClose algorithm for MLL dataset.


Download : Download high-res image (209KB)
Download : Download full-size image
Fig. 30. Speedup of BDPFCCIM (8 Compute Nodes) (2 threads), BDPFCCIM (8 Compute Nodes) (4 threads) and BDPFCCIM (8 Compute Nodes) (8 threads) with respect to DisClose algorithm for DLBCL dataset.


Download : Download high-res image (210KB)
Download : Download full-size image
Fig. 31. Speedup of BDPFCCIM (8 Compute Nodes) (2 threads), BDPFCCIM (8 Compute Nodes) (4 threads) and BDPFCCIM (8 Compute Nodes) (8 threads) with respect to DisClose algorithm for CNS dataset.

Fig. 5, Fig. 11, Fig. 17 show that the gauging of the final FCCI mining result by the proposed BDPFCCIM is not required for MLL datasets with the minsup set to 15 and mincard set 3500. This indicates that the number of significant rows is zero after the preprocessing (pruning of complete set of insignificant gene features and insignificant rows) of MLL dataset and also indicates that the runtime of the proposed BDPFCCIM algorithm is zero. Similarly, Fig. 6, Fig. 12, Fig. 18 highlight that the runtime of the proposed BDPFCCIM algorithm is zero for DLBCL dataset when minsup reaches 15 and mincard reaches 2500. Similarly, Fig. 7, Fig. 13, Fig. 19 highlight that the runtime of the proposed BDPFCCIM algorithm is zero for Central Nervous System embryonal tumor dataset when minsup reaches 10 and mincard reaches 2500. It is observed from the experimental results that the proposed BDPFCCIM algorithm outperforms the DisClose algorithm. This also illustrates the efficiency of the rowset closeness checking method and pruning strategy enclosed with the proposed BDPFCCIM algorithm. The complete pruning of the insignificant gene features and insignificant rows, efficient rowset closeness checking method and efficient pruning strategy provide a major boost to the proposed BDPFCCIM algorithm. The experimental results as shown in Fig. 5, Fig. 6, Fig. 7, Fig. 8, Fig. 9, Fig. 10, Fig. 11, Fig. 12, Fig. 13, Fig. 14, Fig. 15, Fig. 16, Fig. 17, Fig. 18, Fig. 19, Fig. 20, Fig. 21, Fig. 22 indicate that for different values minsup and mincard, the proposed BDPFCCIM (8 compute nodes) outperforms BDPFCCIM (4 compute nodes) and BDPFCCIM (2 compute nodes). It is also observed that for different values of minsup and mincard, the proposed BDPFCCIM (8 threads) outperforms BDPFCCIM (4 threads) and BDPFCCIM (2 threads).

Fig. 23, Fig. 24, Fig. 25 represent the speed-up of the proposed BDPFCCIM (2 compute nodes) (2 threads), BDPFCCIM (2 compute nodes) (4 threads) and BDPFCCIM (2 compute nodes) (8 threads) with respect to the DisClose algorithm for MLL, DLBCL, and Central Nervous System embryonal tumor datasets respectively. Fig. 26, Fig. 27, Fig. 28 represent the speed-up of the proposed BDPFCCIM (4 compute nodes) (2 threads), BDPFCCIM (4 compute nodes) (4 threads) and BDPFCCIM (4 compute nodes) (8 threads) with respect to the DisClose algorithm for MLL, DLBCL, and Central Nervous System embryonal tumor datasets respectively. Fig. 29, Fig. 30, Fig. 31 represent the speed-up of the proposed BDPFCCIM (8 compute nodes) (2 threads), BDPFCCIM (8 compute nodes) (4 threads) and BDPFCCIM (8 compute nodes) (8 threads) with respect to the DisClose algorithm for MLL, DLBCL, and Central Nervous System embryonal tumor datasets respectively. The speedup in Fig. 23, Fig. 24, Fig. 25, Fig. 26, Fig. 27, Fig. 28, Fig. 29, Fig. 30, Fig. 31, has been recorded for different values of minsup and mincard. The varying mincard represents the x-axes, and the speedup represents the y-axes in Fig. 23, Fig. 24, Fig. 25, Fig. 26, Fig. 27, Fig. 28, Fig. 29, Fig. 30, Fig. 31. Fig. 23 shows that the gauging of the final FCCI mining result by the proposed BDPFCCIM is not required for MLL datasets with the minsup set to 15 and mincard set 3500. This indicates that the number of significant rows is zero after the preprocessing (pruning of complete set of insignificant gene features and insignificant rows) of MLL dataset and also indicates that there is no speed-up factor. There is no speed-up factor when minsup reaches 15 and mincard reaches 2500 for DLBCL dataset as shown in Fig. 24. There is no speed-up factor when minsup reaches 10 and mincard reaches 2500 for Central Nervous System embryonal tumor dataset as shown in Fig. 25. The speed-up factor as shown in Fig. 23, Fig. 24, Fig. 25, Fig. 26, Fig. 27, Fig. 28, Fig. 29, Fig. 30, Fig. 31 indicates the proposed BDPFCCIM (8 compute nodes) outperforms BDPFCCIM (4 compute nodes) and BDPFCCIM (2 compute nodes). The branch distribution of the row enumerated tree as shown in Figs. 3, 4 and the speed-up factor of the proposed algorithm for three different high dimensional dataset as shown in Fig. 23, Fig. 24, Fig. 25, Fig. 26, Fig. 27, Fig. 28, Fig. 29, Fig. 30, Fig. 31 indicate that the data scalability and node scalability have been accomplished.

6. Conclusion and future work
The traditional algorithms expend a huge amount of time in an expansive set of the short and average sized itemset. These itemsets do not confine the complete and valuable information. Colossal itemsets are significant and very important for numerous applications, as these itemsets are influential during the decision making. The elimination of a complete set of insignificant features and insignificant rows plays a vital role in reducing the traversal of insignificant row enumerated mining search space. The experimental result highlights the efficiency of proposed BDPFCCIM in comparison with the state-of-the-art algorithm in mining FCCI from HDBD. The rowset closeness checking method and the pruning strategy enclosed with proposed BDPFCCIM algorithm plays a major role in increasing the efficiency of the algorithm. The proposed BDPFCCIM algorithm distributes the branches of the row enumerated tree between the compute nodes with load balancing and then traverses the scheduled branches parallelly to mine the FCCI. The proposed BDPFCCIM algorithm has achieved a maximum speedup of 19 when the number of compute nodes is set to 8 and the number of threads forked from the master thread is 8. The data characteristics of HDBD with an extensive number of gene features and an extensive number of rows require a hybrid enumeration method to mine FCCI efficiently. Hence, the future work concentrates on designing the balanced hybrid distributed parallel FCCI mining algorithm.