Abstract
With the increasing popularity of data sharing among users of a group in clouds, shared data auditing has become an important issue in the cloud auditing field. To address this issue, many shared data auditing schemes have been proposed in the literature based on either public key infrastructure (PKI) or identity-based cryptography (IBC). However, these schemes suffer from issues of complex certificate management or key escrow problem. To address these problems, recently, a certificateless shared auditing scheme was put forward. However, it cannot support data dynamics and does not protect data privacy against a verifier, i.e., the verifier can derive data content when verifying the data integrity, which affects the scheme's security. This paper proposes certificateless privacy preserving public auditing scheme for dynamic shared data with group user revocation in cloud storage (CLPPPA). CLPPPA protects the privacy of data from the verifier by leveraging a random masking technique. Further, CLPPPA also supports shared data dynamics and group user revocation. We formally prove the security of CLPPPA under computational Diffie-Hellman (CDH) and discrete logarithm (DL) assumptions in the Random Oracle Model (ROM). The performance of CLPPPA is evaluated by theoretical analysis, experimental results, and compared with the state-of-the-art ones. The results demonstrate that CLPPPA achieves desirable efficiency.

Keywords
Shared data
Privacy preserving
Certificateless signatures
Cloud storage
Data dynamics


1. Introduction
With the explosive growth of data in today's world and the advancement of Internet technology, cloud storage services (Amazon S3, Microsoft Azure, Apple iCloud, Google App Engine) have become common to provide necessary storage resources on demand without human interaction. As a result, a large number of individuals, communities, enterprises, and public organizations have been moving their data from local storage systems to the cloud for reducing capital and management costs [19]. Also, the cloud makes it easier for cloud users to form the group to store and share their data in the cloud. While cloud storage benefits are clear, it also faces several concerns. The primary concern is the integrity of stored data [11] since the user loses control over their data and the cloud service provider (CSP) is not fully trusted. Therefore, it is highly desirable for the user to ensure the integrity of the data in the cloud [7], [37].

Traditional methods to verify the integrity of the data, such as hash values or digital signatures for entire data, require retrieving the whole data from the cloud. Certainly, this simple approach can successfully check the correctness of cloud data. However, downloading the entire cloud data is not economical because it incurs unacceptable communication costs and may waste users' resources, particularly when data have been corrupted in the cloud. In the cloud computing scenario, the user wants to check data integrity without downloading complete data.

To check the integrity of the outsourced data, several schemes [2], [3], [5], [6], [8], [9], [12], [13], [14], [16], [17], [18], [22], [23], [24], [26], [27], [28], [29], [30], [31], [32], [33], [34], [35], [36], [38], [39], [40], [41], [42], [43] have been proposed in the literature. However, most of these schemes [2], [3], [5], [12], [13], [16], [17], [22], [23], [26], [31], [32], [33], [34], [38], [39], [42], [43] only focus on checking the integrity for personal data, which are not suitable for shared data auditing. In a shared data scenario, a user in a group uploads data to the cloud, and the rest of the group users not only access but also modify the data. When data is shared among multiple users, some new challenges will arise that must be addressed. For example, different blocks may be signed by different users in shared data due to data modifications performed by different users, even if the block is the same. It brings great complexity for checking the integrity of the data. Furthermore, the size of the group is dynamic, i.e., any group member may leave or join the group at any time, so the user revocation is also a significant problem. Specifically, once a user in the group is revoked, he should not be allowed to access or modify the data, and all his pair of public and private keys are to be made invalid, and other existing valid user should resign all the signatures produced by the revoked user. The traditional method for user revocation is to download the blocks signed by a revoked user from the CSP, calculate the new tags, and upload the new tags to the cloud again. It will increase heavy computation and communication cost for a normal user. Therefore, this task should be performed by the cloud server (CS) in a cloud environment rather than the normal user. To address these problems, lots of shared data auditing schemes [6], [9], [18], [24], [27], [29], [30], [35], [36], [40], [41] have been proposed. However, these schemes have the problem of either complex certificate management or key escrow, as they were designed based on PKI or IBC. To avoid these problems in the schemes mentioned above [6], [9], [18], [24], [27], [29], [30], [35], [36], [40], [41], certificateless public auditing schemes [8], [28] are proposed based on certificateless public key cryptography (CL-PKC). However, these schemes also deal with integrity of personal data like [2], [3], [5], [12], [13], [16], [17], [22], [23], [26], [31], [32], [33], [34], [38], [39], [42], [43]. Li et al. [14] proposed certificateless public shared data auditing scheme with user revocation support. However, this scheme does not support data privacy against verifier during auditing process i.e., the linear combination of blocks may potentially reveal the user data contents to verifier and violates the privacy-preserving guarantee. Moreover, this scheme does not support dynamic data updates for shared data, which is also of paramount importance when users frequently updates the data for various application purposes. Hence, designing a secure shared data auditing scheme while supporting data privacy and data dynamics along with the group user revocation remains a significant challenge.

1.1. Contributions
Motivated by the requirements mentioned above of shared data, in this paper, we propose a certificateless privacy-preserving public auditing scheme for dynamic shared data with group user revocation in cloud storage (CLPPPA). To the best of our knowledge, CLPPPA is the first to achieve shared data integrity auditing while supporting privacy-preserving, data dynamics, and user revocation using certificateless signatures. The main contributions are:

1.
In this scheme, we leverage certificateless signatures to generate signatures of file blocks, that can simplify certificate management and eliminates key escrow problem.

2.
CLPPPA achieves data privacy against verifier through random masking technique to blind the data proof during auditing.

3.
We extend double linked list information table (DLIT) to support shared data dynamics such as insertion, modification, and deletion.

4.
In CLPPPA, we let the cloud server perform the resigning on behalf of the group user whenever a user misbehaves or quits the group.

5.
The security analysis proves the correctness, unforgeability, and privacy of CLPPPA based on DL and CDH assumptions in ROM. We also provide a security comparison with some of the existing schemes.

6.
The performance analysis evaluates the performance of CLPPPA theoretically and experimentally in terms of computation overheads.

1.2. Organization
The remainder of the paper is organized as follows. Section 2 presents related work. Preliminaries are given in Section 3. Section 4 defines the system model. Section 5 offers the construction. Section 6 states the security analysis. Section 7 provides a performance analysis for our scheme. Finally, Section 8 presents the conclusion and future work.

2. Related work
To check the integrity of data in cloud storage, in 2007, Ateniese et al. [2] first proposed Provable Data Possession (PDP) without downloading the entire file using RSA-based homomorphic verifiable tags and random sampling of blocks. In this scheme, the user generates the optimal metadata for the file, stores the constant metadata with the verifier for future verification purposes, and then uploads the file and the metadata to the CSP. Finally, deletes the original file at the local site to save the storage space. Later, the integrity of the data is verified in challenge-proof-verify mode. Based on PDP, many public auditing protocols have been proposed to support data updates [3], [5], [12], [17], [22], [26], [32], [38], [42] and to support data privacy [13], [16], [23], [31], [33], [34], [39], [43]. However, all these protocols [3], [5], [12], [13], [16], [17], [22], [23], [26], [31], [32], [33], [34], [38], [39], [42], [43] deal with integrity of personal data, which are not suitable under the situation of data shared in a group. To deal with the shared data auditing, a lot of schemes [6], [9], [18], [27], [29], [30], [35], [40] have been proposed. Initially, to guarantee the integrity of shared data, Wang et al. [29] proposed a public auditing scheme using homomorphic authenticable ring signature to protect users' privacy the group. In shared data auditing schemes, one of the users in the group computes signatures for the shared file and uploads the file along with the signatures to the cloud. Later, Third Party Auditor (TPA) performs auditing of outsourced shared data to ensure the data correctness on behalf of group user. Since then, many shared data auditing schemes [6], [9], [18], [27], [30], [35], [40] have been proposed in the literature. To support a dynamic group, subsequently, Wang et al. [30] designed a scheme named Panda by utilizing proxy re-signatures with user revocation. However, it has a security flaw since the resigning keys of users are stored with proxy in advance, which causes collusion attack from revoked user or CSP. To address this problem, Yuan et al. [40] designed a public auditing scheme by employing polynomial authentication tags. However, it suffers from replay and replace attacks. Later, Jiang et al. [9] adopted the vector commitment technique, and the verifier removed the illegal group members. However, it suffers from collusion attack. Fu et al. [6] proposed a privacy-aware shared data integrity auditing scheme by exploiting a homomorphic verifiable group signature. Similarly, Luo et al. [18] constructed a system for shared data to support revocation by utilizing the Shamir secret sharing technique. Moving forward, L Wu et al. [35] proposed a scheme by employing group signatures. It provides user identity privacy and data privacy by using the random masking technique. Recently, H Tian et al. [27] proposed a scheme to achieve identity privacy, data privacy and extended the dynamic hash table (DHT) to support data updates at any time. However, the schemes mentioned above [6], [9], [18], [27], [29], [30], [35], [40] suffering from the problem of complex certificate management because they are designed based on Public Key Infrastructure (PKI) in which a Certificate Authority (CA) issue a certificate to bind a user with his corresponding public key.

To simplify certificate management, identity based (ID-based) protocols [24], [36], [41] have been proposed based on IBC [21]. In these schemes, keys are generated by a private key generator (PKG) based on the user's identity, which simplifies certificate management by binding the users' identity with the secret key. Yang et al. [36] described a scheme using blind signatures and achieved identity traceability. Zhang et al. [41] presented remote auditing of big data with user revocation by employing ID-based signatures. In this scheme, they update the private keys of existing authorized users instead of updating the signatures of revoked users during revocation. However, the limitation of its application is that all users in the group have the same private key and same public key. Similarly, Shen et al. [24] proposed a mechanism with sensitive information hiding by employing ID-based signatures. In this scheme, a special file called a disinfectant file is created to hide the file's signature information of sensitive blocks. However, all these schemes suffer from key escrow problem, i.e., PKG can initiate impersonation attacks which results in forgery of the user's signatures to pass the verification successfully because the PKG generates full private key of the user and holds the private key.

To get rid of key escrow problem in ID-based schemes mentioned above, unlike [24], [36], [41], the key generation center (KGC) in the proposed scheme, chooses a random value 
⁎
 as its private key and generates 
 as its public key. Upon receiving identity (ID) from the user, the KGC generates the partial private key 
 and sends it to the user through a secure channel. After receiving the partial private key (D), user computes the full private key , where x (
⁎
) is a secret value chosen by herself/himself. This approach solves the key escrow problem by restricting the KGC to generate only the partial private key rather than the full private key. Therefore, the KGC cannot forge the user signature by any means. Based on this notion, Wang et al. [28] first proposed a certificateless provable data possession (CLPDP) scheme and a security model. However, He et al. [8], who pointed out that Wang et al.'s [28] scheme was not secure against the type I adversary and suggested a CLPDP scheme for cloud-assisted wireless body area networks to enhance security. Unfortunately, both the schemes [8], [28] cannot preserve privacy and focused on personal data auditing. Hence, not suitable for shared data auditing. Later, Li et al. [14] introduced a certificateless public auditing scheme for shared data to achieve the shared data integrity along with user revocation in the cloud. However, this scheme does not support shared data dynamics and does not support security property such as privacy preserving, which are necessary demands for shared data auditing.

A brief comparison of some of the existing shared data integrity auditing schemes and the proposed scheme is presented in Table 1 with respect to various functional features.


Table 1. Functionality comparison of different shared data auditing schemes.

Features	PKI based schemes	ID based schemes	CL based schemes
[6]	[18]	[27]	[36]	[41]	[24]	[14]	Ours
Public auditing	✓	✓	✓	✓	✓	✓	✓	✓
Integrity	✓	✓	✓	✓	✓	✓	✓	✓
Revocation	✓	✓	✓	✓	✓	✓	✓	✓
Data privacy	✗	✗	✓	✗	✗	✗	✗	✓
Data dynamics	✗	✓	✓	✗	✗	✗	✗	✓
Certificate management simplification	✗	✗	✗	✓	✓	✓	✓	✓
Free from key escrow	✗	✗	✗	✗	✗	✗	✓	✓
3. Preliminaries
This section discusses the cryptographic primitives used in CLPPPA.

3.1. Bilinear maps
Assume 
 and 
 are the two cyclic groups of the same prime order p. A map 
 is said to be a bilinear pairing if the following three conditions hold true [4]:

Bilinear: 
, ∀ 
 and ∀ 
⁎
.

Computational:  can be efficiently computable ∀ 
.

Non-degenerate: .

3.2. Security assumptions
A. Computational Diffie-Hellman (CDH) Assumption [10]. For any probabilistic polynomial time adversary 
, the advantage of adversary 
 on solving the CDH problem in 
 is negligible, which is defined as
⁎

B. Discrete Logarithm (DL) Assumption [20]. For any probabilistic polynomial time adversary 
, the advantage of adversary 
 on solving the DL problem in 
 is negligible, which is defined as
⁎
 where ϵ denotes a negligible value.

3.3. Extended double linked list information table (EDLIT)
To enable group user to perform dynamic operations such as insertion, modification and deletion on shared data, initially, Wang et al. [29] used Index Hash Table (IHT) data structure which is inefficient with regard to insertion and deletion operations since it is a sequence structure. To overcome above drawbacks, Tian et al. [27] designed a Extended Dynamic Hash Table (EDHT) based on linked list to support shared data dynamic operations. However, search operation is relatively inefficient during the update operations especially insertion and delete operations. To address these problems, we extended DLIT [22] to support shared data dynamic operations efficiently. EDLIT is a two-dimensional data structure stored at the TPA. The structure of the EDLIT is shown in Fig. 1. Data in the EDLIT is split into two types: The left part is the file information 
. The right part gives the block information. It includes current version number, block virtual index number and the signer id, 
. As shown in Fig. 1: whenever a data block is updated, the corresponding 
 will be increased by 1. When 
 is set to −1, it indicates that the data block is deleted. Besides, 
 is needed to know the signer in the group, which helps us to detect revoked users.

Fig. 1
Download : Download high-res image (143KB)
Download : Download full-size image
Fig. 1. Extended double linked list information table.

4. System model
In system model, we define system architecture, design goals, framework, and security model of CLPPPA.

4.1. System architecture
We consider certificateless cloud storage architecture with four entities as illustrated in Fig. 2

1.
KGC is a trusted entity, which generates the system parameters and the master private key. It also generates a partial private key for the user using master secret key (msk) and the user unique identity.

2.
User Group. The user group includes group members and group manager (GM). GM is a trusted entity, plays the role of an administrator. It is responsible for creating the group. It also revoke users on behalf of the group. Each user in the group can upload, access, and update the outsourced data. We consider GM as the owner of the data. Users can join and leave the group any time. There are multiple users in a group. We assume the legal group users are honest.

3.
TPA is also called a public verifier. It has the expertise and capabilities to perform auditing tasks on behalf of users regularly or upon request. Also convinces both cloud server and users by providing unbiased auditing results.

4.
Cloud server (CS) is a semi-trusted entity, which means it is honest but curious. It provides the enormous storage space on its infrastructure to manage the file in the cloud. During user revocation, it also performs delegated re-sign task on behalf of the group. Meanwhile, the cloud cannot learn any private keys of the two users, which means it cannot sign any block on behalf of either revoked or non-revoked user.

Fig. 2
Download : Download high-res image (230KB)
Download : Download full-size image
Fig. 2. Architecture of certificateless public auditing scheme.

4.2. Overview of CLPPPA
In CLPPPA, initially, a user submits a request to the GM to join the group. According to the user's request, GM generates a group key and securely sends it to the user. Then the user requests the partial private key from KGC. The KGC authenticates the user, generates a partial private key, and secretly sends it to the user. On receiving the partial private key from the KGC, the user generates his/her own private key and computes signatures for file data blocks using a private key. After signing data blocks, uploads data blocks along with corresponding signatures to the cloud and deletes them from the local site. Later, to check the integrity of shared data, TPA challenges the cloud by selecting blocks randomly. After receiving this challenge, the cloud returns the proof of shared data as a response to the TPA. Upon receiving proof from the cloud, TPA verifies the correctness of data. Whenever a user in the group misbehaves or quits the group, GM updates the existing RL and forwards it to the CS. Upon receiving the updated RL, the CS performs resigning on revoked user blocks by utilizing proxy re-signatures. Our scheme also allows users to update the data dynamically. That is, the user can modify the data in the cloud without downloading the data. The detailed workflow of the proposed CLPPPA scheme and process of revocation are shown in Fig. 3 and Fig. 4, respectively.

Fig. 3
Download : Download high-res image (82KB)
Download : Download full-size image
Fig. 3. Sequence diagram of the proposed CLPPPA scheme.

Fig. 4
Download : Download high-res image (23KB)
Download : Download full-size image
Fig. 4. The process of user revocation.

4.3. Design goals
We design certificateless public integrity auditing scheme to achieve the following goals:

•
Public verifiability. Anyone who knows the public key can verify data integrity on behalf of the user without retrieving the entire data from the cloud.

•
Correctness. The public verifier can correctly verify the integrity of shared data by challenging CS with randomness.

•
Soundness. The cloud server cannot pass the auditing process if the data is not intact.

•
Privacy preserving. During integrity verification, the TPA should not learn anything about the data of the user.

•
Data dynamics. Every group user is allowed to update the outsourced data remotely without downloading.

•
Group user revocation. Cloud server transforms revoked user(s) blocks to designated existing group user blocks during the revocation. Revoked users should no longer update or sign the data in the cloud.

4.4. Framework
Here, we define proposed scheme algorithms.

•
. It is run by the KGC. It takes a security parameter λ as input and outputs msk and system public parameters .

•
. It is run by the GM. It takes the unique identity (ID) of user as input and outputs group joining key ρ as output.

•
. It is run by the KGC. It takes the , msk, user identity 
 as input and outputs a partial private key 
.

•
. It is run by the user. It takes the , msk, user identity 
 as input and outputs a secret value 
.

•
. It is run by the user. It takes 
 and 
 as input and outputs a private key 
.

•
. It is run by the user. It takes , 
 as input and outputs a public key 
.

•
. It is run by the user. It takes , 
, and data blocks 
 as input and outputs a set of block signatures 
.

•
. It is run by the TPA. It takes the abstract information about the data as input and outputs the challenge C.

•
. It is run by the CS. It takes the file blocks 
, the block signatures 
 and C as input and outputs a proof P.

•
. It is run by the TPA. It takes the 
 and the proof P as input and returns 0 or 1.

•
. It is run by the GM. It takes current revocation list (RL) and user ID's as input and outputs the revised RL.

•
. It is run by CS. It takes private key parts of revoked and non-revoked users and generates rekey 
 for resigning.

•
. It is run by CS. It takes signature 
 and rekey 
 as input and outputs the resignature 
.

•
. It is run by the user. It takes new file block 
, the block position i and the update operation type UO as inputs, and outputs the update request information . The UO may be insert, modify or delete.

•
. It is run by CS and returns 1 if the update operation is finished successfully, otherwise returns 0.

4.5. Notations
Frequently used notations in CLPPPA are given in Table 2.


Table 2. Notations.

Notation	Description
λ	Security parameter
℘	A bilinear map
H1,H2	A collision-resistant hash functions
G1,GT	Multiplicative groups with prime order p
Pparams	Public parameters
ID	Identity of the user
g	The generator of group G1
mj	The jth block of shared file
n	Number of blocks
C	Challenge message
σ	Signature set
P	Proof message
RL	Revocation List
4.6. Security model
We designed CLPPPA scheme to withstand the four types of adversaries namely 
, 
, 
 and 
.

•
Type-I Adversary (
): 
 (malicious outsider) tries to replace the user's public key with a false key even though he could not have access to KGC's master secret key (msk).

•
Type-II Adversary (
): 
 (malicious KGC) tries to mount an impersonation attack having access to the msk of the KGC, but it cannot replace the public key of the user. Even though the KGC is a trusted entity, in a practical scenario, the KGC might engage in other adversarial activities such as eavesdropping on signatures and making signing queries, also known as Type II Adversary.

•
Type-III Adversary (
): 
 (malicious CSP) tries to compute a forged auditing proof that can pass the verification.

•
Type-IV Adversary (
): 
 (malicious TPA) tries to gain access to private information of data during audit process.

Among the four adversaries, both 
 and 
 try to forge the signature of blocks. 
 tries to generate the forged integrity proof, and 
 tries to gain private data access during integrity auditing. The basic difference between 
 and 
 is that 
 cannot access the master key of the KGC but can replace the public keys of any entity of his choice. 
 represents a malicious KGC with the master key of the KGC but cannot replace the public keys of users. Further, these Type I and Type II can be divided into normal, strong, and super adversaries based on their attack power. The super adversary has better attacking power than the other adversaries. Hence, we prove the security of CLPPPA, by considering the super type I adversary and the super type II adversary. We define three games Game 1, Game 2, Game 3 for 
, 
, 
 respectively.
Game 1 (played between 
 and a challenger ):

Setup: Initially,  executes  to obtain the msk and . For super type I adversary 
,  just returns the public parameters ;  keeps the msk secret. 
 could access the following oracles controlled by challenger .

•
Create_user_Oracle: On receiving a query with a different user's identity ID,  executes PartialPvtKeyGen, SetSecretValue, SetPublicKey to obtain partial private key, secret value and public key respectively. Finally,  returns public key to 
.

•
Partial_Private_Key_Oracle: On input of a query on the identity ID,  returns the partial private key to 
.

•
Secret_Value_oracle:  returns the secret value to 
.

•
Public_Key_Replacement_oracle:  replaces the user ID's original public key with a value of his choice.

•
SignGen_oracle: 
 adaptively chooses the tuple (ID,m) and submits it .  executes SignGen algorithm to produce a signature σ and sends it to 

•
Forge: Finally, adversary 
 outputs 
⁎
⁎
⁎
 as its forgery with identity 
⁎
. 
 is regarded to win this game if the following requirements are satisfied:

•
⁎
⁎

•
For 
⁎
, the query Partial_Pvt_Key_oracle does not occur in the game before;

•
 has not submitted before the pair (
⁎
⁎
) to the  with the public key 
⁎
.

Game 2 (played between 
 and a challenger ):
Setup: Initially,  executes  to obtain the msk and . For super type II adversary 
,  returns both msk and . 
 could access the following oracles controlled by challenger .

•
Create_user_Oracle: On receiving a query with a different user's identity ID,  executes SetSecretValue, SetPublicKey to obtain secret value and public key respectively. Finally,  returns public key to 
.

•
Secret_Value_oracle: On input of a query on the identity ID,  returns the secret value to 
.

•
Public_Key_oracle: 
 submits this for querying the public key of the ID.  executes the algorithm of SetPubKey to compute the public key for the ID and returns it to 
.

•
SignGen_oracle: 
 adaptively chooses the tuple (ID, m) and submits it .  executes SignGen algorithm to produce a signature σ for m and sends it to 
.

•
Forge: Finally, adversary 
 outputs 
⁎
⁎
⁎
 as its forgery with the identity 
⁎
. 
 wins the game if the following conditions are satisfied:

•
⁎
⁎

•
For 
⁎
, the query Secret_Value_oracle does not occur in the game;

•
 has never been submitted the pair (
⁎
⁎
) to the .

Game 3 (played by 
 and a challenger ):
•
Setup:  generates the , msk.  keeps the msk secret, but sends  to 
.

•
SignGen_Query: 
 chooses the tuple  and sends it to  for querying the signature.  generates and returns the signature of m to 
 by the algorithm SignGen.

•
Challenge:  generates Chal and sends it to 
 and requests 
 to provide the corresponding proof P.

•
Forge: For the Chal, 
 generates P and sends to . 
 wins the game, if P can pass the integrity check and the blocks in P is incorrect.

5. Proposed scheme-CLPPPA
In this section, we present the detailed construction of CLPPPA scheme including data dynamics and revocation as follows.

5.1. Construction
The detailed construction of CLPPPA is presented based on framework 4.4.

Setup Given security parameter λ, g is a generator of 
. The KGC picks a random element 
⁎
, chooses a random and sets 
. Also KGC picks 
⁎
 randomly and sent to the GM for generating group joining key. Finally, two map-to-point cryptographic functions are chosen 
⁎
, can map an arbitrary string 
⁎
 into an element of 
. Another hash function 
⁎
 maps an element of 
 to 
⁎
. The public parameter 
 is published i.e., made public to everyone and α is kept secret as master secret key.

Join Whenever a user wants to join a group, sends a request to the GM. Upon receiving the request, GM generates a group key as 
 and sends back ρ to the authorized user in a secure way.

PartialPvtKeyGen Upon receiving the group key from GM, user 
 sends his/her unique identity 
 and group key to KGC for partial private key generation. Then, KGC verifies the validity of the user by Eq. (1).(1)
 If the result is false then outputs ⊥. Otherwise, KGC computes the partial private key (
) for the group user as follows:

1.
Compute 

2.
Compute 
 and return to the user.

SetSecretValue After receiving 
, user 
 chooses 
⁎
, 
 randomly and keeps 
 as private secret value and makes 
 public.
PvtKeyGen After setting the secret value, the user 
 combines 
, and 
 to generate actual private key 
.

SetPublicKey After generating 
, the user 
 computes public key as 
 with  and secret value 
⁎
.

SignGen After generating key pair 
, group user 
 computes a signature for a block 
⁎
 using private key 
 as follows.(2)
 where 
 and 
 denotes the file identity. Later group user uploads blocks and corresponding signatures to the CSP.

Challenge After storing data into the cloud, the user request the TPA for data integrity verification. Upon receiving the request from user, TPA selects a subset 
 of c-elements from set , and selects 
⁎
 randomly for each . Let 
 be a challenge message send to the cloud server.

ProofGen After receiving the challenge 
, the server computes a proof, which consists of data proof and signature proof as concretely.

1.
According to signature of each block, the CSP divides the challenged blocks in the set to d disjoint subsets 
, 
...
, where 
 is the subset of challenged blocks signed by group user 
. Let 
 be the count of elements in 
. So, the number of elements in subset 
 is 
. Clearly, we have 
, 
 and 
 for  signed by different users with different private keys.

2.
For each subset 
, CSP computes 
 by(3)
⁎
 where(4)
 
 and 
 where 
⁎
 is a random mask used to blind the data proof to preserve the data privacy against TPA. Meanwhile, the server also calculates an aggregated signature for user 
,(5)
 

3.
Then the server returns final proof  to the TPA as proof, where 
.

ProofVerify The TPA verifies the integrity of outsourced data blocks after receiving proof for the challenge from the server by verifying the following equation.(6)
 
 
 
 
 If the equation holds, blocks stored in cloud are properly maintained. Otherwise, the data is not intact, i.e., data is corrupted or deleted.
5.2. Support shared data dynamics
We describe dynamic operations such as block insertion (
), block deletion (
) and block modification (
) based on EDLIT for data dynamics.

Block Insertion: Suppose a group user wants to insert block 
 after the ith block 
. At start, based on 
 the group user computes the corresponding signature 
. Then, he generates an update request and sends new block and signature 
 to the server. After receiving 
 the insertion request, the server runs  and inserts a corresponding file block 
 after 
 in the cloud; then the user sends the insertion instruction to the TPA 
. Upon receiving the request, TPA updates the entries in EDLIT. The changes in the EDLIT can be found in Fig. 5.

Fig. 5
Download : Download high-res image (150KB)
Download : Download full-size image
Fig. 5. Extended double linked list information table after block insertion.

Block Modification: Block modification operation refers to the replacement of specified block with new one. To modify the ith block 
 to 
, first, user generates new version number 
⁎
⁎
 and signature 
 for the new block 
. Then, user constructs an update request message 
 and sends to the server. After receiving 
 request, the server replaces the block 
 with 
 and replaces the 
 with 
. Then, the user sends 
⁎
 to the TPA. TPA updates the EDLIT accordingly. For example, in Fig. 6, block 2 of file 
 is taken to show a block modification operation. It is clear that the version number of the data block is updated.

Fig. 6
Download : Download high-res image (150KB)
Download : Download full-size image
Fig. 6. Extended double linked list information table after block modification.

Block Deletion: Block deletion is just the opposite operation of block insertion. Suppose the server receives the update request 
 for deleting block 
, it will execute the deletion instruction as shown in Fig. 7. Then user sends 
 to the TPA. Upon receipt, the TPA would find 
 and delete its information in the EDLIT. During deletion no new parameters are generated.

Fig. 7
Download : Download high-res image (150KB)
Download : Download full-size image
Fig. 7. Extended double linked list information table after block deletion.

5.3. Secure group user revocation
In a data sharing group, it is common that users join and leave the group at any time. Whenever a user is revoked from the group, the revoked users' pair of keys should be made invalid to disable the access rights, and signatures must be resigned by the existing user [15], [25]. The cloud server runs the algorithms ,  to generate a rekey and update the revoked users' signatures during revocation upon receiving the revised 
 from GM. GM obtains 
 by running 
. The description of ,  are given below, in which we treat 
 and 
 be the revoked user and a valid non-revoked user respectively in the group.

•
ReKey: This algorithm involves some interactions among 
 and cloud server. Besides, it is required that 
 and cloud server are online simultaneously during the revocation process.

1.
cloud server chooses 
⁎
 randomly and sends η to 
 in a secure way.

2.
 computes and sends 
 
 to 
.

3.
 computes and sends 
 
 
 to cloud server.

4.
Upon receiving 
, cloud server calculates 
 
 
 as rekey.

•
ReSignGen: Then the cloud server transforms all signature-block pairs 
 generated by 
. That is the signature 
 for the block 
 transformed as
 The proof of correctness of above algorithm is as follows:
 
 
 
 

where 
 is the valid signature of 
 for the generating user 
.
6. Security analysis
In this section, we prove the security of CLPPPA in terms of completeness, soundness, and comprehensive privacy preserving as described in Section 4.

6.1. Correctness
If both the verifier and the server are honest, for each valid signature 
 and a random challenge 
, the correctness of the protocol can be elaborated as follows.

Theorem 1

In CLPPPA, the verifier successfully audits the integrity of data iff all the challenged file blocks and its corresponding signatures are intact in the cloud.

Proof

The correctness of CLPPPA can be proved by verifying the Eq. (6), based on properties of bilinear maps. The verification Eq. (6) can be elaborated as follows:
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 From the above proof, we say cloud generates the valid proof for challenged blocks as the selected blocks were not corrupted. Thus cloud will not fail the auditing process launched by TPA.

6.2. Soundness
Here, we prove CLPPPA is unforgeable against 
, 
, 
 as defined in Section 4.6.

Theorem 2

CLPPPA is secure against 
 if the CDH problem is hard in 
.

Proof

If 
 wins the Game 1 with a nonnegligible probability ϵ; then, we could construct an algorithm that simulates a challenger  to solve the CDH problem with a nonnegligible probability. Initially,  contains two hash lists 
 and 
 and a public key list 
 which are empty initially. 
 and  interacts as follows.

•
-Query: If 
 makes an 
-query with identity ID.  checks whether 
 contains 
. If it holds,  returns 
; otherwise,  returns a random 
 to 
 and then adds 
 into 
.

•
-Query: If 
 makes an 
-query with identity ID.  checks whether 
 contains 
. If it holds,  returns 
; otherwise,  returns a random 
 to 
 and then adds 
 into 

•
Setup:  produces the public parameters set including KGCs master public key to 
.

•
PartialPvtKeyGen: Upon receiving a query with identity ID,  does the following.

1. If 
⁎
,  computes 
 and then, store 
 into 
.

2) Return 
.

•
SecretValue:  looks up 
 and returns 
.

•
PublicKeyGen:  returns user's public key 
 to 
.

•
ReplacePublicKey: On receiving this query on 
,  returns 
 if it is already exists in 
; Otherwise,  replaces user's public key 
 with 
 and then adds 
 into 
.

•
SignGen: Upon receiving a query on ,  finds 
 and 
 from 
 and 
 and computes the signature σ for ID on m if 
⁎
 and returns the result to 
. Otherwise,  aborts the game.

•
Forge: Finally, 
 outputs a signature 
 on a message m′. We then show the probability that 
 successfully wins the game as follows.

1.
:  does not abort Game 1 in query Partialpvtkeygen.

2.
: 
 outputs forgery of a signature σ on m for ID.

3.
: After event 
 happens, the signature σ satisfies ID = ID*.

From the simulation, we have
 
 
 From these equations, the probability that  could solve the given CDH problem is
 
 
 From above equation, we conclude that  cannot break the CDH problem since ϵ is nonnegligible. Therefore, CLPPPA is secure against 
 in the random oracle model.
Theorem 3

In the random oracle model, if 
 wins the Game 2 with a nonnegligible probability, then an algorithm  can solve the CDH problem.

Proof

If 
 wins the Game 2 with a nonnegligible probability ϵ; then, we could construct an algorithm that simulates a challenger  to solve the CDH problem with a nonnegligible probability.  generates a random number 
⁎
 as the master secret key, computes public key 
, and returns public parameters 
 and the master secret key α to 
.  picks an identity ID as a challenge identity and answers the 
 and  queries as it does in the proof of the previous theorem.  interact with 
 as follows.

•
PartialPvtKeyGen:  computes 
 and then store 
 into 
 and then return 
 to 
.

•
SecretValue:  looks up 
 and returns 
 if 
⁎
. Otherwise,  aborts the game.

•
PublicKeyGen: Upon receiving this query,  returns the user's public key 
 to 
.

•
Forge: Eventually, 
 generates 
, 
. We then show the probability that 
 successfully wins the Game 2 as follows.

1.
:  does not abort Game 2 in SecretValue query.

2.
: 
 outputs forgery of a signature σ on m for ID.

3.
: After event 
 happens, the signature σ satisfies ID = ID*.

From above process, we have
 
 
 From above equations, the probability that  could solve the given CDH problem is
 
 
 we conclude that  cannot break the CDH problem since ϵ is nonnegligible. Thus 
 cannot win the Game 2. Therefore, CLPPPA is secure against 
 in the random oracle model.
Theorem 4

Given shared data  and its signatures σ, it is computationally infeasible for the cloud to compute a forgery of auditing proof that can pass the verification under DL assumption.

Proof

We prove this Theorem 4 according to the security game defined in 4.6 as follows:

Game 3: First, challenger  sends a challenge message 
 to 
, and the correct proof should be  return to  as proof, where 
 which can pass the verification successfully with equation (6). Now, 
 computes an invalid auditing proof of 
 based on the incorrect data 
, where 
, and at least one element of 
 for  is nonzero. If the proof pass the verification, then the 
 wins the Game 3 and we can find a solution to the DL problem. Otherwise, it fails. If 
 wins the Game 3, then, according to Eq. (6), we have
 
 
 
 

Because  is a correct proof, we have
 
 
 
 

Based on bilinear maps
 
 
 
 For any two random values 
, there exists 
⁎
 such that 
 because 
 is a cyclic group. For the given 
, each u can be randomly and correctly generated by computing 
, where 
 and 
⁎
. Then, we have
 
 
 Clearly, the solution for DL problem can be found. More specifically, given 
, we can compute 
 
 
 unless the denominator is zero. However, as we defined in Game 3, at least one element of Δμ is nonzero, and 
 is random value of 
⁎
, therefore, the denominator is zero with probability of . That is, if 
 wins Game 3, we can find a solution to the DL problem with a probability of , which is non-negligible. It contradicts the assumption in Section 3.2.B. Therefore, it is computationally infeasible, for 
 (malicious cloud) to output a forged auditing proof that can pass the verification.

6.3. Data privacy preserving
Here, we want to prove that 
 (TPA) could not learn user's data content from the information collected during auditing process.

Theorem 5

From the given cloud's auditing proof , it is computationally infeasible for 
 to gain access to private information (
) of shared data.

Proof

We prove the Theorem 5 in two steps. First, we show that no private data on (
) can be derived from shared data μ it is masked by r as 
 where 
 and 
, where 
⁎
 is chosen randomly by server and is hidden from auditor. Thus, privacy of 
 is protected from 
 even μ is given to 
. Second, we show that no private information on 
 can be derived from σ, where 
 
 
 
 
 
 
 Analysis: 
 is masked by  
 
. However, to compute  
 
 from  
 
 and 
, which is the only information TPA can utilize, is a CDH problem. According to CDH problem, it is infeasible for 
 (TPA) to derive private information.

6.4. Comparative summary
Here, we compare the security of CLPPPA with some of the existing PKI/ID-based and CL-PKC based [8], [14], [28] schemes against 
, 
, 
, 
 whose power has been defined in Section 4.6 and is presented in Table 3. As shown in Table 3, schemes [8], [14], [28] does not provide privacy protection. In addition, Wang et al.'s [28] scheme is vulnerable to Type I adversary attacks and He et al.'s [8] scheme does not provide formal proof against 
. Our CLPPPA, however, satisfies the requirements of public auditing scheme including privacy preserving and is proven to be secure against all adversaries 
, 
, 
, 
.


Table 3. Security comparison.

Schemes	
Wang et al. [28]	No	Yes	Yes	No
He et al. [8]	Yes	Yes	No	No
Li et al. [14]	Yes	Yes	Yes	No
Proposed scheme	Yes	Yes	Yes	Yes
: Type I Adversary, 
: Type II Adversary, 
: Type III Adversary, 
: Type IV Adversary.

7. Performance analysis
In this section, we evaluate the computation cost of our scheme (CLPPPA) theoretically, experimentally and compare it with the state-of-the-art recently proposed related shared data auditing schemes [14], [30], [41].

7.1. Theoretical analysis
First, we define some notations used in computation cost analysis:

1.
: one bilinear pairing operation.

2.
: one exponentiation operation on group 
.

3.
: one multiplication operation on group 
.

4.
: one multiplication operation on group 
.

5.
c: the number of challenged blocks.

6.
d: user subsets for the challenge.

7.
: one hash operation in group 
.

8.
⁎
: one multiplication operation in 
⁎
.

9.
⁎
: one addition operation in 
⁎
.

We consider computation overhead mainly comes from bilinear pairings, exponentiation, multiplication and hash operations on the groups 
 and 
. To generate the signature for a block in CLPPPA, the user in the group needs to run  algorithm and whose computation cost is 
. To generate the challenge message for the CSP, the verifier needs to run  algorithm, which incur the negligible cost. Therefore, we ignore the computation cost of . Since there is negligible computation cost in the challenge generation phase, the computation cost of our scheme CLPPPA is mainly generated by the proof generation phase and the proof verification phase and revocation phase. To generate the integrity proof P, server needs to execute the algorithm , which requires 
 computation cost. To check the data integrity, the TPA runs the algorithm  which requires 
 computation cost. The revocation cost is 
 and it depends on the number blocks signed by the revoked user in the file, where R denotes the total count of signatures that needs to be updated. Moreover, to show the efficiency advantage of our scheme, we compare our scheme CLPPPA with the some of the existing schemes such as PKI-based [30], IBC-based [41] and CLPKC-based [14] shared data auditing schemes from different aspects and list the results in the Table 4. From Table 4, we can see that our proof generation, proof verification and resigning time is efficient than [14], [30], [41].

Table 4. Computation cost comparison of SignGen, ProofGen, ProofVerify and ReSignGen over other schemes.

Schemes	SignGen	ProofGen	ProofVerify	ResignGen	Type
Wang et al. [30]	2TG1_ex + TG1_mul + Hs	
⁎
(c + d)TG1_ex + (c + 2d)TG1_mul + (d + 1)Tp + dTG1_mul + cHs	2TG1_ex + TG1_mul + 2Tp + Hs	PKI
Zhang et al. [41]	2TG1_ex + TG1_mul + Hs	
⁎
⁎
⁎
⁎
+	...	IBC
Li et al. [14]	2(TG1_ex +TG1_mul)+Hs	c ⋅ TG1_ex + c ⋅ TG1_mul	(d + 2)Tp + (c + d)TG1_ex + (c + 2d)TG1_mul + dTG2_mul + d(c + 1)Hs	R ⋅ (2TG1_ex + TG1_mul)	CL
Proposed scheme	2(TG1_ex +TG1_mul)+Hs	c ⋅ TG1_ex + (c − 1)⋅TG1_mul	(d + 2)Tp + dTG1_ex + (c + 2d)TG1_mul + dTG2_mul + d(c + 1)Hs	R ⋅ (TG1_ex + TG1_mul)	CL
7.2. Experimental results
Experiments have been carried out for the evaluation of performance of the proposed CLPPPA scheme in terms of computation cost, in a simulated environment using a windows system with Intel i5-7200U CPU @ 2.50 GHz and 16 GB RAM. All experiments are carried out in python 2.7 language (PyCharm IDE) using pairing-based cryptography (PBC) library crypto-0.42 [1] to simulate the proposed scheme. The implementation uses a symmetric super singular elliptic curve where the finite field size is 512-bit and security parameter fixed to 160-bits, that means, the length of the prime order p in the experiments is 160 bits which has the equivalent security level of 1024-bit RSA. The number of shared data blocks n= 100000 and each block size is 2 KB. All results are mean of 15 trials. We provide the experimental results for signature generation (), proof generation (), proof verification () and revocation (), which play the significant role in our proposed CLPPPA scheme. The obtained results are plotted as graphs from Fig. 8a to Fig. 8f.

Fig. 8
Download : Download high-res image (825KB)
Download : Download full-size image
Fig. 8. Computation cost: (a) Computation Time of SignGen algorithm for different number of blocks. (b) Time consumption of ProofGen algorithm. (c) Time consumption of ProofVerify algorithm. (d) Time consumption of verification for various number of users. (e) Computation cost of ReSignGen algorithm for different number of revoked blocks. (f) Computation cost of revocation process for different number of users.

7.2.1. Computational costs for generating signatures
Fig. 8a shows the computation cost of  algorithm. During sign generation, a user in the group generates signatures for the different number of data blocks in the file using  algorithm to check the correctness of data during verification We set the group size to be 50 and the number of blocks ranges from 10,000 to 1,00,000. From Fig. 8a, in all four schemes, we observe that the time needed for  algorithm increases linearly as the number of blocks increases in the file. Both our scheme and [14] takes almost same time to generate signatures whereas [30], [41] requires slightly less time than [14] and our proposed scheme, since it has one less multiplication operation whose computation cost is much less than exponentiation operation's cost. Furthermore, sign generation is done once for the entire life-time of the scheme and brings little influence on the performance of integrity checking.

7.2.2. Computational costs for proof generation
Fig. 8b shows the computation cost of  algorithm. During proof generation, the CS generates the proof against the number of challenged blocks in  message during verification to prove that the data is intact. We increase the counter of challenged blocks from 100 to 1000 with an increment of 100 in each experiment. From Fig. 8b, we can learn that in all the four schemes, the time for proof generation is proportional to the block number; and for the same number of data blocks, CLPPPA spends relatively less time than [14], [30], [41].

7.2.3. Computational costs for proof verification
Fig. 8c and 8d shows computation cost of  algorithm. During proof verification, the TPA runs the  algorithm to detect the misbehavior of CS against the number of challenged blocks and number of users in the group, respectively. From Fig. 8c, in all four schemes, we observe that the time needed for  algorithm increases linearly as the number of blocks increases in the file. From Fig. 8c we can see that when the number of challenged blocks is 100, the time of proof verification takes about 1.1456 s in all schemes, when the number of challenged blocks is 1000 it needs nearly 10.3768901 s, 8.2822234 s, 7.832451 s in [30], [41], [14] respectively, whereas in our scheme it takes only 6.402 s. From this observation, we can say that our scheme takes relatively less time than [14], [30], [41]. Thus, our scheme is feasible for real-life applications. From Fig. 8d in all four schemes, we can learn that the verification time is proportional to the number of users in the group. Moreover, for the same number of users in the group, the verification time of our scheme is less than the half of that of [30] and relatively less than that of [14], [41].

7.2.4. Computational costs for revocation
Fig. 8e depicts the computation cost for the server to run  algorithm for different number of blocks to be resigned on behalf of the existing valid user in the group to ensure the correctness of the signatures made by revoked user. Here, we compare CLPPPA scheme with [14], [30] and ignored Zhang et al. [41] because they simply update the private key of all non-revoked users in the group, instead of resigning the blocks. From Fig. 8e, we can see that the cost of  in all schemes is linear with the number of revoked user blocks and CLPPPA scheme performs better than [14], [30]. Fig. 8f also depicts the computation overhead of revocation process with respect to different number of users. From Fig. 8f, we can see that the cost of revocation is linear to the number of revoked users for different number of blocks. For example, for a group with 50 users consumes 130 ms for resigning 300 blocks, and consumes 143 ms for 500 blocks.

8. Conclusion and future work
In this paper, we focused on shared data auditing in cloud and proposed a privacy preserving public auditing system for dynamic shared data storage in cloud computing by utilizing certificateless signatures. CLPPPA achieves privacy preserving against TPA by masking the data proof during auditing process while refraining from both complex certificate management and key escrow problem. Besides, CLPPPA also supports data dynamics through EDLIT and efficient user revocation utilizing proxy signatures. We formally proved the security of CLPPPA against super Type I, super Type II, Type III and Type IV adversaries under DL and CDH assumptions in ROM and it is proven that CLPPPA is more secure than existing schemes. The performance is evaluated by theoretical analysis and experimental results. The results show that the CLPPPA is efficient and can be used in practice. As a future work we extend this work to support batch auditing.