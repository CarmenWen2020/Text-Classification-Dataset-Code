Abstract
Network coding and topology control techniques have been widely used to increase throughput and improve the lifetime of Wireless Sensor Networks (WSNs). This paper considers the simultaneous utilization of these techniques in a WSN and proposes convex non-linear programming. Since solving the problem for a large-scale and dynamic WSN is impractical and almost impossible, Lagrangian, sub-gradient and the decomposition methods are employed to provide a decentralized algorithm. In the proposed algorithm, a node makes the computations by acquiring local knowledge and information from its neighbors. This paper provides a mathematical language to build an analytic foundation for the design of a modularized and decentralized algorithm that provides transmission ranges and routes for a WSN. The simulation results show that increasing the number of sources, sinks, sensors, and traffic load leads to improving the lifetime which is acquired by the proposed algorithm.


Keywords
Wireless Sensor Network
Topology control
Lifetime
Network coding
Multicast

1. Introduction
Network coding comprises two distinct sub-problems: coding and sub-graph selection. The coding sub-problem determines each intermediate node should do which operation. The sub-graph selection argues on the routes between the sources and destination nodes, which should be optimal in cost. Since network coding, specifically sub-graph selection, needs to know about the neighbors (this information is used to make the routes), topology control is in conflict with the network coding opportunity [20], [25]. In fact, topology control uses some relay nodes to assist transmitting the packets while in network coding the relay nodes may mix the packets with an operator and then send the coded packets [1], [34].

In the following, we illustrate an example of exchanging data in a WSN where topology control and network coding are used, simultaneously. See Fig. 1, where the nodes  and  want to exchange their own packets,  and , respectively. The first choice is direct transmission where the nodes  and  exchange their packets directly with no relay node (see Fig. 1-a). However, the nodes  and  can send their packets to the relay node  that mixes the packets and then sends. The nodes  and  can retrieve each others’ packets by XOR-ing  with their own packets (see Fig. 1-b). Note that without network coding,  transmissions are required because the node  should send  and  independently. This transmission can be accomplished by the relay node , too. Here, the node  exhausts more energy to communicate with the farther node , while the node  uses less transmission range. Additionally, both nodes  and  may be employed as relays in which either  or  mix the packets. The best solution for this problem is affected by the various factors, such as generated traffic of nodes, the distance between them, and their residual energy.

Recently, some studies, see e.g. [18], [22], [23], have been introduced which combined network coding with topology control. These studies provided some mathematical theories and showed some advantages, such as increasing the lifetime, and decreasing energy consumption. To the best knowledge of authors, available approaches use either a heuristics method or a centralized solver to solve the problem. However, the heuristics methods obtain a sub-optimal solution (generally is not close to the optimal solution) and the centralized approaches are subject to some well-known disadvantages. By considering the advantages of combining network coding with topology control, a decentralized approach is required in which the nodes obtain the network topology and network-coding-based routes, independently.


Download : Download high-res image (63KB)
Download : Download full-size image
Fig. 1. (a) No relay (b) Communicate with the relay node .

In this paper, a convex optimization problem is proposed that considers multiple sources and combines network coding with topology control. Then, Lagrange dual, sub-gradient, and the decomposition methods are utilized to present a decentralized algorithm. The proposed algorithm repeatedly solves the simpler sub-problems until it achieves the global object that is the optimal lifetime. We assess the performance of the proposed approach through simulations and compare the obtained results with the available optimal solutions. The simulation outcomes show that considering multiple sources leads to more lifetime compared to considering the sources, separately. We also study the effect of network parameters on the convergence rate of the proposed algorithm. The main contributions of this paper are summarized as follows:

•
It considers multiple sources and provides a convex optimization problem for optimal topology control in network-coding-based-multicast WSNs. The mathematical formulation can help us to assess the essence of this problem.

•
For the first time, a decentralized and optimal algorithm is presented that combines network coding and topology control. The proposed algorithm creates an automated and dynamic structure for WSNs, which continuously changes the routes and transmission range of the nodes.

•
We prove the efficiency of the proposed algorithm by comparing it with the optimal solution and state-of-art approaches.

The rest of this paper is organized as follows: Section 2 presents an overview of related literature. System model and problem definition are described in Section 3. Section 4 describes the proposed decentralized algorithm. The assessment of approaches is done through simulations and the results are reported in Section 5. Finally, conclusions and directions for future research are presented in Section 6.

2. Related work
Both network coding and topology control techniques provide various advantages, such as extending the lifetime, saving energy, reducing interference, decreasing Media Access Control (MAC) and routing complexity [34]. This section reviews the studies that consider these techniques simultaneously. Note that various topology control mechanisms (e.g. power assignment, transmission range adjustment, and communication resource allocation) are considered in these studies.

The authors of [26], [31] showed that the topology of wireless networks has a significant impact on the throughput of network coding. The authors of [24] showed that topology control mechanisms decrease both energy consumption and maximum information flow that obtained by network coding. In [27], Srinivas et al. applied network coding into neighbor-based-topology-control protocols to reduce the number of transmissions. Their simulation results show that their approach improves energy efficiency in network-coding-aware-neighbor-based-topology-control protocols. In [2], an optimization problem is proposed for the multi-hop routing in the device to device communication. This model improved the energy efficiency, throughput rate, resource utility, and packet delivery ratio.

Chi et al. [9] combined network coding with topology design to minimize wiring cost of wired networks. In [29], the authors showed that the choice of both network coding and resource allocation plays a critical role in network efficiency. In [28], Kai et al. proposed a power control approach that can enhance the performance of random-network coding in wireless networks. They used a differential-equation-based framework to analyze random-network-coding throughput and designed a dynamic-power-control algorithm to achieve higher multicast throughput. Han et al. [13] provided an optimization problem to consider the source-node pairing, sub-carrier assignment, sub-carrier pairing, and power allocation. It maximizes the sum of flow rates under per-user power constraints. In [33], the authors studied the dynamic-resource-allocation problem for wireless multicast networks with intra-session network coding to minimize the total transmission power. Their results show that network coding improves energy efficiency [8]. Hung et al. showed that network coding improves the stable rate over plain retransmissions [15]. However, the gain of their approach depends on the physical channel parameters, where its range is from 33% to 410%. Jiang et al. [16] constructed a network structure that provides the network coding requirements when the nodes are deployed randomly. The authors of [19] considered network coding with the itinerary-planning problem that affects network topology. The authors of [18] addressed the problem of lifetime optimization for WSNs where the network uses both range assignment and network-coding-based multicast. Then, they proposed a convex optimization problem.

In combining network coding with topology control, we can refer to “topology control in network-coding-based WSNs” which rigorously integrates these techniques into a single problem. In [22], the authors attempted to maximize the lifetime of WSNs by formulating the problem as a mixed integer non-linear programming. Their optimization considered the reliability and delay as two constraints. They also proposed a centralized heuristic algorithm. An optimization problem which optimizes energy consumption is provided by the authors of [23], then the problem is transformed into a convex problem which leads to theoretical and conceptual advantages. Their simulation results show that their approach decreases end-to-end delay and energy consumption. In [21], a genetic algorithm is proposed for this combination and their results showed that their approach could efficiently get the satisfactorily near-optimal topology in network-coding-based-multicast WSNs. Finally, the authors in [20] proved that there exists a coding solution for the networks which utilize the combination of network coding and topology control.

3. Problem statement and formulation
This section presents the system model, then develops an optimization problem for combining network coding with topology control. The proposed optimization model considers multiple sources in a WSN and finally it is converted into a convex non-linear programming.

Suppose that a set of wireless nodes, , is randomly deployed in the monitoring environment and consists of the sensors, , and sinks,  (i.e. ). Formally, the hyper-graph  defines the set of nodes, , and their connections by the set of hyper-arcs . The nodes can adjust their transmission ranges that define the set of hyper-arcs. Let  denotes the neighbor set of node  in which  where  defines transmission range of node  and  represents the Euclidean distance between nodes  and . In the set , there exist some edges from the node  to its neighbor set . In particular, the vector of transmission range of nodes, , determines the hyper-arcs and plays a dominant rule in the energy dispatching model of WSNs. To transmit a unit of flow rate over a range , the transmission power of node  is equal to  where  is the path loss exponent (depending on the environment ),  is the required energy for transmitter amplifier in the free space propagation, and 
 is the required energy for running the transmitter [34]. In practice, topology control mechanisms use various methods to find the optimum transmission range vector 
. Table 1 shows a list of notations and their descriptions.

We specify a multicast connection with a triple 
 where  is the source of connection,  is the set of all sinks, and 
 defines the rate of flow originated by the source . We use network coding to construct the routes from sources to the sinks because it provides more efficiency in comparison with traditional approaches. In particular, the sub-graph selection sub-problem of network coding chooses links and corresponding flow rates to support a multicast connection, preferably by minimizing some costs such as energy or latency. The sub-graph selection defines two flows, including actual and virtual flows. The actual flow rate 
 is the amount of flow that is conducted by the node 
 from the source  to all sinks . Practically, the actual flow 
 is produced after coding by the node 
 and is the optimal solution of an optimization programming if and only if there exists a network code [10]. The virtual flow is an intermediate variable that is utilized to obtain the actual flow. The virtual flow from the source  on the link  to the destination  is denoted by 
. In fact, by the flow-sharing property of network coding, the actual flow rate 
 needs to only be the maximum of the virtual flows which are originated by the node 
. The vectors of actual and virtual flows from source  are denoted by 
 and 
, respectively. Also, let  and  denote the vectors of all actual and virtual flows, respectively.

By considering the flow demands among different sources and sinks (multi-commodity problem), the problem of combining topology control with network coding is proposed as follows. (1)
 
 

subject to: (2)
 
 (3)
 
 (4)
 (5)
 (6)

This optimization problem is emerged from the mathematical model of sub-graph selection sub-problem, which its goal is to minimize 
, where 
 defines the cost per unit of flow that transmitted by node 
 [14], [23]. In this cost function, the summation of all actual flows (from all sources) that are transmitted by the nodes is of concern. In the objective function (1), we assume that 
 
 where 
 denotes the remaining energy of node 
. The reason of this assumption is explained in the following. If we omit the energy consumption for reception and computation, then the node 
 consumes 
 for transmitting where 
 denotes the power consumption for transmitting a unit of flow. Therefore, the lifetime of node 
 is 
 
 and minimizing 
 
 maximizes the summation of lifetime of all nodes. In particular, supposing that all nodes have the same volumes for the parameters 
, 
, and , then the objective (1) is provided.

The constraints (2) show that the actual flow, 
, is equal to the maximum of virtual flows for all ,  and 
 (these constraints comes from network coding optimization model and for more details see [14]). The constraints (3) are referred to the mass balance constraints or flow conservation law. In fact, these constraints state that for each 
, , and , the outgoing flow from node 
 minus the entering flow into 
 should be equal to 
, 
, or zero. In practice, the left hand side of (3) is equal to 
 for the source node , 
 for the sink , and zero for other nodes that are transitional. The constraints (4) force the non-negativity property of flows. Furthermore, the constraints (5) show that the summation of virtual flows from all sources on the link  should be lower than its capacity where (7)
 


Table 1. The notations and their descriptions.

Notation	Description
The set of nodes.
The set of sinks.
The set of sensors.
The neighbor set of node 
.
The transmission range of node 
The transmission power of node 
.
The rate of flow originated by the source .
The amount of actual flow rate that is conducted by the node
 from the source .
The virtual flow from the source  on the link  to
the destination .
Thus, if 
, the constraints (5) show that the summation of flows from all sources on the link  is bounded to the node capacity, 
. On the flip side, if 
 then 
 should be zero, because it is non-negative (
). The constraints (6) demonstrate the minimum and maximum transmission range properties that are depended on the transmitters’ features.

The optimization problem (1)–(6) is a non-convex non-linear programming (Hessian matrix is not semi-definitive). There are numerous algorithms for solving this problem, however they cannot distinguish between the local optimal solutions and the global optimum [6]. To convexify the problem, we introduce the following changes for the variables: 
Then, the optimization problem (1)–(6) is recast to the following optimization problem. (8)
 

subject to: (9)
 
 (10)
 (11)
 (12)
 (13)
where (14)
 

Obviously, if we substitute Eq. (9) in the objective (8), an optimization problem with two decision variables emerges. The Hessian matrix of objective function is not semi-definite (the proof is same as [23]), therefore this mathematical programming is a convex nonlinear problem.

4. Proposed decentralized algorithm
There are polynomial-time and practically fast algorithms that can solve the convex optimization (8)–(13). However, the computational characteristics of WSNs do not allow us to use the centralized algorithms. More clearly, it is almost impossible or impractical to gather all information to solve the proposed optimization problem, especially when the number of deployed sensors is large and network dynamically changes. The main advantage of the proposed optimization problem is its decomposability structure, which leads to a decentralized (and iterative) algorithm. Note that decentralized algorithms are attractive in the large-scale and dynamic WSNs where the centralized approaches are infeasible, non-scalable, too costly, and very fragile. This section utilizes Lagrangian, sub-gradient and decomposition methods to propose an algorithm for solving the problem (8)–(13). In what follows, the mathematical theory and pseudo-code description of the proposed algorithm is demonstrated.

4.1. Algorithm theory
Lagrangian function of optimization problem (8)–(13) is defined as follows. (15)
 
 
 where 
 and 
 are Lagrange coefficients which are associated with the equality constraints (10) and the inequality constraints (12), respectively. Note that this Lagrangian function does not contain the constraints (11), (13) because they are considered in the algorithm design. Lagrangian function (15) can be re-written as follows: (16)
 
 
 which comprises multiple smaller sub-functions that each one corresponds to a node. More precisely, this function is separable as follows: (17)
where 
 and 
 are respectively corresponding to the vector variables  and  at the node 
, also (18)
 
 

Hereby, Lagrangian function is separated into several smaller functions. Each sub-function corresponds to a sub-problem that can be assigned to a node. Take into consideration that this problem has two coupling variables 
 and 
 which effect from two adjacent node 
 and 
. These coupling variables can be handled by using an iterative approach and exchanging information between nodes in each iteration. To catch a solution for a sub-problem, each iteration of the proposed algorithm has two phases. The first phase uses sub-gradient method to update the values of the dual variables 
 and 
, where it is supposed that the primal variables 
 and 
 are invariant. The second phase employs inverse of the first phase and supposed that dual variables are fixed, then two new values are assigned to the primal variables. In the following, the phases which should be done in each iteration, are demonstrated.

Initially and at the iteration , some preliminary values are considered for the problem variables where referred by 
, 
, 
, and 
. In the first phase of iteration , fixed values for 
 and 
 are considered which are denoted by 
 and 
, respectively. In this situation, Lagrangian 
 is a linear function of dual variables 
 and 
. Then, by taking a step along sub-gradient, the values of 
 and 
 are computed by (19)
and (20)
where 
 and 
 belong to the sub-differential of Lagrangian function (18) correspond to the variables 
 and 
, respectively, i.e.  (21)
 
 and (22)
 

In (19), (20), 
 and 
 are step-sizes which are associated with the variables 
 and 
, respectively. Section 5 describes the simulations which are carried to assess the step-size selection procedure. In constraints (19), (20), 
 is the projection function that maps the resulted values to the positive domain, i.e. (23)
 

In the second phase of iteration , we deal with obtaining values of primal variables 
 and 
 where 
 and 
 store the values of the variables 
 and 
, respectively. The process of obtaining primal variables is similar, however, we describe their calculations separately. We first look a value for 
 which minimizes Lagrangian function while 
, 
 and 
 have constant values. Therefore, the value of 
 is computed by (24)
 

The returned set by  may be the empty, a singleton, or contains multiple elements. If the problem has at least a solution, a value is returned by  (since the problem is convex). Take into consideration that 
 should be bounded to 
 and 
 which provides the constraint (13). Thus, 
 can be computed by: (25)
 
where 
 comprises some parts of Lagrangian function (18) which take effect from the variable 
 and is equal to (26)
 
 

In a similar way, the value of 
 is computed by (27)
 
 
 where 
 comprises some parts of Lagrangian function that take effect from 
. More clearly, it is intended to find a value for 
 that minimizes Lagrangian function. When we are computing a value for 
, for all , 
, and , the 
 is invariant, so 
 is equal to (28)
 
 
 where (29)
 

4.2. Algorithm description
In the previous subsection, we introduce the mathematical aspects of proposed algorithm that utilizes Lagrange, sub-gradient and decomposition methods. This subsection describes the pseudo-code of proposed algorithm which is shown in Algorithm 1.

Initially and at the iteration , the variables 
, 
, 
 and 
 start with some preliminary values (lines 3–7 of pseudo-code). These values of variables are considered as the best obtained values, so they are stored by a procedure which is called Store. Afterward, based on the current values of variables, the upper bound or maximum achieved value for Lagrangian function is computed. In particular, the upper bound is calculated by: (30)
 
 

After initializations, the entire statements of while is repeated. In practice, the number of repetitions is defined by Termination_Criterion() which determines the algorithm convergence. A criterion is 
 and 
, that means all of the obtained sub-differentials at all nodes are zero. This termination may never occur even if there is an optimal solution for the problem because sub-gradient algorithm has a random behavior. For the verification of the algorithm, we use a constant number as the number of repetitions that is more practical. To determine the number of iterations, some simulations are carried which are demonstrated in Section 5.

Step_Size_Select() provides two positive numbers for the step-sizes of algorithm (
 and 
). As mentioned, step-size selection has a considerable effect on the algorithm performance and we discus it in Section 5. Afterward, the node 
 executes Exchange_Negh() to exchange the current values of variables (
, 
, 
 and 
) to its one-hop neighbors 
. Subsequently, the node 
 utilizes the relation (25), (27), (19), (20) to obtain new values for 
, 
, 
 and 
, respectively. Based on the values of variables in the iteration , the upper bound, 
, is computed. Finally, if 
 then the new values of variables are better than which are obtained in all previous iterations, so these values are stored by Store(). If 
 then the previous stored data is better, therefore the node 
 updates its achieved upper bound by 
.


Download : Download high-res image (264KB)
Download : Download full-size image
The proposed approach is a decentralized algorithm because its statements only require the values of variables which exist on an arbitrary node or can be obtained with direct communication with its one-hop neighbor. In other words, it is neither necessary to know the global topology of the network nor any other nonlocal information, therefore the proposed algorithm is a decentralized approach.

5. Performance evaluation
This paper considers controlling the topology of network-coding-based WSNs with multiple sources and proposed a convex programming and a decentralized algorithm which are called OpMuToNe and DeMuToNe, respectively. In this section, simulation setup and results are presented that show the performance of these approaches.

To evaluate the performance of studied approaches, we consider that the nodes are randomly deployed in a 
 square region. The number of sensors and sinks are equal to 
 and 
, respectively. Due to random deployment, simulations are repeated for  times, and the presented results are the average outcomes of these repetitions. The number of sensors that periodically generate multicast packets is equal to 
, and they send their flows to all sinks. The sources originate 256-bit UDP packets at random intervals with the exponential distribution such that the average of that is . We assume that the nodes utilize SMAC (synchronized MAC protocol) and the channel is ideal. We also suppose that each node has random remaining energy generated by a uniform distribution from  J to  J (to have different initial energies). Other simulation parameters are defined in Table 2. Furthermore, all optimization problems are modeled by AMPL (A Mathematical Programming Language) [11] and solved by MINOS (Modular IN-Core Nonlinear Optimization System). The constructed topology of all approaches are implemented in the INET Framework of OMNeT++ [30].

If the nodes run the proposed algorithm in an asynchronous manner at different rates without synchronization, then each node performs its update independently of others by using out-of-date sub-gradients. Asynchrony increases the risk of divergences, and the convergence analysis of asynchronous algorithms tends to be more challenging [3]. In other words, if the nodes are asynchronous, then the algorithm converges under more restrictive conditions than its synchronous counterpart. In addition, various network mechanisms (e.g. SMAC protocols) needs such synchronization.

In the following, the experiments are organized into two subsections, first, we evaluate the effectiveness of OpMuToNe versus traditional optimized approaches, latter, the simulations that assess the performance of DeMuToNe are demonstrated.


Table 2. Simulation parameters.

Parameter	Value
3
5.1. Evaluating the optimization approach
OpMuToNe is an optimization model (the relations (8)–(13)) and its outcomes specify the transmission range of nodes (consequently topology) and the network-coding-based flows between the sources and sinks (the routes). We compare OpMuToNe with OToNec [23] and ORaNec [18] which considered energy consumption and the lifetime, respectively. Although these approaches combine topology control with network coding, they do not clarify how multiple sources are considered in their simulations. In other words, ORaNec and OToNec consider a multicast connection 
 and specify 
 and 
 for every node 
. In the following, we describe our approach for applying multiple sources in OToNec and ORaNec. Let 
 defines both graph and network flow which are constructed based on the source  by OToNec. Similarly, we define 
 and then two sets 
 and 
 are provided. From these sets, two new compound graphs, 
 and 
, are extracted, which are utilized in the simulations. Practically, the transmission range of nodes in the compound graph 
 is equal to the maximum of obtained ranges in the set 
, i.e. for every node 
. To make a proper comparison, two variants of ORaNec (are called ORaNec1 and ORaNec2) and OToNec (are called OToNec1 and OToNec2) are considered which differ in determining the optimal flows. The network flows are re-computed based on the compound graphs for ORaNec1 and OToNec1 while ORaNec2 and OToNec2 utilize the network flows of ORaNec and OToNec, respectively. More clearly, OToNec1 and ORaNec1 ignore the computed flows, and calculate the network-coding-based-multicast routes for the compound graphs. Therefore, for each source in OToNec1 and ORaNec1, a linear programming is raised that re-computes the optimal route. Note, recomputing the routes for ORaNec1 and OToNec1 has an overhead and increases computation time, especially in a dynamic network. We could find the multicast routes without network coding consideration, but it is proven that non-coding approaches exhaust higher energy [17], [32].

Fig. 2 shows the energy consumption of the approaches as a function of the pair 
, where 
, and 
. ORaNec optimizes the lifetime and may use the routes with more energy, so its variants waste more energy than others. Although, the transmission ranges in both ORaNec1 and ORaNec2 are the same, the results show that ORaNec1 achieves better results in comparison with ORaNec2. The reason for this observation is that all routes in ORaNec1 use larger transmission ranges (see the definitions of ORANec variants). Also, OToNec2 exhausts more energy in comparison with OToNec1, so re- computing of routes leads to better results. There is a direct relation between the number of packets and the chance of encoding packets together (network coding opportunity), therefore raising the network load leads to more network coding opportunity. OpMuToNe enjoys from this situation and wastes less energy than other approaches in the high loads (more 
 and lower ). More clearly, this experiment shows that the energy consumption of OToNec1 is lower than OpMuToNe, although OpMuToNe is better in the case  and 
.


Download : Download high-res image (537KB)
Download : Download full-size image
Fig. 2. The effect of 
 and  on the energy consumption, where 
, and 
.

Fig. 3 shows the effect of 
 on energy consumption, where 
, 
, and . If 
 then OpMuToNe consumes a lower energy versus OToNec1 while if the number of sink decreases, OpMuToNe wastes more. The results show that ORaNec2 exhausts higher energy than others. In addition, OToNec1 and ORaNec1 respectively provide better results than OToNec2 and ORaNec2, because they re-compute the flows for the compound graphs and utilize larger transmission ranges for all sources.

Fig. 4, Fig. 5 respectively compare the total and per-node energy consumption of approaches in the presence of the various density (number of sensors), where 
, 
, and . Clearly, increasing the number of sensors raises the total consumed energy and reduces the per-node consumption. In particular, if the number of sensors increases, more nodes collaborate in the load conducting, which leads to raising the total energy consumption. However, increasing the 
 decreases the portion of consumed energy that corresponds to each node. This experiment shows that OpMuToNe acts better in the denser networks and its effectiveness increases in a network with more 
.


Download : Download high-res image (267KB)
Download : Download full-size image
Fig. 3. Energy consumption versus 
 (mJ), where 
, 
, and .

The presented results show that decreasing  as well as increasing 
, 
, and 
 leads to higher throughput for OpMuToNe. More precisely, if 
, 
, 
, and  then OpMuToNe consumes 5% lower energy, however if 
, 
, 
, and  then it operates 10% weaker versus OToNec1.


Download : Download high-res image (190KB)
Download : Download full-size image
Fig. 4. Total energy consumption (mJ), where 
, 
, and .


Download : Download high-res image (169KB)
Download : Download full-size image
Fig. 5. Per node energy consumption (mJ), where 
, 
, and .

In the next experiment, the network lifetime is assessed which is usually more important than energy consumption. In particular, there are various definitions of lifetime in the literature and its precise definition depends on the intended application. Among these definitions, we consider two following ones: first, the time elapsed between the deployment and the moment which the first node exhausts its energy that is called 
, second, 50% of the nodes run out of power that is called 
.

The effects of pair 
 on the 
 and 
 are depicted in Table 3, Table 4, respectively. In this experiment, we assume that 
, and 
. The results show that if the network load reduces (more  and less 
), the lifetime of approaches increases. ORaNec1 utilizes larger transmission ranges in all routes, therefore it achieves more than 9.5% higher 
 and 8.5% for 
 in comparison with ORaNec2. Also, the lower lifetime of OToNec variants comes from the fact that they do not take into account the remaining energies of nodes. Furthermore, OpMuToNe achieves better results versus others, because it constructs a topology with regard to all sources that exist in the network.

Table 5 shows the effect of the number of sinks on the lifetime. In this experiment, we assume that , 
, 
, and 
 is changed from  to  with the step . Clearly, all approaches achieve lower values for the 
 when compared with the 
. The results show that OpMuToNe has a higher lifetime versus others and the difference is at least 21.48% for 
 and 22.85% for 
. The gap between OpMuToNe and other approaches increases progressively. In addition, the nodes in both OToNec variants dead earlier when compared with ORANec variants and ORaNec1 leads to more than 9% higher lifetime in comparison with ORaNec2.


Table 3. The effect of 
 on the 
, where 
, and 
.

(
, )	Lifetime of approaches (ms)
OpMuToNe	ORaNec1	ORaNec2	OToNec1	OToNec2
93 115	71 823	64 787	59 219	54 205
82 276	60 791	54 836	50 123	45 879
72 699	51 454	46 413	42 424	38 832
94 604	73 259	66 083	60 404	55 289
83 592	62 006	55 932	51 126	46 797
73 861	52 482	47 340	43 273	39 609
96 118	74 724	67 405	61 611	56 395
84 930	63 246	57 052	52 147	47 732
75 044	53 531	48 289	44 137	40 400

Table 4. The effect of 
 on the 
, where 
, and 
.

(
, )	Lifetime of approaches (ms)
OpMuToNe	ORaNec1	ORaNec2	OToNec1	OToNec2
166 123	125 375	114 393	104 718	96 226
148 352	106 117	96 823	88 634	81 446
132 482	89 818	81 951	75 020	68 936
170 277	127 883	116 681	106 812	98 151
152 062	108 240	98 759	90 406	83 075
135 796	91 615	83 589	76 520	70 315
174 534	130 440	119 015	108 948	100 114
155 864	110 405	100 734	92 213	84 737
139 190	93 447	85 261	78 049	71 721
The experiments show that the lifetime of ORaNec1 is closer to OpMuToNe. Thus, we define the lifetime improvement of OpMuToNe as follows. (31)
 
where 
 and 
 denote the 
 for OpMuToNe and ORaNec1, respectively. Similarly, 
 is defined which determines the percentage of lifetime improvement corresponds to the 
 among OpMuToNe and ORaNec1. Table 6 depicts the amount of 
 and 
 in a network with various 
, and 
, where , and 
. Clearly, 
 is more than 
, also increasing 
 and 
 raises both 
 and 
. However, the effect of 
 on the lifetime improvement is more than 
. More precisely, Table 5 exhibits 
 is lower than 17% for  sources, while it is more than 19% for a network with  sources.


Table 5. The effect of number of sinks on the lifetime, where , 
, and 
.

Approaches	
2	4	6	8
ORaNec2	78 245	70 421	63 379	57 041
ORaNec1	86 742	78 068	70 261	63 235
OToNec2	65 466	58 919	53 027	47 724
OToNec1	71 521	64 369	57 932	52 139
OpMuToNe	105 381	99 058	93 115	87 528
ORaNec2	138 156	124 340	111 906	100 715
ORaNec1	151 419	136 277	122 649	110 384
OToNec2	116 215	104 594	94 135	84 722
OToNec1	126 471	113 824	102 442	92 198
OpMuToNe	186 023	175 792	166 123	156 986
Although energy consumption and the lifetime are the most important goals in WSNs, end-to-end latency is also considered in some applications. In the next experiment, end-to-end latency was examined. Fig. 6 presents the range, median, and mean of total end-to-end latency for the studied simulations. Obviously, OToNec1 provides lower end-to-end latency, while ORaNec2 has higher results. The range of latencies related to the OToNec variants is almost lower than ORaNec variants, however their gap is not considerable. In addition, the range of latencies correspond to OpMuToNe is more than OToNec variants and lower than ORaNec variants, however the gap between them is lower than 10%.


Table 6. The lifetime improvement of OpMuToNe correspond to ORaNec1, where , and 
.

20	40	60	80
5	10.83%	17.69%	17.69%	17.2%
10	12.72%	19.44%	19.44%	18.96%
15	14.58%	21.15%	21.15%	20.68%
20	16.4%	22.83%	22.83%	22.37%
25	18.18%	24.47%	24.47%	24.02%
30	19.92%	26.08%	26.08%	25.64%
5	11.98%	18.6%	18.55%	17.85%
10	14.79%	20.76%	20.71%	20.11%
15	17.51%	22.85%	22.81%	22.31%
20	20.15%	24.89%	24.85%	24.44%
25	22.69%	26.88%	26.84%	26.52%
30	25.16%	28.81%	28.77%	28.54%
5.2. Evaluating DeMuToNe
In this subsection, we assess the performance of DeMuToNe which is a decentralized algorithm in which all sensors operate in parallel.

When the sensors are executing DeMuToNe, they should exchange the intermediate variables with their one-hop neighbors. The number of these transmissions which affected by the convergence rate, specify the volume of wasting energy; however, we assume exchanging intermediate variables takes place with data packets by piggybacking, and do not waste more energy [12].

There are many results on the convergence of sub-gradient-based algorithms, however we examine convergence of DeMuToNe which proves the reliability of results. The convergence of proposed algorithm depends on the step-size selection (determining appropriate values for 
 and 
). Three common ways have been introduced and tested for step-size calculation. The first option is the constant step-size where 
 and 
 are constant for all iterations. Although there are some proofs for the convergence results corresponding to the constant step-size (e.g. [7]), our experiments show that it is inappropriate for DeMuToNe. More clearly, an arbitrary constant step-size number is either very small for a network condition or too large for another one. The small step-size leads to slow convergence and premature termination, but less oscillation occurs near the optimized solution. However, if the step-size was too large, iterations might overshoot the optimal solution and perhaps oscillate between two non-optimal solutions. The second option is the optimal step-size, which is optimal for every iteration. In particular, there is an explicit formula for the locally optimal step-size (for more detail, see [5]). However, the optimal step-size requires the optimal value of the problem which is unfortunately unavailable before solving DeMuToNe (such as the most practical problems). The last option is the diminishing step-size, which starts with moderate values and is progressively reduced up to a small positive value [6]. Practically, the simulations show that diminishing step-size is more appropriate for DeMuToNe.

Various forms of diminishing step-size have been introduced and extensive experiments are done to evaluate them. However, the sequence 
 
 is utilized to produce the step-sizes where  is a constant and positive number [7]. This sequence satisfies two fundamental requirements including: the summation of produced step-sizes tending to infinity, and as  gets higher values, then the step-size eventually gets closer to zero (the sequence has limit zero as  tends to infinity). Let 
 and 
 denote the constant numbers corresponding to 
 and 
, respectively. Fig. 7 shows the transmission range of an arbitrary node when three different 
 and 
 are utilized. In the early iterations, many oscillations occur, but it gradually converges and fewer oscillations are observed. In practice, 
 and 
 affect the algorithm performance. The simulations show that 
 and 
 provide appropriate convergence rate (for more details see [4], [7]).

The network parameters dynamically change on constant bases and the optimal solution of problem may change, accordingly. However, DeMuToNe cannot track the changes because the diminishing step-size gradually generates very small step-sizes. As an attempt to tackle this flaw, we re-initialize the step-size calculator for every 
 iterations. Fig. 8 shows the effect of 
 on both 
 and energy consumption in a network, where 
, 
, 
, and . Lower values for 
 leads to larger step-sizes and consequently more oscillations will happen close to the optimal solution, also it leads to a lower lifetime and more energy depletion. On the other hand, if 
 then very small step-sizes are generated which leads to slow convergence and premature termination. In other words, utilizing a large volume for 
 leads to more energy consumption and decreasing the lifetime because DeMuToNe does not take effect from the alterations that happens in the network. The best range to see the effect of applying re-initializer is from  to  where the energy consumption is minimized and the lifetime is maximized. More clearly, if 
 then 
 is approximately 5% more than when 
. Furthermore, our experiments show that the network with more sensors and sinks needs larger 
.


Download : Download high-res image (448KB)
Download : Download full-size image
Fig. 7. The effect of 
 and 
 on the convergence rate of DeMuToNe.

In the next experiment, the lifetime of DeMuToNe is assessed. However, the form of DeMuToNe’s solutions differs from the previous experiments and is not constant overtime. More clearly, DeMuToNe provides a solution (transmission range and network flows) for each iteration and needs some iterations to converge while OpMuToNe provides an optimal solution based on the initial parameters. Thus, we introduce the instantaneous lifetime 
 and 
 for DeMuToNe which are estimated based on the values of variables at the iteration . Take into consideration that the irregular behavior of DeMuToNe in achieving the optima leads to some oscillations on the instantaneous lifetime in the process of time. Fig. 9 shows the instantaneous lifetime of a network, where 
, 
, 
, and . In this figure, 
 and 
 present the average of  repetitions in the instantaneous lifetime, also 
 and 
 present the optimal OpMuToNe’s lifetime (determined based on the initial parameters). In the early iterations, DeMuToNe produces some non-optimal solutions that lead to lower lifetime than OpMuToNe. If , DeMuToNe outperforms OpMuToNe, because DeMuToNe balances the energy consumption among the nodes in the process of time. By elapsing time increasing the , the gap between DeMuToNe and OpMuToNe is raised. Moreover, 
 and 
, that means we need more iterations to have higher 
 in comparison with 
. Note, if the solving process of OpMuToNe is repeated in each iteration and its optimal solution is utilized in the network, then it always provides a higher lifetime than DeMuToNe. In fact, solving OpMuToNe in a network with  sensors takes about  h, consequently solving OpMuToNe in each iteration is impractical and almost impossible especially in a large-scale and widespread WSN. To make a proper evaluation, we assess a variation of DeMuToNe that utilizes initial energy instead of the remaining energy. The results show that DeMuToNe can obtain satisfactory near optimal solution, however it may miss finding the global solution. Practically, this variation of DeMuToNe converges to OpMuToNe in 95% of repetitions.


Download : Download high-res image (211KB)
Download : Download full-size image
Fig. 8. The effect of 
 on the lifetime and energy consumption, where 
, 
, 
, and .

In the next experiment, the effects of 
 on the performance of DeMuToNe is investigated. Fig. 10 shows the lifetime until 50% of nodes death in a network with different number of sinks, where 
, 
, and . Clearly, increasing the 
 reduces the lifetime. However, the rising slope related to the 
 is more than when more sinks are deployed. In other words, increasing 
 leads to a reduction in the climbing rate. Thus, if more sinks are employed in a network then the convergence rate decreases and more iterations are needed to have 
.


Download : Download high-res image (349KB)
Download : Download full-size image
Fig. 9. The 
, 
, 
, 
, 
, and 
 in the process of time, where 
, 
, 
, and .

To measure the efficiency of DeMuToNe in comparison with OpMuToNe, the lifetime improvement is defined as follows: (32)
 
where 
 denotes the time that first node death in a network that employs DeMuToNe. Similarly, we define 
 that shows the lifetime improvement which is provided by DeMuToNe for 50% of nodes death. Table 7 shows 
 and 
 regarding to the 
 and 
 in a network that , and 
. We observe that the lifetime improvement is at least 10% which corresponds to a network that 
, and 
. The results show that 
 is between 15% and 31.97% while 
 is lower than 18.06%, thus the improvement of DeMuToNe is higher for 
. Moreover, both 
 and 
 raise when the number of sensors and sinks are increased. In other words, we can obtain more benefit from utilizing DeMuToNe in denser networks.

The previous simulation shows that the 
 and 
 have a considerable effect on the lifetime improvement for both 
 and 
. To investigate the effect of 
, 
, and  on the performance of DeMuToNe, further experiments are carried out in a network with fixed number of sinks. Table 8, Table 9 respectively show 
 and 
 in a network with  sinks and various 
, , and 
. Clearly, in a denser deployment (higher 
) with higher network load (more 
 and lower ), both 
 and 
 increase. More in detail, a network with 
, 
, and  achieve 
 and 
 while the achievement is 
 and 
 for a network with 
, 
, and .


Table 7. The lifetime improvement of DeMuToNe correspond to the OpMuToNe, where , and 
.

20	30	40	50
10.00%	11.00%	12.65%	14.93%
11.00%	12.10%	13.92%	16.42%
12.10%	13.31%	15.31%	18.06%
15.00%	16.50%	18.98%	22.39%
17.85%	19.64%	22.58%	26.64%
21.42%	23.56%	27.10%	31.97%
In spite of the efficiency of the proposed decentralized algorithm, this article ignores three issues that may be considered in the future researches. First, the transmitted signals may have additional power loss because of environmental factors such as noise, interference, reflection, and obstructions. This extra power loss leads to an irregular transmission region around a node. Second, the distance between nodes calculated by the positioning systems or Received Signal Strength Indication (RSSI), cannot obtain perfectly accurate. Later, the effect of the mobility of sensors on the performance of convergence rate is not studied. Therefore, proposing a decentralized algorithm for combining topology control and network coding in lossy links is critical in the future work.


Download : Download high-res image (292KB)
Download : Download full-size image
Fig. 10. The 
 and 
 for various 
, where 
, 
, and .


Table 8. The effect of 
,  and 
 on 
, where 
.

20	30	40	50
10	11.10%	13.54%	17.20%	22.19%
20	13.10%	15.98%	20.29%	26.18%
30	16.24%	19.81%	25.16%	32.46%
40	20.14%	24.57%	31.20%	40.25%
10	10.00%	12.20%	15.49%	19.99%
20	11.80%	14.40%	18.28%	23.58%
30	14.63%	17.85%	22.67%	29.25%
40	18.14%	22.14%	28.11%	36.26%

Table 9. The effect of 
,  and 
 on 
, where 
.

20	30	40	50
10	16.10%	20.61%	26.69%	34.96%
20	19.24%	24.63%	31.89%	41.78%
30	24.82%	31.77%	41.14%	53.89%
40	32.51%	41.62%	53.89%	70.60%
10	15.00%	19.20%	24.86%	32.57%
20	17.93%	22.94%	29.71%	38.92%
30	23.12%	29.60%	38.33%	50.21%
40	30.29%	38.77%	50.21%	65.78%
6. Conclusion
This paper addresses network lifetime optimization in a WSN that employs both network coding and topology control, jointly. The proposed convex optimization problem considered multiple sources in a network in which can provide higher efficiency. However, obtaining its solution faces some essential difficulties especially for large networks. By utilizing Lagrange dual, sub-gradient and decomposition methods, a decentralized and iterative algorithm was developed which obtains optimal lifetime for a WSN. In practice, the problem is broken into smaller sub-problems, the solving of each part is performed by a sensor that executes the local incremental update on own variables. The proposed algorithm creates an automated and dynamic structure for WSNs, which continuously changes the transmission range of nodes and routes. Simulation results validate the proposed algorithm from the convergence and performance perspective. The proposed algorithm can provide 70% higher lifetime in comparison with solving an optimization problem for a network. As a part of future research, it is important to enhance a decentralized approach for combining network coding with topology control in WSNs with the non-ideal communication channel for mobile WSNs.