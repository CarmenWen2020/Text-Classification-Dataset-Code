Abstract
In this paper we present two deterministic distributed algorithms for the Steiner tree (ST) problem in the CONGEST model. The first algorithm computes a 2(1−1/ℓ)-approximate ST using O(S+nlog⁎⁡n) rounds and O(mS+n3/2) messages for a graph of n nodes and m edges, where S is the shortest path diameter of the graph and ℓ is the number of leaf nodes in the optimal ST. It improves the round complexity of the best distributed ST algorithm known so far, which is O˜(S+min{St,n}) [34], where t is the number of terminal nodes. The second algorithm improves the message complexity of the first one by dropping the additive term of O(n3/2) at the expense of a logarithmic multiplicative factor in the round complexity. We also show that for graphs with S=O(log⁡n), a 2(1−1/ℓ)-approximate ST can be deterministically computed using O˜(n) rounds and O˜(m) messages and these complexities almost coincide with the results of some of the singularly-optimal minimum spanning tree (MST) algorithms proposed in [15], [22], [37].


Keywords
Steiner tree
Distributed approximation algorithm
Singularly-optimal

1. Introduction
Network optimization problems are prevalent in computer networks, distributed systems, and operations research. There are generally two kinds of network optimization problems in the distributed setting: local and global. Graph coloring [2], [31], maximal independent set [21], [44] etc. are a few examples of the local variety. A network optimization problem is considered as a global problem if solving it necessitates the collaborative computational effort of all the nodes, and information must travel to the farthest nodes in the network. In the last few decades solving network optimization problems in the distributed setting has received remarkable attention, especially in the CONGEST model [39]. In this model, a communication network coincides with the input graph, nodes are considered computationally unbounded, the communication among nodes is bi-directional, and the bandwidth of each link is restricted to  bits, where n is the size of the network.1 A few global problems such as breadth first search (BFS) tree, spanning tree etc. require  rounds [39], where D is the unweighted diameter of the network whereas for some other problems like finding the diameter [17], all-pairs shortest paths [16], [24] etc. it is even hard to achieve round complexities near linear in n in the CONGEST model. There is a significant amount of work for many other global problems such as MST [11], [29], [32], Steiner forest [28], [34] etc. in the CONGEST model of distributed computing.

In this work we focus on solving a global optimization problem called the “Steiner tree” problem (denoted as ST problem) in the CONGEST model. It is a fundamental problem in the area of network optimization and is defined as follows.

Definition 1.1 ST problem

Given a connected undirected graph  and a weight function , and a set of vertices , known as the set of terminals, the goal of the ST problem is to find a tree  such that  is minimized subject to the conditions that  and .

Formulation of the ST problem in the CONGEST model. The input graph G coincides with the communication network. Each vertex of G is uniquely mapped to a node (processor) and edges of G are naturally mapped to the links between the corresponding nodes. Each node knows whether the vertex assigned to it is a terminal or not. All nodes run the same algorithm for the ST problem. Regarding output, whenever an algorithm for the ST problem terminates, each node knows whether the vertex assigned to it is in the solution or not and which of its incident edges are in the solution. For termination, each node terminates the algorithm for the ST problem in a finite time.

Note that if , then the ST problem reduces to the problem of finding the shortest path between two distinct nodes in the network. On the other hand, if , then the ST problem becomes the MST problem. The ST problem is a generalization of the MST problem. It is known that the MST problem can be solved in polynomial time, however the ST problem is one of the original 21 problems proved NP-complete by Karp [25]. The best known (polynomial time) approximation ratio for solving the ST problem in the centralized setting is , for any constant  due to Byrka et al. [5]. It is also known that the ST problem can not be solved in polynomial time with an approximation factor  [9] unless .

There are many variations of the ST problem such as Directed Steiner tree, Metric Steiner tree, Euclidean Steiner tree, Rectilinear Steiner tree, and so on. Hauptmann and Karpinski [23] provide a website with continuously updated state of the art results for many variants of the problem.

The ST problem finds applications in numerous areas such as VLSI layout design, communication networks, transportation networks, content distribution (video on demand, streaming multicast) networks, phylogenetic tree reconstruction in computational biology etc. Moreover the ST problem appears as a subproblem or as a special case of many other problems in network design such as Steiner forest, Prize-collecting Steiner tree etc.

Motivation. Elkin [13] showed that approximating MST within any constant factor on graphs of small unweighted diameter  requires  rounds (assuming B bits can be sent through each edge in each round). Das Sarma et al. [11] achieved an unconditional lower bound on round complexity of the MST problem and showed that approximating MST within any constant factor requires  rounds. The deterministic lower bounds on round and message complexities of the MST problem in the CONGEST model are  [40] and  [33] respectively.2 Since the ST problem is a generalization of the MST problem, the lower bounds on round and message complexities of the MST problem also apply for the ST problem in the distributed setting. It is therefore highly desirable to obtain a round or message optimal distributed algorithm which computes a near optimal ST. The best round complexity known so far for solving the ST problem in the CONGEST model of distributed computing is due to Lenzen and Patt-Shamir [34] which takes  rounds,3 where S is the shortest path diameter of the graph (definition is deferred to Section 2) and , and the result is optimal up to a factor of . There is quite a gap in the round complexity between the best known MST algorithm [19], [32] and the best known ST algorithm (both in the CONGEST model). Nevertheless the following interesting question is still open:

“What is the best approximation factor that can be achieved in solving the ST problem while incurring a round complexity cost that is close to that of the best known MST algorithm?”

Until 2016, algorithms were known for the MST problem which are either time-optimal [14], [32] or message-optimal [1], [18], but not both simultaneously. Recently a few singularly-optimal distributed algorithms have been proposed for the MST problem [15], [22], [37] beating the long standing time-message trade-off.4 However such a study has not been carried out for the ST problem in the distributed setting. Therefore another intriguing question is:

“Can we achieve a distributed algorithm for the ST problem in the CONGEST model whose round and message complexities coincide with that of the singular optimality results of the MST algorithms [15], [22], [37] while maintaining an approximation factor of at most 2?”

Our work in this paper is one step towards answering the above two questions.

Our contribution. In this paper we present a deterministic distributed algorithm for the ST problem (henceforth it will be denoted as DST algorithm) in the CONGEST model [39] having an approximation factor of , where ℓ is the number of leaf nodes in the optimal ST. The DST algorithm has a round complexity of 
⁎
, which is better than the best distributed ST algorithm known so far [34]. The algorithm also significantly reduces the round complexity gap between solving the ST problem and the MST problem in the CONGEST model. The message complexity of the DST algorithm is .

The DST algorithm is inspired by a couple of centralized algorithms. It consists of four steps (each step is a small distributed algorithm) — the first step is to build an SPF of the given input graph  with a terminal set , which is essentially a partition of G into disjoint trees: Each partition contains exactly one terminal and a subset of non-terminals. A non-terminal v joins a partition containing the terminal  if , . Note here that  denotes the (weighted) length of the shortest path between nodes u and v. In second step, weights of the edges are suitably changed; in third step, the GKP algorithm (Garay, Kutten, and Peleg [19], [32]) is applied on the modified graph to build an MST; and finally some edges are pruned from the MST in such a way that in the remaining tree (which is the required ST) all leaves are terminals.

The main contribution of this paper is stated in the following theorem.

Theorem 1.1

Given a connected undirected weighted graph  and a terminal set , there exists a deterministic distributed algorithm that computes an ST using 
⁎
 rounds in the CONGEST model with an approximation factor of , where ℓ is the number of leaf nodes in the optimal ST.

We also investigate the round-message trade-off in computing ST in the CONGEST model of distributed computing. Specifically we replace the third step of the DST algorithm by the singularly-optimal MST algorithm proposed by Elkin [15] which helps us achieve the round and message complexities of  and  respectively and still achieve an approximation factor of . The polylogarithmic factors involved with the round and message complexities of the modified DST algorithm are  and  respectively. We note that in the modified DST algorithm the message complexity is better than that of the original DST algorithm; however the round complexity is marginally poorer than that of the original DST algorithm. Specifically we prove the following theorem.

Theorem 1.2

Given a connected undirected weighted graph  and a terminal set , there exists a deterministic distributed algorithm that computes an ST using  rounds and  messages in the CONGEST model with an approximation factor of .

As a by-product of the above theorem, for networks with constant or sufficiently small shortest path diameter  the following corollary holds.

Corollary 1.3

If , then a -approximate ST can be deterministically computed with the round and message complexities of  and  respectively in the CONGEST model.

Note that in case of , the round and message complexities of the modified DST algorithm are  and  respectively, which almost coincide with the best known singular-optimality results of distributed MST construction in the CONGEST model due to [15], [22], [37] and the approximation factor of the resultant ST is at most .

Related work. There is a long line of study of polynomial time approximation algorithms [7], [26], [30], [41], [42], [46], [47], [49], [50] for the ST problem in centralized setting. Byrka et al. [5] proposed a polynomial time centralized algorithm for the ST problem for general graphs which has the best approximation factor of , for any constant . Borradaile et al. [4] proposed a polynomial time approximation scheme (PTAS) for ST problem in planar graphs. Combining the algorithmic paradigms of approximation scheme and parameterization, Dvořák et al. [12] proposed an efficient parameterized approximation scheme that computes a -approximate ST, for any constant , using  time units, where ,  is the optimum ST, and  is the set of vertices in .

Regarding the distributed algorithms for the ST problem, there are a number of works which are mainly based on the MST heuristic, the shortest path heuristic (SPH), and the average distance heuristic (ADH). Chen et al. [8] proposed the first MST heuristic based deterministic distributed algorithm for the ST problem in the asynchronous CONGEST model and achieved an approximation factor of . The time and message complexities of the algorithm proposed by Chen et al. are  and  respectively, where . The SPH based 2-factor distributed approximation algorithms for the ST problem have been proposed in [3], [43], [45]. In SPH based algorithms, it is assumed that each node knows in advance the shortest path distances to all other nodes in the network. One of the approaches is Prim based SPH (P-SPH) [3], [43] (aka cheapest insertion heuristic) where only a single tree grows at a time in the network. The time and message complexities of the P-SPH based algorithms presented in [3], [43] are  and  respectively. Novak et al. [36] improved the algorithms proposed in [3], [43] and achieved a better approximation ratio using simulation; however the worst-case complexities remain same as of [3], [43]. Bauer et al. [3] proposed a Kruskal based SPH (K-SPH) algorithm to construct a multicast tree (which is essentially the ST) whose time and message complexities are  and  respectively and its approximation factor is 2. Singh and Vellanki [45] studied distributed algorithms for constructing multicast trees (STs), and presented a K-SPH based algorithm which improved (by simulation) the message complexity to .

A more generalized version of the K-SPH is the ADH [48]. The execution of the ADH based algorithms begin with a set of components, initially each one consists of a terminal node. In each iteration, two components are merged by a path that crosses a node that has a minimum average distance to those two components. The ADH based algorithm terminates with a single tree, spanning all the terminal nodes. The distributed version of the ADH was proposed by Gatani et al. [20] whose approximation factor is 2 and its time and message complexities are  and  respectively.

Chalermsook et al. [6] presented a 2-approximate deterministic distributed algorithm for the ST problem in the CONGEST model with round and message complexities of  and  respectively. Khan et al. [28] presented an -approximate randomized distributed algorithm for the ST problem in the CONGEST model with round complexity  and message complexity . Recently Lenzen and Patt-Shamir [34] presented two distributed algorithms for the Steiner forest problem (a more generalized version of the ST problem) in the CONGEST model: one is deterministic and the other one is randomized. The former one finds, a -approximate Steiner forest using  rounds, where k is the number of terminal components in the input. The latter one finds a -approximate Steiner forest using  rounds with high probability. Note that if  then the Steiner forest problem reduces to the ST problem. In this case the round complexities of the two algorithms in [34], in which one is deterministic and the other one is randomized reduce to  and  respectively.

Performances of some of the distributed algorithms mentioned above, together with that of our work, are summarized in Table 1.


Table 1. Summary of results for ST problem in distributed setting. Here n = |V|, m = |E|, t = |Z|, DT = deterministic, RM = randomized, and “-” means that the parameter is not discussed in the corresponding paper. Note that, the time and message complexities of all the algorithms presented in [3], [20], [36], [43] are shown for the situation where a node does not have the prior information of distances to all other nodes in the network.

Model	Type	Round complexity	Message complexity	Approx.
Chen et al. [8]	Asynchronous CONGEST	DT	O(n(n − t))		2(1 − 1/ℓ)

[3], [36], [43]	LOCAL	DT	O(tD + n)	O(mn)	2

Gatani et al. [20]	LOCAL	DT	O(tD + n)	O(mn)	2

Chalermsook et al. [6]	Synchronous CONGEST	DT		O(tn2)	2

Khan et al. [28]	Synchronous CONGEST	RM			

Lenzen et al. [34]	Synchronous CONGEST	DT		O(mn)	2 + o(1)
RM		-	2 + o(1)

This paper	Synchronous CONGEST	DT	
⁎
O(Sm + n3/2)	2(1 − 1/ℓ)
2(1 − 1/ℓ)
Paper organization. The rest of the paper is organized as follows. In Section 2 we define the system model and notations. Section 3 contains the description, an illustrating example, and the correctness of the SPF algorithm. Section 4 contains the description, an illustrating example, and the correctness of the DST algorithm. Section 5 describes the round-message trade-off in distributed ST construction. We conclude the paper in Section 6.

2. Model and notations
System model. We consider the CONGEST model as specified in [39]. A communication network is modeled as a weighted undirected graph , where V is the set of nodes, E is the set of communication links, and  is a weight function. We assume that each node has a unique identity (ID) which can be encoded in  bits. Each node knows the weight of each edge incident to it. We also assume that the weight of each edge in G is either a non-negative integer or a non-negative real number which can be encoded in  bits and therefore polynomially many sums of weights can be encoded in  bits. Nodes communicate and coordinate their actions with their neighbors by passing messages (of size  bits) only. In general, a message contains a constant number of edge weights, node IDs, and arguments (each of them is polynomially bounded in n).

The algorithm proceeds in synchronous rounds as follows. At the beginning of each round, each node receives all the messages sent to it. After that each node performs some local computation based on the messages received in that round. Then each node sends (possibly different) messages on its incident links, which will be processed in the next round. The round complexity is measured by the number of rounds required until all the nodes terminate. The message complexity is measured by the number of messages sent until all the nodes terminate. It is also assumed that nodes and links do not fail.

Notation. We use the following terms and notations.

•
 denotes the weight of an edge e.

•
 denotes the set of edges incident on a node v.

•
 denotes the height of a node v with respect to the (rooted) tree T.

•
 denotes the set of child nodes of a node v with respect to the (rooted) tree T.

•
 denotes the source node of a node v with respect to the (rooted) tree T. Intuitively  denotes the root of a tree T in which v is a descendant.

•
 denotes the tentative  of a node v.

•
 denotes the length of the weighted shortest path between v and . Similarly  denotes the tentative length of the weighted shortest path between v and 
.5

•
 denotes the weighted distance6 between nodes u and v.

•
Let . Then at node v,  denotes the tentative distance of a neighbor node incident on the other end of e. Similarly at node v,  and  denote the ID and the tentative source respectively of a neighbor node incident on the other end of e.

•
 and  denote the predecessor and tentative predecessor respectively of a node v.

•
 denotes the message 
. Here 
 are the arguments of the message M. Note that unless it is necessary, the arguments of  will not be shown in it.

•
 denotes the number of edges in a weighted shortest path between u and v. Note that there may be more than one weighted shortest path between u and v. In this case,  is the number of edges of the weighted shortest path having the least number of edges.

•
 (or S for short) denotes the shortest path diameter of a given weighted graph G, which was first introduced by Khan and Pandurangan [27].  
 . Note here that .

3. SPF construction
Definition 3.1

SPF [8]
Let  be a connected undirected weighted graph, where V is the vertex set, E is the edge set, and 
 is the non-negative weight function. Given a subset , a SPF is a sub-graph 
 of G consisting of disjoint trees 
,  such that

•
For all i, 
 contains exactly one node 
 of Z.

•
For all 
, 
, where 
.

•
 and 
 for all .

•
.

•
The weighted shortest path between v and 
 in 
 is one of the weighted shortest paths between v and  in G.7

Regarding distributed SPF construction in the CONGEST model, Chen et al. [8] presented a deterministic distributed algorithm to construct an SPF for  of a graph  with the round and message complexities of  and  respectively, where , and . Lenzen and Peleg [35] studied a similar problem called source detection. Given an unweighted graph , a subset  of source nodes, let 
 denote the (ascending) lexicographically ordered list of pairs , where  and  is the length of the (unweighted) shortest path from s to v. The 
-detection problem requires that each node  learns the first 
 entries of 
, where 
 is the number of sources  satisfying that 
. Lenzen and Peleg [35] showed that 
-detection problem can be solved using 
 rounds in the CONGEST model.
3.1. Distributed SPF algorithm
In this subsection we give a detailed description of the SPF algorithm that constructs an SPF using  rounds and  messages in the CONGEST model. It will be used later as a subroutine in the DST algorithm. It is inspired by the well known Bellman-Ford algorithm. We assume that at the beginning of the algorithm there exists a BFS tree 
 of G rooted at a terminal r. Note that a BFS tree can be deterministically computed using  rounds and  messages in the CONGEST model [39]. We also assume that r, the root node knows the height (denoted as ) of 
.

The height of a node is the number of edges on the longest path between that node and a leaf of the subtree rooted at that node. The height of a tree is the height of the root node r. Intuitively r can compute  using a broadcast and convergecast procedure as follows. Initially r sends a message called  to all of its child nodes in the BFS tree. Upon receiving , each node forwards it to all of its child nodes. Whenever a leaf node v in the BFS tree receives , it sets its  to 0 and sends a message called  to its parent. Upon receiving 
 from each of its child nodes 
, an internal node u sets  to 
 and sends the resulted  to its parent. In this way eventually r receives the heights of all of its child nodes. Then it computes 
, which is the required height of the BFS tree. It is obvious that r can compute  using  rounds and  messages. Since  can be at most D, the round complexity of computing  in the worst-case is .

Input. Each node knows whether it is a terminal or not, and the set of edges incident to it. Let  denotes the parent of a node v in the BFS tree T, rooted at r. Except r, all other nodes in T know their parents; for r we assume that . Initially, , and  for each node . Furthermore r uses two additional local variables called height and start_flag which are initially set to h  and false respectively.

Output. Whenever the algorithm terminates, , , and  for each node .

Outline of the algorithm. The special node r initiates the algorithm by setting , , , , and sending  messages on all of its incident edges. After that if r does not receive any message in a round, it sets height to . Whenever height becomes −1, r sets start_flag to false and the algorithm terminates.

Let U and Y denote the set of  and set of  messages respectively received by a node v in an arbitrary round. Upon receiving a set of  or  messages  or  a node v acts as per the following rules.

R1.
if , then it resets height to h.

R2.
if  and  and for the first time it receives some messages, then it sets , , and .

R3.
if  and , then it computes  for each  ∈U and chooses the minimum one, say 
 resulted by 
, 
. If 
, then it updates 
, 
, and 
. Otherwise, ,  and  remain unchanged.

R4.
if  is updated, then

(a)
sends  on all of its incident edges.

(b)
sends  to .

R5.
if  is not updated and , then v sends  to .

Termination detection. Termination of an algorithm is a state in which no message is in transit or sent by any node in the network. The root r of the BFS tree detects the termination of the SPF algorithm. Whenever r finds that the local variable height becomes −1, it terminates the algorithm. At the beginning of the algorithm, r sets height to h. If r does not receive any message in a round, it sets height to . During the execution of the algorithm a node v sends an  message to  in any one of the following two cases.
1.
it updates its local state

2.
receives  message from at least one of its child nodes

The above two cases guarantee that an  message generated at any node in the network eventually reaches r. If r receives some messages, it resets height to h. Since h is the height of the BFS tree, it is guaranteed that from the time of any change of local state in a node (which generates an  message), r receives this information (by receiving an  message) after at most h rounds. This ensures that r resets height to h before it becomes −1 in at most h rounds from the time of any changes occur in the network. In case r does not receive any message for  consecutive rounds, this ensures that no changes have been occurred at any node in the network in last  rounds. In this case height becomes −1 and r terminates the algorithm by setting start_flag to false.

3.2. An illustrating example of the SPF algorithm
Let us consider the application of the SPF algorithm in a graph  as shown in Fig. 1(a). The thick edges represent the BFS tree. The set of source nodes (terminals) is  and B is the root of the BFS tree. The initial tentative source, tentative distance, and tentative predecessor of each node are shown in the table. The root node B starts the algorithm by sending  messages to all of its neighbors. Fig. 1(b) shows the states of all the nodes after the second round of the algorithm. Upon receiving  messages, nodes A, C, H and I update their local information. Arrows along the edges indicate the tentative predecessors (tπ) of the nodes, except for those whose predecessors are yet undefined. Similarly, Fig. 1(c) and Fig. 1(d) pictorially depict the state of the graph after the third and fourth rounds of execution of the algorithm respectively. Fig. 1(e) shows the state of the graph after the sixth round of execution of the algorithm. The final SPF 
 (indicated by the thick edges) for Z of G and a table which contains the lengths of shortest paths of all the nodes to their respective sources are shown in Fig. 1(f).

Fig. 1
Download : Download high-res image (226KB)
Download : Download full-size image
Fig. 1
Download : Download high-res image (430KB)
Download : Download full-size image
Fig. 1. (a) A weighted connected graph G = (V,E,w) with the terminal set Z = {B,G,J,R}, and B is the root of the BFS tree. The initial values are shown in the table. (b) After the second round, all neighbors of B receive 〈update〉 message and update their local information. The updated values are shown in the table. (c) After the third round of execution of the algorithm. (d) After the fourth round of execution. (e) After the sixth round of execution. (f) The final SPF GF = (V,EF,w) for Z of G is indicated by the thick edges.

3.3. Correctness of the SPF algorithm
Lemma 3.1

The SPF algorithm terminates after at most  rounds.

Proof

At the beginning of the algorithm, r sends an  message to all of its neighbors. Whenever a node v receives  messages, if applicable, it updates its own states and then sends  messages including its updated parameters to all of its neighbors and an  message to . This guarantees that after h rounds of execution every node in the network receives at least one  message.

After h rounds of execution, all nodes proceed in parallel and in every subsequent round, upon receiving  messages, if applicable, each node updates its local state. Since S is the shortest path diameter, any path in the SPF contains no more than S edges. The SPF algorithm has a single initiator (the root node r of the BFS tree). This implies that a leaf node v may be delayed of updating its local information by h rounds; such a node v converges to its correct  value in at most S additional rounds. Therefore, in the worst-case, after  rounds of execution no local changes occur at any node in the network. Note that every time local changes occur at a node v, it sends  message to . Since after at most  rounds no changes occur at any node in the network, after  rounds an  message can not be generated by any node in the network due to any local changes. However after  rounds of execution of the algorithm, some  messages can be still in transit in the network which were generated on or before 
 round. In this case, upon receiving a set of  messages, a node v simply sends an  message to . Since h is the height of the BFS tree, it is guaranteed that from the time of any change of local state in a node (which generates an  message), r receives this information (by receiving an  message) after at most h rounds. In case r does not receive any message for h consecutive rounds, it ensures that no changes have been occurred in any node in the network in the last h rounds. In this case r terminates the algorithm in the next subsequent round. Therefore after at most  rounds of execution, no further messages related to the SPF algorithm will be sent or in transit in the network. This concludes that the SPF algorithm terminates after at most  rounds. □

Theorem 3.2

The round complexity of the SPF algorithm is .

Proof

Lemma 3.1 ensures that the SPF algorithm terminates after at most  rounds. We know that h is the height of the BFS tree. Since , the round complexity of the SPF algorithm is . □

Theorem 3.3

The message complexity of the SPF algorithm is .

Proof

The SPF algorithm uses two types of messages:  and . During the execution of the algorithm, in a round, a node can send at most two messages ( and ) on an edge. This ensures that, in a round, at most four messages are exchanged on an edge (two messages from each end). Since the input graph G has m edges, in a round,  messages are exchanged in the worst-case. By Theorem 3.2, the SPF algorithm terminates in  rounds. Therefore, the overall message complexity of the SPF algorithm is . □

Lemma 3.4

Let 
 be the length of the tentative (weighted) shortest path from node v to  after i rounds . Suppose the SPF algorithm terminates after X rounds . Then for each node , 
.

Proof

During the execution of the SPF algorithm, terminal nodes () do not maintain distance information to any other node in the network; they keep the record of only their own local information. Whenever a node  receives an  message for the first time, it updates its , , and these values remain the same throughout the execution of the algorithm. Therefore, for every , 
 for any .

Let 
 be the length of a shortest path from v to  after k rounds of execution of the algorithm. Now we prove by induction that for every , 
 for .

Base case : In this case  for every node . This ensures that no path exists between v and  for every . Therefore, for every node  
.

Inductive step : Let P be the path from v to  which is formed after  rounds and u be the node through which v joins P. Let R be the path from u to . Since v joins P in which u is the predecessor of v, . By the induction hypothesis, 
, where  denotes the length of R.

After k rounds, v updates 
. Since v joins u,
 Therefore 
 holds for any . Note that whenever the algorithm terminates, no update happens for  for each node . The termination state ensures that  and  for each node . Therefore we conclude that if the SPF algorithm terminates after X rounds, then 
 for each node . □

4. DST algorithm
4.1. Preliminaries
Definition 4.1

Complete distance graph [30], [49]
A graph 
 is called a complete distance graph on the node set  of a connected undirected weighted graph  if for each pair of nodes , there is an edge  in 
 and the weight of the edge  is the length of a shortest path between u and v in G.

Our DST algorithm is inspired by the principles of two centralized algorithms — one is by Kou et al. [30] (Algorithm H) and the other one is by Wu et al. [49] (Algorithm M). For the sake of completeness, below we briefly describe the working principles of both the algorithms.

The worst-case approximation ratio of the DST algorithm follows from the correctness of the Algorithm H. For a given connected undirected weighted graph  and a set of terminal nodes , Algorithm H computes an ST 
 as follows.

1.
Construct a complete distance graph 
.

2.
Find an MST 
 of 
.

3.
Construct a sub-graph 
 of 
 by replacing each edge of 
 with its corresponding shortest path in G.

4.
Find an MST 
 of 
.

5.
Construct an ST 
 from 
 by deleting edges of 
 so that all leaves of 
 are terminal nodes.

The running time of the Algorithm H is 
. Following the principles of both Prim's and Krushkal's algorithms, Wu et al. [49] proposed a faster algorithm (Algorithm M) which improves the time complexity to , achieving the same approximation ratio as of the Algorithm H. The speed-up is achieved by computing a so-called generalized MST 
 for Z of G in one step as opposed to the multiple steps of the Algorithm H. The generalized MST is defined as follows.
Definition 4.2

Generalized MST [49]
Let  be an undirected weighted graph and Z be a subset of V. Then a generalized MST 
 is a sub-graph of G such that

•
there exists an MST 
 of the complete distance graph 
 such that for each edge  in 
, the length of the unique path between u and v in 
 is equal to the weight of the edge  in 
.

•
all leaves of 
 are in Z.

and it is clear that 
 is an ST for Z in G and is the actual realization of 
. In summary, the Algorithm M constructs a generalized MST 
 for Z of G as follows.
Initially, the set of nodes in Z are treated as a forest of  separate trees and we successively merge them until all of them are in a single tree 
. A priority queue Q is used to store the frontier vertices of paths extended from the trees. Each tree gradually extends its branches into the node set . When two branches belonging to two different trees meet at some node then they form a path through that node merging these two trees. The algorithm always guarantees to compute only such paths of minimum length for merging trees.

GKP algorithm. Since we use the GKP algorithm proposed by Garay, Kutten, and Peleg [19], [32] as a subroutine in the DST algorithm, here we give a high-level description of the same. Note that GKP algorithm has the best known deterministic round complexity (
⁎
) for MST construction in the CONGEST model. It is a combination of two algorithms: the GHS algorithm due to Gallager, Humblet, and Spira [18] and Pipeline algorithm due to Peleg [38]. The key idea is to apply GHS algorithm on a given graph until the diameter of each fragment becomes . The GHS algorithm is applied up to  phases and at the end it ensures that there are at most  fragments. The running time of this part is 
⁎
. In the second part, it uses the Pipeline algorithm to find at most () MWOE (minimum weight outgoing edges) to connect all the remaining fragments (). In the Pipeline algorithm initially a rooted BFS tree 
 is built. Let r be the root of 
. Using the edges of 
, the information about all the candidate edges which are inter-fragment tree edges are sent to the root r using pipelining and each intermediate node v of 
 filters out all candidate edges that have largest weight in a cycle. Eventually the root r of 
 collects all inter-fragment tree edges with their weights, constructs an MST (
) by considering each fragment as a super node. Then r broadcasts the edges in 
 to all the respective nodes by using the edges of 
. Since the height of 
 is at most D and each node sends at most  edges upward (in case of the collection of the inter-fragment tree edges by r) and at most  edges downward (in case of broadcasts), the running time of the Pipeline algorithm is . Therefore the overall round complexity of the GKP algorithm is 
⁎
. However the second part of the GKP algorithm is responsible for its large message complexity which is 
.

4.2. DST algorithm
In this subsection we present the outline of the DST algorithm. It has a round complexity of 
⁎
. There are four steps (small distributed algorithms) in the DST algorithm. The speed-up is achieved due to step 1 and step 3. Step 1 computes an SPF using  rounds. Step 3 computes an MST using 
⁎
 rounds due to the application of the GKP algorithm.

We assume that a BFS tree rooted at some terminal node () of G is available at the start of the algorithm (any node  can be considered as the root of the BFS tree). The root node r initiates the algorithm. Note that an ordered execution of steps is necessary for the correct working of the DST algorithm. We assume that the root r ensures the ordered execution of steps (from step 1 to step 4) and initiates step  after step i is terminated. The outline of the proposed DST algorithm is as follows.

Step 1.
(SPF construction). Construct an SPF 
 for Z in G by applying the algorithm described in Subsection 3.1. This produces  disjoint shortest path trees. Each such tree contains one terminal, which is the root of the tree, and a subset of non-terminals. A non-terminal v is included in a tree rooted at  if , . Theorem 3.2 and Theorem 3.3 ensure that the round and message complexities of this step are  and  respectively.

The graph 
 is the basis for the construction of the generalized MST for  of G (denoted as 
). To construct 
, the following two steps (Edge Weight modification and MST construction) (in order) are necessary.

Step 2.
(Edge Weight modification). With respect to the SPF 
, each edge  of the graph  is classified as any one of the following three types.

(a)
tree edge: if 
.

(b)
inter_tree edge: if 
 and end points are incident in two different trees of 
.

(c)
intra_tree edge: if 
 and end points are incident in the same tree of 
.

Now transform  into 
. The cost of each edge  is computed as follows.

(a)
 if  is a tree edge.

(b)
 if  is an intra_tree edge.

(c)
 if  is an inter_tree edge. In this case 
 realizes the weight of a path from the source node  to the source node  in G that contains the inter_tree edge .

The classification of the edges of G and the transformation to 
 can be done as follows. Each node v of G sends a message called ) to all of its neighbors. Let a node v receives  on an incident edge . If , then v sets  as an inter_tree edge and 
 to . On the other hand, if , then  can be either a tree edge or an intra_tree edge: if  or , then node v sets  as tree edge and 
 to 0. Otherwise, v sets  as intra_tree edge and 
 to ∞.

Assuming that the root (r) of the BFS tree initiates this step, it is clear that step 2 can be performed using  rounds. Also on each edge of G, the message  is sent exactly twice (once from each end). Therefore, the message complexity of step 2 is .

Step 3.
(MST construction). Construct an MST 
 of 
. The 
 contains all tree edges and  inter_tree edges of 
. Specifically, in this step, we apply the GKP algorithm to construct the MST 
. The round and message complexities of the GKP algorithm are 
⁎
 and 
 respectively.

Step 4.
(Pruning). Construct a generalized MST 
 from 
. This is accomplished by performing a pruning operation in the 
. The pruning operation deletes edges from 
 until all leaves are terminal nodes. Pruning starts at the non-terminal leaf nodes. A non-terminal leaf node v prunes itself from 
 and instructs its neighbor u to prune the common edge  from the 
. This process is repeated until no further non-terminal leaf nodes remain and we get the final 
 which contains  inter_tree edges and all leave nodes are in Z. Now edge weights of the 
 are restored to w.

Since pruning can be started in parallel from all the non-terminal leaf nodes of the 
 and any non-terminal leaf node v can be at most S hops away from  (which is a terminal node), step 4 can be performed using  rounds. Also, in pruning, at most one message is sent on each edge of 
. Since 
 has exactly  edges, the message complexity of step 4 is .

The DST algorithm terminates with step 4.
4.3. An illustrating example of the DST algorithm
Let us consider the application of the DST algorithm in a graph  shown in Fig. 2(a). The set of terminals (sources) is . An SPF 
 for Z is constructed which is shown in Fig. 2(b). In 
, each non-terminal node v is connected to a terminal node  whose distance is minimum to  than any other terminal node in G which is shown in the table of Fig. 2(b). The graph G with 
 is shown in Fig. 2(c). The construction of graph 
 and labeling of the edge weights according to the definition of 
 are shown in Fig. 2(d). Fig. 2(e) shows after the application of the GKP algorithm on 
 which constructs an MST 
 of 
. The final ST 
 for Z of G, which is a generalized MST for Z of G is constructed from 
 by performing a pruning operation, which is shown in Fig. 2(f).

Fig. 2
Download : Download high-res image (408KB)
Download : Download full-size image
Fig. 2. (a) A graph G = (V,E,w) and a terminal set Z = {B,G,J,R}. (b) An SPF GF = (V,EF,w) for Z of G. The distances of nodes to their respective sources are shown in the table. (c) The graph G with GF. (d) The graph Gc = (V,E,wc). (e) An MST TM of Gc. (f) The final ST TZ (generalized MST) for Z of G.

4.4. Correctness of the DST algorithm
Theorem 4.1

The round complexity of the DST algorithm is 
⁎
.

Proof

Each of step 1 and step 4 of the DST algorithm takes  rounds. Step 2 and step 3 take  and 
⁎
 rounds respectively. Since , the overall round complexity of the DST algorithm is 
⁎
. □

Theorem 4.2

The message complexity of the DST algorithm is 
.

Proof

It is clear that the overall message complexity of the DST algorithm is dominated by step 1 and step 3. By Theorem 3.3, the message complexity of step 1 is . Also the message complexity of step 3 is 
. Combining all steps (step 1 to step 4) we get that the message complexity of the DST algorithm is 
. □

Definition 4.3

Let X be a subgraph of an undirected weighted graph . Then  denotes the sum of weights of all the edges in X.

Now we show that the DST algorithm constructs an ST with an approximation factor of  (recall that ℓ is the number of leaf nodes in the optimal ST). Towards this we show the following.

•
The computed 
 is a generalized MST for Z of G.

•
The cost of 
 is at most  times the cost of an optimal ST (
), i.e., 
 
.

Lemma 4.3

(Chen et al. [8], Page 81, Lemma 2). The length of any path containing an  edge  between two terminal nodes in G is greater than or equal to 
.

Consider a graph 
⁎
⁎
⁎
 whose vertex set is Z and whose edge set 
⁎
 is defined from 
 as follows. For each  edge  of 
, there is an edge  in 
⁎
 such that , and 
⁎
. Then we claim the following lemma.

Lemma 4.4

⁎
 is a spanning tree of a complete distance graph 
 for  of graph .

Proof

To prove 
⁎
 is a spanning tree of 
, we need to show that i) 
⁎
 is acyclic and ii) 
⁎
 spans all the nodes of Z.

Since 
 is a tree, each pair of nodes in 
 is uniquely connected. This implies that each edge is a cut edge of 
. A path between two distinct terminal nodes in 
 contains at least one  edge of 
. According to the definition of 
⁎
, each edge of 
⁎
 corresponds to a path which contains exactly one  edge of 
. This implies that each edge of 
⁎
 is a cut edge and there exists exactly one unique path for each pair of nodes in 
⁎
. Therefore 
⁎
 contains no cycle.

It is given that the end points of an edge of 
⁎
 correspond to two terminal nodes of 
. Since 
 has exactly   edges and all of them are considered to construct 
⁎
, 
⁎
 contains exactly  edges. The preceding fact plus the acyclic property of 
⁎
 ensure that 
⁎
 spans exactly t nodes, i.e., all the nodes of 
. □

Lemma 4.5

⁎
 is an MST of 
.

Proof

By contradiction let 
⁎
 is not an MST of 
 and instead of that 
 is an MST of 
. Therefore 
 is different from 
⁎
 by at least one edge. For simplicity we consider that 
 is different from 
⁎
 by one edge. Suppose the distinct edges in 
⁎
 and 
 are  and 
 respectively. Recall that 
⁎
 denotes the weight of an edge e in 
. Since by assumption 
 and 
⁎
⁎
, this implies that 
⁎
⁎
. We prove by contradiction that 
⁎
⁎
 does not hold.

Since  is an edge in 
⁎
, according to the definition of 
⁎
,  corresponds to an  edge  of 
 such that  and 
⁎
. By Lemma 4.4 
⁎
 is a spanning tree of 
. Note that  is an edge of 
. This ensures that 
⁎
 corresponds to the weight of a shortest path between a and b in G. Since the path between a and b in G contains the  edge , by using Lemma 4.3 we get(1)
⁎

Similarly assuming that the path between 
 and 
 in G contains the  edge 
, where 
 and 
, by using Lemma 4.3 we get,(2)
⁎

Note that  is an edge of 
. If we remove  from 
, 
 will split into two subtrees 
 and 
 containing u and v respectively. Since  is included in the 
, the distributed MST algorithm (GKP algorithm, step 3 of the DST algorithm) must selected  as an MWOE (minimum weight outgoing edge) to merge 
 and 
 instead of selecting the edge 
 as an MWOE. This guarantees that 
. Now using (1) and (2) we get 
⁎
⁎
, a contradiction to the fact that 
⁎
⁎
. Therefore 
⁎
 is an MST of 
.

Now by induction assume that 
 differs from 
⁎
 by multiple edges. Considering each such edge one by one and using the same logic described above we can show that the assumption does not hold. This concludes that 
⁎
 is an MST of 
. □

Definition 4.4

Straight path
Given that  is a connected undirected weighted graph and . Let  are two distinct nodes. Then a path 
 (may contain only one edge) between u and v is called straight if all the intermediate nodes in 
 are in .

Note that since 
 is built from 
 by pruning all the non-terminal leaf nodes, all the leaf nodes of 
 are in Z. Furthermore, by Lemma 4.5 there exists an MST 
⁎
 of 
 in which each edge 
⁎
⁎
 of 
⁎
 corresponds to a shortest straight path between the nodes 
⁎
 and 
⁎
 in G. Therefore we claim the following theorem.
Theorem 4.6

The tree 
 computed by the DST algorithm is a generalized MST for  of G.

Since 
 is the actual realization of 
⁎
 for Z of G, 
. Now if we substitute 
 of the theorem 1 in Kou et al. [30] by 
, then we get the following theorem.

Theorem 4.7

.

The correctness of the above theorem essentially follows from the correctness of the Theorem 1 (Kou et al. [30], Page 144). For the sake of completeness here we give the outline of the correctness. Let 
 consists of  edges. Then there exists a closed walk8 
 in 
 in such a way that
•
every edge in 
 appears exactly twice in L. This implies that 
.

•
every leaf of 
 appears exactly once in L. If 
 and 
 are two consecutive leaves in L, then the sub-walk connecting 
 and 
 is a path.9

Note that L can be decomposed into ℓ paths (recall that ℓ is the number of leaf nodes in the 
), each of them connects two consecutive leaf nodes in L. By deleting the longest path from L, the remaining walk (say P) in L satisfies the followings.
•
every edge in 
 appears at least once in P.

•
.

Now assume that 
 is a generalized MST for Z of G. We know that 
 realizes the MST 
⁎
 of the complete distance graph 
 for Z of G. In other words 
. Note that each edge  in 
⁎
, where , corresponds to a shortest straight path between u and v in 
. This ensures that the weight of an edge  in 
⁎
 is at most the length of a path (say 
) between nodes u and v in P. In other words, for each edge  in 
⁎
, where , 
⁎
. If we consider all the edges of 
⁎
, then 
. This concludes that 
.

4.5. Simulation results of the DST algorithm
Considering some arbitrary networks with varying number of nodes and links, few graphs are plotted for the proposed DST algorithm and compared with two best known deterministic distributed ST algorithms due to Lenzen and Patt-Shamir [34] and Chalermsook et al. [6]. Fig. 3 depicts the simulation results of the “number of rounds vs. network size”. In all the cases, i.e., (a) , (b) , and (c) , the DST algorithm outperforms the other algorithms in terms of the round complexity.

Fig. 3
Download : Download high-res image (430KB)
Download : Download full-size image
Fig. 3. Simulation results of the “number of rounds vs. network size” of the proposed DST algorithm against the algorithms due to Lenzen and Patt-Shamir [34] and Chalermsook et al. [6].

Fig. 4 depicts the simulation results of the “approximation factor vs. varying number of leaf nodes in the optimal ST”. The plotted graphs clearly depicts that the DST algorithm outperforms the other algorithms in terms of the approximation factor.

Fig. 4
Download : Download high-res image (155KB)
Download : Download full-size image
Fig. 4. Simulation results of the “approximation factor vs. varying number of leaf nodes in the optimal ST” of the proposed DST algorithm and the algorithms due to Lenzen and Patt-Shamir [34] and Chalermsook et al. [6].

Fig. 5 depicts the simulation results of the “number of messages vs. network size and network links”. For the cases of (a)  and (b) , which are shown in Fig. 5(a) and Fig. 5(b) respectively, the DST algorithm outperforms the other algorithms in terms of the message complexity. For the case of , which is shown in Fig. 5(c), the performance of the DST algorithm is significantly better than the performance of the algorithm due to Chalermsook et al. and almost coincides with the performance of the algorithm due to Lenzen and Patt-Shamir in terms of the message complexity.

Fig. 5
Download : Download high-res image (1MB)
Download : Download full-size image
Fig. 5. Simulation results of the “number of messages vs. network size and network links” of the proposed DST algorithm and the algorithms due to Lenzen and Patt-Shamir [34] and Chalermsook et al. [6].

5. Round-message trade-off in distributed ST construction
There exists a few singularly-optimal distributed algorithms for the MST problem [15], [22], [37] which address the long standing time-message trade-off. To the best of our knowledge, till date, no such algorithm exists for the ST problem. In this section we investigate the round-message trade-off of ST construction in the CONGEST model. Towards this we show that a -approximate ST can be deterministically computed using 
 rounds and 
 messages.

Regarding the singularly-optimal distributed algorithms, Pandurangan et al. [37] proposed a randomized singularly-optimal distributed algorithm for the MST problem with the round and message complexities of 
 and 
 respectively. Note that both the round and message complexities of the algorithm proposed by Pandurangan et al. are optimal upto a polylogarithmic factors in n and the factors are 
 and 
 respectively.10 Elkin [15] proposed a simple deterministic distributed algorithm for the MST problem with the near-optimal round and message complexities of  and 
⁎
 respectively. Recently Hauepler et al. [22] proposed a singularly-optimal distributed algorithm for the MST problem which is deterministic in nature but they do not explicitly specify the polylogarithmic factors involved with the round and message complexities. However, it is apparent from their analysis that the rounds and messages incurred by their algorithm are 
 and 
 respectively.

Elkin's algorithm [15]. We use Elkin's algorithm as a subroutine in the modified DST algorithm (see Subsection 5.1). Note that it is the best singularly-optimal deterministic distributed MST algorithm till date. The algorithm starts with the construction of an auxiliary BFS tree 
 rooted at some root node r. It consists of two parts. The first part constructs an -MST forest11 which is termed as the base MST forest. In the second part, the algorithm from [37] is applied on top of the base MST forest to construct the final MST. Specifically in the second part, the Boruvka's algorithm is applied in such a way that merging of any two fragments requires  rounds.

The first part of the algorithm runs for  phases. At the beginning of a phase i, (i varies from 0 to ), the algorithm computes 
-MST forest (
). Each node updates its neighbors with the identity of its fragment. This requires  rounds and  messages. Every fragment 
 of diameter 
 computes the MWOE 
. For each 
, , , a message is sent over 
 by u and the receiver v notes down u as a foreign-fragment child of itself. In case the edge  is the MWOE for both the neighboring fragments 
 and 
, the endpoint with the higher identity fragment becomes the parent of the other endpoint. This defines a candidate fragment graph 
, where 
 is the set of fragments whose diameter is 
 and each such fragment is considered as a vertex of 
 and 
 is the set of MWOEs of all the fragments in 
. The computation of the candidate fragment graph 
 requires 
 rounds and  messages. Then a maximal matching of 
 is built by using the Cole-Vishkin's 3-vertex coloring algorithm [10]. The computation of a maximal matching of 
 requires 
⁎
 rounds and 
⁎
 messages. The phase i ends at the computation of a maximal matching of the candidate fragment graph 
. Hence the running time of a phase i is 
⁎
 and it requires 
⁎
 messages. Since the first part runs for  phases, the overall time and message complexities to construct a base MST forest are 
⁎
 and 
⁎
 respectively.

In the second part, the algorithm in [37] is applied on the top of the -MST forest (). This part maintains two forests: one is the base MST forest  which is already computed in the first part of the algorithm and the other one is the MST forest 
 obtained by merging some of the base fragments into the fragments of 
 via Boruvka's algorithm. The second part of the algorithm requires  phases. In each phase , it does the following. In every base fragment , the MWOE  is computed (in parallel in all base fragments) that crosses between  and 
, where 
 is the larger fragment that contains F. This step requires  rounds and  messages. Once all  MWOEs are computed, all of these information are sent to r of 
. This is done using pipelined convergecast procedure over 
, in which each vertex u in 
 forwards the lightest edge for each fragment 
 to its parent in 
. This step requires 
 rounds and 
 messages. Then the root node r (i) computes MWOE 
 for every 
, (ii) computes a graph whose vertices are fragments of 
 and edges are the MWOEs, and (iii) computes the MST forest 
. After that r sends  messages over 
 using pipelined broadcast where each message is of the form 
, and  and 
. The root 
 of the base fragment F (each base fragment has a root node) receives this information 
 and broadcasts the identity of 
 as the new fragment identity to all the vertices of F. This takes  rounds and  messages. Finally each vertex v updates its neighbors in G with the new fragment identity. This requires  rounds and  messages. Combining both the parts, the overall round and message complexities of Elkin's algorithm are  and 
⁎
 respectively.

5.1. Modified DST algorithm
Observe that the asymptotic term 
 involved with the message complexity of the DST algorithm presented in Subsection 4.2 is the bottleneck. To get rid of the asymptotic term 
 from the message complexity we modify the DST algorithm. Similar to the DST algorithm there are four steps (small distributed algorithms) in the modified DST algorithm namely— step 1 (SPF construction), step 2 (Edge weight modification), step 3 (MST construction), and step 4 (pruning). Specifically we replace step 3 of the DST algorithm by the singularly-optimal MST algorithm proposed by Elkin [15]. The other steps of the modified DST algorithm remain the same as that of the original DST algorithm.

The correctness of the modified DST algorithm and its approximation factor, which is , directly follows from the correctness of the algorithm proposed by Kou et al. [30].

Round complexity. By Lemma 3.2, step 1 of the modified DST algorithm takes  rounds. Step 2 and step 3 of the modified DST algorithm take  and  rounds respectively. Since step 4 also takes  rounds, the overall round complexity of the modified DST algorithm is . We know that . Therefore 
. Note that the polylogarithmic factor involved with the round complexity of the modified DST algorithm is at most .

Message complexity. By Lemma 3.3, the message complexity of step 1 of the modified DST algorithm is . The message complexities of step 2, step 3, and step 4 are , 
⁎
, and  respectively. It is clear that the overall message complexity of the modified DST algorithm is dominated by step 1 and step 3. Combining these two steps we get that the message complexity of the modified DST algorithm is 
⁎
. Note that 
⁎
, and since the graph G is connected, . Therefore we can write 
⁎
. The polylogarithmic factor involved with the message complexity is at most 
.

Observe that in case of , the round and message complexities incurred by the modified DST algorithm are 
 and 
 respectively. This implies that for graphs with , the round and message complexities of the modified DST algorithm coincide with the results of the singularly-optimal MST algorithms proposed in [15], [22], [37] and the cost of the resultant ST is at most  of the optimal.

5.2. Simulation results of the modified DST algorithm
In this subsection, considering some arbitrary networks of varying number of nodes and links, few graphs are plotted for the modified DST algorithm and compared with the DST algorithm and the algorithm due to Lenzen and Patt-Shamir [34]. Fig. 6 depicts the simulation results of the “number of messages vs. network size and network links”. It is clear from Fig. 6(a) that for the case of , the modified DST algorithm outperforms the other algorithms in terms of the message complexity. In case of , which is shown in Fig. 6(b), the performance of the modified DST algorithm almost coincides with the performance of the DST algorithm in terms of the message complexity. However, for the case of , which is shown in Fig. 6(c), the other algorithms perform better than the modified DST algorithm in terms of the message complexity.

Fig. 6
Download : Download high-res image (1MB)
Download : Download full-size image
Fig. 6. Simulation results of the “number of messages vs. network size and network links. Graphs are plotted for the modified DST algorithm against the DST algorithm and the algorithm due to Lenzen and Patt-Shamir [34].

Fig. 7 depicts the “number of rounds vs. network size” and clearly shows that the DST algorithm always outperforms the modified DST algorithm in terms of round complexity. In case of , which is shown in Fig. 7(c), the performance of the modified DST algorithm almost coincides with the performance of the algorithm due to Lenzen and Patt-Shamir in terms of the round complexity. For all other cases, the Lenzen and Patt-Shamir's algorithm outperforms the modified DST algorithm in terms of the round complexity.

Fig. 7
Download : Download high-res image (534KB)
Download : Download full-size image
Fig. 7. Simulation results of the “number of rounds vs. network size”. Graphs are plotted for the modified DST algorithm against the DST algorithm and the algorithm due to Lenzen and Patt-Shamir [34].

6. Conclusion
In this paper we have proposed DST, a deterministic distributed algorithm for the ST problem that computes a -approximate ST with the round and message complexities of 
⁎
 and 
 respectively in the CONGEST model. We have also investigated the round-message trade-off in distributed ST construction. Specifically we have proposed a modified DST algorithm which computes a -approximate ST and its round and message complexities are 
 and 
 respectively.

It is known that approximating MST within any constant factor  requires  rounds [11] (assuming B bits can be sent through each edge in each round). The well-known lower bound of message complexity to find an exact MST is  [33]. Since the ST problem is a generalization of the MST problem, the above lower bounds of the MST problem are also applicable to the ST problem. Recently Byrka et al. [5] showed that in the centralized setting, the ST problem can be approximated upto a factor of  (for any constant ) of the optimal. Therefore, there are open research directions of improvement of the approximation factor, the round as well as the message complexity of the ST construction in the CONGEST model of distributed computing.
