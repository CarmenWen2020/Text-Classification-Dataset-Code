Abstract
Nowadays smartphones become an indispensable tool in many people's everyday life that makes themselves attractive targets for attackers. Among various malware targeting at smartphones, SMS-based malware is one of the most notorious ones. Though a number of Android dynamic analysis frameworks have been proposed to analyze SMS-based malware, most of these frameworks or some Android tools, such as Google Android Emulator, do not support an app or malware to send SMS messages to a real smartphone; hence, security researchers cannot use them directly to analyze the behavior of SMS-based malware. In our previous work, SMS Helper, we designed an application layer tool to allow an app or malware in an Android emulator to send and receive SMS messages to or from a real smartphone. Based on SMS Helper, this paper proposes an Android dynamic analysis framework, called SMS Observer, to assist security researchers to analyze SMS-based malware. SMS Observer integrates SMS Helper into it as a client agent, meanwhile, and it maintains the integrity of system logs. This paper also figures out a way to detect whether an app is executed in an emulator and describes how to use SMS Observer to prevent such evasion. Experimental results using real-world malware samples show SMS Observer is much more effective in detecting SMS-related behavior of SMS-based malware than existing frameworks, such as Google Android Emulator, Andrubis, CopperDroid, and DroidBox. SMS Observer can analyze sophisticated SMS-based malware samples and provide a comprehensive view of malicious behavior.


Keywords
Unified messaging
Information security
Network security
Emulation
System analysis and design


1. Introduction
Along with the rapid development of telecommunication systems, SMS-related security problems, such as propagation of malware, fraud, advertising and, even botnets, are also growing quickly. According to the reports released by Kaspersky, from 2013 to 2020, SMS Trojans occupied between top 1 and top 5 among all mobile threats [5] [6]. Besides, when telecommunication systems become more and more mature, botnets using SMS messages to communicate with each other are also growing. Nigam et al. [30] revealed a table of mobile bots in the wild that use HTTP, SMS or hybrid as their C2 type.

To detect SMS-related malicious activities, various approaches have been developed. Signature-based methods are applied by some researchers [9] [1], while these kinds of mechanisms cannot find unknown malicious apps [55]. Others use Android logging systems or SMS propagation prediction methods to detect SMS-related malware. However, these approaches need to be operated in an SMS enabled environment. Basically, current Android emulator architectures do not allow a customized app or malware to send or receive text messages to or from a real smartphone. They can only be done on physical devices. Even though SMS Trojan has become a major threat of smartphones, most Android tools and dynamic analysis frameworks in an emulator, including Google Android Emulator, neither can send SMS messages to a real smartphone nor can receive SMS messages from a real smartphone. These tools and frameworks can only simulate the above behaviors and various new techniques (e.g., packing, anti-emulator, etc.) further make them ineffective. In our previous work, SMS Helper, we designed an application layer tool to allow an app or malware in an Android emulator to send and receive SMS messages to or from a real smartphone [49]. Based on SMS Helper, this paper proposes an Android dynamic analysis framework, called SMS Observer, to assist security researchers to analyze SMS-based malware.

Moreover, this paper describes a way to detect whether an app is executed in an emulator through SMS. We found that by sending out a text message to a phone number and then check the sending status on a server, an app can know whether it is running on a real device. However, current native emulators cannot send an SMS message to a real smartphone. With SMS Observer, a researcher can avoid an app to use the above feature to detect whether it is executed in an emulator. Furthermore, if a smartphone user sends an SMS message to another user, then his phone number will show in the SMS message. If this phone number falls into the hands of non-benign persons, information leakage occurs. The user may then be harassed by advertisements or frauds. SMS Observer can provide a messaging service that is independent of a real smartphone. Hence, SMS Observer can further protect the privacy of users' real numbers.

SMS Observer provides two modes, cloud service mode and real device mode, to transmit SMS messages. Cloud service mode uses an Android emulator to transmit SMS messages; hence, no real smartphone is required to transmit SMS messages and the privacy of a user's phone number can be protected. Real device mode allows security researchers to observe the execution of an app on an Android emulator running on a computer while using a real device to transmit SMS messages. Both modes maintain the integrity of SMS and Android system event logs and prevent the logs from being tampered by attackers. SMS Observer collects and indexes the logs which allows security researchers to easily analyze SMS-related behavior of malware. Moreover, SMS Observer can integrate with any other Android dynamic analysis frameworks quickly and strengthen its capability.

To prove the effectiveness of SMS Observer, we executed 149 sample apps on SMS Observer and the other four frameworks. Experimental results show that SMS Observer can more accurately detect 4 distinct dangerous behaviors of these malicious apps than all the other four frameworks.

The organization of this paper is as follows. Section 2 describes related background knowledge and related work. Section 3 presents the system design of SMS Observer. Section 4 describes the effectiveness and efficiency of SMS Observer and discusses the security issues and future work as well. Section 5 gives the conclusion.

2. Background and related work
This section describes the background knowledge and previous works related to this paper. It is divided into three subsections. The first subsection introduces the SMS-based malware running on Adroid smartphones. The second subsection introduces comparisons of malware analysis systems running in real devices and emulators, and explains the features of various Android emulators, including official emulators and non-official ones. Moreover, anti-emulator techniques and Android dynamic analysis methods are discussed in this subsection too. Finally, the third subsection introduces related studies of detecting SMS-based malware.

2.1. SMS-based malware on Android and mobile botnet
In the past, a lot of mobile malware on Android used the SMS system to harvest victims' SMS messages and to communicate with other devices. Since late 2015, there were a significant evolution in terms of obfuscation, anti-analysis, C&C communication, and infection mechanisms [28]. The number of malware combining the use of Trojans and botnet techniques have been rising during 2017 [44] and 2018 [38], especially in the banking area, such as GMBot (also known as Slempo and SlemBunk) [10], MazarBot [50], Catelites [28] and ExpensiveWall [7]. Recently, the widespread of coronavirus results in the phenomenon that the word “covid” was used as the names of many pieces of hiding spyware, banking Trojans, adware, or Trojan droppers [6]. Moreover, sophisticated botnets were built on tainted apps to power the spread of ads and SMS fraud. Malicious apps often use compromised websites, malicious download links disseminated through social media, emails, or even SMS to spread themselves.

A botnet is a collection of compromised devices that are under the control of an attacker. There are two major models of botnets, Client-server model and Peer-to-peer. A C/S model relies on a central server to connect all bots, whereas a P2P network is a decentralized architecture that does not rely on a single server.

Compared with traditional botnets, e.g. PC botnets, mobile botnets have distinct properties. Nigam et al. [30] discussed the differences between PC botnets and mobile botnets from five points of view. For a PC botnet, the botmaster and bots are both on PCs. On the contrary, for a mobile botnet, the botmaster can be on a PC or smartphone and the slave runs on smartphones. As for connectivity, mobile botnets can use the cellular network or Internet to communicate with their botmasters. But PC botnets can only interact with botmasters through Internet only. In terms of lucrativeness, mobile devices are portable and can be carried around by users. According to Eslahi's [13], except downloading the unwanted content, fraud, adware, and data theft, with camera capturing, voice recording, SMS and GPS features, mobile devices can launch more attacks than PCs, such as tracking user locations or intercepting call logs and SMS messages. Mobile botnets are relatively easy to be taken down compared with PC botnets. However, high phone bills may expose the existence of mobile botnets.

As mentioned previously, cellular networks give mobiles another way to communicate with other devices and empower attackers to transfer commands. Furthermore, a botmaster may own a list of slaves' phone numbers [27]. A slave not only receives commands from the C&C server but also is asked to send spam to his contacts or even send premium-rate SMS messages causing financial loss [9].

The types of SMS-based botnets (i.e. SMS botnets) can be classified by the communication methods of their C&C servers and the architecture of botnets. An SMS-based botnet can be implemented by SMS-only method or SMS-HTTP hybrid method [27]. A simple example of the SMS-only bot is Android/SmsHowU.A. This bot communicates with a remote smartphone through SMS messages. As an attacker sends “How are you???” or “how are you?”, the bot responds a message containing the GPS location of the hosted smartphone [30]. Besides, Android/NickiSpy.B is a botnet working via SMS messages only. Later, variant C sends commands through SMS messages and uses the network to transmit other sensitive data [20]. Instead of using SMS messages, variant C also uses the Internet to communicate with its C&C server.

Regarding the hybrid scheme, a malware sample called Android/Smspacem.A accepts both HTTP and SMS commands from its C&C server and propagates malicious links by sending SMS messages to all contacts. A bot also uses SMS messages to tell its C&C that it is alive [30]. Using similar propagation methods, Wroba.I [16] and XXShenqi [52] also propagate malware by sending SMS messages. Wroba.I leaks banking credentials and credit card details by launching services that direct a user to a fake phishing page. On the other hand, XXShenqi sends fraudulent premium SMS messages and charges users' accounts for fake services without their knowledge. Android malware dubbed ExpensiveWall [7] that works similarly to XXShenqi but what makes it different than others is that it is ‘packed’, which is an advanced obfuscation technique used by malware developers to encrypt malicious code allowing it to evade Google Play's built-in anti-malware protections. To talk about the network topology of botnets, it can be in the centralized form or the peer-to-peer form. In a peer-to-peer design, Mulliner et al. [26] proposed a tree model to lower the number of outgoing SMS messages per device, and on the other hand, Zeng et al. [51] presented a decentralized, unstructured and pull-styled botnet.

2.2. Android emulators
According to the research of Xue et al. [47] and Alzaylaee et al. [2], 98.6% of malware samples were successfully analyzed on real smartphones, whereas only 76.84% of malware samples can be successfully inspected using emulators. The reason of this result is that most existing tools relying on emulators can be detected by various anti-emulation approaches. Hence, one of the goals of SMS observer is to remove this weakness.

On the other hand, it is a common practice that malware executes different payloads according to the commands from a remote command and control (i.e., C&C) server and the payloads often rely on a range of Android versions, hardware brands, and models, especially the APT malware. The detection rates would also vary from different samples on different devices and Android versions. And it is not easy and a time-consuming work for researchers to prepare a lot of devices and various Android versions. However, we can simply acquire most of the common devices and Android versions by using emulator software such as Genymotion. Even though some researchers such as Ning et al. [31] and Chau et al. [4] introduced container-based malware analysis structures that also provide high flexibility in utilizing various Android versions, they still need to work on a real device and have no hardware diversity.

An Android emulator enables users to test apps without a smartphone. It provides a relatively safe and low-cost platform to test apps, while it might be dangerous to test an unknown app on a real device. Moreover, a tested app may be a malicious one. While testing malware on a real device, it may crash and will cost a lot of effort to recovery the malware analysis system completely. On the contrary, we can easily recovery the analysis environment in time from a snapshot of the emulator for effective malware analysis, especially for zero-day attacks. Besides, an emulator can be upgraded to a different version more quickly. From 2013 to 2020, it has released nine versions of Android OS. It would be costly to buy mobile devices equipped with all these Android versions.

Hence, for reasons outlined above, i.e. security issues and the cost, using an emulator to test apps would be a handful. Most of the software features of Android are provided by an Android emulator, even though their performance is subject to the machine in which the emulator runs. The hardware features like the camera and the audio can be offered by the webcam and the microphone that connected to a PC, whereas the functions powered by a cellular network such as the GPS, the SMS, and phone calls can be only done by emulation. There are several emulators such as Android Emulator - the native emulator provided by Google, Genymotion, Bluestacks, DuOS, Andy, etc. that provide a virtual platform for the developers or users to run Android apps.

2.2.1. Android dynamic analysis methods
There are two types of app analysis methods, static analysis, and dynamic analysis. Dynamic analysis lets an app run in a closed environment which allows its user to observe and record the execution of the app.

To the best of our knowledge, most Android dynamic analysis frameworks cannot transmit an SMS message to a real smartphone. Hence, most of these methods mainly simulate sending and receiving SMS messages manually between two emulators in the same PC by using the command console or a text input interface of Android emulators such as Google Android Emulator, Genymotion and Bluestacks, etc. Droidbox [23] is a framework integrating TaintDroid [12] and API monitoring. It can capture outgoing calls and message events. But it cannot really transmit an SMS message to a real phone. Andrubis [45] also instruments sending SMS messages and making phone calls. Besides, Andrubis simulates the recipient of SMS message events. These features enable Andrubis to detect the events of sending SMS messages. But it still cannot receive SMS messages from real smartphones. However, if the behavior of an app is triggered by the content contained in an incoming SMS message, the emulator needs to know the trigger content which may be obtained by using static analysis.

To build a dynamic analysis framework, modifying the original system is usually inevitable. To trace privacy leaks, TaintDroid modifies many parts of the layer of the Android Open Source Project (AOSP) [3], and Andrubis makes its patches at the Dalvik level and the emulator level. AppsPlayground [33] and Droidscope [48] only modify or extend the Android emulator. CopperDroid [40] runs apps in vanilla Android while this framework collects information through its own emulator instead of the native emulator.

According to the survey on current notable sandboxes, this paper offers a lightweight method that can be easily integrated with an existing framework, no matter how the framework is built. The designers of dynamic analysis frameworks can empower their sandboxes by SMS Observer which allows an app or malware to send and receive SMS messages automatically and authentically, while the destination and the source can be either another emulator or a real smartphone.

2.2.2. Anti-emulator techniques
Android developers and malicious apps often adopt some methods to protect their apps from being analyzed using reverse engineering or dynamic analysis tools. Emulators or sandboxes are useful tools to analyze apps. Hence, developers or malicious apps often use anti-emulator techniques to forbid their apps from being executed in a virtual environment, such as an emulator or a sandbox. The anti-emulator techniques can be implemented by simply using Android APIs [53] to check phone numbers, device IDs, build properties, etc. Furthermore, system performance, hardware, and software components, e.g. Google's services, can also be used to check whether an app is executed in an emulator [41]. In a virtual environment, the cellular network is not available. Thus, connecting to the mobile network, making a phone call, and sending an SMS is not available in an emulator. This feature provides developers or malicious apps another method to detect whether an app is executed in an emulator. For example, SMS emulation can only emulate the event of receiving SMS messages. Thus, app developers can handle the SMS receiving event for their apps. However, the emulation cannot really send/receive SMS messages to/from another phone in the real world. By checking whether an outgoing SMS message can be received by a target smartphone, a malicious app can detect whether the app is executed in an emulator.

2.3. Related work
This subsection introduces some related work about mobile botnets and SMS botnets. Traced back to 2009, there were several studies focused on mobile botnets. Flo et al. [15] firstly raised an issue about botnets spreading in mobile devices. Vural et al. [42] proposed a forensics mechanism from network activities to detect mobile botnets. Feizollah et al. [14] used machine learning to build a detection model while Eslahi et al. [13] adopted a data labeling and aggregation scheme. The detection rate can reach 99.94% but it may not guarantee to figure out new malware samples. Another study was done by Choi et al. [8] which used VPN to address the problem both in 3/4G networks and the Internet but only put forward a solution for pull-styled C&C servers.

In the academic circle, many studies implement SMS botnets. One notable PoC was conducted by Mulliner et al. [27] who developed a tree model SMS botnet to ensure that there is no broken point and every single node has limited sub-nodes in the network. Another PoC implemented by Zeng et al. [51] encountered a large amount of SMS communication. Thereby, to overcome this problem, Hua et al. [21] adopted a flooding algorithm to lower the number of SMS messages. In addition, in contrast to pull-styled bonnets proposed by Zeng et al. in 2012, Zhao et al. [54] presented a push-styled prototype. Zhao's SMS botnets were developed by utilizing the Google Cloud to Device Messaging service.

Even though signature-based mechanisms can detect SMS botnets, they do not promise to detect unknown ones. Hence, various detection methods, such as behavior-based detection, were also proposed. Nguyen et al. [29] utilized information grabbed from the Android logging system to detect botnet commands. In this study, manually distinguishing bot commands from normal SMS messages is still a challenging task. Besides, the researchers in AT&T Security Research Center deploy agents according to the device's contact list to predict the propagation of SMS messages [43]. However, this method might influence legal users due to false positives. In 2014, Alzahrani et al. adopted a hybrid architecture to detect SMS botnets [1]. The system is divided into devices and central servers. Upon receiving an SMS message, the system compares the message with its signature database and blocks the message if it matches a signature in the database. Suspicious messages are sent to a central server for further analyzing. AT&T and Alzahrani's research experimented in real devices. Especially the AT&T's work, to predict the propagation of an SMS botnet, there are plenty of mobile devices being used in this model. Hence, it is costly to maintain such a system.

Chi-Yu You et al. [49] proposed a preliminary work of this paper, called SMS Helper. It provided a proof of concept to show that people can modify a smartphone emulator to allow the emulator to send and receive SMS messages. However, the cloud server mode posed by Chi-Yu You et al. [49] can only use Twilio, which may limit its popularity. This paper removes this limitation. In present work, we study the main differences of the APIs for sending messages and the formats of the logs for receiving messages among the cloud communication services such as Twilio [37], Plivo [36], and Vonage [25]. Hence, we extend the compatibility of our system by implementing and packing the related APIs and functions for these cloud services and providing an interface to let the user choose which service they would like to use. However, for the consistency of the effectiveness evaluation, we conducted the experiments mainly by means of Twilio to prove our concept. Besides, Chi-Yu You et al. [49] did not apply their work to analyze real SMS-based malware to show that their work can really help security researchers to understand more detailed behavior of malware, especially the behavior triggered by SMS messages. SMS Observer uses SMS Helper as a major component to collect logs related to SMS-based malware. SMS Observer also utilizes log analysis software such as Elastic Stack [11] and Splunk [35] to detect the SMS-related behavior of SMS-based malware. This paper uses SMS Observer to analyze several pieces of real SMS-based malware to show that SMS Observer can assist security researchers to obtain more detailed behavior of malware, the external devices working with the malware, and the communication content used by the malware and external devices. Moreover, in this paper, we made a comparison of the capability of detecting the malicious behaviors of real SMS-based malware between SMS Observer and the other frameworks, such as Google Android Emulator, CopperDroid, DroidBox, and Andrubis. Finally, Chi-Yu You et al. [49] did not provide performance evaluation; therefore, their users cannot have a concrete idea about how much extra time they need to use their tool. This paper utilizes a benchmark tool, Antutu, and various experiments to show the performance overhead of SMS Observer. To sum up, most of the previous work are basic methods which can be achieved and has been proved. This paper further institutionalizes the mechanism and we think that business organizations can utilize this mechanism to conduct advanced malware forensic on Android OS.

3. System design
This section describes the design considerations of our system, system structure of SMS Observer, major components of SMS Observer, and an overview of cloud service mode and real device mode.

3.1. Design considerations
Most dynamic analysis frameworks' implementations are based on the modifications on Android OS. One notable framework is TaintDroid which adds inspectors in all layers of Android source code. Andrubis, Droidscope and the other methods adopt TaintDroid in their emulator. However, modifying OSes is not easy work. Along with the upgrade of OSes, related dynamic analysis frameworks also need to be upgraded, which usually is not a trivial work.

Due to the above reason, our first consideration in designing SMS Observer is integration. Hence, SMS Observer is designed on the application layer, not the framework or Linux kernel layer, so that it can be integrated with other existing dynamic analysis frameworks more easily.

The second design consideration is log integrity. A malicious app might modify the SMS database to hide its intention. To ensure the logs are not tampered, SMS Observer reserves a copy of the logs outside the virtual device. In our design, the logs can be stored in a local PC or a cloud server with the log analysis software such as Elastic Stack and Splunk.

3.2. System structure and system components
SMS Observer is implemented in the application layer and can be easily integrated with any Android emulator. The structure overview of SMS Observer is depicted in Fig. 1. SMS Observer consists of two major components, SMS Helper and SMS Observer Server. As shown in Fig. 1, SMS Helper in a local emulator, SMS Observer server, and the real device are in the local side. The remote side is a real smartphone. The local side and remote side communicate with each other either through an Internet communication service or through the local real device depending on the mode that SMS Observer uses.

Fig. 1
Download : Download high-res image (90KB)
Download : Download full-size image
Fig. 1. Structure of SMS Observer.

SMS Observer can be operated in two modes, cloud service mode and real device mode. Basically, both modes use different structures to implement similar work. No matter under which mode SMS Observer is operated, SMS Observer server is composed of the same major components, SMS Event Controller and Elastic Stack which is used for log analysis software. Both components can work on a server or a PC. Elastic Stack contains Beats, Elasticsearch and Kibana in charge of log collection, indexing and analysis in both modes. Most major components used by SMS Helper in both modes are the same. But each mode has its own special components. Subsection 3.2.2 and subsection 3.2.3 describe the major components of SMS Helper in cloud service mode and real device mode respectively.

Both modes use SMS Send Hook to interact with the framework layer. SMS Send Hook hooks sendTextMessage to detect the events of sending SMS messages and transfers the events to the corresponding components in cloud service mode or in real device mode, and helps the application to send out the messages in an emulator. Only real device mode needs the collaboration of SMS Observer Server to work on messaging events while the cloud service mode works with a cloud communication service.

Besides, for the purpose of dynamic analysis, both modes use System Checker to detect access of specific processes and files, and then create event logs, and use Event Collector to periodically read event logs and send them to SMS Observer Server. SMS Event Controller is a program in charge of the communication between SMS Helper and a real device in real device mode.

3.2.1. Device setups in different modes
There are two modes in SMS Observer. Both of them allow an app to send and receive SMS messages from an emulator to a real smartphone. Fig. 2 shows a device setup of cloud service mode. The leftmost host is a computer that not only deploys an emulator running SMS Helper, but also acts as SMS Observer Server with Elastic Stack. The rightmost device is a smartphone that works on the remote site. Initially, SMS Helper in the emulator has to hook sendTextMessage to detect the events of sending SMS messages and to execute other related operations. Furthermore, SMS Observer uses the online cloud communication service to send SMS messages. In our implementation, we used Twilio [37] as our SMS service provider. When the app in our emulator requests to send an SMS message, SMS Helper would call Twilio Rest API [34] to transmit the SMS message to the smartphone. Meanwhile, SMS Observer continuously polls the Twilio message logs [24] to retrieve new incoming SMS messages.

Fig. 2
Download : Download high-res image (65KB)
Download : Download full-size image
Fig. 2. Device setup in cloud service mode.

The other mode is real device mode. Fig. 3 shows a device setup of this mode. Instead of using an online SMS service provider, this mode needs a real smartphone to send SMS messages for the emulator. This smartphone takes the same role as an online SMS service provider. First, an emulator, a local smartphone, and SMS Observer Server with SMS Event Controller and Elastic Stack connected to the same Wi-Fi network. Both the emulator and SMS Observer Server are executed on the same PC. Next, SMS Event Controller in SMS Observer Server starts to listen to the incoming client connections. The emulator and the local smartphone connect to SMS Observer Server. An outgoing message of the emulator is sent from the emulator to the local smartphone through SMS Observer Server. Then the local smartphone sends the SMS message to the remote smartphone. An incoming SMS message would be sent from the remote smartphone to the emulator by using the reverse path. As a result, apps executed in the emulator are allowed to send and receive SMS messages by using a local smartphone.

Fig. 3
Download : Download high-res image (71KB)
Download : Download full-size image
Fig. 3. Device setup in real device mode.

The main difference between the two modes is that in real device mode the SMS Event Controller module in SMS Observer Server and SMS Receiver module in SMS Helper in a real device work together instead of the functions of Cloud Communication Service in cloud service mode. Besides, the Communicator module in Real Device mode functions the same as the combination of SMS Send Requester and Polling Requester modules in cloud service mode. Details of various modules in two modes will be introduced later.

3.2.2. Cloud service mode
In this paper, the system is implemented in an Android emulator. Fig. 4 illustrates the operation of SMS Observer in cloud service mode. The cloud service mode does not need to run any auxiliary program. In other words, it is able to make the emulator send and receive SMS messages alone with SMS Helper. In cloud service mode, SMS Helper consists of SMS Send Requester, Polling Requester, SMS Send Hook, System Checker and Event Collector and the first three components are responsible for sending SMS messages and receiving SMS messages respectively. In our implementation, we use Twilio as the cloud communication service and it can be substituted by other services like Plivo, Vonage, etc.

Fig. 4
Download : Download high-res image (183KB)
Download : Download full-size image
Fig. 4. Execution flow and components of SMS Observer in cloud service mode. (For interpretation of the colors in the figure(s), the reader is referred to the web version of this article.)

For an SMS message sending scenario, when an app in an emulator is going to send an SMS message, the app gains SmsManager service first and call function sendTextMessage later. Then, SMS Send Hook receives the function call event and passes the event to SMS Send Requester. Afterward, SMS Send Requester creates a request and asks the cloud communication service to send the SMS message. By using the above approach, SMS Helper can send an SMS message from an emulator to a real smartphone.

For an SMS message receiving scenario, it is clear that the real entity for communicating with a remote smartphone is the cloud communication service. For the remote smartphone, it only recognizes the phone number provided by the cloud communication service instead of the device executing an emulator. Therefore, the cloud communication service receives the SMS message from the remote smartphone first. On the client side, within SMS Helper, Polling Requester continues polling the message list that can be obtained from cloud communication service. If Polling Requester finds there are new messages received, it creates a new message in the emulator. To create a new SMS message in the emulator, the app should obtain the BROADCAST_SMS permission, which means the application should be signed by the system key.

In Fig. 4, the solid line path shows the control flow of sending an SMS message originating from an Android app. SMS Send Hook captures the SMS message sending event and then propagates the event to SMS Send Requester. The dot line path describes the control flow of receiving an SMS message. The SMS message receiving event is grabbed by Polling Requester firstly, and then it creates a new SMS message in the emulator. Furthermore, the green lines represent the passing flow of event logs. SMS Helper can monitor system changes by working with System Checker and can collect massages and event logs by using Event Collector either in an emulator or in a remote smartphone. Both SMS Helper and the cloud communication service will send the logs to SMS Observer Server.

3.2.3. Real device mode
In real device mode, SMS Helper is installed in both an emulator and a real device (e.g. a smartphone) associated with the emulator. These two SMS Observer clients communicate with each other through SMS Observer Server. For an SMS message sending event, SMS Observer Server passes the event from SMS Helper to a real device. Besides, SMS Observer Server brings the SMS message receiving event from a real device to SMS Helper. Hence, SMS Observer Server is required in this mode. Moreover, SMS Helper consists of five components, Communicator, SMS Receiver, SMS Send Hook, System Checker and Event Collector.

Communicator communicates with SMS Observer Server and it residing in an emulator passes not only SMS message sending events from the SMS Helper in the emulator to SMS Observer Server but also SMS message receiving events from SMS Observer Server to the SMS Helper. Oppositely, the Communicator in a real device executes the reverse operations. In other words, the Communicator in the real device transmits SMS message receiving events from the SMS Helper in the real device to SMS Observer Server.

Fig. 5 illustrates the execution flow of sending an SMS message and the execution flow of receiving an SMS message in real device mode. The solid line path originates from an app running in an emulator. The app calls API sendTextMessage which is hooked by SMS Send Hook. The app then generates an SMS message sending event and later propagates this event to the Communicator in the emulator. After the Communicator in the emulator passes the event to SMS Observer Server, SMS Observer Server notifies the Communicator in the real device. The Communicator in the real device asks the real device to send the SMS message. When an SMS message arrives at the real device, the SMS Receiver in the real device obtains the SMS message and forms an SMS message receiving event. The Communicator in the real device receives the event and tells SMS Observer Server to transmit it to the emulator. When the emulator gets the SMS message receiving event, its Communicator creates a new SMS message. Finally, the emulator receives the SMS message. For the passing flow of event logs, similar to the cloud service mode by working with System Checker and Event Collector, is shown as the green lines. All the SMS Observer clients in the emulator, the real device and the remote phone will send the logs to SMS Observer Server.

Fig. 5
Download : Download high-res image (171KB)
Download : Download full-size image
Fig. 5. Execution flow and components of SMS Observer in real device mode.

4. Evaluation
In this section, various experimental results are presented to show the effectiveness and efficiency of SMS Observer. This section is divided into three subsections. The first subsection shows the environment setup used in our experiments. The second subsection discusses the effectiveness of SMS Observer. The final part of this section is Performance Evaluation. In this part, we will show the overhead of SMS Observer.

4.1. Experimental setup
Our experimental environment is shown as Table 1. We implement the SMS Observer client in a native virtual smartphone emulated by Genymotion, a cross-platform Android emulator which can emulate various Android versions and screen size. All of the modules in SMS Helper mentioned in section 3 are developed in Android Studio with Java language, while the only one self-develop module in SMS Observer Server, SMS Event Controller, was programmed in C/C++ language. In order to grant the root privilege to SMS Helper, we adopt SuperSU [39] which allows advanced management of superuser access rights for all apps on a device which needs to be rooted. Thereafter, SMS Helper uses Xposed [46] to intercept sendTextMessage events. Xposed is a framework for modules and it can change the behavior of a system and apps without touching any APKs. The remote smartphone is an HTC EVO 3D that interacts with virtual smartphones by sending and receiving SMS messages. The local smartphone, a Sony Xperia L, is also used when the experiment works in real device mode. We also develop two test apps, SMS Sender and SMS Echoer. SMS Sender can set the duration and times of sending SMS messages while SMS Echoer can echo every SMS message it receives. As the SMS message arrives at the smartphone, the app SMS Echoer would echo the SMS message with a new timestamp.


Table 1. Experimental environment.

Components	Cloud service mode	Real device mode
SMS Observer Server	Intel Core i7-7700, 8 GB RAM, Windows 10 x64, Genymotion 3.0, Beats, Elasticsearch, Kibana, SMS Event Controller (C/C++)	Intel Core i7-7700, 8 GB RAM, Windows 10 x64, Genymotion 3.0, Beats, Elasticsearch, Kibana, SMS Event Controller (C/C++)

SMS Helper in a local emulator	Android 4.3, 5.1, 6.0 and 8.0, 1 GB RAM, SuperSU, Xposed, SMS Send Hooker, SMS Send Requester, Polling Requester, Event Collector, System Checker (Java)	Android 4.3, 5.1, 6.0 and 8.0, 1 GB RAM, SuperSU, Xposed, SMS Send Hooker, Communicator, Event Collector, System Checker (Java)

Cloud Communication Service	Twilio	None

SMS Helper in a real device	None	Sony Xperia L, 1 GB RAM, Android 4.2.2, 1 GB RAM, SuperSU, Xposed, SMS Sender, SMS Send Hooker, Communicator, Event Collector, System Checker (Java)

SMS Helper in a remote phone	HTC EVO 3D, 1 GB RAM, Android 4.0.3, 1 GB RAM, SuperSU, Xposed, SMS Echoer, Event Collector, System Checker (Java)	HTC EVO 3D, 1 GB RAM, Android 4.0.3, 1 GB RAM, SuperSU, Xposed, SMS Echoer, Event Collector, System Checker (Java)
Since we can simulate most common devices and Android versions by using an emulator, we have tested our systems on Android 4.3, 5.1, 6.0 and 8.0 for installation and operation to make sure that logs can be sent back to SMS Observer Server. For versions above Android 9.0, we need additional efforts to grant the root privilege and to use Xposed to intercept events of sending and receiving SMS messages. Therefore, we would like to reserve the technical problem as the future work. Besides, we conducted experiments mainly on Android 4.3, and tested with some newer samples such as Mazar BOT and GMBot on the other aforementioned versions to make sure the complete mechanism is able to work. Although SMS Observer may work properly the on versions above Android 4.4, changes of security features we will still discuss later.

4.2. Effectiveness
We used SMS Sender, a native MMS app, SMS Echoer, and an SMS-based anti-emulator app to test the effectiveness of SMS Observer. The SMS-based anti-emulator app uses the responses of sending SMS messages to check whether it is executed in an emulator to avoid being analyzed. SMS Sender and the native MMS app test the SMS messaging function of the emulator. SMS Echoer simulates the communication between bots of a botnet by automatically responding to every SMS message it receives. Finally, we used the SMS-based anti-emulator app to check whether SMS Observer can assist the emulator to avoid being detected by a malicious app that checks the response of sending SMS messages to decide whether it is executed in an emulator.

SMS Sender sends SMS messages every fixed period of time. SMS Sender is implemented by us while the MMS app is a native message app of an Android emulator. Execution results of both SMS Sender and the MMS app show that the SMS Helper allows an emulator to transmit SMS messages to a real smartphone.

SMS Echoer echoes the SMS messages between two devices. Hence, it should be installed in two devices, called device A and device B in this subsection. First, SMS Echoer in device A sends an SMS message to device B. After device B receives the SMS message, it replies another SMS message to device A. Similarly, after receiving the echoed SMS message, device A replies another SMS message to device B. The above activities between device A and device B repeat until we terminate SMS Echoer.

We implemented an SMS-based anti-emulator app to complete the following two jobs. First, an app can detect whether it is executed in an emulator by checking whether an SMS message can be sent to its destination. Second, whether SMS Observer can assist an emulator to avoid being detected by the above approach so that the emulator can analyze the behavior of the SMS-based anti-emulator app. Table 2 shows the experimental results of running the SMS-based anti-emulator app on Google Android Emulator and SMS Helper. As Table 2 shows, the SMS-based anti-emulator app can detect that it is executed in Google Android Emulator. However, the app cannot detect the emulator with SMS Observer; hence, people can use the emulator to analyze the behavior of the SMS-based anti-emulator app.


Table 2. The results of running an SMS-based anti-emulator app on a Google Android Emulator and an emulator with SMS Observer.

Sending SMS messages to a real smartphone	Receiving SMS messages from a real smartphone	Being Detected
Google Android Emulator	No	No	Yes
Emulator with SMS Observer	Yes	Yes	No
Since SMS Observer allows an emulator to transmit SMS messages to a real smartphone, with SMS Observer security researchers can observe an app's activities that are triggered by SMS messages. However, current dynamic analysis frameworks cannot provide the above function because they cannot transmit SMS messages to a real smartphone. Malicious apps or SMS botnets, such as Mazar BOT [50], GMBot [10], Wroba.I [16], XXShenqi [52], Nitmo.A [17], FakeInst.FZ [18], and Shedun.C [19] whose vector includes utilizing SMS approaches have run wild in the real world. They all utilize SMS messages to perform their malicious activities. We use the above malware to show that with the help of SMS Observer, researchers can get more complete information about malware which needs SMS messages to complete its work.

Firstly, Mazar BOT asks a user to install a new app with a generic name: MMS messaging when the user downloads the malware. Mazar BOT also downloads and installs a legitimate TOR Android app in the infected device without the user's interaction. Then, it runs the TOR application to connect to an onion server, and an SMS message will be sent to a phone number with “Thank you”, which seems to register itself to a remote server. If Mazar BOT is executed in an analysis tool that cannot send out an SMS message to a real smartphone, researchers cannot get the above information. We conducted some experiments to analyze Mazar BOT and GMBot, and we found that they work very similarly to each other. Firstly, Mazar BOT requests RECEIVE_SMS, SEND_SMS, and READ_SMS permissions that are written in its AndroidManifest.xml shown as follows:



Download : Download high-res image (263KB)
Download : Download full-size image
On the other hand, we found that as Mazar BOT does, GMBot requests the similar permissions shown as follows:



Download : Download high-res image (264KB)
Download : Download full-size image
Secondly, Mazar Bot will connect to a C&C server whose URI is written in its code shown as follows:



Download : Download high-res image (36KB)
Download : Download full-size image
On the contrary, GMBot will connect to a C&C server whose URI is written in its code shown as follows:



Download : Download high-res image (60KB)
Download : Download full-size image
Finally, Mazar BOT disguises as an “MMS Messaging” app and executes in the background. When a target app, such as “MobilePay”, is executed, Mazar Bot creates a window to overwrite the window of “MobilePay” so that it can steal the data that a user inputs for “MobilePay”. We also found that Mazar BOT sends stolen user data to its C&C server. Likewise, GMBot pretends to an Adobe Flash app, and do similar malicious functions.

Malicious app Wroba.I can further confirm the value of SMS Observer. One of Wroba.I's behavior is to propagate malware through SMS messages. But the action occurs only when it receives an SMS message with ak40-[MSG] which means sending an SMS message containing MSG to all contacts [30]. By simply hooking sendTextMessage as what some dynamic analysis frameworks do, the sending SMS message event can be found by these frameworks. However, without really receiving the ak40-[MSG] SMS messages, Wroba.I will not send the SMS messages which propagate malware. As a result, SMS Observer assists dynamic analysis frameworks to find more activities that an app may execute. To maintain the integrity of SMS logs, SMS Observer saves SMS logs in a remote server of a PC executing an emulator.

Another malicious app XXShenqi also propagates itself by sending SMS messages. Most Android applications use MainActivity class as an entry point; however, according to the AndroidManifest.xml configuration file of this malicious application, XXShenqi calls WelcomeActivity class to evade signature-based anti-virus detection. When XXShenqi is executed in a user's smartphone, to propagate itself, its WelcomeActivity class is used to send the user's contacts phishing SMS messages which contain a copy of the link to a malicious apk. The user's contacts are recorded in the Android user's contact list [52][47]. After installing XXShenqi, a trojan package com.example.com.android.trogoogle embedded in the app was also be installed. By using SMS Observer, we found the package will monitor some of the behaviors of the user, collect the information which the user inputs, and upload the collected information to a C&C server by sending SMS messages. The aforementioned information includes the content of the user's contacts, the content of the SMS messages sent by the user and even the personal credentials including the username and the citizen ID number input by the user on the registration page of the XXShenqi app, as shown in Fig. 6.

Fig. 6
Download : Download high-res image (62KB)
Download : Download full-size image
Fig. 6. A victim's personal credentials uploaded to a C&C server by XXShenqi using an SMS message.

Nitmo.A is a malicious Android app that has both the Trojan and Spy properties. We used SMS Observer to analyze its behavior to see what extra information we can obtain, compared with other dynamic analysis frameworks. The main application is called Mobile Security and is contained in the package com.BioTechnology.iClientsService7 [17]. In the background, the malware registers an infected device by sending HTTP POST requests to a C&C server, and sends an SMS message containing the serial number of the SIM card, the phone model, and the manufacturer to a C&C phone number, as shown in Fig. 7. Moreover, we found that it also monitors incoming SMS messages either to receive commands from its C&C server or to forward all incoming SMS messages whose content include the bot ID, the IMEI, the received SMS body and the sender's phone number to the C&C server, as shown in Fig. 8. However, without really receiving the incoming SMS messages as what SMS helper does, other dynamic analysis frameworks in an emulator would not obtain the above behavior of the malware successfully.

Fig. 7
Download : Download high-res image (56KB)
Download : Download full-size image
Fig. 7. An SMS message containing the serial number of the SIM card, the phone model, and the manufacturer. Nitmo.A sends it to its C&C server.

Fig. 8
Download : Download high-res image (54KB)
Download : Download full-size image
Fig. 8. An incoming SMS message containing the bot ID, the IMEI, the received SMS body, and the sender's phone number. The SMS message is captured by Nitmo.A and forwarded to a C&C server.

Android Trojans named FakeInst.FZ and Shedun.C do not send SMS messages to mobile phone numbers. Instead, they send SMS messages to a fixed Line phone number or Short Code. We selected packages named duchm.sa and com.par.cdcwqo which respectively belong to the two types of malware described above. We found that they have similar behaviors such as sending SMS messages frequently to charge users' accounts for fake services without their knowledge. As shown in Fig. 9, and Fig. 10, these behaviors can be captured by SMS Observer successfully.

Fig. 9
Download : Download high-res image (160KB)
Download : Download full-size image
Fig. 9. The SMS message sent by FakeInst.FZ to a fixed Line phone number.

Fig. 10
Download : Download high-res image (140KB)
Download : Download full-size image
Fig. 10. The SMS message sent by Shedun.C to Short Code.

4.3. Comparisons of malicious behavior detection accuracy
SMS Observer allows malicious apps to send and receive SMS messages to real phones; hence, as shown in subsection 4.2, compared with existing dynamic analysis frameworks, it can collect more critical information about malware. To further prove this claim, we conducted more experiments using more malicious apps, including the above 7 variants, on Google Android Emulator, CopperDroid, DroidBox, Andrubis, and SMS Observer to check what kinds of vicious behaviors can be stimulated or detected by these tools. We picked up 132 mobile bot samples belonging to 52 variants from Nigam et al. [30]. These samples request the SMS permission. If a malicious APP has more than 3 variants, we only chose 3 samples from these variants since their behaviors are similar. Because Nigam's table only contains the variants found before Oct. 2014, we also surveyed some emerging SMS-based malware from the threat reports by FortiGuard Labs, FireEye, Inc., Check Point Ltd., etc. for evaluating the effectiveness of our method on newer malware. A total of 58 variants with 149 samples shown as Appendix A were downloaded from Koodous [22], a collaborative platform and a vast APKs repository.

Table 3 shows the experimental results. In this table, each cell contains two numbers, x and y, which are shown in the form . y represents the number of malicious apps requesting this permission. x represents the number of malicious apps having been detected having the related behavior by the related dynamic analysis framework. We tested 4 types of sensitive behaviors that SMS-based mobile malware may execute, including personal information access (such as accounts, locations, and phone number), contacts list access (i.e., contacts, SMS messages, and call logs), sending and receiving SMS messages.


Table 3. Comparisons of detection accuracy in detecting sensitive behaviors executed by 149 malware samples using different dynamic analysis frameworks. 4 types of sensitive behaviors that mobile malware may execute were tested.

Behavior	Google Android Emulator	CopperDroid	DroidBox	Andrubis	SMS Observer
Personal Info access	0/149(0%)	123/149(82.6%)	41/149(27.5%)	108/149(72.5%)	131/149(87.9%)
Contact List access	12/62(19.4%)	53/62(85.5%)	55/62(88.7%)	51/62(82.3%)	57/62(91.9%)
Sending SMS	0/149(0%)	7/149(4.7%)	5/149(3.4%)	23/149(15.4%)	110/149(73.8%)
Receiving SMS	0/72(0%)	0/72(0%)	0/72(0%)	18/72(25.0%)	51/72(70.8%)
As shown in Table 3, Google Android Emulator almost cannot detect most of the behaviors because it is used to develop Android apps, not mainly for malware dynamic analysis. Some malicious apps access the contact list to find the recipients of their SMS messages. But Google Android Emulator cannot send SMS messages to a real smartphone, errors occurred and these malicious apps showed error messages to describe that they cannot send SMS messages to persons listed in the contact list. Based on the error messages, we know that these malicious apps accessed contact lists. CopperDroid and DroidBox can only simulate broadcasting SMS messages to nearby emulators. Hence, malicious apps executed on them cannot contact their C&C servers by SMS messages. Therefore, these malicious apps cannot function as expected. Although Andrubis can simulate a recipient and a sender to detect SMS message-related events, it does not allow an emulator to transmit SMS messages to or from a real smartphone or a C&C server. Hence, it cannot trigger the SMS-related behaviors of most malicious apps.

Compared with other four different dynamic analysis frameworks, SMS Observer has the best detection rate for all four tested behaviors. According to Table 3, it seems that SMS Observer has about 30% miss rate in detecting sending and receiving SMS messages. However, further analysis shows that even though some malicious apps request SMS-related permissions, they do not perform the corresponding activities. It also shows that not only benign apps will request more permissions than what they really need but also malicious apps do.

4.4. Performance evaluation
To evaluate the performance of SMS Observer, we conducted experiments through the Android benchmarking tool Antutu [32] and measured the performance overhead introduced by SMS Observer. To understand the overhead, we established a set of measurements as the baselines. A baseline represents an Antutu score which was measured with an unmodified Android running in a native emulator without installing SMS Helper and transmitting SMS messages.

4.4.1. Benchmark - Antutu
Antutu is a benchmark tool for Android devices. We use Antutu 5.7 in our experiment to measure the performance of an Android emulator. Antutu uses a score to summarize the performance of CPU, GPU, memories and user experience to represent the overall performance. A higher score indicates higher performance.

Our experiment was conducted by creating native virtual Android smartphones emulated by Genymotion which was operated on Microsoft Windows 10 x64 with Intel Core i7-7700 CPU and 8G RAM. We executed the benchmark five runs for each of the following three emulators with different configurations “Vanilla Android, Android with standby SMS Helper, and Android with working SMS Helper” and averaged their scores to evaluate their overall performance.

Vanilla Android means an unmodified Android running in a native emulator without installing SMS Helper and transmitting SMS messages. In this configuration, an Antutu score represents a baseline. Android with standby SMS Helper is an emulator that installs SMS Helper, but the emulator does not transmit SMS messages. On the contrary, Android with working SMS Helper is an emulator that installs SMS Helper and our test app SMS Sender while SMS Echoer is installed in a remote smartphone. In this configuration, these two apps sent SMS messages with each other and Antutu was used to evaluating related performance.

We evaluated the performance of Android with standby SMS Helper and Android with working SMS Helper in both cloud service mode and real device mode which were introduced in subsection 3.2. When evaluating Android with working SMS Helper, the performance of sending and receiving SMS messages are measured separately. Table 4 shows the Antutu scores of various emulators in cloud service mode and real device mode.


Table 4. The Antutu scores of five runs and the average for the three emulators, and the overhead in cloud service mode and real device mode.

Run		1	2	3	4	5	Average	Overhead
Baseline		41455	41223	41837	41662	40870	41409.4	-

Cloud service mode	Standby	41929	40321	40051	40025	42271	40919.4	1.18%
Send	38875	37268	39231	39592	39567	38906.6	6.04%
Receive	36774	34206	35766	36896	35281	35784.6	13.58%

Real device mode	Standby	38067	38575	39946	38908	37545	38608.2	6.76%
Send	38255	38975	37765	37878	37897	38154.0	7.86%
Receive	36818	37786	35606	37113	34121	36288.8	12.37%
As Table 4 shows, Android with standby SMS Helper has the smallest performance overhead. Compared with sending SMS messages, receiving SMS messages created a higher performance for Android with working SMS Helper in both modes.

Fig. 11 shows a comparison of the performance overhead between Android with standby SMS helper and Android with working SMS Helper in both cloud service mode and real device mode. Both of the overhead “Sending SMS” and “Receiving SMS” is measured in the configuration of Android with working SMS Help. However, the former only measures the overhead of sending SMS messages while the latter only measures the overhead of receiving SMS messages. That the performance overhead of Android with standby SMS Helper in real device mode is 5% larger than the performance overhead of the emulator in cloud service mode. The performance overheads of sending and receiving SMS messages of Android with working SMS Helper are similar in both modes.

Fig. 11
Download : Download high-res image (70KB)
Download : Download full-size image
Fig. 11. Comparison of the performance overhead of various emulators in cloud service mode and real device mode.

4.4.2. Time overhead
Except for Antutu Benchmark, we measured the operating time of sending an SMS message in the configuration of Android with working SMS Helper in both modes and the operating time of sending an SMS message by using a real smartphone. Similarly, we also measured the operating time of receiving an SMS message in the configuration of Android with working SMS Helper in both modes and the operating time of receiving an SMS message by using a real smartphone. Besides, compared with the SMS message transmission time, we also calculated the time overhead to transmit SMS messages in the configuration of Android with working SMS Helper in both modes. The time to send an SMS message in cloud service mode begins at the time when an app calls sendTextMessage and ends when the remote smartphone recipient receives the SMS message. The time to receive an SMS message begins when a remote smartphone sends an SMS message and ends when an emulator receives the SMS message.

In the cloud service mode, SMS Observer can only affect the time period that an app sends an SMS message to an online text messaging service. Hence, after calling Rest API, the overhead is determined by the cloud communication service, which SMS Observer cannot control. SMS Observer can only enhance the performance of forwarding a sending SMS request and the polling task.

In real device mode, the time overhead is introduced by SMS Observer Server. SMS Observer Server connects an emulator and a remote smartphone. While the SMS message transmission time between a local smartphone and a remote smartphone is determined by the related telecom operator, the total transmission time of an SMS message should also include the time to deliver the SMS message between a local smartphone and SMS Observer Server and the time to deliver the SMS message between SMS Observer Server to the emulator.

Table 5 shows the experimental results where row Average shows the average time in milliseconds and row Overhead shows the overall overhead for sending and receiving an SMS message in the configuration of Android with working SMS Helper in both cloud service mode and real device mode. The average time of the baseline was measured at first that sending an SMS message costs 4979 ms while receiving costs 4710 ms. The experimental results demonstrated that Android with working SMS Helper in cloud service mode had a considerable time overhead due to the processing procedure of the cloud communication service. On the contrary, Android with working SMS Helper in real device mode had a time overhead of less than 1 sec.


Table 5. Average time and the overhead to send and receive SMS messages in cloud service mode and real device mode (time: millisecond).

Baseline	Cloud service mode	Real device mode
Type	Send SMS	Receive SMS	Send SMS	Receive SMS	Send SMS	Receive SMS
Average	4979	4710	8458.27	8225.29	5340.18	5052.41
Overhead	-	-	41.14%	42.74%	6.77%	6.78%
4.5. Deployment of SMS Observer
SMS Observer provides two modes to allow a user of an Android emulator to send and receive SMS messages. In cloud service mode, researchers can easily deploy a test environment by creating an emulator rather than buying an Android smartphone to analyze the behavior of Android apps. In real device mode, a user can still test apps in an emulator which can transmit SMS messages. Even though in this mode, SMS messages are transmitted through a real local smartphone, the app execution still occurs in an emulator; hence, no smartphone will be damaged by tested apps. SMS Observer records SMS logs in another place in both modes. In cloud service mode, the complete logs are stored in a message list in the cloud service's database. In real device mode, SMS Observer Server automatically records all incoming and outgoing SMS messages.

People can use SMS Observer for the following purposes. First, users can use SMS Observer to figure out whether an app overuses SMS-related permissions or whether the app is a bot app. Second, SMS Observer allows a user to use an emulator to observe the execution behavior of a malicious app that uses SMS messages to detect whether it is executed in an emulator to avoid being analyzed. Third, if a user does not want to reveal his authentic phone number after sending an SMS message, SMS Observer in cloud service mode allows the user to send and receive SMS messages using the phone numbers provided by a cloud service provider, instead of his phone number. This feature helps the user to hide his phone number to protect his privacy. Fourth, users can use SMS Observer to protect the integrity of their SMS message logs.

4.6. Discussion
This subsection discusses SMS security problems of Android which allows SMS-based botnets to use SMS messages to communicate with each other, even though new Android versions try to stop this problem.

Before Android 4.4, SMS-botnets can be easily deployed in smartphones. Android 4.4 officially introduces the concept of the default SMS app to enhance Android messaging security. After the release of this version, only the app that is set as the default SMS app can manipulate, such as delete, insert, or abort the SMS database, while other apps can read the database only. To directly receive an SMS, a new intent SMS_DELIVER_ACTION should be used. In terms of sending SMS messages, a non-default SMS app can still work as usual.

A malicious app that makes a smartphone a bot of a botnet can work well, even though it cannot delete the SMS messages sent by its C&C server. Though a bot app that is set as a non-default SMS app cannot hide incoming SMS messages from its botmaster, a malicious app can still deceive a user to change itself as a default SMS app and allow it to work as before. Another handy way for a botnet author to solve the above problem is that he can hide his commands in SMS messages which look like an ad.

Furthermore, an enhanced app permission control mechanism was introduced since Android 6.0. App permissions now granted individually at run-time, not all-or-nothing at installation time. However, these new features still cannot defend against most of the malware. We can find that new versions of samples with the same variant as the samples we download from Koodous website keep growing and there is very few analysts and anti-viruses able to detect them. For example, the malware XXShenqi we introduced in section 4.2 was found in August 2014 for the first time, but it did not be stopped infecting the latest Android phones until late 2020 with various app names such as XXshenqi, Heart App and feichengurao or package names such as com.zgektx55tf, com.googlesuit.ggkj and uvv.wtccr.enueu.

Finally, we did not evaluate the false positive rate of SMS Observer, because our work presently focuses on detecting the events of sending and receiving SMS messages and collecting logs more thoroughly to help researchers obtain more detailed behavior of malware. In order to judge whether an app is malware or not, there are still a lot of work for us to take efforts in the future.

5. Conclusion
SMS Observer provides a mechanism that can be used in a virtual environment or a real device to keep the integrity of SMS logs. SMS Observer provides two modes for emulators to transmit SMS messages. SMS Observer can be integrated into current Android dynamic analysis frameworks easily. It allows an emulator to transmit SMS messages to invalid the SMS-based anti-emulator mechanism. Besides, cloud service mode can be applied without a real device to protect a user's phone number while allowing a user to observe the execution behavior of apps without worrying that the app may damage his smartphone. Researchers and users can choose which mode to use according to their needs. Finally, by evaluating with real-world malware samples, including 58 variants within 149 sample apps, SMS Observer is more effective than existing frameworks, with the capability to analyze sophisticated SMS-based malware samples and provide a comprehensive view of malicious behaviors of these samples. SMS Observer can be used in SMS botnets research in the future, and to empower Android sandboxes to address issues related to SMS.