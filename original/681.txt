Abstract
In recent years, with the continuous expansion of metropolitan area networks, the routing security problem has become more and more serious. In particular, promise-violating attack to inter-domain routing protocol is one of the most difficult attacks to defend, which always leads to serious consequences, such as maliciously attracting traffic and disrupting the network. To deal with such attack, current research generally adopts routing verification. However, it can only detect attacks violating a specific routing policy triggered by one malicious node, and no research has yet solved the problem caused by multiple collusion nodes. In this paper, we propose BRVM, a blockchain-based routing verification model, to address the issue that violating the shortest AS Path policy. The main idea of BRVM is to construct a route proof chain to verify whether a route violates the policy with the help of the blockchain technology. The precondition that avoiding the collusion attack is that the proportion of the malicious verification nodes is lower than the fault tolerance rate of the consensus algorithm. Then, we prove the correctness of BRVM in theory, and implement a prototype based on Quagga and Hyperledger Fabric. Some experiments on this prototype show that BRVM can indeed solve the promise-violating problem caused by multiple collusion nodes, and about 15.5% faster in performance compared with SPIDeR.

Keywords
Inter-domain routing
Blockchain
Routing verification
Privacy
Security

1. Introduction
Recently, research on the smart city is increasingly becoming a new hotspot. Based on a new generation of information technology, a smart city can manage available resources more efficiently by collecting electronic data from various parts of the city, such as citizens, devices, and assets. With the collected big data, researchers can also carry out big data analysis to provide better public services and build more sustainable urban environments. Therefore, it can achieve a thorough understanding of the urban living environment, comprehensive management of urban resources, and coordination of all parts of the city. For communication network in a smart city (smart metropolitan area network), it may contain many Autonomous Systems (ASes) which belong to different ISPs, such as China Mobile, China Unicom, etc. Information in a smart city is transferred among those ASes in MANs. So the security issue of Inter-domain routing in the Internet will also happen in MANs.

When two ASes start to establish a connection, they need to negotiate business relationship and routing promises. The business relationships include provider-customer, peer-peer, and several variations based on the first two relationships. For example, the routing policies and contracts for partial transit relationships are complex [6]. Sometimes, one AS need to tweak the route selection for his neighbor ASes by using BGP communities [4] to complete their contracts. The negotiation about the provision of routing service and routing promises is very important for network service providers to achieve their contractual goals, such as maintaining traffic ratios.

However, in the current Internet, promise-violating events occur often as a result of misconfiguration or intentional malicious behaviors [23], [27], [29], [30], [33]. Some well-known security incidents on the Internet were caused by policy violations, including the 2004 TTNet route injection incident [36], the 2008 Pakistan Telecom hijacked YouTube incident [37], the 2012 Australian network disruption [2], and the 2017 Japanese Internet interruption due to Google’s mistake [16]. Some problems can be solved using ideas of IOV [40]. Sometimes, misconfiguration can cause more damage than attacks, because the AS administrator who unintentionally violates the promises may not prepare for a sharp increase in traffic, leading to more serious consequences. This error may also occur in an industrial IoT [43].

Unfortunately, routing promises are easy to violate, while routing verification is difficult to achieve in practice. Firstly, for inter-domain routing protocol, it is difficult to detect violations of promises. The faked routing information looks the same as the verified route advertisement, and the common security methods based on identity authenticity (such as digital signatures, encryption, etc.) cannot solve the issue. Many proposed variants of secure BGP (such as S-BGP [24] and So-BGP [42]) can check bogus paths or forged prefixes through path authentication and origin authentication, but they cannot deal with the issue whether the route advertisement matches the routing contracts between two ASes. Secondly, the privacy of Internet Service Provider (ISP) must be guaranteed during the routing verification. Our problem is, for the BGP best route selection policy, how to verify whether the route received by a route receiver is the best one? For security and business reason, it is impossible to expect ISPs to participate in a centralized management organization and share private information. In theory, complete verification can be done by displaying all routing information, but this is not possible in reality.

It is very hard to resolve the aforementioned issues that fully meet the requirements of both verifiability and privacy. However, authors in [49] proposed a secure and private inter-domain routing (SPIDeR), that can verify whether the received BGP route meets certain promises (such as the shortest AS Path rule) during the route selection process and ensuring privacy. SPIDeR enables the network to validate the promises collaboratively by dividing each promise into small pieces, while protecting privacy. However, SPIDeR can detect promise-violating events only when one malicious entity exists. It becomes invalid when facing multiple entities collude. The reason is that SPIDeR performs cooperative multi-party verification only based on the neighbors of the AS to be verified. If the neighbor who has announced a better route does not report the fraud, the collude attack may succeed. Authors in [44] adopted data auditing scheme with blockchain technology.

In this paper, we propose a blockchain-based routing verification model (BRVM) to resolve the promise-violating problem that violates the shortest AS Path policy in two cases: one spurious node and collude of multiple malicious nodes. The main idea of BRVM is to introduce the concept of route proof in the blockchain-based routing verification. When all the verification nodes are honest, a promise-violating attack can be detected completely; if some verification nodes are colluded, the condition for detecting this attack is that the ratio of colluded nodes is lower than the fault tolerance of the blockchain. This is similar to the work [9].

The use of blockchain technology in BRVM essentially allows all routing nodes to participate in a multi-party verification system, thereby avoiding the collusion among routing nodes. The only possibility of a collusion attack in BRVM is that some verification nodes are malicious, resulting in putting some faked route proofs into the block. However, as long as the proportion of malicious verification nodes is lower than the fault tolerance rate of the consensus algorithm, the violation can still be avoided. For example, POW algorithm has a fault tolerance rate of 50%.

Based on BRVM, we design an enhanced verifiable inter-domain routing protocol (EVIRP). Currently, there are at least more than 50K＋ ASes running on the Internet, which is a huge challenge for the existing blockchain technology to support such a large scale. Therefore, we implement a practical prototype system based on Quagga BGP and Fabric, and used a two-tier verification structure to optimize its performance. Our work has two contributions: (1) we are the first to address the promise-violating problem caused by collusion. (2) Analysis and experiments show that our solution is better than SPIDeR in performance.

The rest of the paper is organized as follows: In Section 2, we introduce some background concepts. In Section 3, we propose BRVM to address the promise-violating issue that violates the shortest AS Path policy. A theoretical proof guarantees the correctness of BRVM satisfying verifiability and privacy. We present a verifiable routing protocol in Section 4. In Section 5, we describe the implementation and experiments. In Sections 6 Related work, 7 Future work, we discuss the related work, conclusion and future work.

2. Background
2.1. Routing policy of BGP
The Internet is composed of thousands of ASes. BGP is a de facto interdomain routing protocol among ASes in Internet. An AS needs to consent to an agreement before establishing a connection to another AS. The agreement defines the consensus rules of BGP best route selection and what kind of business relationship should be used between the two ASes.

Each BGP router makes configurations according to the promise among its neighbor ASes. The rule of BGP best route selection must be the same as long as each router complies with the protocol specification. The BGP decision procedure is carried out on the basis of routing attributes, beginning with the attribute of local preference and proceeding down a chain of tiebreakers. Choosing the shortest route is one of those attributes, if the front preference rules were tied. Some attributes attached for some tied rules are publicly available, indicating that ASes are willing to disclose certain aspects of their routing policies. For example, BGP communities are numeric tags attached to route advertisements publicly, which often make influence on the route preference. However, many preference tiers are not public. Because one AS has only made a public promise matching the first tied rule, outside observers cannot be sure which route would actually be preferred, concerning many routes in the same tier.

The business relationships between two ASes include provider-customer,peer-peer, and other variations based on the two. The business relationship affects routing propagation among ASes. [13] argues that typically ASes tend to avoid announcing routes from a provider or peer to another provider or peer. As a result, routing in the Internet should be valley-free. More precisely, after a provider-customer edge or a peer-peer edge, the AS path cannot traverse customer-to-provider edges or another peer-peer edge. The valley-free property is strongly recommended to be used in routing policy because the Internet routing will be stable if all the paths in the Internet are valley-free [13]. However, guaranteeing valley-free globally is a challenging task because the business relationships among ASes are usually confidential, and it is difficult to verify that every path is valley-free and whether a router conforms to the business relationships by outside observers.


Download : Download high-res image (190KB)
Download : Download full-size image
Fig. 1. An example of correct routing promise.


Download : Download high-res image (199KB)
Download : Download full-size image
Fig. 2. Single-point attack scenario, Alice receive a route from Bob, but cannot verify if Bob keeps his promise.

In this paper, we make an AS’s promises as an order model and try to solve the promise-violating issue for the shortest AS Path policy, considering one spurious node or conspiracy of multiple malicious nodes if this rule is matched.

2.2. Routing promise
To simplify the explanation, we use name (Alice, Bob, etc.) to represent every AS and edges to represent inter-AS links. Two ASes Alice and Bob are connected by a direct link. Alice can receive inter-domain routes from Bob via BGP, and these routes may typically come from one of Bob’s neighbors respectively: Charlie, Doris, or Eliot. We can describe the basic process of BGP like this: at any given time, Bob may receive several routes to a prefix p; he will choose one among these routes according to his local policy and then decides whether or not to make this route available to Alice.

In most instances, Bob has made some kind of promise to Alice regarding his routing policy. A promise is a declaration that Bob tends to prefer certain routes over other routes. For example, in Fig. 1, Bob can make a promise that he will always choose the shortest route as the best route, or he tends to prefer routes through AS Charlie over routes through Eliot.

The routing promise affects the routing decision process, where several routes enter and at most one leaves. A promise does not participate in a single routing process but gives preference information about which route is considered “better” than other routes.


Download : Download high-res image (222KB)
Download : Download full-size image
Fig. 3. Multi-point collusion attack scenario: Alice receives a route from Bob, and believes that Bob keeps his promise. In fact, Bob and Charlie deceived Alice jointly.

Definition 1

Suppose that S(A, p) is the set of all available routes received by AS A to a prefix p, in a given total order. A promise on  defines a partial order , and partitions  into several indifference classes. We use set C to label various classes of routes, with a partial order, representing the definite preference of one class over another. Every route can be classified to exactly one class in set C. Routes in class  constitute a subset , where  and  for every . The meaning of an indifference class is that there is no preference among routes within one class.

In particular, if  for , means there exists a preference between routes in  and : for each  and , route r is less preferred than route s.

For instance, we use AS Path length as the label for various classes of routes, so the set C may contain class labeled path length 2, class labeled path length 3, and so on. In addition, a promise is that routes with a shorter AS Path can have a higher priority to be chosen. In Fig. 1, Bob receives three routes from his neighbors, with different AS path length. Hence, the set C can be defined as . Obviously, the route learnt from Charlie is more preferred than routes from Doris and Eliot.

2.3. Problem description
Since the incoming routes received by Bob are not available to Alice, Bob can easily break his promise intentionally or unintentionally while Alice cannot notice it. For instance, a configuration error on routing policy might result in routes through Eliot will be chosen, instead of the preferred route through Charlie. Then promise-violating problem happens.

2.3.1. Single-point attack scenario
We describe the promise-violation problem in Fig. 2. Consider five ASes here: Bob and his four neighbors Alice, Charlie, Doris and Eliot. Bob receives three routes to a prefix from Charlie, Doris and Eliot. He chooses one from these routes as its best route according to his promise and decides whether to make this route available to Alice.

A promise of Bob to Alice is a statement that Bob will prefer certain routes over other routes. For example, a promise is defined that Bob chooses the route with the shortest AS Path as the best one and sends to Alice. In Fig. 2, Charlie announced to Bob a route to prefix 74.125.58.0/24 with AS Path length of 3, Doris announced a route with AS Path length of 4, and Eliot announced a route with AS Path length of 5. According to the promise between Bob and Alice, Bob should announce to Alice the route learnt from Charlie.

However, Bob can easily break his promise and Alice cannot verify whether routes received from Bob follow the promise between them. For example, Bob intentionally chooses Doris’s route to advertise, which is the second-shortest route. Anyway, Alice has to accept this route since Bob’s incoming routes are not visible to Alice. Fig. 2 gives an example that one malicious AS (Bob) breaks its promise.

2.3.2. Multi-point collusion attack scenario
Fig. 3 gives an example of a collusion attack. Two spurious ASes, Bob and Charlie, are shown with a bigger icon than honest ones. Bob announces to Alice a route to prefix 74.125.58.0/24 learnt from Doris which is the second-best route. In any case, Alice cannot check Bob’s incoming routes directly due to the privacy protection, but she can use solutions like SPIDeR to verify the route. The procedure of SPIDeR is like this: Alice tells Bob’s neighbors that she received a route with AS Path length of 5 from Bob. If Bob is the only liar, Charlie will honestly tell Alice that the route he sent to Bob has AS Path length of 3, and Alice can find Bob violated his promise. However, if Charlie is Bob’s accomplice, he obviously can choose not to report Bob’s cheating. As a result, a conspiracy attack has occurred, and few studies currently can put forward a viable solution to this complex issue.

2.4. Verifiability and privacy
Routing verification is used to verify whether an advertised route conforms to the routing promise between two ASes. For example, a promise is defined that any AS chooses the route having the shortest AS Path as the best route. Then, routing verification is to verify whether the advertised route has the shortest AS Path among all possible routes received by this AS.

The requirement of privacy is defined the same as that in [49]: (1) any AS cannot infer additional information about routing table or policy of other ASes, beyond that it already learnt via BGP; (2) when a promise violation is detected, it is reasonable to reveal more information to indicate this violation.

We aim to deal with two attack scenarios: for single-point attack scenario, we wish to find this attack that breaks the promise between ASes; for multi-point collusion attack, we wish to find this collusion attack as early as possible in order to avoid greater losses.

2.5. Introduction to spider
The main idea of SPIDeR is its collaborative verification of promises. The following features appear in SPIDeR: (1) add a mandatory commitment phase, in which each producer holds a signed proof that the elector has acknowledged its input while each consumer holds a route from the elector, and each producer and consumer holds a commitment that the elector sent. (2) introduce an optional verification phase, in which any producer or consumer can trigger a verification of the elector’s route by broadcasting a verification message to other producers and consumers, and ask the elector to provide the bit proof for this route. After receiving the bit proofs, any producer or consumer can verify the correctness of commitment value in commitment phase, and checks whether the elector breaks the promise. Therefore, the single-point attack problem can be solved naturally.

However, SPIDeR has some limitations. (1) It can work well for the violating problem caused by only one malicious node, but cannot solve the complex problem caused by multiple spurious collusion attack. Considering the collusion attack in Fig. 3, Bob sent to Alice a route e with AS Path 4, learnt from Doris. Alice believes that Bob keeps his promise by SPIDeR. In fact, Bob and Charlie jointly deceived Alice, since Charlie did not report Bob’s cheating. (2) It uses broadcast mechanism to remind neighbors to start the verification of the elector’s route, and uses a passive triggering mechanism to acquire the bit proof. This may cause more overhead in packet propagation and verification procedure, so the verification is not efficient.

3. BRVM: Princple and model
According to routing principle, route attributes can be divided into two categories: transitional and non-transitional. Some common route attributes, such as Origin, AS-Path and Next-hop, are transitional. While others, such as MED (Multi-Exit-Discriminators), Local-Preference are non-transitional. A non-transitional route attribute only works between two routing nodes, which cannot be verified by our method currently. Our proposed verification model BRVM only verifies if a route conforms to the shortest AS Path policy. Our solution mainly focused on the promise-violating problem caused by collusion nodes, which is not solved by SPIDeR.

3.1. Assumption
We make the following assumptions:

(1) Each AS creates a public–private key pair and uses it in the routing verification;

(2) No AS can forge the digital signature of any other AS;

(3) Use the existing security mechanisms to ensure the security of inter-domain routing protocol, including origin authentication and path authentication. Therefore, routes with bogus paths, fake origin or forged prefixes can be discarded by the receiver.

3.2. Definition
First, we introduce variable descriptions in Table 1.

Definition 2 Class of Route

We use  to represent the class of route u.  can be defined using a k bit array , where  iff , otherwise .


Table 1. Variable description.

Notations	Description
Private key of 
Public key of 
The identification of , i.e., the hash value of 
The operation of route u: update or withdraw
The timestamp when route u is sent
The destination prefix of route u
Route proof chain of a route to prefix p from  to 
Definition 3 Route Proof

We define  for the route proof of a route u. A route proof is related to exactly one route, and represents this route in the routing verification without disclosing additional private route information.

Suppose that  selected a route  learnt from  as its best route, then created a route (i.e., route  ) and announced it to . A route proof  for route  provided by  has five parts: the preceding route proof , the basic information , the identification of route , , the signature and public key of receiver, and the signature and public key of sender. The detail of every part is as below:

•
 is a pointer to a route proof  in proof storage, which is actually a route proof of route .

•
The basic information  contains six parts: sender ID , receiver ID , , , , . For example, we use AS Path as the class of route. If the AS Path of route  is 4 and , then .

•
The identification of route , , is the unique identification of route , which can be defined as .

•
The signature  of receiver  can be obtained from a reply that  returns to ;  is defined in step (2) of the process of BRVM. And public key  is used to check the authenticity of the signature of receiver.

The signature  of sender  is set as follows:


This field is used by a verification node to verify that the content of a route proof has not been tampered with.

Definition 4 Preceding Route Proof

Suppose that  selected a route  learned from  as its best route after a route selection process, then created a route (i.e., route ) and announced route  to . We define  as the preceding route proof of route , denote .

According to Definition 1, we obtain the following expressions.

Expression 1

Any route  belongs to one and only one subset : .

Expression 2

If  for some  and  in , then a preference exists between routes in  and : for  and , if  (), then .

3.3. Routing verification model based on blockchain
3.3.1. The principle of BRVM
Instead of requiring neighbor ASes to join the collaborative verification, BRVM introduces a distributed routing verification system. An AS announces a route to its neighbors AS, and then it sends to the routing verification system a route proof corresponding to this route. The route proof is used in the routing verification process; it must be verified and inserted into a block on the verification system after achieving global consensus consistency among the verification nodes. All route proofs for a prefix involved in the route propagation process can be organized as a route proof chain.

The route receiver determines whether the received route conforms to the routing promise by querying whether there exists a corresponding route proof in the blockchain. The key point of BRVM depends on the correctness and completeness of route proofs recorded in the blockchain. The probability of a promise-violating attack occurring depends on the consensus algorithm in the blockchain. The routing verification system composes of two parts: verify module to verify route proofs and routes, proof storage to store route proofs. Verify module consists of verification nodes, and proof storage consists of route proofs.

Fig. 4 shows an example to illustrate the process of BRVM. It mainly has four steps: (1)  announces a route d with his signature  and  to his neighbor ; (2)  signs some information of route d and replies his signature  to  to indicate that  receives route . (3)  constructs a route proof  with his signature, and sends it to proof storage in the verification system, which verifies the received route proofs and stores the verified ones in the blockchain; (4) when receiving a route ,  will trigger a request for verifying route d to verify module in the verification system, and wait for the response to decide how to deal with route .

3.3.2. The verification process of a route proof
This process corresponds to the step (3) in the process of BRVM, which is the key point of BRVM, including three important stages:

Checking the basic information of a route proof. (1) checking whether  exists in proof storage and whether  is the latest evidence based on its time stamp; (2) checking whether  in  is the same as that in ; (3) checking whether class of route  is consistent with that in ; (4) checking whether sender ID,  is correct using public key  to verify ; (5) checking whether receiver ID,  is correct using public key  to verify .

Checking signatures in a route proof. (1) checking if the signature of sender is correct using public key ; (2) checking if the signature of receiver is correct using public key .

Optimal route checking. To check whether route  is optimal, the verification system will search for an evidence in proof storage to deduce whether the sender  has received a better route than route u. It will retrieval route proofs using receiver ID,  as the index under the condition that  : if there exists a route proof satisfying that  is better than , that means some AS has sent to  a better route  than the selected route , but  conceals the route .

If a route proof passes all the stages, it can be considered as verified and saved into proof storage.

3.3.3. The process for request of verifying a route
Verify module uses  as the index to search the match item in proof storage. The matching item shows the corresponding route is verified.

3.4. Example
With the same examples described in the previous background, we describe how BRVM works.

3.4.1. Defend single-point attack
In this scenario, Bob is the only attacker, and he intentionally chooses Doris’s route , which is the second-shortest route, creates route  and announces it to Alice.

Bob could conduct a single-point attack in two cases: (1) sends a faked route proof  to the verification system, for example, he may announce that AS Path length of the route  is 4, but the actual value is 5; (2) sends a correct route proof  to the verification system.

For case (1), Bob provided a faked route proof  where  is changed to  from  (shown in Fig. 5. This faked route proof  can be detected in the stage of checking the signatures in a route proof, because the signature of Alice is signed for the actual value of . The content of the faked route proof  is shown in Fig. 5, where an error is detected when checking the signature of the receiver.

For case (2), route  is learnt from Doris,  is  and  is . Bob has received a route  from Charlie with AS Path length of 3. Since Charlie is honest, he will definitely send a route proof  to the verification system with . Therefore,  cannot pass the , where  will always be found because  is better than . This process is shown in Fig. 6, where route proofs for all the routes received by Bob are stored in proof storage, together with their proceeding route proofs in a route proof chain.


Download : Download high-res image (433KB)
Download : Download full-size image
Fig. 5. A faked route proof RP(d) of route d provided by attacker Bob.

3.4.2. Defend multi-point attack scenario
Bob and Charlie are accomplices. Bob chooses Doris’s route  to announce to Alice (a route  is received). The route  learned from Charlie is the best route.

In Fig. 3, AS Path of route w to prefix  is . Bob sends a route proof  of route  to the verification system, and wants to put it in the blockchain. As we know in the former scenario a),  will be detected wrong when Charlie announced a correct route proof  to the verification system. The reason is that  is better than . Therefore, in order to help Bob pass the verification, Charlie needs to send a faked route proof  with  not better than , e.g., .

Here comes a problem: can this faked  be accepted by the verification system? It depends on what route proof sent by Green, Charlie’s upstream AS. If Green is honest, this faked  will be detected wrong and collusion attack is over. In order to continue this collusion attack, Green needs to send a faked route proof  to the verification system. But the faked  will not be lucky this time since it meets Henry, a route origin AS, who will not participate in any route proof fraud according to assumption 3. Therefore, a multi-point collude attack will always be detected even if most nodes participate in collusion, since the verification of a route proof will eventually reach the route origin AS.

3.5. Correctness of BRVM
In the following, we will theoretically prove the correctness of BRVM. A promise satisfies the condition: the class of route in a route proof is correct, iff each route proof in the route proof chain is valid and the class of route in each route proof is consistent.

A lemma is introduced to guarantee the correctness of the process of checking the basic information of a route proof. Other two theorems ensure that the promise-violating issue can be solved to meet the needs of verifiability and privacy.

Lemma 1

The class of route in route proof of route , , is correct iff the preceding route proof of route  (i.e., ) is correct, and the class of route in  is consistent with that in .

Proof

Suppose that there are n route proofs  () in the route proof chain of , satisfy: ,  for . We use  to represent  is consistent with . Proof of Lemma 1 is equivalent to prove the following proposition:


The condition that a promise satisfies can be considered as an axiom, which can be described in formula (1). (1)

We will prove  from two aspects:

(a) prove : .

According to formula (1),  is obviously established.

(b) prove : .

(2)(3) (according to (2), (3), (1)).  □

Theorem 1 Anti-Single Point Attack

If  is the only malicious node in the network, and claims that he announced a route  to  and sent a route proof  to the verification system later, the verification system can completely verify whether the route  meets the promise made by .

Proof

There are only four cases to consider: (1)  announced a non-optimal route , with a route proof  for the optimal route ; (2)  announced a non-optimal route , with a route proof  for this route ; (3)  announced an optimal route , with a route proof  for a non-optimal route ; (4)  announced an optimal route , with a route proof  for this optimal route .

For case (4), it is normal. The route proof  can be passed the verification process obviously and be put in a block of the blockchain.

For cases (1) and (3), they belong to the same kind of the problem that the class of route  is incorrect. According to step Checking the basic information of a route proof, Checking the signatures in a route proof,  will be detected wrong. According to Lemma 1,  is wrong for inconsistency with that in .

For case (2), a promise violation can be detected in step Optimal route checking: there must exist a route proof  satisfies that  is better than , because  has received a better route  than route , and a corresponding route proof  should be stored in proof storage before.

Therefore, it can guarantee that a single point attack can be completely detected in theory, since there is no collusion, and the consensus algorithm provides a certain fault tolerance.  □

Theorem 2 Anti-Collusion Attack

If all the verification nodes are honest, the verification system can completely avoid the collusion attacks caused by the routing nodes. If the verification node colludes, the condition for avoiding the promise violation is that the ratio of malicious nodes is lower than the fault tolerance of the consensus algorithm used.

Proof

For the first part, we prove all the collusion attacks by the routing nodes can be detected.

Similar to Theorem 1, only the same four cases can happen. There is no attack found in case (4), we only consider the first three cases. For case (1) and case (3), the prove process is the same as that in Theorem 1.

In case (2),  announced a route , which is learnt from a non-optimal route , and sent a route proof  to the verification system. Assume  received  routes, and  routes have better AS Path length than route , marked as , learnt from , respectively.

As long as anyone in  provides a correct route proof, route proof  cannot pass the verification in the step of optimal route checking since there exists a better route proof than , i.e., . Therefore, the precondition that route proof  can pass the verification is that ,  all participate in collusion together with .

We will prove that it can be detected when anyone in ,  colludes with . Take  as an example. Assume  sent a route  to  with AS Path length of , and AS Path of route  is .

To support  to pass the verification,  needs to provide a faked  with a faked , which should be no better than . According to Lemma 1,  is required to be consistent with its preceding route proof. In order to make this faked  to become correct, it requires all the participants  in this route proof chain to provide faked CR value. However, according to assumption (3), a route origin AS is honest, i.e.,  cannot provide a faked route proof.

Therefore, this faked  cannot be accepted by the verification system because at least one participant in the route proof chain cannot provide a faked CR. So anyone (include ) in ,  cannot be an accomplice with  to help  to put  in the verification system.

For the second part, the probability of a collusion attack occurring depends on the consensus algorithm.  □

In summary, if all the verification nodes are honest, collusion attack cannot happen. Otherwise, avoiding anti-collusion attack requires that the proportion of collusion nodes does not exceed fault tolerate rate of the consensus algorithm. For example, if a POW is used, the collusion attack can be avoided as long as the proportion of malicious verification nodes does not exceed 50%.

Consideration of Privacy. No AS can learn any additional information about the promise of any other AS from BRVM, beyond what it already learnt via BGP.

Here, we consider privacy in two ways. First, we use the route proof in the verification process, which has no private route information; Second, the public–private key pair of each AS is generated locally. Since no one can trace the AS ID to an actual AS, it is impossible to infer routing information (e.g., AS Path) of an actual AS. Therefore, no one cannot obtain the relationship between the routing information and the actual AS, so that the privacy is protected.

According to the mechanism of BRVM, no AS can learn any additional information about the promise of any other AS beyond what it already learnt via BGP. That is, BRVM can satisfy the requirement of privacy.

The correctness of route verification depends on the correctness of route proofs. Because the verification node itself can be malicious, the correctness of BRVM will be guaranteed by the consensus algorithm.

4. Mechansim and protocol
4.1. Protocol design
Currently at least 50K ASes are working in the Internet, and process over 300K routes. Since different ASes do not trust each other, they all want to participate in the verification process of route proofs. Since the default value of MARI (Minimum Route Advertisement Interval) is 30 s, when considering the concurrency, the time required to verify a route should not exceed 0.6 ms (30 s/50K route proofs) theoretically.

To optimize the verification time, we propose a two-tier verification system, including a local verification system and a global verification system. A node in the local verification system, acts as a node in the blockchain, located in a physical router. It may be a bitcoin core in Bitcoin or an endorser node in Fabric. In addition, it does not take part in the consensus process, and only waits to receive blocks from the global verification system and stores into the cache the index tables of route proofs that it concerns. The communication process is shown in Fig. 7, and involves four entities: a local verifier, a global verifier, a sender of route, and a receiver of route.

When receiving a route proof, a local verifier and a global verifier will check its correctness according to step the verification process of a route proof in BRVM, respectively. The difference lies in: a local verifier checks the correctness of a route proof locally, while global verifiers will reach a consensus on the correctness of a route proof together. If the verification result for the same route proof is different between a local verifier and global verifiers, only two cases will occur: (1) the local verifier is malicious. Global verifiers will check whether the local verifier is hacked, and ask the route receiver to rolled back the incorrect route; (2) the local verifier is honest, but the number of malicious global verifiers exceeds the fault tolerance of the consensus algorithm. EVIRP cannot work in a blockchain with an incorrect status.

To deal with the situation that the verification result for one route proof is different between a local verifier and global verifiers, the routing node adopts the following remedies. Firstly, a queue (named route-to-be-ready queue) is introduced for storing the routes that it sends out. When a routing node sends a route out, it will store it in the route-to-be-ready queue. Only after the routing node receives the verification result for a route proof from global verifiers, it will make a decision based on the verification result. Two cases are here: (1) if the verification result is the same between a local verifier and global verifiers, the routing node will remove the route corresponding to this route proof; (2) otherwise, the routing node will revoke the route corresponding to this route proof, and issue an alert to check something goes wrong. In a real world, the first case may happen very often, while the second case happens rarely. Therefore, this two-tier verification system can achieve a good performance in most instances.

When receiving a request for verifying a route, a local verifier first searches the route proof of this route locally, and forwards this request to a global verifier if it does not find.

The possible overhead increased is that a local verifier needs to forward the verification request to the global verification system, when it cannot find a corresponding route proof locally. However, a local verifier has a higher probability of storing all the route proofs needed, since it is often closer to the direct neighbors of a receiver. Therefore, it can be inferred that the possible overhead increased is negligible.

4.2. Mechanism
Since a huge number of route proofs need to be recorded in the blockchain, the linear linked list structure of the traditional blockchain will greatly reduce the verification performance. Due to the irrelevance of route prefixes, multiple route proof blockchains can be created by route prefix, route sender and route receiver to reduce the number of blocks in a single blockchain.

Specifically, a single root proof chain  is indexed by . It represents a route proof for a route to a prefix , sent from  to . To label a route proof chain, we use  as a key. For every AS  as a route receiver, we retrieval the results for  and save them in the cache to accelerate the routing verification.

The performance of routing verification mainly depends on the efficiency of local verifiers. Local verifiers mainly perform synchronization, verification and query operations. Because the query operation is simple, we mainly discuss other two operations.

4.2.1. Synchronization blocks with route proofs
In EVIRP, only global verifiers participate in the consensus procedure and transfer blocks with route proofs to local verifiers periodically. A local verifier checks the validity of blocks, and put them into its local storage like blockchain does. In addition, according to the received blocks, the local verifier will update its cache that contains index tables and route proofs that it concerns to speed up local processing.

4.2.2. Verification of route proofs
The difference in the verification of route proofs between local verifiers and global verifiers is the verification of . Since a local verifier is located in a physical router, it can naturally acquire the route u and calculate its  directly.

In addition, a local verifier can accelerate the routing verification in the process of checking whether  exists and optimal route checking in a smaller search space. Assume that the storage cost of a route proof is , the number of different route prefixes is , the number of ASes is , the average number of neighbors per AS is , and the number of changes in each route is . Then, the space cost for a global verifier is , while that cost for a local verifier is . We use the key–value form for query, so the cost to locate a root route proof is . Thus, for the verification algorithm, main computation cost is to search if there exists a better preceding root proof, which is .


Table 2. Experimental configuration.

AS	Neighbors	ip addr (one AS has multiple ip addr)
172.32.0.1,172.42.0.1,172.52.0.1
172.32.0.2, 172.63.0.1
172.42.0.2, 172.94.0.1
172.52.0.2
172.63.0.2,172.76.0.1,172.86.0.1
172.76.0.2,172.117.0.1
172.86.0.2,172.108.0.1
172.94.0.2,172.109.0.1
172.108.0.2,172.109.0.2,172.111.0.1
172.117.0.2,172.111.0.2
5. Prototype and experiment
5.1. Prototype
The blockchain technology is well known because of its good feather such as decentralized recode, encryption method, anonymous identity, consensus mechanism, etc. So it is naturally suitable for a distributed ledger, and this motivates us to choose a blockchain system as the basis implement platform for the design of our EVIRP solution.

We implement a prototype of EVIRP, where the verification system is implemented using Fabric [22], and routing system using Quagga [34]. The prototype architecture consists of two parts and its architecture is shown in Fig. 8. The left part is the structure of a local verifier and a global verifier. The modules with dotted line are modified, while the ones with solid line are original. A local verifier, as a node of Fabric, is located in a physical node of the routing system. A routing node runs Quagga/bgpd with some modification, and mainly includes route receive routine , route send routine  and an interface to the local verifier. We add a route verification function in route receive routine to deal with incoming routes, and a route proof send function in route send routine to send out route proofs. We add a route verification function in Route receive routine to deal with incoming routes and route proofs, and a route proof send function to Route send routine to send the route proofs out.


Download : Download high-res image (318KB)
Download : Download full-size image
Fig. 8. The prototype of EVIRP.

The global verification system is implemented based on the framework of Fabric. It mainly composes of six parts: SDK, chaincode, endorser, committer, orderer and ledger, and we mainly modify endorser, chaincode and ledger modules. Route proofs are sent to endorsers to be verified via interfaces in SDK, and the synchronization between local verifier and global is mainly done by committer nodes when a new block is created by orderers. We implement a new chaincode and modify the endorsement of transaction proposal in endorser nodes to support the routing verification procedure.

For the requirements of performance and scalability, we use DPOS as the consensus algorithm, which can support 50K＋ nodes and needs 3 s to confirm a block that includes at most 400 route proofs, i.e., the time to confirm a route proof is theoretically 7.5 ms (3 s/400 route proofs).

5.2. Experiment and evaluation
In this part, we aim to obtain some results from an experimental evaluation of EVIRP. First, we set up some experiments to validate that EVIRP is useful for solving the promise-violation issue under two kinds of attacks: one malicious node attack and collude attack. The experiment topology is shown in Fig. 9. There are 10 ASes deployed in the routing system, the configuration of ip address and AS id of ASes is shown in Table 2. Each node in the experiment is running in a container (e.g. docker), and runs routing service and blockchain service.

•
One malicious node scenario

According to EVIRP, there exists a route proof in the verification system for route  learnt from . we can find that there exists a route proof for route  from  to  that has AS path of 2. So a route proof for route  cannot pass the optimal check in the verification, and is stored in the database for invalid route proofs. The verification mechanism in EVIRP ensures that one malicious node attack cannot be achieved.


Download : Download high-res image (125KB)
Download : Download full-size image
Fig. 10. Promise-violating attack experiment topology.


Download : Download high-res image (129KB)
Download : Download full-size image
Fig. 11. Promise-violating attack experiment topology.


Table 3. Experimental result in a hierarchical topology.

Average verification time (millisecond)	Number of routes
1	5	10	50	100	500	1000
Peer: 4
Orderer: 1	342.86	394.16	488.16	466.97	424.99	893.24	913.75
Peer: 8
Orderer: 4	483.42	462.76	549.08	537.03	465.79	935.47	983.24

Table 4. Experimental result in a linear topology.

Average verification time (millisecond)	Number of routes
1	5	10	50	100	500	1000
Peer: 4
Orderer: 1	342.86	413.61	446.79	619.66	573	968.09	987.71
Peer: 8
Orderer: 4	483.42	404.48	442.23	685.06	643.93	994.79	1135.31

Table 5. Experimental result with local verifiers in a hierarchical topology.

Average verification time (millisecond)	Number of routes
1	5	10	50	100	500	1000
Hierarchical topology	364	436.17	486.05	478.26	405.1	390.46	395.56
Linear topology	364	384.33	499.07	665.7	600.55	756.11	807.34
•
Multiple malicious nodes scenario

We assume  and  are malicious nodes in Fig. 8, and set the experiment like this:  receives two routes for prefix 111.0.0.0/24 from  and , with AS path length is 2 and 3, respectively.  sends to  a route  learned from . The experiment result is the same as the case in one malicious node scenario. If  wishes the route  learned from  can pass the verification, he will ask his companion  to help announce a fake route  which has AS path length larger than 3. But it is an impossible task for . Since  has received a route with AS path length of 1, this fake route  cannot pass the route verification when  announced it out. Therefore, the verification mechanism in EVIRP guarantees that collusion attacks caused by multiple malicious nodes are detectable before attacks take effect.

•
Performance experiment

We ran experiments on a cluster of 10 servers connected by a 1 Gbps Ethernet network. Each server had a 2.1 GHz Intel CPU of 4 cores and 4 GB RAM, and ran Ubuntu 14.04 (Linux 4.4.0).

In this part, we consider two kinds of topologies: hierarchical topology in Fig. 9 and linear topology in Fig. 11. For each topology, we do experiments to study what factors are related to the verification time, including number of routes, number of global verifiers, number of routing nodes.

(1) Experiments in a hierarchical topology

First, we set experiments to study the relationship between the verification time and the number of routes under two kinds of configuration for global verifiers: 4 peer nodes and 1 orderer nodes, 8 peer nodes and 4 orderer nodes. The result is recorded in Table 3. There is no local verifier in this experiment.

In Table 3, we can observe that the verification time is longer with more global verifiers.

(2) Experiments in a linear topology

For experiments in a linear topology, we use the same configuration in the hierarchical topology. The result is recorded in Table 4. There is no local verifier in this experiment.

In Table 4, the same conclusion like the first experiment can be found.

(3) Experiments with local verifiers

The first two experiments are set without local verifiers, the result for a hierarchical topology and linear topology is recorded in Table 5.

From the result in Table 5, we can find that: the local verification only search the cache to find a match entry or just pass the request to the global verification system, so it is very fast (in milliseconds).

(4) Comparison experiments

Similar to our work, SPIDeR also added the route verification in the traditional routing process. When verification is triggered, the proof generator in SPIDeR will reconstruct the MTT at the commitment stage and then generate a set of bit proofs for each neighbor. They have recorded the time of reconstruct: it took 13.4s to reconstruct the MTT and 70.2s to generate the proofs for the five neighbors. They applied their system for the shortest AS path policy, and obtained the time to generate a set of bit proofs after MTT reconstruction is 0.431s. Therefore, when verification is not triggered, SPIDeR can run fast with low overhead, but in the worst case, SPIDeR will trigger the routing verification, the overhead to verify a route is at least 0.431 s. But the verification time in our work for verifying one route is 0.364 s, which is 15.5% faster than SPIDeR.

6. Related work
The security problem for Internet interdomain routing has been studied for many years. Most previous security related works focus on bogus paths. Butler et al. [3] survey the current BGP [35] security issues with its solutions such as S-BGP [24], soBGP [42], IRV [15], origin authentication [1], SPV [21] and so on. S-BGP [24] assures the security of information by validating path attributes based on the certificates in the PKI. SoBGP [42] can only provide origin authentication, but cannot provide path authentication. IRV is a centralized solution whose operation is independent of routing protocol. It requires that every AS report its link or relationship with other AS to IRV servers. Other solutions can be found, such as signature amortization [38], reference locality [28], psBGP [31], MOAS detection, intrusion detection [25], BPHAS [26], etc. Goldberg et al. [14] pointed out that the existing secure routing protocols only address the security of route announcement semantics, which can only guarantee the paths are topologically valid but fail to ensure the logical trustworthiness. Our work focuses on the issue of the logical trustworthiness. Some methods [41], [47] using machine learning can be considered in the future work. Privacy research in IOT [8] can also be considered. Some methods in smart city [32] need to be introduced in the future work.

The secure problems caused by valley paths are the examples of such trustworthiness issues. [33] proposes a mechanism to avoid the valley path by adding a transitive attribute in BGP reflecting the relationships between AS. In fact, this mechanism reveals the business relationships between ASes. SCION [48] is another attempt to provide the valley-free paths. However, it can only guarantee the properties of the valley-free paths in a trust domain (a group of several ASes) without ensuring all the valley-free paths in the whole network. We will consider the lightweight method using blockchain [45] in the future work.

BorderGuard [7] verified different types of commitments, namely whether the ISP advertises a consistent route using information that is already available to the ISP, so privacy protection is not a problem. NetReview [19] allows routing decisions to be checked without considering privacy protection. SPIDeR [49] performs collaborative verification for inter-domain routing with considering privacy at the same time, which is the most relevant to our work. However, SPIDeR cannot guarantee the detection of promise violation caused by more entities collude. Our solution mainly focused on the promise-violation problem caused by collusion of many nodes. Privacy research in fog computing can be found in [12].

Gupta [17] introduces SMPC (secure multiparty computation) into inter-domain routing, to separate private information into different computing entities, and the results are calculated by multiple entities. Gurney [18] proposes the similar idea with [49]. Chen [5] focuses on privacy protection methods, and to find out how to ensure that the shortest path between two routes with the assumption that two topological nodes are known, without revealing the topology information of the two domains. Sundaresan [39] deals with issue that violates the Gao-Rexford export rule through labeling the valley-path, and the relationship between ASes in the process of route advertisement. Henecka [20] aims to change the principle of route advertisement without revealing the topology structure, and can calculate the shortest path by using the way of backtracking. Research of privacy in blockchain can be found in [10], [11], [46]. All of them consider the privacy protection.

7. Future work
For detecting attacks that violate shortest AS Path policy caused by single node and multiple nodes, we are the first to propose a mechanism based on a blockchain approach. However, we still face many difficult problems to be solved in the future. For example, if a global verifier and a routing node are the same entity, it can infer the detail routing information of others by collecting all routing proofs. The risk of privacy leakage still exists. How to enhance privacy protection is our next research focus. Secondly, the scale of BGP nodes in Internet and the size of routing tables are very large. Our proposed method has still a certain gap from the actual deployment. How to further improve the performance and scalability of the verification system, how to carry out incremental deployment is still challenges we need to consider in the future. Thirdly, the current method is only for one rule. How to find a better method suitable for conformance check of other rules is also a difficult problem to be solved.