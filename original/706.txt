Abstract
In this work, we propose Maximal-2-Packing-Halin, a distributed algorithm that finds a maximal 2-packing set in undirected non-geometric Halin graphs of order  in linear time. First, this algorithm finds an external face of the input graph through the application of graph-reduction rules. Second, each vertex determines if it belongs to a maximal 2-packing set by applying a set of vertex-coloring rules.

Previous
Next 
Keywords
Maximal 2-packing set

Halin graph

Distributed algorithm

1. Introduction
In this work, we propose a distributed algorithm that computes a maximal -packing set in non-geometric Halin graphs. Let  be an undirected connected graph, where  and  are the sets of vertices and edges, respectively. A -packing set  is a set of vertices such that the shortest path between any pair of vertices  is at least  edges long. A path in  is an alternating sequence of vertices and edges such that all vertices are different and the number of edges is the length of the path. The distance between two vertices in  is its shortest path. There exist some well-known restricted versions of the -packing set problem. One of them is the -packing set problem, also known as the independent set problem [38]. Another one is the -packing set problem, also known as the strong stable set [32], the one we study in this paper.

A -packing set  is maximal if it does not exist another -packing set  such that . The set  is maximum if  has the greatest cardinality among all maximal -packing sets of . Computing a maximum -packing set is an NP-hard problem for arbitrary graphs [32]. Dynamic programming has been a useful tool to solve some optimization graph problems, including the maximum -packing set [8], the maximum -packing set [19], and the maximum -packing set [40], all of them for restricted graphs. In contrast, finding a maximal -packing set in an arbitrary graph is not an NP-hard problem; however, solving this problem in a distributed computing environment represents a challenge, since each vertex has only a local view of the system.

The main contribution of this work is Maximal-2-Packing-Halin, a distributed algorithm that computes a maximal -packing set in a Halin graph . This algorithm, shown in Pseudocode 1, consists of two phases. The first one generates a two block partition of the set . During the second phase, the algorithm identifies the vertices of the maximal -packing set, starting in the vertices of  and ending on those of .


Download : Download high-res image (77KB)
Download : Download full-size image
1.1. Preliminaries
Let  be an undirected connected graph.  is a planar graph if it admits a drawing on the plane such that edges only intersect at the vertices. A planar drawing of  generates a partition of the plane into regions bounded by edges [18]. The unbounded region is the external face; the remaining ones are inner faces.

A graph  is -outerplanar if its embedding in the plane produces a drawing in which each vertex touches the external face [39]. Generally speaking, an embedding of  is -outerplanar if it is planar, and when removing the vertices lying on the external face, the remaining embedding is ()-outerplanar [14].

 is a geometric graph if its vertices are distinct points on the plane, and its edges are straight line segments with possible crossings [41]. Each vertex in  knows its pair of coordinates , and each edge has a weight representing the Euclidean distance between its two end-vertices [13], [47]. It seems to be easier to design algorithms in geometric graphs than in non-geometric ones (this conjecture based on the fact that geometric graphs provide additional information). For example, the authors of [51] present a simple algorithm that detects the edges of the external face in a geometric -outerplanar graph; in contrast, the algorithm of [39], that solves the same problem in a non-geometric one, is more elaborated.

Let  be an embedding of a tree in a plane such that no vertex has degree two and . Let  be the set of leaves of . Assume that there exists a set of extra edges  that connects all the vertices of  in the cyclic order of its embedding. Then, the graph , where  and  is Halin [31]. Halin graphs are -outerplanar. Fig. 1a shows an example of a Halin graph. In particular, the complete graph of four vertices, , is the smallest Halin graph. The skeleton of , shown in Fig. 1b, is the graph induced by . The skeleton of any Halin graph is always a tree.

Eppstein [17] designed a set of two reduction rules, called D3a and D3b, that when applied to a Halin graph, , the resulting graph, , is also Halin and . The successive application of these reduction rules gradually transforms the input Halin graph, , into a . We can think of this reduction procedure as a sequence of  graph transitions , where each transition transforms  into , for . Then, Eppstein uses an expansion procedure to identify the vertices that touch one external face of  (an external face is not necessarily unique for Halin graphs [20]; e.g., one can draw a  with four different external faces [48]).


Download : Download high-res image (141KB)
Download : Download full-size image
Fig. 1. (a) Example of a Halin graph . Solid and dotted edges denote  and , respectively. (b) Skeleton of .

1.2. Motivation of this work
This section describes our motivation and the practical and theoretical importance of the 2-packing set problem and Halin graphs. There are several applications for -packing sets for ; however, as the value of  grows, their importance seems to be more of theoretical interest.

According to Hale [30], -packing sets have applications to solve the frequency-distance constrained and frequency constrained optimization problems, where the general goal is to assign different frequencies to radio transmission stations to minimize channel interference. His work shows the equivalence between these two problems and graph coloring problem with neighborhood exclusion at a distance .

Similarly, Gairing et al. [21] and Manne and Mjelde [37], consider the computation of a 2-packing set as a subroutine in problems that require mutual exclusion such as the resource and facility allocation problems, where neighborhoods are required to avoid overlapping.

Butenko [12] shows relationships between independent sets and areas such as information retrieval, signal transmission analysis, classification theory, biomedical engineering, and economics. In his work, an example is the market graph that represents the cross-correlation of stock price fluctuation among markets. In such a graph, each stock is a vertex, and each edge is the correlation coefficient of its endpoint vertices. Here, independent sets are essential to finding diversified portfolios and classify stocks into different groups.

The importance of Halin graphs is two-fold. First, they admit polynomial-time algorithms for some problems that belong to the class NP-hard for arbitrary graphs. Some examples of this type of algorithms are the following: the traveling salesman problem [56], oriented chromatic number [16], the minimum edge coloring [24], the Steiner problem [55], and some other related problems.

Second, Halin graphs have many interesting structural properties that are important from the graph theory point of view, and some of them have practical applications. Some examples of these properties are the following: Halin graphs are 3-connected; i.e., in a Halin graph, there exist three vertex-disjoint paths between each pair of vertices. This property is relevant to the design of fault-tolerant networks. Halin graphs have treewidth  3; this property is relevant in the design of fixed-parameter tractable algorithms. Halin graphs are 1-Hamiltonian [36]; i.e., each Halin graph  is Hamiltonian, and after removing any vertex from , the remaining graph is still Hamiltonian. Bondy and Lovasz [9] proved that Halin graphs are almost pancyclic; i.e., they contain a cycle of each length between 3 and  with the possible exception of one length, which must be even; therefore, Halin graphs are non-bipartite. Sysło [48] proved that any Halin graph  different from a necklace has a unique embedding in which the cycle of edges that connects the leaves of the tree forms the external face of . Some examples of necklaces are the  and the trigonal prism, which have four and three different embeddings, respectively. Any other necklace graph has exactly two different embeddings.

1.3. Computational model
We model a distributed system as an undirected graph , where each vertex represents a processor and each edge a communication link between processors.

Our computational model is a restricted version of the shared memory model of [2]. Their model assumes that each processor can write only in its register, but can read from any processor in the system; in contrast, our model assumes that each processor can write only in its register, but it can read only from its closed neighborhood. The open neighborhood of vertex , denoted by , is the set of all neighbors of . The closed neighborhood of , denoted by , is the set .

We also assume the asynchronous model in which there exists no upper bound on how time elapses between consecutive read/write operations of a processor. In this paper, each vertex  has a unique identifier (id) of  bits. The length of any variable is  bits. We measure the time complexity as the maximum number of steps required by our algorithm. In counterpart, synchronous algorithms measure the time complexity in rounds. A round is the minimum period in which all processors perform read operations over the registers in its closed neighborhood and write in its register.


Table 1. Works related to the 2-packing set problem.



1.4. Related work
Many algorithms solve problems related to the -packing set. Table 1 shows an overview of some relevant deterministic algorithms for these problems. They assume different computational models, input graph instances, and values for . Some algorithms compute maximal sets, whereas others compute maximum sets. We can split the algorithms of Table 1 into three categories: -packing sets, -packing sets, and -packing sets.

1.4.1. 1-packing set
For the 1-packing set problem, some algorithms work on distributed or centralized computational environments. In Table 1, the distributed algorithms of [5], [25], [33], [35], [42], [43], [45], [46], [52] compute a maximal set, whereas the centralized algorithms of [7], [8], [15], [54], [57] compute a maximum set.

The work in [35] is very fast when a small constant bounds the maximum degree of the graph. Authors in [5], [42], [43] use the network decomposition technique [3]. This technique first partitions the set of vertices of the input graph into clusters with special characteristics. Then, it solves the problem for each cluster concurrently. Finally, it combines all the partial solutions to generate a global solution for the original problem. Unfortunately, this technique is not suitable for solving the -packing set problem for .

Authors of [25], [33], [45], [46], [52] provide self-stabilizing algorithms that compute maximal -packing sets. Self-stabilization in distributed algorithms deal with the tolerance of transient faults. All these algorithms work for arbitrary graphs, except the algorithm of [45], which works for anonymous trees.

There exist other approaches, not included in Table 1, to compute approximate solutions for the maximal -packing set problem. Some works focus on randomized distributed algorithms [6], [23]. Other works propose heuristics such as the genetic algorithm GENEsYs [4] and the optimization technique of [11]. The work of [58] proposes a simulated annealing algorithm to compute a near-optimal solution to the maximum -packing set problem.

There exist some other parallel algorithms, not included in Table 1, to find -packing sets. Some of them compute maximal sets [1], [27], [28], [34], others guarantee specific set sizes [29], or near maximum sets [49].

1.4.2. 2-packing set
Regarding the maximal -packing set problem, most of the algorithms of Table 1 are self-stabilizing [21], [22], [26], [44], [50], [53]. The algorithms of [21], [26], [44] are for arbitrary graphs. Gairing et al. [22] and Turau [53] extended the self-stabilizing model of computation to allow each processor to consult the information at a distance two. With this model, they compute a maximal 2-packing set on arbitrary graphs. Trejo-Sánchez and Fernández-Zepeda [50] designed an algorithm that computes a maximal -packing set in a cactus. Their algorithm computes a maximum -packing set when this graph is a ring.

For the maximum -packing set problem, there exist some algorithms that work on a centralized computational environment [19], [40]. These algorithms use a dynamic programming approach to solve this problem in a cactus and a tree, respectively.

As far as we know, the only distributed algorithm for the maximal 2-packing set, that is not self-stabilizing, is the algorithm of Trejo-Sánchez and Fernández-Zepeda [51]. Their algorithm assumes a geometric -outerplanar graph as input. Their algorithm uses circulating tokens to determine the external face of the graph. Then, it performs an ear decomposition. Finally, the algorithm computes a maximal 2-packing set by traversing each ear of the graph. Row  of Table 1 includes the result proposed in this paper.

1.4.3. k-packing set
There exist some algorithms to compute -packing sets. For arbitrary graphs, the algorithm of [37] finds a maximal -packing set on a distributed environment using self-stabilizing greedy rules. For trees, the algorithms of [40] solve a maximum -packing set on both distributed and centralized computational environments using dynamic programming.

We organize this paper as follows. Section 2 introduces some basic definitions and notation. Section 3 presents External-Face-Halin. Section 4 describes Vertex-Coloring. Section 5 presents the correctness and analysis of Maximal-2-Packing-Halin. Finally, Section 6 presents our concluding remarks and suggestions for future work.

2. Terminology and notation
Let  be the complete graph of three vertices, , shown in Fig. 2a. In this paper, we refer to  as the triangular graph. When  is a subgraph of a Halin graph, , the degree of each vertex in  is at least three. Let  be a set of triangular graphs, where . The fan graph [10], shown in Fig. 2b, is the graph generated by , such that all triangular graphs share a common vertex, called apex, and  and  share an edge for . A wheel graph [10] is a fan graph in which  and  also share an edge. Fig. 2c shows a , an example of a wheel graph where .

In a fan graph, a mid vertex is the one that has degree three, and a corner vertex is the one that is neither apex nor mid, see Fig. 2b. If  is a fan graph and subgraph of , then  connects to  only through the apex and the corners. Through the rest of this paper, we refer to a mid vertex and a corner vertex as mid and corner, respectively. In graphs of this type, there are always two corners and at least one mid. In a wheel graph, there are no corners.


Download : Download high-res image (66KB)
Download : Download full-size image
Fig. 2. (a) Triangular graph, . (b) Fan graph; vertex  is the apex; vertices  and  are corners; vertex  is a mid. (c) Wheel graph, .

Let  and


be the set of all triangular and fan subgraphs of , respectively. Let  be the resulting Halin graph after the th-iteration of External-Face-Halin. Given a subgraph

, any edge , such that  and , is a periedge of  and  is a perivertex of . Two subgraphs

are neighbors if they share at least one periedge.
Example 1

Assume that  is the triangular subgraph of Fig. 1a that consists of vertices  and edges . Then,  and , ,  are the sets of perivertices and periedges of , respectively.

Let  be the degree of vertex  in . The edge-adjacency list of , denoted by  in Pseudocodes 1, 2 and 10, is the list of edges incident to  in . Let  be the edge adjacency list of  in  during an execution of External-Face-Halin. Let  be the edge-adjacency list of the th neighbor of , where . Similarly,  denotes the th edge of , where , and  is the th neighbor of . Let  be the set of neighbors of  with degree three.

The  is a tuple of three elements used to determine if  locates in a fan or wheel subgraph. Fields one and two store vertex ids, whereas field three a binary flag. Each vertex  uses the binary operation , defined by Eq. (1), to update its . Operation  is associative and commutative. (1) where  and  in Eq. (1).

3. Finding an external face in a Halin graph
We implemented the Eppstein’s D3a and D3b reduction rules [17] into a distributed environment for determining . Eppstein presented a centralized implementation of these rules. We refer to our implementation of these rules as Compress-if-necessary-  and Compress-if-necessary-


, respectively.
The D3a rule of Eppstein collapses a triangular subgraph, , of  into a single supervertex, preserving the connections to the perivertices of . Fig. 3 illustrates the D3a rule. The D3b rule of Eppstein works only in fan subgraphs with . It removes the mid vertex and transforms it into a triangular subgraph. Fig. 4 illustrates the D3b rule.

External-Face-Halin consists of two main phases, compression and expansion. During the compression phase, the algorithm applies Compress-if-necessary-


to any existing fan subgraph in the current Halin graph. After that, the algorithm executes Compress-if-necessary-  to any existing triangular subgraph. Each time the algorithm applies these rules to a Halin graph , it generates a new Halin graph  with a smaller vertex set. This procedure repeats until the resulting graph is . At this point, the algorithm selects the  leader, the vertex with the minimum id that previously detected . We can think of the compression phase as a contraction algorithm that starts in the leaves of  and ends in .
During the expansion phase, the algorithm gradually assigns a color from the set  to each vertex of . We can think of the expansion phase as a ‘painting wave’ that starts in the  leader and propagates to the leaves of . At the end of this phase, the vertices of  are green, and the vertices of  are brown. Next, we describe this distributed algorithm, presented in Pseudocodes 2–9. These pseudocodes specify the actions to be performed by vertex .

Pseudocode 2 (External-Face-Halin) is the main component of Maximal-2-Packing-Halin. Its input is the edge-adjacency list, , of vertex . Its output is the flag  that the algorithm sets to green if ; otherwise, this flag is brown.

Line 2 of Pseudocode 2 initializes a set of variables through Initialize (see Pseudocode 3). During each iteration of the while cycle of Line 3, the algorithm first determines if the set of vertices of the current Halin graph forms a , through Detect-, in Line 6. If the Halin graph is not a , the algorithm determines if there exists some set of vertices that forms a fan graph, through Detect-


, in Line 9. If it exists, Line 10 performs its contraction through Compress-if-necessary-

; otherwise, Line 25 determines if there exists a set of vertices that forms a triangular graph through Detect- . If it exists, Line 26 compresses it through Compress-if-necessary- .
After executing Compress-if-necessary-


, Lines 13–22 update the degree and the edge-adjacency list of each vertex  in the resulting Halin graph. After the execution of Compress-if-necessary- , Lines 29–33 update the list  for each . After detecting a  and electing the  leader, the while cycle ends. Finally, Line 36 executes the expansion phase through Expansion.

Download : Download high-res image (304KB)
Download : Download full-size image

Download : Download high-res image (110KB)
Download : Download full-size image
In this paper, some pseudocodes use function sync, where . This function stops the execution of vertex  momentarily until each vertex  reaches  in the pseudocode.

The purpose of Pseudocode 4 (Detect-) is to determine if the current Halin graph is a . The nested cycles of Lines 3–16 check if there exist three edge overlaps in the edge-adjacency lists of . These overlaps imply that  forms a ; therefore,  forms a , as shown in Fig. 5b. In this procedure, at least one vertex detects a .


Download : Download high-res image (73KB)
Download : Download full-size image
Fig. 3. Reducing a triangular subgraph in a Halin graph. (a) Original triangular subgraph. (b) Reduced subgraph after applying the Eppstein’s D3a rule.


Download : Download high-res image (82KB)
Download : Download full-size image
Fig. 4. Reducing the smallest fan subgraph in a Halin graph. (a) Original fan subgraph. (b) Reduced subgraph after applying the Eppstein’s D3b rule.

Example 2

Fig. 5a shows that edges , and  are edges that overlap in the edge-adjacency list of ; therefore, vertex  detects a .



Download : Download high-res image (266KB)
Download : Download full-size image
When a  exists, Lines 18–21 determine if  is the  leader; if yes,  exits the compression phase. Then, Lines 26–31 notify this detection to all the vertices of  so they can quit the compression phase. After that, Lines 32–35 apply only for any  member that belongs to a supervertex. Such a vertex is an interceptor, i.e., a vertex that belongs simultaneously to two triangular subgraphs, or a triangular subgraph and a , or a triangular subgraph and a fan. Finally, Lines 38–43 communicate to the remaining vertices of a supervertex that a  was detected so they can quit the compression phase. Henceforth, the auxiliary variables  and  refer to singletons; i.e., sets with only one element.

The objective of Pseudocode 5 (Detect-


) is to determine if  locates in a wheel or a fan. Lines 5–11 determine if  is mid by checking if  and its neighbors of degree three connect to some common vertex, the apex. Lines 13–20 select some mids to be fictitious corners, preventing cases in which  locates in a wheel graph. Lines 22–34 determine if  is a corner by checking that  is neighbor of only one mid. In Line 24, ‘’ means the unique element .

Download : Download high-res image (258KB)
Download : Download full-size image
The purpose of Pseudocode 6 (Compress-if-necessary-


) is to remove all the mids from a fan subgraph to generate a triangular subgraph. In case the current Halin graph is a wheel, this routine generates a .
Lines 4–30 handle the case for the mids. In the while cycle of Lines 5–12, each mid  updates its  by computing the binary operation  with its two neighbors of degree three, one at a time. In Lines 6 and 9, mid  avoids the operation  with its neighbor  only when  is a fictitious corner, , and . This restriction allows only to the fictitious corner with the lowest id, , to detect its id in .


Download : Download high-res image (376KB)
Download : Download full-size image
When mid  locates in a fan subgraph, ,  exits the while cycle as soon as its , where  are the ids of the two corners of . Then,  quits the compression phase in Line 14. When mid  locates in a wheel subgraph,  exits the while cycle as soon as its , where  is the id of the lowest fictitious corner. If mid  is not neighbor of the lowest fictitious corner,  quits the compression phase in Line 17; otherwise,  belongs to the  and updates  in Lines 18–28.

Lines 31–42 handle the case for fictitious corners. In the while cycle of Lines 32–34, each fictitious corner  updates its  in the same way as the mids. When fictitious corner  locates in a fan subgraph,  exits the while cycle as soon as its . Then,  quits the compression phase in Line 36. When  locates in a wheel subgraph, ,  is the only vertex that exists the while cycle as soon as  detects that . Then,  updates  and waits in the while cycle of Line 39 until all the mids and non-fictitious corners in  quit the compression phase. Finally,  quits the compression phase in Line 40. All fictitious corners, except the lowest indexed one, exit the while cycle of Lines 32–34 as soon as , and quits the compression phase in Line 36.

Finally, lines 43–51 handle the case for corners. In the while cycle of Lines 44–46, each corner  updates its  repeatedly until it reads the id of the other corner. After exiting the while cycle,  updates  in 47–50.

The objective of Pseudocode 7 (Detect- ) is to determine if a three-vertex set forms a triangular subgraph, . Each vertex of degree three, independently, analyses the edge-adjacency lists of its neighbors of degree three to detect . Vertex  needs to determine the existence of a path (that does not include ) between two of its neighbors  and . It is enough to find one common edge in  and , see Example 3 and Lemma 1.

The nested for cycles of Lines 4–17 search for an edge overlap in the edge-adjacency lists of . If Line 7 determines that such an overlap exists, vertex  through Lines 10–12 constructs the edge-adjacency list of the resulting supervertex as follows. Take the edges of , , and  and remove the edges inside ; i.e., edges  and the overlapped edge (each edge appears twice). The three remaining edges were the periedges of , and now, they belong to the edge-adjacency list of the new supervertex. This new list preserves the external connections of , see Example 4. Additionally, Line 13 stores in variable  the vertices of .


Download : Download high-res image (282KB)
Download : Download full-size image
Example 3

In Fig. 6a, vertex  determines that edge  belongs to both  and ; therefore, there exists a triangular subgraph among .

Example 4

In Fig. 6b, vertex  removes edges , and  from , and . The remaining edges,  form the edge-adjacency list of the new supervertex.

The purpose of Pseudocode 8 (Compress-if-necessary- ) is to transform a triangular subgraph  into a supervertex. In Line 8, each vertex  of  determines if its perivertex belongs to a neighbor triangular subgraph. In Lines 10–14, the detector of  computes the minimum id of the neighbor triangular subgraphs, if they exist. Lines 16–19 propagate the above information from the detector to the remaining vertices of . Lines 21–29 allow the vertices of  to compress if  has no neighbor triangular subgraphs or the id of  is the minimum among all ids of its neighbors.

In Lines 33–44, vertex  quits the compression phase if  belongs to the supervertex that contains , but . In Lines 34–36 and 37–41, the detector  of  identifies the vertices that must quit the compression phase and stores its ids in . Finally, in Line 43, each vertex that reads its id from  quits the compression phase.


Download : Download high-res image (290KB)
Download : Download full-size image
The objective of Pseudocode 9 (Expansion) is to identify the vertices of . Lines 2–5 start the expansion phase by assigning the brown color to the  leader, whereas Line 6 assigns the green color to the remaining vertices of . We can see the expansion phase as a color wave that starts in the , propagates outwards, and ends in the vertices of . This pseudocode distinguishes four cases.

•
Case 1. (Lines 8–11) When  is an uncolored mid, it waits until its apex sets its color to brown. Then,  sets its color to green.

•
Case 2. (Lines 13–27) When an uncolored vertex  belongs to a triangular subgraph ; there are two subcases. First, when  is not an interceptor of ,  waits until some of its neighbors in  sets its color. Second, when  is an interceptor, it waits until some neighbor outside  sets its color. After that, in either case,  sets its color to brown only if it directly connects to a brown vertex outside ; otherwise, it sets its color to green.

•
Case 3. (Lines 29–37) When an interceptor  is green, it recolors to brown only if  directly connects to a brown vertex outside .

•
Case 4. (Line 39) When a non-interceptor vertex is green, it belongs to .

Expansion ends when each vertex  of  has its variable .

4. Coloring a maximal 2-packing set
This section describes Vertex-Coloring, an algorithm, that sets the variable  to one color from the set  for each . Each vertex  uses a variable , which points to some , to ease the computation of the maximal -packing set. The set of red vertices corresponds to a maximal -packing set of . Each red vertex always points to itself. Each blue vertex  always locates to a distance one from its unique red neighbor  and points to . Each blue vertex  always locates to a distance of at least two from its nearest red vertex and points to itself. This coloring procedure is inspired by the procedure of Trejo-Sánchez and Fernández-Zepeda [50], which finds a maximal -packing set in a cactus graph.


Download : Download high-res image (219KB)
Download : Download full-size image
Pseudocode 10 (Vertex-Coloring) is the main component of the coloring procedure. Line 3 of this algorithm selects the cycle leader, the vertex with the minimum id among the vertices of , through Leader-Election (not shown in pseudocode). This procedure is practically the same as the one External-Face-Halin uses during the election of a fictitious corner when handling wheel graphs.

Line 4 assigns a sequential number, , from the set  to each , through Numbering-Cyc-Vertices (not shown in pseudocode). This procedure starts in the cycle leader and continues with its lowest indexed neighbor of . Finally, Numbering-Cyc-Vertices sets the variables  for each . For each , this procedure also defines a ‘predecessor’ and a ‘successor’ (denoted by  and , respectively); i.e., vertex  is successor of  iff ; the definition for the predecessor of  is similar.

Lines 8 and 10 color the vertices of  and  throughSkeleton-Coloring and Cycle-Coloring, respectively. Finally, Lines 13–24 recolor some vertices from  to  and vice versa to correct some inconsistencies. We assume that all the vertices in the graph finish their computations the same time after the execution of Leader-Election and Numbering-Cyc-Vertices.

Pseudocode 11 (Skeleton-Coloring) colors the vertices of . First, Line 2 identifies each skeleton leaf. Then, Lines 3–9 assign the red color to the skeleton leader, the unique vertex of the skeleton that is neighbor of the cycle leader. After that, through Lines 13–16, each non-colored vertex , at a distance one from a red vertex , receives the blue color and points to .

Then, through Lines 22–24, each non-colored vertex  at a distance two from a red vertex receives the blue color (and points to itself) if  is a skeleton leaf; otherwise, through Lines 26–28,  receives the blue color and points to its non-colored neighbor with the lowest id. Finally, through Lines 17–20, if  is non-colored and it has a blue neighbor that points to , then  receives the red color and points to itself. Fig. 8a shows an example of the coloring of the skeleton in which  is the skeleton leader. This figure shows red, blue, and blue vertices as black, gray, and white circles, respectively.


Download : Download high-res image (206KB)
Download : Download full-size image
Pseudocode 12 (Cycle-Coloring) colors the vertices of . First, through Lines 2–4, each  identifies its ‘skeleton neighbor’ () and reads its color. The skeleton neighbor of  is its only neighbor that belongs to the skeleton. Then, in Lines 5–8, the cycle leader sets its color to  and its pointer to the skeleton leader. After that, through Lines 10–13, each , whose , sets its color and pointer according to Table 2. Before using this table,  requires to know the colors of the following vertices: the skeleton neighbor of , , and the skeleton neighbor of . Fig. 7 illustrates the location of such vertices. Finally, Lines 14–17 set the color and pointer of  whose . Fig. 8b shows an example of the coloring of the external cycle in which  is the cycle leader.


Download : Download high-res image (150KB)
Download : Download full-size image
5. Correctness and analysis of Maximal-2-Packing-Halin
This section proves the correctness of Maximal-2-Packing-Halin, which consists of two parts: one for the skeleton and one for the external cycle. Finally, we analyze the execution time of Maximal-2-Packing-Halin.

5.1. Correctness of External-Face-Halin
Next, we prove that our distributed reduction rules are correct and equivalent to those of Eppstein [17]; therefore, External-Face-Halin identifies each .

Lemma 1

Vertex , through Detect-, identifies the existence of a triangular subgraph in  among vertices  by checking that , ,  and  and , where  and  are vertices in the supervertices of  and , respectively.

Proof

By contradiction. Assume that there exists in  a set of three vertices  that satisfies the conditions of Lemma 1, but it does not exist any triangular subgraph among such vertices. Note that  and  are neighbors of . Since  belongs to supervertex , there exists a path from  to . Similarly, there exists a path from  to . Since edge  belongs to both  and , there exists a path from  to , from  to , and from  to  that does not cross . Therefore, there exists a triangular subgraph among .  □

Lemma 2

Compress-if-necessary- reduces a triangular subgraph to a single supervertex.

Proof

By the definition of edge-adjacency list, each list , , and  contains one periedge of the triangular subgraph. It is enough to show that the removed edges belong to the triangular subgraph. Note that edges ,  belong to the triangular subgraph since  and  are neighbors of . Additionally, the overlapped edge also belongs to the triangular subgraph because this edge is part of the path that connects  to . By symmetry, each edge appears twice in the edge-adjacency lists; therefore, the three remaining edges form the edge-adjacency list of the new supervertex.  □

Lemma 3

Each vertex , through Detect-


, assumes the role of mid of a fan subgraph consisting of vertices , , ,  by checking that , ,  , and by checking the existence of some  such that , ,  .

Download : Download high-res image (152KB)
Download : Download full-size image
Fig. 8. Identifying a maximal -packing set, , in . Black vertices belong to . (a) Graph after the execution of Skeleton-Coloring. (b) Graph after the execution of Cycle-Coloring.

Proof

The conditions of Lemma 3 are necessary and sufficient to detect a mid in a fan subgraph, according to Section 2.

Lemma 4

Each vertex , through Detect-


, assumes the role of corner of a fan subgraph by checking that , , where  is a mid and .
Proof

The conditions of Lemma 4 are necessary and sufficient to detect a corner in a fan graph, according to Section 2.

Lemma 5

Each vertex , through Detect-


, assumes the role of fictitious corner in a fan subgraph if  is a mid, , such that  and  are mids, and  has the minimum id in .
Proof

The conditions of Lemma 5 are necessary and sufficient to detect a fictitious corner in a fan graph, according to Section 2.

Lemma 6

Compress-if-necessary-


reduces a fan subgraph to a triangular subgraph.
Proof

Let  be a fan subgraph of . In Compress-if-necessary-


, each mid  propagates the ids of the two corners by performing the binary operation  with the information of one or two of its neighbors and updates its variable . Each mid  removes from  (quits the compression phase) as soon as it detects the ids of both corners. Finally, Compress-if-necessary-

updates the edge-adjacency list of both corners. Additionally, the edge adjacency-list of the apex updates after returning to External-Face-Halin; therefore, the apex and the corners form a triangular subgraph.  □
Lemma 7

Compress-if-necessary-


reduces a wheel to a .
Proof

Let  be a wheel. Since there are no corners in , Compress-if-necessary-


identifies the fictitious corner  with the lowest id. Then, each mid  propagates the id of  by following a procedure similar to the one discussed in Lemma 6. All the mids, except  and its two neighbors, quit the compression phase. Finally, Compress-if-necessary-

updates the edge-adjacency lists of the two neighbors of . The edge-adjacency list of  does not change. The edge-adjacency list of the apex updates similarly as discussed in the proof of Lemma 6; therefore, the remaining four vertices form a .  □
Lemma 8

Each vertex , through Detect-, determines if  belongs to a  by checking that  and the existence of three pairs of edge overlaps in , , and .

Proof

Any vertex in a  has three neighbors of degree three. Vertex  checks this condition before the execution of Detect-. Then, this procedure searches exhaustively the existence of three edge overlaps in , , and . These overlaps imply that there exists a triangular subgraph in the vertices of . Since these three vertices are also neighbors of , vertex  is in a .  □

Lemma 9

The compression phase of External-Face-Halin reduces a Halin graph to a .

Proof

By Lemma 1, Lemma 2, Lemma 3, Lemma 4, Lemma 5, Lemma 6, Lemma 7, our implementation of the two reduction rules of Eppstein [17] is correct, whereas, by Lemma 8, the algorithm stops the compression phase after detecting a . □

Lemma 10

Expansion identifies all the vertices of .

Proof

The proof follows from the procedure of Eppstein [17]. Expansion reverses our implementation of the Eppstein reduction rules. This algorithm starts by assigning the brown color to the  leader and the green color to the remaining vertices of . By case 1, Expansion assigns the colors to vertices in fan subgraphs. By cases 2 and 3, it assigns the colors to vertices of triangular subgraphs. Finally, by case 4, it concludes the coloring of the vertices that touch the external face of . This expansion phase continues until restoring the original graph. The green vertices correspond to  and brown vertices to .  □

Corollary 1

External-Face-Halin identifies all the vertices of .

Proof

It follows from Lemma 9, Lemma 10.

5.2. Correctness of Vertex-Coloring
Next, we prove that Skeleton-Coloring and Cycle-Coloring identify the vertices that belong to a maximal -packing set of .

Lemma 11

Skeleton-Coloring identifies the vertices of  that belong to a maximal -packing set of .

Proof

The correctness of this lemma comes directly from the coloring phase of [50] since Skeleton-Coloring is inspired by such a work. The algorithm of [50] performs the coloring in a cactus graph. Since the skeleton is also a cactus, such a procedure identifies all the vertices of a maximal -packing set of .  □

Lemma 12

Cycle-Coloring identifies the vertices of  that belong to the maximal -packing set of .

Proof

By induction on the variable .

•
Base case. When ,  sets its color to  and its pointer to  (the skeleton leader) since such a vertex is .

•
Inductive hypothesis. Assume that Cycle-Coloring identifies all the red vertices of  up to , such that .

•
Inductive step. Note that the color of , whose , depends only on , , and . Then, Cycle-Coloring computes the color of  from Table 2 since it establishes the best color for  for all possible color combination of these three vertices.

Finally, the vertex , whose , receives the blue color since the skeleton leader is at a distance two.  □

Remark 1

Vertex-Coloring changes the color of some vertices from  to  or vice versa and corrects their pointers to be consistent with the selection of red vertices. This final color correction only affects blue vertices; i.e., it does not affect the maximal -packing set.

Corollary 2

Vertex-Coloring identifies the vertices that belong to a maximal -packing set of .

Proof

It follows from Lemma 11, Lemma 12.

5.3. Time complexity
Next, we prove that Maximal-2-Packing-Halin runs in  time.

Lemma 13

Detect- determines if  belongs to a triangular subgraph of  in  time.

Proof

Note that Detect-  only executes if . Then, Detect-  searches the existence of a common edge  in at most three lists of size three; therefore, Detect-  takes  time.  □

Lemma 14

Compress-if-necessary- reduces a triangular subgraph to one supervertex in  time.

Proof

Constructing the new  of the supervertex takes  time since this procedure removes only six edges from , , and .  □

Lemma 15

Detect-


determines if  is either a mid, a corner, a fictitious corner, or none of them in  time.
Proof

It is sufficient to show that vertex  can verify the necessary conditions of Lemmas 3, 4, and 5 in  time by checking its local variables.  □

Lemma 16

Compress-if-necessary-


reduces a fan subgraph  to a triangular subgraph in  time, where  is the number of mids in .
Proof

The propagation of the ids of the two corners takes  time since each mid  can update its variable  in  time through the binary operation . Updating the edge-adjacency list of both corners takes  time since the degree of each corner is three.  □

Lemma 17

Compress-if-necessary-


reduces a wheel subgraph ϒ to a  in  time, where  is the number of mids in ϒ.
Proof

Detecting the fictitious corner with the minimum id and propagating it to each mid takes  time. Updating the edge-adjacency list of all the vertices of  takes  time since the degree of each vertex is three.  □

Lemma 18

Detect- determines if  belongs to a  in  time.

Proof

Detecting the existence of three edge overlaps in the three edge-adjacency lists of  takes  time since each vertex has degree three.  □

Lemma 19

The compression phase of External-Face-Halin takes  time.

Proof

In the worst case, in each iteration, External-Face-Halin detects and compresses a triangular graph, or a fan graph, or detects a . In the first case, these detection and compression take  time, and the number of vertices of the current graph reduces in two units. In the second case, the detection and compression take  and  time, respectively. For this case, the number of vertices of the current graph reduces in  units. Finally, in the third case, the detection takes  time. On average, reducing the number of vertices in one requires  time; therefore, the compression phase of External-Face-Halin requires  time to reduce to a .  □

Lemma 20

Expansion takes  time.

Proof

Expansion sets the color of each . This process takes  time per vertex. In the worst case, a vertex sets its color immediately after one of its neighbors already set its color; therefore, Expansion takes  time.  □

Lemma 21

Skeleton-Coloring executes in  time.

Proof

Skeleton-Coloring requires  time to color each vertex; therefore, this procedure takes  time.  □

Lemma 22

Cycle-Coloring executes in  time.

Proof

Cycle-Coloring is a sequential procedure that requires  time to color each vertex of ; therefore, this procedure takes  time.  □

Remark 2

In  time, Vertex-Coloring corrects the colors and pointers of some blue vertices to be consistent with the selection of red vertices.

Theorem 23

Maximal-2-Packing-Halin runs in  time.

Proof

It follows from Lemma 19, Lemma 20, Lemma 21, Lemma 22.  □

6. Concluding remarks and future work
In this paper, we propose Maximal-2-Packing-Halin, a distributed algorithm that computes a maximal -packing set in undirected, non-geometric Halin graphs in linear time.

This algorithm consists of two phases. The first one, External-Face-Halin, identifies the vertices of the external cycle and the skeleton of the input graph. For this phase, we designed a distributed algorithm that implements the Eppstein’s reduction rules [17]. Eppstein described such rules from a centralized point of view. The main challenge to carry out these rules in our distributed computational model is how to replace the global view of the system by the partial view of each processor.

The second phase, Vertex-Coloring, performs a procedure that assigns the color  to the vertices of a maximal -packing set. This procedure consists of two subphases. The first one colors the vertices of the skeleton, whereas the second one colors the vertices of the external cycle. The algorithm of [50] is the base of Vertex-Coloring.

For future work, we are planning to analyze the feasibility of generalizing Maximal-2-Packing-Halin to find a maximal -packing set.