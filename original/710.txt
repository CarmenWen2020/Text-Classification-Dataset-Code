Abstract
Hybrid cloud is a cost-effective way to address the problem of insufficient resources for satisfying its users’ requirements in a private cloud by elastically scaling up or down its service capability by combining the private cloud and public clouds. However, it is a challenge to schedule tasks on hybrid resources concerning their performance and security requirements. To address the challenge, this paper aims at improving the number of finished tasks with deadline and security requirements and the resource usage cost in heterogeneous hybrid clouds, based on data protection technologies providing various security levels with different overheads for data transfers and task executions in public clouds. We first formulate the problem as a bi-objective binary nonlinear programming (BOBNP) model which is a NP-hard problem. Then, to solve the problem in polynomial time, we propose a Task Scheduling method concerning Security (TSS). To improve the cost, TSS iteratively assigns the task requiring maximum cost of public resources to the local cluster, and rents the public resource with the best cost-performance ratio first for outsourced tasks. To complete as many tasks as possible, TSS assigns tasks cannot be finished by public clouds to the local cloud at first, and employs the idea of Least Slack Time First (LSTF) with Earliest Deadline First (EDF) in each computing node. Extensive experimental results show the superior performance of TSS in satisfying task requirements, and in resource efficiency when task deadlines are not too tight, compared with four hybrid cloud scheduling methods proposed recently.

Keywords
Cloud computing

Hybrid cloud

Task scheduling

Security

1. Introduction
Cloud computing has received increasing attention in both research and business for more than ten years as it provides a great deal of benefits, e.g., elastic resource provisioning, pay-for-use, economies of scale, high reliability, dynamic customization, etc. [60]. Although provisioned resources appear to be infinite to its users, a cloud has limited resources in the real world. A cloud should have enough resources for satisfying the peak demand of its users’ requests.

When there are insufficient resources for a private cloud meeting the peak demand of its users, three methods can be exploited.

(1)
The first one is to reject some unimportant requests,e.g., cheap requests, to make room for processing important requests whose rejections cost much more [29]. While this method reduces the service provider’s reputation [14], and thus results in a loss of potential users.

(2)
The second approach is adding enough infrastructures to the private cloud for satisfying the peak demand. While, in a real production environment, the peak resource demand is usually much larger than the average one, but transient [4], [25], which leads to a lot of idle resources most of the time if using the method. Besides, most of small to medium enterprises have insufficient capital for infrastructure investments.

(3)
The third method, hybrid cloud [68] (a.k.a, cloud bursting), is a cost-efficient way to address the problem, which elastically scales up or down the service capability based on demand by combining the private clouds and public clouds. Most of the small to medium enterprises prefer the method [9], and nowadays, both commercial and open-source virtualization tools support basic cloud bursting functionalities, e.g., VMware [63], Open Nebula [42], OpenStack [43]. As a new computing paradigm, hybrid cloud computing plays a crucial role not only in developing cloud computing, but also in the integration of cloud computing and Internet of Things (IoT) [8] as others, e.g., edge computing [52], fog computing [16], mobile cloud computing [20].

To optimize the task execution on hybrid clouds, some task scheduling methods have been proposed for various objectives, e.g., minimizing the makespan [11], [73], [74], optimizing the financial cost [11], [45], [51], [65], minimizing SLA violation [36], etc. While for simplification, the majority of these methods treated private resources1 in the same way as public resources and many works considered that the private and public resources were homogeneous in various ways, e.g., all resources were homogeneous [11], private resources were heterogeneous while public resources were homogeneous [7], [31]. In real world, private resources are heterogeneous because servers are gradually provisioned and replaced over the operation [18]. For example, there are more than ten different computing capacities of servers in the Gaia Cluster [58] of the University of Luxembourg, which has evolved six times. Each Borg cluster of google includes thousands of heterogeneous machines [61]. Public clouds, e.g., Amazon Elastic Compute Cloud (Amazon EC2) [3] and Alibaba Cloud [2], provide resources in the forms of virtual machines (VMs) with several types. And the resource heterogeneity is a key to optimize the performance of task executions [15], [37]. Therefore, the heterogeneity2 of resources should be concerned when designing task scheduling methods in a cloud environment.

Security is the top concern of an enterprise outsourcing its tasks to a public cloud [40], [47], [50]. Thus, several works tried to address the security problem when scheduling tasks in hybrid cloud environments [13], [28], [34], [48], [53], [54], [55], [72]. While, to our best knowledge, all existing works used two-level security model, when concerning security of task execution on hybrid clouds. The private task with the high security level must be processed in the private cloud, while a public task with the low security level represents it can be executed in both the private and public clouds. While, in real world, usually, the security requirements are not just binary decisions for various tasks [71]. For example, tasks processing the financial transaction data generally have a higher security level than tasks processing the users’ game data for gaming service providers, where both kinds of tasks have security requirements [19], [30].

Some tasks having security requirements can be also outsourced to the public cloud [22], [32], [38], [69], which provides more opportunities for optimizing the performance of task execution while increases the complexity of the problem. However, there are resource overheads to achieve a level of security in public clouds, where the security level is generally implemented by data protection technologies [71], e.g., MD5, SHA-1, etc., and thus when a new task with security requirements is arriving, there is a tradeoff between the overheads of using protection technologies for outsourcing the task to a public cloud and the consumption of limited private resources for executing it.

Thus, in this paper, we design task scheduling algorithm to optimize task execution on hybrid clouds using multi-level security model. We focus on two objectives of maximizing the number of completed tasks and minimizing the cost satisfying the requirements of tasks’ deadlines and security levels. To achieve these objectives, we first formulate the task scheduling problem on hybrid clouds concerning security of task execution as a bi-objective binary nonlinear programming (BOBNP) problem. As the problem is NP-hard problem [33], we then propose a heuristic algorithm to solve the BOBNP problem in polynomial time complexity. In brief, the contributions of this paper can be summarized as follows:

•
We model the task scheduling on heterogeneous hybrid clouds into a BOBNP problem concerning multi-level security model, which maximizes the number of completed tasks and minimizes the cost for renting resources from public clouds to processing tasks with various deadline and security constraints.

•
To solve the BOBNP problem in polynomial time, we design a heuristic algorithm for task scheduling concerning security (TSS) considering the completed task number maximization as the main objective. At first, to avoid task violation, TSS assigns tasks that cannot be finished by public clouds to the local cluster,3 and then greedily assigns the task which needs the public resource costing the most to the local cluster. In the local cluster, to minimize the used server number, TSS schedules tasks to the server with maximal processing capacity. When local resources are insufficient, TSS rents the VM with the best cost-performance ratio for finishing outsourced tasks. In a computing node (a local server or a public cloud VM), TSS employs the idea of Least Slack Time First (LSTF) and Earliest Deadline First (EDF) to assign tasks to cores for finishing as many tasks as possible within their respective deadlines, and reassigns the last task in the core with maximal use time to the core with minimal use time to balance loads among cores for improving the resource efficiency and the task performance.

•
We conduct extensive simulation experiments using a real world data trace to investigate the effectiveness and efficiency of the proposed algorithm. The experiments results show that our heuristic algorithm improves up to 48.6% resource utilization, up to 71.6% energy efficiency for local resource usage, up to 300 times finished tasks, and up to 34.6% makespan, compared with four recently proposed methods, MPHC [55] and TRH1-3 [75]. And more important, TSS has no deadline violation in task execution on the hybrid cloud all the time.

The rest of the paper is organized as follows. Section 2 presents our model of the task scheduling problem on hybrid clouds, Section 3 designs the heuristic algorithm for solving the problem. Section 4 evaluates our scheduling algorithm based on a real world data trace. Section 5 discusses related work and Section 6 concludes this paper.

2. Problem formulation
In a hybrid cloud environment, a task runs on a server in the private cloud (or the local cloud/cluster) or a VM leased from the public cloud. The private resources can be provided in the form of physical machines (PMs)4 or VMs, which has no impact on our model and approach. If a task with a security level requirement is assigned to the public cloud, then corresponding protection technologies must be exploited to satisfy the requirement. In this paper, the objective is cost-efficiently scheduling tasks to the hybrid resources to meet the complete time within corresponding deadline and their required security levels, i.e., to provide the mapping between the PMs or rented VMs and the tasks with maximal finished tasks and minimal cost while fitting deadlines and security levels.

2.1. Hybrid cloud model
We consider a hybrid cloud consisting of a private cloud and a public cloud, as shown in Fig. 1. Multiple public clouds in a hybrid cloud can be seen as one big public cloud including the resources provisioned by these public clouds, which holds true to executing independent tasks. In the private cloud, there are  servers to execute submitted tasks. Server 
 () has 
 cores for each of which the computing capacity is 
. 
 can be quantified with several optional performance units, e.g., MIPS, FLOPS, Hz, etc. The unit of choice is Hz in our experiments, and our model is compatible to any other performance units. The public cloud provides  VM types (
) that the private cloud selects to rent VM instances when it has insufficient resources for satisfying all tasks’ requirements. A VM instance of 
 type has 
 cores each with computing capacity of 
. The price per unit time of VM instances with 
 type is 
. The notations used in this paper are shown in Table 1.


Table 1. Notations.

Notation	Description
The number of tasks.
The th task.
The size of 
.
/
The input/output data size of 
.
The deadline of 
.
The number of servers in the private cloud.
The th server in the private cloud.
The number of computing cores of 
.
The computing capacity of each core on 
.
The number of VM types provided by the public cloud.
The th VM type.
The number of VM instances with th VM type.
The number of computing cores of VM instances with type 
.
The computing capacity of each core on VM instances with type 
.
The price per unit time of each VM instance with type 
.
/
The read/write bandwidth of the DFS in the private cloud.
The network bandwidth between a private server and a public VM instance.
The price per unit size of data transferred from the public cloud to the private cloud.
/
/
The security level required by 
 in authentication/confidentiality/integrity.
/
/
The security level provided by 
th authentication method/
th cryptographic algorithm/
th hash function, where the security level required by 
 can be satisfied by the authentication/cryptographic/hash method.
/
/
The overhead of 
th authentication method/
th cryptographic algorithm/
th hash function.
The execution time of 
 in 
.
The execution time of 
 in a VM instance with type 
 without any security requirement.
The execution time of 
 in a VM instance of type 
 with the security requirements that are satisfied by 
th authentication method, 
th cryptographic algorithm, and 
th hash function, respectively.
/
/
The execution time of 
 in a VM instance of type 
 with only the security requirement in authentication/confidentiality/integrity, which is satisfied by 
th authentication method/
th cryptographic algorithm/
th hash function.
The finish time of 
 when it is executed by core  on 
.
/
The finish time of 
 when it is executed by core  on 
 with the bottleneck of the computing/network resource.
The finish time of 
 when it is executed by core  on th instance with VM type 
, where the security requirements are satisfied by 
th authentication method, 
th cryptographic algorithm, and 
th hash function, respectively.
/
The finish time of 
 when it is executed by core  on th instance with VM type 
, where the security requirements are satisfied by 
th authentication method, 
th cryptographic algorithm, and 
th hash function, respectively, where the computing/network resource is the bottleneck.
The cost for renting th instance with VM type 
.
The cost for network resources in the public cloud.
2.2. Task execution model
In this paper, we focus on independent tasks, e.g., parallel image rendering [62], data analysis [41], and software testing [10], as their prevalence in the parallel and distributed systems [24], [39]. We will extend our approach to support other kinds of applications, e.g., workflows, in the future.

There are  submitted tasks (
) to be executed in the hybrid cloud. The size of task 
 is 
 in the performance unit of servers, then it consumes 
 time to finish the task5 if the task is assigned a core with the computing capacity of . For task 
, the sizes of input data and output data are respectively 
 and 
, and its deadline is 
. There are various deadline requirements for different tasks, for example, online dangerous detection algorithms must provide results within a very few seconds for drivers, while the recognition of offline dangerous states can tolerate minutes of latency, in Advanced Driver Assistance Systems (ADAS) [26]. Without loss of generality, we assume that 
.

We assume that the data required by tasks are stored in a distributed file system (DFS), a most commonly used method, on the private cloud, and their output data are also stored in the DFS. The bandwidths of server 
 reading and writing data from the DFS are respectively 
 and 
. If 
 is assigned to 
, inputting and outputting data take 
 and 
 time, respectively, then to complete 
, it tasks time (1)
 
 
 

The data transfer bandwidth between the private and public clouds is ,6 then inputting and outputting data for 
 without security requirements, i.e., transferring data from a cloud to another, take time 
 and 
, respectively. The consumed time of finishing 
 without security requirements on a VM instance of type 
 is (2)
 
 

2.3. Security model
In this paper, we concern security level requirements of tasks in three aspects, user authentication, integrity and confidentiality, representing degrees of guarding against main security threatens, alteration, snooping and spoofing, respectively [71]. For a task, values of security levels are set between 0 and 1, to represent its minimum security level requirements, in these three aspects. The higher the security levels, the more security sensitive the task is. The same security level value in different security aspects has different meanings.

When a task is assigned to the private cloud providing the maximum level of security environment, there is no additional protection technology for satisfying the task’ security level requirements, as it provides services only for insiders. While if a task with security level requirements is outsourced on the public cloud, corresponding technologies must be exploited to guard against potential threats in respective certain degrees based on required security levels. However for each aspect of security level requirement, protection technologies have overheads [71] which increase the finish times of some tasks.

For each security method, the security level can be quantified by theoretical analysis, which has matured due to a history of more than 100 years for the modern cryptography. The overhead of each security method can be achieved by experiments. In this paper, the security level and the overhead of each security method are set referring to [32], [71]. The security level required by each task can be got from the corresponding service level agreement. Referring to [32], [71], several alternative technologies used for implementing functionalities of user authentication, confidentiality and integrity for outsourcing tasks, and their overheads are shown in Tables 2, 3, and 4, respectively.

As shown in Fig. 1, when a task is outsourced to the public cloud, it requests the private cloud to send its input data to the public cloud for its execution. The authentication of request must be validated to protect the data transfer from alteration attacks in a certain extent according to its service level requirement. For task 
 having security level requirement of 
 in the aspect of user authentication, a user authentication method providing a higher security level must be applied if the task is outsourced to the public cloud, (3)
where 
 represents the security level provided by the 
th authentication method (
,  in this paper). We assume that 
, 
, without loss of generality,7 as shown in Table 2, where 
 is the overhead of 
. Thus, the best authentication method (say 
th) satisfying the security level requirement with minimum overhead for task 
 is that meets the following conditions, (4)
While the method has a fixed overhead as it is executed only once for an outsourced tasks (
), as shown in Table 2, which increases the execution time of the task, (5)
where 
 is the time consumed by finishing outsourced task 
 assigned to a VM instance of type 
 exploiting 
th authentication method satisfying the task’s security level requirement only in user authentication, and 
 is the one-time overhead of 
th authentication method.

After authorizing the request of an outsourced task, 
, the input data requested by the task is transferred from the private cloud to the public cloud for its execution, and the output data will be sent back to the private cloud when the task is completed. An encryption method or a cryptographic algorithm should be applied to prevent snooping or other attacks, such that information and resources are not available to unauthorized persons or processes, for satisfying the security level requirement in the data confidentiality (
) with minimum overhead, (6)
where 
 is the security level provided by 
th cryptographic algorithm (
). The time overhead of a cryptographic algorithm is proportional to the amount of protected data, as shown in Tables 3. Then the consumed time of outsourced task, 
, is increased to (7)
where 
 represents the consumed time when the task has only a security level requirement in the data confidentiality implemented by 
th cryptographic algorithm, and 
 is the time overhead of 
th cryptographic algorithm per data amount.


Table 2. User authentication methods.

Number	Authentication methods	Security level	Overhead (ms)
0	No method	0	0
1	HMAC-MD5	0.55	90
2	HMAC-SHA-1	0.91	148
3	CBC-MAC-AES	1.00	163
–	Private Cloud	1.00	0
When the private cloud receives the result from an outsourced task (
), the data integrity should be checked to prevent spoofing attacks, which is usually implemented by hash functions as shown in Table 4. Assuming 
 is the task’s security level requirement in the data integrity, satisfied by 
th hash function that provides the security level of 
 (
), then we have (8)
As cryptographic algorithms, a hash function also has a time overhead being linear to the data amount, as shown in Table 4. Then the time exhausted by the task having only a security level requirement in the data integrity implemented by 
th hash function is (9)
where 
 is the time consumed by 
 that has only the data integrity requirement satisfied by 
th hash function, and 
 is the time overhead of 
th hash function per data amount.


Table 3. Cryptographic algorithms for confidentiality.

Number	Cryptographic algorithms	Security level	Overhead (KB/ms)
0	No method	0	–
1	SEAL	0.08	168.75
2	RC4	0.14	96.43
3	Blowfish	0.36	37.5
4	Knufu/Khafre	0.40	33.75
5	RC5	0.46	29.35
6	Rijndael	0.64	21.09
7	DES	0.90	15
8	IDEA	1.00	13.5
–	Private Cloud	1.00	–

Table 4. Hash functions for integrity.

Number	Hash functions	Security level	Overhead (KB/ms)
0	No method	0	–
1	MD4	0.18	23.90
2	MD5	0.26	17.09
3	RIPEMD	0.36	12.00
4	RIPEMD-128	0.45	9.73
5	SHA-1	0.63	6.88
6	RIPEMD-160	0.77	5.69
7	Tiger	1.00	4.36
–	Private Cloud	1.00	–
Take these three aspects together, we have the time consumed by the task (
) outsourced on an instance of VM type 
 with the security level requirements in user authentication, data confidentiality, and data integrity, (10)
where 
 is the time exhausted by 
 having security level requirements that respectively satisfied by 
th authentication method, 
th cryptographic algorithm, and 
th hash function.

2.4. Problem formulation
Assuming that there are 
 instances (
) of VM type 
 should be rented to finish all tasks within their respective deadlines. 
 and 
 represent whether 
 is assigned to core  of server 
 and core  on instance  of VM type 
, respectively, (11)
  (12)
 

Each task can be executed on only one core,8 therefore, (13)

A core has capacity of finishing all tasks assigned to it within their respective deadlines if and only if each task can be finished within its deadline when the core executes these tasks with earliest deadline first [64], then the finish time of a task executed on a core can be deduced by the last task’s finish time on the core. There are two cases for two successive task executions, as shown in Fig. 2, when the computing and network resources are the bottleneck, respectively.

In the first case that computing resource is bottleneck, for the execution of two successive tasks, the input data of the latter will be already ready before the former has finished the computation part, and the latter will not wait when the computing resource begin to process its data. At this point, the finish time of latter task is the time of finishing former task’s computation plus the consumed of computation and output data transfer of latter task.9 Then when 
 is assigned to core  in 
, its finish time is (14)
 
 
 
 

While in the second case, the input data is not ready when the computing resource is finished, and thus, the computation of latter task can be started only when its input data transfer is finished. Then the finish time of latter task is the finish time of former tasks’ input data transfer plus its total time consumed. Then in this case, the finish time of 
 in core  of 
 is (15)
 
 
 
For each task executed in the local cluster, its finish time is the later of 
 and 
 calculated by (14), (15), respectively, i.e., (16)
 
where 
 is the finish time of 
 assigned to core  of 
.

Similar to the task execution on a local server, when 
 is assigned to core  in VM  of 
, concerning overheads of the security guarantee in public clouds, its finish time can be calculated by (17)–(19). 
 
 
(17)
 
 
 
 
 
(18)
 
 (19)
 
 Then the deadline constraint for 
 can be formulated as (20)
(21)
 where inequality (20) guarantees the finish time is earlier than the deadline for 
 when it is assigned to core  of server 
, and inequality (21) ensures 
 is finished before its deadline if it is assigned to core  on instance  with type 
.


Download : Download high-res image (202KB)
Download : Download full-size image
Fig. 2. Two cases of task executions in a core.

For each VM rented from public clouds, its rent time is the latest finish time of tasks assigned to the VM, then the cost for renting instance  of VM type 
 is (22)
 

In general, public clouds charge their network resources only for the data transfer out of VM instances [2], [3]. The network resource is charged in terms of time with fixed bandwidth(Mbps/Hour) or of the traffic (
/GB). In the paper, we use the latter price model, then the cost of network resource for finishing outsourced tasks is (23)

Then the problem of maximizing completed tasks and minimizing the cost satisfying deadline and security requirements of all tasks in a hybrid cloud environment can be formulated as the following optimization problem, (24)
(25)
 subject to: (26)
(27)
(28)
(29)(30)(31)
(32)
 where the decision variables are 
 and 
. The objective Eq. (24) is maximizing the number of completed tasks. The objective Eq. (25) is minimizing the rent cost of VMs from public clouds. Constraints (26), (27) calculate the finish time of each task and ensure that all tasks are finished within their respective deadlines with their required security levels satisfied. Constraints (28), (29) calculate the cost for each rented VM and network resources from the public cloud, respectively. Constraints (30) guarantee that each task must be assigned to exactly one core. The last two sets of constraints represent the binary requirements for the decision variables. The finish time of each task is calculated according to Eqs. (1), (2), and (10). After solving the optimization problem, we achieve the task assignments (
, 
) and the renting time for each VM instance (
).

The optimization problem can be reduced into the multidimensional bin packing problem packing tasks (objects) into computing nodes (bins) by ignoring the heterogeneity of computing nodes and constraints of deadline and security, and thus is NP-hard [23]. Therefore, we designed a heuristic method to solve the problem in polynomial time in the next section.

3. Task scheduling concerning security
In this paper, the aim is to maximize the number of finished tasks and minimize the total cost of renting public resources with security or deadline requirements. The deadline and the security requirements of a task should not be violated for maintaining the service provider’s reputation and avoiding the violation cost, thus we design a heuristic scheduling method (TSS) with the basic idea of assigning the task with the maximal cost to a server (PM) and scheduling the task with earliest deadline to the VM with the best price/performance ratio when the private cloud has insufficient resources, satisfying the task’s deadline and security constraints, to improve the resource utilization of the private cloud and the rent cost in the public cloud. The details of the algorithm are described as follows, outlined in Algorithm 1.


Download : Download high-res image (997KB)
Download : Download full-size image
As shown in Algorithm 1, TSS first initializes a cost for each task (Line 1 in Algorithm 1), which is the minimal cost of outsourcing the task to public clouds, (33) 
 
where  and  are respectively the cost and the output data amount of the task  is the set of public VM instances.  and 
 are the unit prices for renting the VM instance  and its uplink network resource. 
 is the executing time of  on , which is calculated based on Eq. (10).

Then when the private cloud has available resources (Lines 2–12 in Algorithm 1), TSS selects the server with maximal available capacity (Lines 3 in Algorithm 1) to execute tasks for improving energy efficiency by reducing the used server number [27], [67] if there are sufficient private resources. At first, for satisfying all task requirements, TSS prioritizes the scheduling of tasks cannot be finished in the public cloud (Line 5 in Algorithm 1). TSS iteratively assigns the task with maximal cost and with finish time earlier than its deadline to the selected server (Line 7 in Algorithm 1), until there is no task can be finished in the server (Lines 8–11 in Algorithm 1). TSS repeats these previous steps until there is no tasks to be scheduled (Lines 13–14 in Algorithm 1) or no available server (Line 2 in Algorithm 1).

When there is no available resource in the private cloud (Lines 15–26 in Algorithm 1), TSS rents a VM instance with the best cost-performance ratio and can finish the task with earliest deadline satisfying its security requirements from public clouds (Line 16–17 in Algorithm 1). If there is no such VM instance, then these unscheduled tasks cannot be finished fitting their deadlines or security levels in the hybrid cloud, and will be rejected10 (Lines 18–20 in Algorithm 1). If a VM instance is rented, TSS iteratively assigns the task with earliest deadline to the VM instance until no task can be finished on the VM instance with deadline and security constraints (Lines 21–26 in Algorithm 1). Whereafter, TSS repeats these previous steps until all tasks are scheduled (Line 15 in Algorithm 1).


Download : Download high-res image (574KB)
Download : Download full-size image
When several tasks are assigned to a computing node with multiple cores, the mappings between tasks and cores and the executing order of tasks mapped to one core should be decided. To address these decision problems, TSS uses LSTF scheduling with earliest deadline first (EDF) task order method to execute as many tasks as possible, concerning the security constraints, outlined in Algorithm 2.

As shown in Algorithm 2, TSS iteratively assigns the task with earliest deadline to the core such that the task can be finished within its deadline and its finish time is closest to its deadline, with its security constraint (Lines 1–10 in Algorithm 2). If there is a task cannot be finished within its deadline in any core, then the mapping between tasks and the node is a failure (Lines 4–5 in Algorithm 2).

On a computing node, when all tasks are assigned to corresponding cores, there may be a load imbalance among cores, i.e. the used time of a core is much longer than that of another core, which can be relieved by task shift between cores to improve the used time and the resource utilization of the node [66]. As shown in Algorithm 2, TSS iteratively shifts the task with latest finish time to the core with shortest used time until the used time of the node cannot be improved by the task shift (Lines 11–19 in Algorithm 2).

Thanks to Algorithms 1 and 2, TSS addresses the task scheduling problem on a heterogeneous hybrid cloud with deadline and security constraints.

In Algorithms 1, the time complexity of initialization for all tasks (Line 1 in Algorithms 1) is . When scheduling tasks in the private cloud (Lines 2–12 in Algorithms 1), the selectings of a server and a task to be assigned to the server is respectively  and  at worst, thus the time complexity of task scheduling in the private cloud is  at worst. Similarly, outsourcing tasks to the public cloud(s) is  in time complexity, where  is the number of rented VMs, when the private resource is insufficient (Lines 15–26 in Algorithms 1). Therefore, the time complexity of Algorithms 1 is . As only some of tasks are considered to be shifted for all nodes, the time complexity increased by the task shift is  at worst by ignoring the core number in a node as its small fixed value in real world. In overall, the time complexity of TSS is .

4. Performance evaluation
In this section, we conduct a set of experiments to evaluate TSS scheduling method in various performance metrics, and analyze the results in detail.

4.1. Experiment design
We use a 3 month trace collected from the University of Luxemburg Gaia cluster system i.e., UniLu Gaia log in Parallel Workloads Archive [21], [44], to evaluate the performance of our algorithm. We assume that the trace data are the information of tasks running on 2 GHz cores. We exclude tasks with negative allocated processors or negative used memory, resulting in 49079 tasks. We randomly set the deadline and the security levels of each task. The deadline of a task is set in the range of [, ] timing its run time on a 1 GHz core, where  is 0.5, 1, 2, or 3 and called as deadline ratio in this paper, which generates four groups of experiments with various deadline tightness for evaluating each scheduling method. To concern more “real” deadline values, we also conduct a group of experiments where the deadline of each task is set as its runtime in the data trace. This group of experiments has similar results with that presented in the followings, thus we do not include these experiment results in this paper as they are not helpful for new findings.

The servers used in our simulation experiments are the 273 servers11 in the Gaia Cluster [58], a high performance computing platform in Luxembourg. The parameters of these servers are shown in Table 5. The read and write IO Bandwidths are respectively set as 7 GiB/s and 6.5 GiB/s, which is the performance of GPFS used for Home/Work, in the cluster. When applying a scheduling method in our experiments, we sort servers in the decreasing order of computing capacity () to minimize the number of used servers.

We use various compute optimized instances (c5) of amazon EC2 [3] and shared performance compute type instances (ecs.n4) of Alibaba Cloud [2] to be the candidate VMs for our experiments, as shown in Table 6, where VMs’ parameters are referred to respective official websites. The uplink and downlink bandwidth of public clouds are respectively set as the metric values of cn-hongkong-b and us-east-2a respective for Alibaba Cloud ECS and Amazon EC2, which providing network performance with small deviation and good performance, tested by Cloudharmony Network Test.12


Table 5. Parameters of 273 servers in the Gaia cluster.

Name	Number	#Cores per server	Hz	
gaia-[1–60]	60	12	2.26	110	175
gaia-[123–154]	32	12	3.07	110	175
gaia-[155–178]	24	24	2.5	210	300
gaia-[179–182]	4	24	2.5	210	300
gaia-[183–184]	2	64	2.5	350	500
moonshot1-[1–45]	45	4	1.8	70	110
moonshot2-[1–45]	45	4	1.8	70	110
gaia-[61–62]	2	12	2.26	110	175
gaia-[63–72]	10	12	2.26	110	175
gaia-73	1	160	2	420	600
gaia-74	1	32	2.4	210	300
gaia-[75–79]	5	16	2.2	125	210
gaia-80	1	120	2.5	420	600
gaia-81	1	160	2.4	420	600
gaia-[83–122]	40	12	2.93	110	175
In this paper, we compare our method (TSS) with four state of the art scheduling methods, MPHC and TRH1-3 respectively proposed by Sharif et al. [55] and Zhang et al. [75]. All of these four methods scheduled each task to the resource with the minimal cost’s increment. The difference of these methods are their used task ordering rules, where MPHC employed Heterogeneous Earliest Finish Time (HEFT), and TRH1-3 respectively ranked tasks based on earliest latest start time first (ELSFT), longest task first (LTF) and shortest task first (STF). When concerning the security, MPHC used the two-level security.13 TRH1-3 did not concern the security problem, and we improved them by considering two-level security when scheduling tasks, as done by MPHC.


Table 6. VM types provided by public clouds (EC2 and AlibabaCloud)

Name	#Cores	Hz	Price	Downlink	Uplink	Uplink price
($/Hour)	(Mbps)	(Mbps)	($/GB)
ecs.n4.large	2	2.5	0.047	78.92	9.7	0.076
ecs.n4.xlarge	4	2.5	0.168	78.92	9.7	0.076
ecs.n4.2xlarge	8	2.5	0.336	78.92	9.7	0.076
ecs.n4.4xlarge	16	2.5	0.672	78.92	9.7	0.076
ecs.n4.8xlarge	32	2.5	1.354	78.92	9.7	0.076
c5.large	2	3.6	0.085	20.8	7.66	0.07
c5.xlarge	4	3.6	0.17	20.8	7.66	0.07
c5.2xlarge	8	3.6	0.34	20.8	7.66	0.07
c5.4xlarge	16	3.6	0.68	20.8	7.66	0.07
c5.9xlarge	36	3.6	1.53	20.8	7.66	0.07
c5.18xlarge	72	3.6	3.06	20.8	7.66	0.07
We compare task scheduling methods in the following aspects.

•
Task Violation. The amount of violated tasks due to failing to satisfying their deadlines. The number and the accumulated size of violated tasks are two metrics to quantify it. For each metric, a lower value is better.

•
Resource Utilization. The overall computing utilization rate of the hybrid cloud, which is the ratio of accumulated amount of resources consumed by task executions and accumulated amount of resources provided by the hybrid cloud. This metric is one of the most prevalence for evaluating the resource efficiency. For this metric, a higher value means more efficient usage of resources.

•
Energy Efficiency. The energy efficiency of task execution in the local cluster, quantified by the size of tasks finished per electricity unit, i.e., the ratio of accumulated size of finished tasks and the consumed energy (
), 
. This metric can be used to quantify the efficiency of the local resource usage. A higher value means more efficiency.

•
Cost Efficiency. The cost efficiency of task execution in clouds, quantified by the size of tasks finished per cost unit, i.e., the ratio of accumulated size of finished tasks and the consumed cost of used public resources, 
. This metric can be used to quantify the efficiency of the public cloud resource usage. A higher value means more efficiency.

•
Makespan. The latest finish time of all executed tasks. It is one of the commonest metric for measuring the task execution performance. A lower value is better.

For estimating consumed energy of servers, we use the prevalent linear model [5], [6] (34)
where 
 is the energy consumed by 
, 
 is the used time of 
, 
 is the resource utilization changed with time  in 
, 
 and 
 are the power of 
 with idle and full loads, respectively. The power parameters of servers are set referring to literatures [5], [6], [59], given in Table 5. When a server is not used, its consumed energy is assumed to be 0.

4.2. Experiment results
4.2.1. Task violation
Fig. 3 shows the task violations in both number and size when applying various scheduling methods. As shown in the figure, TSS has no task violation, while others failed to completing 30785–46006, 18082–42341, and 7725–34839 tasks, when  is 0.5, 1, 2, respectively. This mainly because one of TSS design idea is to avoid any task violation by scheduling tasks cannot be finished in public clouds, and TSS uses a deadline-aware task scheduling approach, EDF + LSTF, in each computing node.


Download : Download high-res image (337KB)
Download : Download full-size image
Fig. 3. The task violations in number (a) and size (b).

In fact, the violated tasks are usually small due to their early deadline. Such as the experiment result of MPHC when  is 0.5, the violated tasks is about 62.7% of all tasks while their size is only about 4.9%. This because long tasks have high tolerance for waiting, and thus have high probability for finish. For this reason, TRH2 has the poorest performance in task violation reduction because it schedules longest task first, and thus results in many short tasks cannot be finished. This also causes TRH2 is the only method cannot finish all task when task deadlines are slack ().

4.2.2. Resource utilization
Fig. 4 shows the overall resource utilization when applying various scheduling methods for task executions, respectively. As shown in the figure, TSS achieves the highest resource utilization rate when the deadline ratio () is greater than 1. TSS has about 10.8%, 23.2%, and 48.6% higher resource utilization rate than MPHC, TRH1 and TRH3, and about 8.9%, 12.1%, and 28.3% higher than TRH2 when  is respectively 1, 2, and 3. These illustrate that our proposed method utilizes hybrid resources more efficiency. This is because that our approach tries to complete as many tasks as possible by applying EDF + LSTF in every server and improve the resource efficiency by balancing the load among cores of each computing node. While other methods all focus on cost reduction by greedily assigning tasks to the core14 with the lowest computation load applying HEFT, ELSFT, LTF, or STF task order approaches, which may lead to some violated tasks with tight deadlines can be finished if they are scheduled first, and thus may result in less tasks executed on a computing node, which reduce resource use efficiency.


Download : Download high-res image (295KB)
Download : Download full-size image
Fig. 4. The overall computing resource utilization rate.

While when task deadlines are too tight, TSS has a poorer performance in resource utilization, compared with other four methods. Such as, when , TSS achieves about 19.9% and 22.8% lower utilizations than MPHC/TRH1/TRH3 and TRH2, respectively, as shown in Fig. 4. The reason is that there are a lot of tasks outsourced to the public cloud for satisfying all deadline requirements when applying TSS, as detailed in Section 4.2.4 (see Fig. 7, Fig. 8), while other approaches have much fewer tasks executed in the public cloud due to many tasks are rejected because of failing to completing them with their respectively deadline or security requirement satisfactions. And usually, public resources execute a task with security requirements less efficiency than local resources because it takes more time for data transmission due to the poor inter-cloud network performance and the data protection overheads. These causes also account for an increasing resource utilization with a postponed deadline, as shown in Fig. 4. Thanks to these causes, our proposed method has a superior performance in task deadline satisfactions, as illustrated in Section 4.2.1.

4.2.3. Energy efficiency
Fig. 5 shows that TSS has about 14.8%, 30.6%, and 60% more tasks in size than MPHC/TRH1/TRH3 by consuming one unit of computing energy in the local cluster, and has about 42.5%, 50.8%, 71.7% more than TRH2, when  is respectively set as 1, 2, and 3. This result proves that our approach has a better local resource use efficiency. The reason is that our approach improves the resource efficiency by trying to execute as many tasks as possible and balancing loads among cores in a server, while others do not consider the task deadlines and the load imbalance among cores, which leads to a low resource utilization for each server, as illustrated in Section 4.2.2, and thus an energy inefficiency.


Download : Download high-res image (262KB)
Download : Download full-size image
Fig. 5. The energy efficiency of task executions in the local cluster.

When  is 0.5, TSS has about 25.1% and 29.6% poorer energy efficiency than MPHC/TRH1/TRH3 and TRH2, respectively, as shown in Fig. 5. This is mainly because TSS schedules tasks that cannot completed in public clouds to the local servers at first for satisfying all task deadline requirements. These priority tasks usually have relatively large amount of transferred data and relatively tight deadlines (thus they cannot finished within their respective deadline by public resources). The long data transmission time causes the result of a low computing resource utilization, and thus reduces the energy efficiency. Even so, it is very worthwhile for satisfying all task requirements (see Section 4.2.1) with a slight resource efficiency reduction.

4.2.4. Cost efficiency
As shown in Fig. 6, TSS has 17.4%–30.8% less finished task in size per dollar than MPHC and TRH1-3 when  is less than 3. When  is 3, TSS, MPHC, TRH1, and TRH3 all finish all tasks in the local cluster, and thus their cost efficiencies are set as 0. The reason why TSS has a lower cost efficiency is as follows. For MPHC and TRH1-3, they do not outsource tasks with security requirement to public clouds, as done in any other existed work employing two-level security scheme. For finishing all of tasks, TSS employs various data protection methods to outsource some of tasks with security requirements to public cloud, and thus incurs the overheads of these data protection methods for finishing these outsourced tasks. This leads to a reduction in public cloud resource efficiency, and thus reduces the cost efficiency, while accounts for much more tasks finished in the cloud as shown in Fig. 7, Fig. 8: TSS finished about 300 times tasks than MPHC and TRH1-3 in public clouds. Due to TSS assigns tasks cannot be finished by public clouds to the local cluster at first, it completes slightly less tasks locally, due to the relatively resource inefficiency for these task executions as illustrated in the last subsection.


Download : Download high-res image (307KB)
Download : Download full-size image
Fig. 6. The cost efficiency of cloud resource usage for task executions.

4.2.5. Makespan
From Fig. 9, we can see that TSS achieves a better makespan than MPHC, TRH1, and TRH3 when task deadlines are not too tight (), even though TSS completes more tasks, which is benefit from the improvement of TSS balancing load among cores by task shift. While when  is 0.5, TSS has the latest makespan. This is because TSS finishes much more tasks than others, and the improvement of TSS cannot completely offset the makespan postponed by these tasks. The reason of TRH2 achieving the earliest makespan when  is that much less tasks are executed, as shown in Fig. 7, due to much more task violations, as shown in Fig. 3.


Download : Download high-res image (343KB)
Download : Download full-size image
Fig. 9. The latest finish time (makespan) of all task executions.

As shown in Fig. 9, makespan is prolonged for TSS, MPHC, TRH1, and TRH3 as task deadlines are increased, except that TSS has earlier makespan when  is increased from 2 to 3. For MPHC, TRH1, and TRH3, this is mainly because more tasks are executed in the hybrid cloud when the deadline are increased. While for TSS, finished tasks are not increased with the deadline as it has no task violation all the time. When  is smaller than 3, that the makespan is prolonged with the deadline is because more tasks are executed in the local cluster, as shown in Fig. 7, Fig. 8, which prolongs the makespan of local executed tasks, and thus prolongs the overall makespan as the amount of tasks has a small influence in makespan on public clouds due to the cloud elasticity, the rent resource amount is increased with the outsourced tasks generally. When  is smaller than 3, all tasks are executed in the local cluster, and thus the makespan is irrelevant to the task execution in public clouds. Therefore, the makespan is decreased by removing the limit of task finish time in public clouds, when  is 3.

When  is 3, all tasks are executed in the local cluster for TSS, MPHC, TRH1, and TRH3, while TSS has the earliest makespan, which is mainly benefit from the task shift balancing the loads among cores. This further confirms a higher resource efficiency of our proposed method, compared with others.

5. Related work
Hybrid cloud is a cost-effective way to address the problem of satisfying the peak resource demand when the local cloud has insufficient resources. Thus, there are several works trying to optimize various objectives they concerned by designing appropriate task scheduling methods.

Zhang et al. [73] proposed an effective heuristic (EH) to minimize the makespan with budget constraints on hybrid clouds by scheduling the longest task to the public/private cloud with the earliest finish time for the task. Later, they presented an insertion based method to arrange the task sequence to improve EH [74]. More recently, they proposed three BoT scheduling method, TRH1-3 respectively ranking tasks with ELSTF, LTF, and STF, which iteratively scheduled the first task to the VM with the minimal total cost’s increment [75]. They assumed that a task must be executed on a VM instance exclusively at a time and that all VM instances are charged in seconds, which remarkably reduced the complexity of the scheduling problem with narrow applicability in real world.

Wang et al. [65], [66] proposed a heuristic method to executing BoT tasks with deadline constraints in heterogeneous hybrid clouds for optimizing the financial cost of renting public resources by scheduling the task closest to its deadline to the resource with the best cost-performance ratio. Both Sanaj et al. [51] and Parthasarathy & Venkateswaran [45] exploited meta-heuristics algorithms, whale optimization, center-based genetic, and group search optimization, to design task scheduling methods for optimizing the profit of providers in hybrid clouds. Marcu et al. [36] proposed a dynamic scheduling method minimizing the number of tasks whose finish times exceed their deadlines, in hybrid clouds, which scheduled the task with highest priority to the VM instance with enough resources and minimal price, and assumed that there were one-to-one relationships between tasks and VMs for any time. Pasdar et al. [46] proposed a two-stage scheduling method to improve the execution time and the resource cost in hybrid clouds. The first stage is generating an initial scheduling strategy based on a genetic algorithm optimizing the local resource utilization considering the data locality. The second stage reschedule each task without the data locality restriction of VMs to other private VM providing lowest finishing time or other private VM with best cost-efficiency, as there are some overloaded VMs in the initial strategy.

These previous works did not concern the security even though it has been ranked as the top concern for organizations considering outsourcing their tasks or data to public clouds [40], [47], [50]. To address security issues, some works focused on scheduling tasks on hybrid clouds with security constraint for various applications.

Ko et al. [28] presented the HybrEx model to add more computing and storage resources from public clouds to a private cloud for Bigtable [12] or MapReduce [17] jobs, using two labels, the private label and the public label, to determine the placement of data and computation accordingly. Chen et al. [13] addressed the problem of large scale secure computation outsourcing for the most important step of interpreting DNA sequences, read mapping operations involving intensive computation of calculating edit distances between short DNA sequences generated from sequencers and all the substrings on the reference genome, preventing identifying sequence donors by these short DNA sequences [35]. Yuan et al. [72] outsourced workloads without sensitive design data to an untrusted public cloud while keeping sensitive Intellectual Property (IP) blocks safe at the private cloud for timing analysis when designing integrated circuits to accelerate the in-house integrated circuit (IC) design procedure with IP protection. These researches focused on the implementation of securely executing a specific kind of applications on hybrid clouds without concerning the cost of renting resources from the public cloud(s), which is one of the most concerns for an enterprise, or designing the task scheduling method within one (public/private) cloud.

Liu et al. [34] proposed a heuristic method based on max–min algorithm for scheduling tasks on hybrid clouds to minimize the cost and the execution time with QoS requirements of the deadline, budget, safety, and reliability of task execution. They considered that there was only one task run on a public VM, which may lead to serious waste of resources as VMs were usually charged hourly. Rahman et al. [48] designed an adaptive hybrid heuristic (AHH) scheduling algorithm, based on Genetic Algorithm [70] and DCP heuristic [49], to execute a workflow job on a hybrid cloud with constraints of deadline, budget and the task placement specified by the user. Sharif et al. [53], [54], [55] proposed several scheduling methods to minimize the cost of a business enterprise without violating any DAG workflow’s deadline and privacy constraints on a hybrid cloud with homogeneous private resources. The differences of these proposed methods were their task ranking methods and/or the scheduling unit, individual tasks or an entire (partial) critical path [1] of a workflow. Stavrinides and Karatza1 [57] presented two methods for scheduling BoT with sensitive input data in a hybrid cloud, respectively improving Min–Min and Max–Min by adjusting the completion time of each task based on the standard deviation of estimated completion time of the task on each suitable VM, to concern the sacrifice of monetary cost savings for task execution timeliness.

All these above methods considered the simple two-level security model. The task with the high security level must be processed in the private cloud, while the task with the low security level can be executed in both the private and public clouds. While, there are various levels of security demands for tasks [22], [32], [38], [69], in real world, making the task scheduling problem more complex. Thus, in this paper, we focus on scheduling tasks on heterogeneous hybrid clouds with multi-level security model to minimize the cost satisfying demands of deadline and security.

6. Conclusion
To address the task execution problem in hybrid clouds with various security and deadline requirements, we first formulate the problem with multi-level security model, and then propose a heuristic method, TSS, to solve the problem in a polynomial time. For cost improvement, TSS assigns the task consuming maximum cost of public cloud resources first. TSS assigns a task to the server with maximal processing capacity in the local cluster for used server number minimization, and rents a new VM with best cost-performance ratio when there is not enough local resources. To execute as many tasks as possible in a computing node, TSS employs the idea of EDF and LSTF for task ordering and task scheduling, respectively, and to avoid the task violation, TSS assigns tasks cannot be finished in public clouds to the local cluster at first. Compared with four recently proposed methods, based on real world data trace, TSS has the best resource efficiency when task deadline are not too tight, and guarantees all task performance requirements can be satisfied.

In this paper, we focus on independent tasks, as done in many published works, which is a kind of very common application in real world. While the inter-dependent relationship among tasks of workflow jobs remarkably increases the complexity of task scheduling with the complex network topology in a hybrid cloud. One of our future work is trying to address the problem. Another future work is to improve the cost by exploiting diversity of public cloud resource charge model, e.g., reserve and spot VMs.

