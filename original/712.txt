Abstract
The current UTXO-based blockchains require the validators to keep the entire ever-growing UTXO set to verify transactions, which is unsuitable for ordinary machines since they occupy a large size of RAM in the long run, resulting in network centralizations. Recently, stateless blockchain technology has been proposed which uses the accumulator to combine the large UTXO set into one short, constant-sized commitment. However, the UTXO commitments in these methods are inefficient since the UXTO set is required dynamic addition and removal of elements as transactions are processed. In this work, we propose MiniChain, which replaces the UTXO set with two append-only data structures: STXO (Spent Transaction Outputs) set and TXO (Transaction Outputs) set. Thus, a valid UTXO must belong to the TXO set, but not in STXO set. Then, we construct a novel STXO commitment and TXO commitment by using a trapdoor-less RSA accumulator and a Merkle Mountain Range (MMR) respectively, greatly increasing the efficiency of accumulator. Besides, we introduce a cache mechanism, by storing the STXOs of latest  blocks, the transaction proof can be kept alive for a period of time, avoiding constantly recomputing proofs for unaccepted transactions. Our evaluation shows that (i) MiniChain only needs a fixed-size RAM and the disk usage grows very slow since only the block headers are stored; (ii) comparing to the state-of-the-art work, the performance of the accumulator update has been improved from  to , enabling MiniChain to support a higher TPS.


Keywords
Stateless blockchain
RSA accumulator
UTXO growth
STXO commitment
TXO commitment

1. Introduction
Blockchain technology [22], [37], can be described as a distributed append-only ledger over a large peer-to-peer (P2P) network, is revolutionizing how people exchange values without a trust third party under non-trust environment. Blockchains have demonstrated great promise of utility over several fields, including the Internet of Things (IoT) [17], finance [28], share economy [17], and identity management [18].

Each validator in blockchain keeps the entire ledger and verifies all transactions independently, greatly increasing network security. However, the ever-growing nature of blockchain could be quite cumbersome for ordinary machines which usually have limited storage resources. On one hand, the ledger is too big since it contains all historical transactions from genesis block and keeps growing rapidly, which not only increases the disk storage burden on validators but makes the synchronization an extremely slow process when a new validator joins the network [33]. On the other hand, since the blockchain data is too large, naively querying it will take too long. For this reason, most blockchains are typically stateful. They maintain an appropriate index called state in memory database (e.g LevelDB) which is enough for checking transaction validity. In the UTXO-based blockchains, the state is a set of immutable coins called UTXO (unspent transaction outputs), a transaction is valid if it spends coins which belong to UTXO set. In the account-based blockchains, the state is a set of mutable accounts, a transaction is valid if it is trying to spend less than the available balance. In particular, the state is in order of GBs (currently, the UTXO set in Bitcoin is around 3.02 GB and Merkle Patricia Trie in Ethereum is around 16 GB) and could grow substantially in the coming years, which is called state explosion problem. Thus, keeping the ever-growing state in RAM could also be burdensome. Besides, when the size of the state exceeds the capacity of RAM, a part of the state would be kept in a secondary disk, leading to slow transaction validation due to expensive I/Os, which is the primary source of DoS vulnerabilities, like the one took place on Ethereum in 2016 [7].

Due to heavy burden on storage, most users only have the ability to run light clients (e.g., mobile wallet, SPV node). They cannot independently verify transactions and have to rely on a certain number of full nodes, which introduces new security risks, like long-range attacks [20]. Besides, it can be speculated that only a small number of supernodes can run validators as the storage burden increases further, resulting in network centralization. Thus, building a lightweight protocol where all nodes can independently check the validity of transactions without having to store the large historical blocks and states is an urgent requirement in the cryptocurrency community [12].

Earlier, the ledger pruning techniques [11], [19] have been proposed to reduce the storage and bootstrapping costs for validators, which summarized the entire state periodically by using state blocks that are similar to state checkpoints in PBFT [10]. However, the ledger pruning techniques can only solve the problem of historical blocks growth, which still requires validators to store the complete state. Recently, the stateless blockchain concept [32] has been proposed, which uses an accumulator to combine the large state into one short, constant-sized commitment, removing the current need for storing order-of-GB state in RAM, as well as hundreds of GB historical blocks on disk. For example, several colleagues [12], [25], [30] of the blockchain community have proposed making a commitment to the UTXO set in every block using a Merkle tree based accumulator, thus a user can efficiently prove to another user that his coins are unspent by providing the Merkle proof to the UTXO commitment. However, the Merkle tree based accumulators have many problems. First, the size of Merkle proof is 
, where n represents the size of UTXO set. It is not constant-sized and keeps growing as the number of UTXO increases. Second, updating a Merkle proof needs all branches that have been changed, which consumes a lot of bandwidth resources. Moreover, checking the commitment has been properly updated incurs a significant overhead [5].

Due to the problems of Merkle based accumulator, some works [5], [12], [25] have been proposed to replace the Merkle based accumulator with cryptographic accumulator [1], [2], [9], [14], [31]. Specifically, each block contains an accumulator which represents the current state of blockchain, i.e. the UTXO set. When a user wants to spend a coin, he can provide a membership witness corresponding to the accumulator for the coin that is being spent. It is worth noticing that the witness is constant-sized, and by using batching techniques of the accumulator, we can create a succinct and efficiently verifiable batch membership and batch nonmembership proof. However, in a public blockchain environment where no trusted accumulator manager exists, it incurs a significant overhead to update the accumulator since the deletion operations consume much computation without the secret key [5]. Besides, since the witness and the commitment are closely related, users have to update their witness whenever a new commitment is generated, which places a significant burden on users.

In this work, we proposed MiniChain, a lightweight protocol for UTXO-based public blockchains. MiniChain has used three strategies to overcome the above problems. Firstly, MiniChain uses RSA accumulator to make a STXO (Spent Transaction Outputs) commitment in every block instead of UTXO commitment. STXO set contains all the coins that have been spent. It is just an append-only data structure, thereby avoiding costly deletion operations. Users can provide a batch nonmembership proof [5], [21] for the coins that are being spent, which can indicate that the coins are indeed unspent. Secondly, to prevent users from forging coins that do not exist, an additional existence proof is required, which can be easily done by providing the Merkle proof where the coin is generated. However, this method requires the validators to store all block headers and can quickly access these block headers. As the number of blocks increases, the retrieval efficiency will decrease. To avoid this, we further propose a TXO commitment by using MMR (Merkle Mountain Range), allowing validators to store only the MMR peaks (logarithmic in the length of blockchain) to efficiently verify the inclusion of any coin on the blockchain. Furthermore, we use PoE (Proof of Exponentiation) [4], [5] protocol to reduce the computation overhead of validators. Thirdly, motivated by the literature [34], [35], [36], in order to decrease the proof update frequency, each validator keeps a STXO cache for the latest N blocks, avoiding the user resubmitting the updated proof whenever a new block is generated.

In summary, this paper makes the following contributions:

•
We have a comprehensive and systematic introduction to the stateless blockchain and explain why it can solve the state explosion problem.

•
We prove by theory and experiment that the statelessblockchain based on UTXO commitment proposed byBoneh [5] is impractical due to the bad performance of accumulator updates.

•
We propose a novel STXO commitment and TXO commitment, then build a stateless blockchain called MiniChain based on them. Comparing to Boneh, MiniBlock has improved the efficiency of accumulator updates from 
 to .

•
We implement MiniChain, the experiments show MiniChain is lightweight enough that allows validators to check transactions without storing the large historical blocks and states. Besides, by greatly improving the efficiency of the accumulator updates, MiniChain supports a higher TPS.

Organization of the Paper.The rest of this paper is organized as follows. We firstly give some background definitions and formally introduce the stateless blockchain in Section 2. In Section 3, we present the design goals and the architecture overview of MiniChain. In Section 4, we present the detailed design of MiniChain. We theoretically and experimentally evaluate our prototype implementation of MiniChain in Section 5. The related works are presented in Section 6. Finally, we conclude our paper and discuss the possible future researches in Sections 7 Limitation and future work, 8 Conclusion.

2. Background
In this section, we outline the most relevant prior works that our work builds on. Firstly, we briefly introduce the architecture of stateful blockchain and stateless blockchain, and analyze their advantages and disadvantages. Second, we describe the function of the cryptographic accumulator and show how the basic RSA accumulator works. Last, we introduce the NI-POE (Non-interactive Proof of Exponent) protocol, which can greatly reduce the verification overhead of validators.

2.1. Stateful & stateless blockchain
Blockchain state is a changeable data structure that represents the current status of blockchain and which is enough for deciding transaction validity. State is not necessary for blockchain integrity, but plays an important role in accelerating transaction and block verification. According to whether the node needs to keep the entire state, blockchain can be divided into two categories: stateful blockchain and stateless blockchain.

The architecture of stateful blockchain is shown Fig. 1(a), validators can check the transaction by querying the state, then update the state according to the new block. For example, in an UTXO-based stateful blockchain, the validators store the whole UTXO set and use it to verify whether a coin is spent or not. When a new block is added to the blockchain, it deletes all spent coins in the block from the UTXO set and adds new coins. The advantage of stateful blockchain is that users can issue transactions without knowing the whole UTXO set, feeling no difference with a centralized banking system. However, locally maintaining the ever-growing state is quite burdensome.


Download : Download high-res image (217KB)
Download : Download full-size image
Fig. 1. Stateless & Stateless Blockchain.

In contrast, the stateless blockchain, shown in Fig. 1(b), only needs to store the commitment of state in each block header, which is short and constant-sized, while the specific state and historical blocks can be safely discarded. However, without states, validators cannot fully verify the transaction independently and require users to submit an additional validity proof along with transaction, so that the validators can check the transaction by verifying whether the proof is correct based on the commitment of the current state. The advantage of stateless blockchain is that it is lightweight enough for a normal node to run a validator without worrying about the storage resource shortages. However, how miners can effectively update the commitment of state and how users can effectively generate succinct proofs are big challenges.

2.2. RSA accumulator without trapdoor
Basically, a cryptographic accumulator [14] is an algorithm to combine a large set of values into one short commitment, and enables to compute a short membership witness (or nonmembership witness) of any element that has (or not) been accumulated. Below, we briefly introduce how the basic universal RSA accumulator works.

The basic RSA accumulator is based on modular exponentiation under the strong RSA assumption [21]. Let 
 be the set of elements that will be accumulated. Firstly, the accumulator manager chooses two strong primes  and  that are suitably large, and then chooses a large base  that is relatively prime to . It is worth noting that the elements to RSA accumulator must be restricted to prime numbers in order to be collision-free. Thus, a random hash to prime function 
 [5], [15] is needed. For each element 
 in S, the prime representative of 
 is computed through 
, denoted as 
. The accumulator value  of set  can be computed 
To prove that some element 
 is in S or not, the membership witness and the nonmembership witness can be generated, which can refer to the universal RSA accumulator [21].

In decentralized public blockchains where no single trusted accumulator manager exists, the basic RSA accumulator does not satisfy the requirement, anyone who knows the secret keys  and  can use the Euclidean theorem  to calculate the order of RSA group, which can further forge any membership and nonmembership witness. Since the trapdoor is not required for our construction, we use the Boneh’s work [5] for RSA accumulator in groups of unknown order which eliminates the trusted setup.

2.3. Proof of exponentiation
PoE (Proof of Exponentiation) [4], [5] protocol allows a prover to convince a verifier that a triple (u, w, x) satisfies 
, the verifier only needs to do a small amount of calculations to be able to believe that the prover has performed the calculation correctly. Besides, PoE protocol is interactive and can be made non-interactive using the Fiat–Shamir heuristic [3]. The non-interactive, succinct, and efficiently verifiable NI-POE is very useful to reduce the overhead of verification that accumulator has been updated correctly, which will be used in the next few sections.


Download : Download high-res image (70KB)
Download : Download full-size image

Download : Download high-res image (305KB)
Download : Download full-size image
Fig. 2. Architecture overview of MiniChain. Fig.(a) shows the TXO commitment by using Merkle Mountain Range(MMR). The tree grows as the new block’s TMR (Transaction Merkle Root) adds to the right side. Fig.(b) shows the block header composition, which mainly contains three parts: the TMR, the STXO_C (STXO commitment) by using RSA accumulator, and the TXO_C (TXO commitment) by combining the MMR peaks using a normal Merkle tree. Fig.(c) shows the procedure the transaction processing.

3. System overview
3.1. Design goals
MiniChain is a lightweight UTXO-based public blockchain that eliminates the UTXO growth problem, it needs to meet the following goals.

•
Low storage: Validators do not need to store the full historical data in disk and large state in RAM but only the block headers to validate transactions.

•
Full decentralization: There is no trusted accumulator manager or single points of failure.

•
High throughput: The system provides higher throughput than other state-of-the-art stateless blockchains.

•
Long-term liveness: Transactions can be kept alive for a long time before being processed to avoid repeatedly resubmitting the transaction.

3.2. Prior UTXO commitment: Boneh [5]
To combat the UTXO growth problem, a few of works have been proposed, the most outstanding work was proposed by Boneh, who firstly extended the current RSA-based accumulator to create a universal accumulator for a decentralized setting where no single trusted accumulator manager exists and where updates are processed in batches, and then used the new constructions to design a stateless blockchain for UTXO model. Specifically, each block contains an accumulator which represents the current UTXO set. When a user wants to spend a coin, he provides a membership witness for the coin that is spending. A miner can verify the transactions and use deletion operation to properly delete all spent coins from the accumulator. For the newly produced and minted coins the miner uses addition operation to add them to the accumulator. Neither of these operations requires the miner to have any state beyond the accumulator value. However, as mentioned in Boneh’s work, without knowing the group order of RSA accumulator, deleting elements from the accumulator is not simple. For a single element, the membership witness 
 for an element x is equivalent to the value of the accumulator without x. Therefore, the updated state of accumulator after deleting a single element is just its membership witness. But for a set of tuples 
 and an accumulator  such that 
, the elements need to be removed in sequence, where in each removal all other membership witnesses are updated using the standard witness update algorithm, resulting in complexity of 
. Therefore, Boneh proposed another method called BatchDel which iteratively uses ShamirTrick for each 
 to compute 
. BatchDel requires an approximate calculation of formula 
. Since each 
 has the same bits, we can assume that each 
 is approximately equal to 
. From Theorem 1, we can get the complexity of BatchDel which equals 
. Thus, the complexity of BatchDel is also 
. Besides, BatchDel relies on the output of the last iteration, it cannot be accelerated by parallel computing.

Theorem 1

Right-to-Left Binary Method of Modulus Exponentiation [27]
Given base b, exponent n, and modulus m, the complexity of modular exponentiation 
 is .

Boneh built a stateless blockchain based on UTXO commitment by using RSA accumulator, which requires a lot of deletion operations. Since the complexity of deletion operation is 
, the efficiency of the accumulator updates would drop rapidly when the number of deletion operations increases. Furthermore, the inefficiency of the accumulator updates would severely limit the system throughput.

3.3. MiniChain Architecture
MiniChain builds closely on Boneh’s work and addresses several challenges that Boneh’s work leaves unsolved. First, the complexity of the BatchDel in Boneh’s work is 
 and cannot be computed in parallel, resulting in an inefficient update of accumulator for new state, which cannot be used in a high-throughput system. For 1000 deletion operations, the BatchDel consumes nearly 160 s, the system throughput can only reach 6.6 operations per second (one Intel i5 processor core). Second, since the transaction proofs are closely related to the current state accumulator value, users have to update their transaction proofs if the transaction is not processed in the next block, which places a significant burden on users. MiniChain uses three strategies to address the above challenges, the architecture is shown in Fig. 2.

STXO Commitment. Firstly, to improve the accumulator update efficiency, we propose replacing the UTXO commitment with a novel STXO (Spent Transaction Outputs) commitment. STXO is an append-only data structure which contains all spent transaction outputs, removing the time-consuming deletion operations needed by UTXO commitment. Specifically, each block header contains an accumulator which represents the current STXO set. When a user wants to spend a coin, he provides a nonmembership witness which specifies that the coin was not spent before.

TXO Commitment. Secondly, to prevent adversaries from generating a non-existing coin, user needs to provide an existence proof to prove that the coin was indeed generated before, which can be easily done by providing the Merkle path to the TMR where the coin was generated. However, this method requires the validators to store all block headers and can quickly access these block headers. As the number of blocks increases, the retrieval efficiency will decrease. To avoid this, we further propose a TXO commitment by using MMR (Merkle Mountain Range), allowing validators to store only the MMR peaks (logarithmic in the length of chain) to efficiently verify the inclusion of any coin on the blockchain.

STXO Cache. Thirdly, since the transaction proof is closely related to the commitment of the current state, users have to update and resubmit the transaction proof whenever the state is changed before the transaction is processed, which is extremely unfriendly to user. To address this problem, MiniChain introduces STXO cache, which contains all STXOs of the latest N blocks (e.g 1-hour or 1-day window). The validator can still verify transaction as long as the proof is valid based on one of the latest N state commitments by further checking the inputs of transaction are not in STXO cache to prevent double spending attack.

4. System detail
In this section, we introduce the core components ofMiniChain: STXO commitment, TXO commitment, proof generation & verification, and proof updating. Let  be a security parameter, 
 denote the accumulator value at time t, 
 denote the coin x generated at time t, 
 represent the nonmembership proof of coin x at time t. The algorithms are described in Algorithm 1. For the sake of brevity, we have omitted the  in every formula of modulus exponentiation.

4.1. STXO commitment
MiniChain uses RSA accumulator to combine the STXO set into one short and constant-sized commitment, which is kept in every block header. It is important to note that the inputs to the RSA accumulator must be restricted to prime numbers to be collision-free [9]. Thus, we need to convert every spent output to a prime representative, which can be done using HashToPrime function [5], [15]. Computing the accumulation value with only the public key requires doing a modular exponentiation for each element, this quickly becomes infeasible as the size of STXO set increases, because the product of S j-bit integers can be up to jS bits. However, due to the cumulative nature of RSA accumulator, we do not have to compute the accumulation value from scratch for every new block, the miner can use the prior accumulation value as the base, see  function (Algorithm 1).

Function 1

AccUpdate: Let 
 be the accumulator value at time t,  be a new transaction. The new accumulator value 
 that contains the transaction  can be computed as follows. Firstly, the function gets all STXOs in  (that is the inputs of transaction), then, converts every STXO in  to the prime representative through  and calculates the product of these all prime representatives, denoted as . In the end, we compute 
.

It is worth noticing that the verifiers do not need to recalculate the updated accumulation value by themselves. When the miner successfully mines a new block, it needs to provide an NI-POE proof to prove that the accumulator value has been correctly updated. The verifiers (see AccVerify function (Algorithm 1)) can firstly calculate the product of all new spent outputs by themselves, and then verify NI-POE within a fixed short time.


Download : Download high-res image (331KB)
Download : Download full-size image
4.2. TXO commitment
To avoid storing and querying the block headers, we propose to make TXO commitment by using a Merkle tree variant known as Merkle Mountain Range (MMR) over all blocks’ TMR added to the blockchain so far, see Fig. 2(a). As blocks’ TMR are accumulated we hash them into trees, or mountains, building up the largest possible perfect binary trees as we go. So in effect it always has more than one binary tree. Each tree’s root is a peak in MMR. To get the TXO commitment, the Merkle root of the whole MMR, we calculate the MMR root by bagging these peaks from right to left.

MMR allows efficient appends at the prover side and efficient inclusion verifications at the verifier side. Further more, it enables efficiently update inclusion proof since the previous proof is a subtree of new proof. As a result, each MMR root stored at every block height can be seen as a TXO commitment up to that height. Each validator can update and check the TXO commitment by only keeping the MMR peaks, which is only logarithmic in the length of blockchain. Suppose each hash takes 32bytes, the validators only need to keep 3.2 KB if the number of blocks reaches 
, which is not possible to reach.

4.3. Proof generation & verification
MiniChain builds stateless client based on STXO commitment, which summarizes all spent coins (Spent Transaction Outputs). When a user wants to spend a coin, he is required to prove that the coin is both valid and unspent. Thus, the validity proof of transaction should contain two parts: the existence proof and unspent proof. The goal of existence proof is to indicate the spending coin was indeed generated before. Since every block header contains a TXO commitment of all transactions, user can generate a Merkle path from the transaction where the coin was generated to the TXO commitment to show that the coin is valid. Besides, since STXO set contains all the coins that have been consumed, a coin is unspent as long as it is not in STXO set. Thus, user can construct a nonmembership witness corresponding to the latest STXO commitment to prove that the coin is unspent.

Existence proof. By using TXO commitment, the existing proof of a coin should contain two parts: the TMR inclusion proof based on TXO commitment and coin inclusion proof based on TMR. Suppose the latest TXO commitment is 
, to prove that a coin is indeed generated in some block 
, we firstly need to provide an MMR inclusion proof that the 
 in 
 is committed to 
. Then, just as for a regular SPV proof, we need further provide a Merkle proof to prove that a transaction that generates the coin was committed to 
. The validators can easily verify these proofs based on 
. Besides, the TMR inclusion proofs of multiple different coins can be merged into a single proof while the coin inclusion proof cannot be merged since they may be generated at different blocks.

Unspent Proof. The unspent proof of a coin is the nonmembership witness corresponding to the latest STXO commitment. For any unspent coin 
, the proof generation and verification algorithms are shown in NonMemWitCreate and VerifyNonMemWit (Algorithm 1).

Function 2

NonMemWitCreate: Suppose 
, the nonmembership witness 
 can be computed as follows. Firstly, the function gets all STXOs from 
 where the coin 
 was generated to the latest 
, denoted as 
. Then, convert every STXO in 
 to the prime representative by using  and calculate the product of these all prime representatives, denoted as . Since x and p are distinct prime numbers, it is easy to find the Bezout coefficients  and  such that  by using extended Euler’s theorem. Finally, let 
, the nonmembership witness for 
 corresponding to 
 is .

Function 3

VerifyNonMemWit: Let 
 be the nonmembership witness of 
 corresponding to accumulator value 
, given   
. To verify the witness, one checks that 
, which holds because 
.

It is worth noting that, the unspent proofs of multiple coins can be merged into one single proof simply by letting x be the product of spending coins, which not only decreases the proof size, but also reduces the verification overhead. For example, suppose two coins 
 and 
 that generated at time t and time t+1 separately, we can make a batch nonmembership witness for these two coins from time t because the coins 
 generated at a later time cannot be successfully spent before time t+1.

4.4. Proof update
Existence proof. The existence proof of a specific coin contains two parts: the TMR inclusion proof based on MMR and the coin inclusion proof based on TMR. Obviously, the coin inclusion proof remains unchanged, while the TMR inclusion proof needs to be updated as the new block’s TMR are committed to TXO commitment. It is worth noting that the update of the TMR inclusion proof is very low frequency. Suppose the blockchain length is , the inclusion proof of a particular TMR will be updated  times at most. Further more, MMR enables efficient update inclusion proof since the old proof is a subtree of new proof.

Unspent proof. Different from existence proof, the unspent proof of a coin is required to be updated for every addition to the STXO set. The impossibility result [8] suggests that this is unavoidable. Therefore, Boneh envisions that some users will use services that provide them with updated proofs. A service stores the whole UTXO set and can compute membership witnesses from scratch. A service may need to produce many membership witnesses at once, it can produce all membership witnesses in  time. However, according to the size of the current UTXO set, it takes more than 90 days (one Intel i5 processor core) to update all membership witnesses for a single deletion operation, which is impractical. MiniChain uses a hierarchical mechanism to reduce the complexity of proof update.

Firstly, since the nonmembership proof is bounded to the most-recent STXO commitment, there is a frequently-occurring case where the proof of transaction has expired due to network propagation delay or the miners did not process the transaction in time. As a result, users have to update the proof and resubmit the transaction, which places a significant burden on users. To address this problem, we require each validator to store the most-recent N blocks and the corresponding STXO set in the memory database, e.g. LevelDB. Thus, the validator can process the transaction in the next N blocks. Specifically, the validator firstly checks the Merkle proof and the nonmembership witness. If the nonmembership witness does not correspond to the latest STXO commitment, the validator then needs further check whether the transaction inputs have been consumed in the later blocks, which can be done by simply querying the STXO cache.

Secondly, for the most-recent updated coins, user can update their nonmembership witness by themselves using UpdateNonMemWit function (Algorithm 1).

Function 4

UpdateNonMemWit: Given an unspent coin 
 that generated at time t, for any nonmembership witness 
 which has been updated to time n and wants to be further updated to time m, the new nonmembership witness 
 can be computed as follows. We can firstly obtain all STXOs between time n and m, denoted as 
, and calculate the product of all prime representatives of 
, denoted as p. Then, it is easy to calculate the Bezout coefficients 
 and 
 such that 
. Let 
, we compute 
, 
. To verify the witness, one checks that 
, which holds because 
.

Lastly, for those coins that have not been updated for a long time, updating the nonmembership witness with low computing resources is time-consuming. Under our local computer, it can only process 150 addition operations per second without considering the network propagation delay. Assume each transaction consumes two coins, the user can only process 75 transactions per second when updating the nonmembership witness. If the TPS reaches 7, the same as Bitcoin, it takes 3 days to update a nonmembership witness for a coin that was generated a month ago. Here, we also introduce the service providers (or bridge nodes) which can update the nonmembership witness for old coins. The service providers can use two strategies to accelerate the computation: firstly, by storing the product of prime representatives of spent coins into a cache for each block, the providers can reduce a lot of redundant computations when updating witness for different coins; secondly, computing the nonmembership witness in parallel by using the special processors like GPU. Under this model, the computation power of the network can be effectively utilized, instead of doing the meaningless hash operation in Bitcoin mining.

5. Evaluation
In this section, we theoretically and experimentally evaluate our prototype implementation of MiniChain.

5.1. Implements and experiment setup
Based on the source code of RSA-Accumulator [21], [24] and Merkle tree [29], Merkle mountain range [23], we implemented two types of MiniChains: MiniChain
 only uses STXO commitment while MiniChain
 uses both of STXO commitment and TXO commitment. We use RSA accumulator with 3072 bit-modulus, 128 bits prime representative, and the Merkle root is set to 32 bytes. All these parameters are considered to be safe enough in the field of cryptography. We run all our experiments on our Mac Pro equipped with one 2.6 GHz Intel Core i5 processor, 8 GB RAM, and perform 10 runs and report their average for each data point of running time. We test the performance of the accumulator update, accumulator verification, witness update and compared it with the state-of-the-art works.


Table 1. Comparison of the MiniChain with the existing work (m is the number of transactions in block, n is the size of UTXO set, L is the length of blockchain, k is the number of UTXO increment, and the d is the number of UTXO reduction).

EDRAX	Todd	Boneh	MiniChain
MiniChain
Accumulator type	SMT(UTXO)	MMR(UTXO)	RSA(UTXO)	RSA(STXO)	RSA(STXO)+MMR(TXO)
Proof generation					
Proof size					
Proof verification					
Proof update					
Accumulator update			
5.2. Overall comparisons
In this section, we theoretically analyze the MiniChain with the existing works. Let m be a constant number indicating the maximum number of transactions in each block, n be the size of UTXO set, L be the length of blockchain, k and d be the number of UTXO increments and decrements separately. The result is shown in Table 1.

The Merkle based constructions, including Sparse MerkleTree (SMT) and Merkle Mountain Range (MMR), consume  bandwidth overhead per transaction in proof size, proof verification, proof update and accumulator update, which is substantial and incurs a significant overhead. In contrast, the RSA accumulator based constructions only consume constant bandwidth, that is why we use the RSA accumulator to replace the Merkle based accumulator. Moreover, compared with Boneh, MiniChain has made many improvements in these methods except for a slight increment in proof size. Especially, MiniChain has greatly improved the efficiency of accumulator updates from 
 to .

Due to the heavy burden on bandwidth consumption in Merkle based constructions, in the following sections, we focused on testing Boneh and MiniChain since they were both built on RSA accumulator.

5.3. Accumulator update and verification
In this section, we test the performance of accumulator update and verification. Suppose a transaction consumes an old UTXO and outputs a new UTXO. The results are shown in Fig. 3 and Table 2.

Fig. 3 shows Boneh consumes much more time on accumulator updates than MiniChain, especially when the number of transactions is large. For example, when the number of transactions reaches 1000, Boneh is 50 times slower than the MiniChain. This is because Boneh is built on UTXO commitment, which used the BatchDel to delete all spent coins from the accumulator and used the BatchAdd to add newly produced coins to the accumulator. Since the complexity of the BatchDel is 
, the update efficiency of the accumulator will drop rapidly when a large number of deletion operations are required. In contrast, MiniChain is built on STXO commitment, which only uses BatchAdd to add newly produced coins to the accumulator. Since the complexity of the BatchAdd is only , it can greatly reduce the cost of accumulator updates.

Table 2 shows the accumulator verification time by using NI-POE protocol. Verifiers can check whether the accumulator is updated correctly only using a constant number of group operations in NI-POE protocol, which consumes a constant short time. The verifier’s biggest workload is to calculate the product of each element that needs to be added into the accumulator. Since each block contains a small number of transactions (e.g. smaller than 1000), the calculation of the product will also consume a small amount of time. Besides, MiniChain only takes half the time to verify the accumulator compared with Boneh, since Boneh needs to perform two rounds of NI-POE verification, one for BatchAdd and another for BatchDel, while MiniChain only needs one to check BatchAdd.


Table 2. NI-POE verification time on BatchAdd or BatchDel.

Operation count	200	400	600	800	1000
Verification time (s)	0.05	0.10	0.16	0.22	0.29
5.4. Transaction proof and verification
The validity proof of transaction in MiniChain contains two parts: existence proof and unspent proof. The existence proof of MiniChain
 is the Merkle path from the transaction to the TMR, while the existence proof of MiniChain
 contains additional MTR inclusion proof corresponding to TXO commitment. To verify the existence proof, the validators in MiniChain
 need to store all the historical block headers, while the validators in MiniChain 
 only need to save the latest N block headers. To generate unspent proof for coin 
 generated at time , MiniChain needs all spent coins after time , while Bonth needs both new coins and spent coins after time . We assume the length of blockchain is 
, each block can contain at most 
 transactions, and each transaction consumes one old coin and generates one new coin.

The proof size and verification time of a single transaction are shown in Table 3. The result shows that although the proof size of MiniChain has increased compared to Boneh, the verification time has not significantly increased.

5.5. Proof update
From Section 4.4 we know that the Merkle based existence proof in MiniChain
 remains unchanged, while in MiniChain
, the existence proof only needs to be updated with low frequency which equals to . Suppose the length of blockchain is 
(much longer than Bitcoin), even the earliest generated coin, the existence proof only needs to be updated 20 times, which is negligible.

For unspent proof, the nonmembership witness keeps changing as the new STXO commitment generates. Suppose each transaction has one input and one output, we test the efficiency of witness update. Fig. 4 shows that the time to update the witness grows linearly with the number of operations increases in both of MiniChain and Boneh. Since the MiniChain is built on STXO commitment, it only needs to add the spent coins to the accumulator. Accordingly, the nonmembership witness is only required to update after the addition operations. In contrast, Boneh is built on UTXO commitment, which not only needs to delete the spent coins from the accumulator, but also needs to add the new coins to the accumulator. As a result, Boneh requires twice as much time as the MiniChain to update witness.

5.6. System comprehensive performance
5.6.1. Storage
In this section, to test the storage overhead, we obtained the snapshots of Bitcoin’s UTXO set from Jan 2015 to Jan 2019 and applied them to MiniChain and Boneh. Besides, we set the window of MiniChain STXO cache to 1 day, which is long enough for the majority of transactions to be processed.

Fig. 5 shows the RAM usage of Bitcoin and MiniChain. The RAM requirement of Bitcoin has increased 4 times from Jan 2015 and has reached 2.7 GB. In contrast, the MiniChain
 only needs to keep the STXOs in 1 day’s window, the RAM usage keeps nearly constant and only needs 25 MB on average. Without TXO commitment, MiniChain
 needs store all block headers in RAM to speed up the verification of existence proof. Although the RAM usage increases linearly as the blockchain grows, the RAM usage is one magnitude less than Bitcoin. Besides, since the Boneh has no cache mechanism, the validators only need to keep the latest block’s header, the RAM usage is the smallest. However, Boneh faces the serious problem of transaction expiration, which is one of the challenges that MiniChain has solved.

Fig. 6 shows the disk usage of Bitcoin, MiniChain and Boneh. Since the Bitcoin needs to store all historical blocks, the disk usage of Bitcoin has reached 233 GB and keeps growing rapidly. In contrast, since only the block headers are required in MiniChain and Boneh, the disk usage is very low, which can be stored on any ordinary machines, even mobile phones and IoT nodes. It is worth noting that MiniChain
 consumes slightly more disk space than MiniChain
, because MiniChain
 uses additional TXO commitment, as a result, the block header in MiniChain
 is 384 bytes larger than MiniChain
.


Download : Download high-res image (162KB)
Download : Download full-size image
Fig. 5. RAM Usage: MiniChain
 only needs 25 MB on average while the Bitcoin needs 2.7 GB.

5.6.2. TPS
We test the maximum TPS the system can support considering the performances of transaction verification and accumulator update, which are the two most important factors affecting the system TPS. We assume each block contains 500 transactions, each transaction consumes two old coins and generates two new coins. The result is shown in Table 4.

The experimental results show that Boneh can only achieve 3.2 TPS due to the low efficiency of accumulator update. In contrast, the TPS of MiniChain is only restricted by the transaction verification time, it can reach 100 TPS.


Table 4. System maximum TPS.

Boneh	MiniChain	
Tx verification time [Max TPS]	0.01 s [100]	0.01 s [100]	
Acc update time [MAX TPS]	156 s [3.2]	3.01 s [166]	
Maximum TPS	3.2	100	
6. Related work
6.1. Cryptographic accumulator
A cryptographic accumulator [2], [14], [16] is a primitive thatmerges a large set of elements into a constant-size value such that for a given element these is a membership/nonmembership proof confirming that the element was indeed accumulated into the value or not. Accumulators have been used in many applications, including membership testing, time stamping, authenticated directory and certificate revocation, privacy-preserving data outsourcing, computations on authenticated data, anonymous e-cash [14].

Accumulators were firstly introduced by Benaloh andde Mare [2]. Later, Baric and Pfitzmann [1] refined the concept of accumulators asking from them to be collision-free under the strong RSA assumption. However, it needs to re-run the accumulator when the set of elements changes which is highly impractical especially when the element set is large. To solve this problem, Camenisch and Lysyanskaya [9] proposed dynamic accumulator which can dynamically add and delete element to or from the original set. With known the trapdoor, the cost of adding or deleting elements and updating individual witness is independent from the number of elements accumulated. LLX [21] further proposed a universal accumulator which supports both membership proof and nonmembership proof. Boneh [5] proposed several batching and aggregation techniques for accumulators, and extent current RSA-based accumulator to create a universal accumulator for a decentralized setting using groups of unknown order [6] where no single trusted accumulator manager exists, specifically, elements can be removed from the accumulator without a trapdoor or even knowledge of accumulated set.

6.2. Commitment to blockchain state
Stateless blockchain concept was firstly proposed by Vbuterin [32] to solve the problem of Ethereum state explosion, that is full nodes would only store the state roots, and it would be miner’s responsibility to package Merkle branches (witnesses) along with the blocks, then full node could verify these blocks by check the validity of witnesses. There are two types of accumulators.

6.2.1. Merkle based accumulator
The most straightforward way to construct a commitment of state is using a Merkle tree based construction, including Sparse Merkle tree [13] and Merkel Mountain Range [26], [30]. The advantage of Merkle tree based construction is that a user can efficiently prove to another user that his coins are unspent. However, transferring and updating Merkle proofs incur a significant overhead.

Similarly, Todd [30] proposed TXO commitments using Merkle Mountain Range (MMR) [26] to combat UTXO growth. Specifically, it archived less frequently accessed parts of UTXO set, allowing full nodes to discard the associated data, still providing a mechanism to spend these archived outputs by proving that the outputs are in fact unspent. Both the state of a specific item in the MMR, as well as the validity of changes to items in MMR, can be proven with 
 sized proofs consisting of a Merkle path to the tip of the tree. However, as the author mentioned, checking that the commitment has been properly updated incurs a significant overhead.

6.2.2. Cryptographic accumulator
Some authors proposed using cryptographic accumulator to resolve the problems of Merkle based accumulator. Lenonid [25] proposed using cryptographically authenticated data structures to make verification of transactions much more efficient. Provers hold the entire data structure and modify it as the transactions are processed, publishing proofs that each transaction has correctly modified the data structure. In contrast, verifiers, who hold only a short digest of the data structure, verify a proof and compute the new digest that corresponds to the new state of the data structure, without even having to store the structure itself, making it possible for light nodes to check a blockchain with full security guarantees on commodity hardware, which is important for the health of the cryptocurrency.

Alexander presents a general architecture call EDRAX [12] for building cryptocurrencies with stateless transaction validation. In EDRAX, all nodes, such as miners and validators, can validate incoming transactions and subsequently update the user’s balance simply by accessing the last confirmed block. They provide two instantiations of EDRAX, one for UTXO-based blockchain using a sparse Merkle tree, and one for account-based blockchain where algebraic vector commitments are used. However, EDRAX had ignored the witness update issue, which places a significant burden on users.

Boneh [5] proposed batching techniques for trapdoor-less universal accumulator and vector commitments in groups of unknown order, then used these new constructions to design a stateless blockchain. However, as mentioned before, the poor performance of the accumulator update makes it impossible to be used in a high TPS blockchain.

7. Limitation and future work
This paper focused on the UTXO growth problem of the current UTXO-based blockchain, and addressing it by using stateless design based on STXO commitment. There still remain a few problems that need further researches.

Incentive for Service Provider. The users who do not update their nonmembership witness for a long time rely on service providers, how to ensure that the service providers can work diligently is very important. One feasible solution is to provide an economic incentive mechanism for service providers. They can get a reward after they help users update their nonmembership witnesses.

Witness Update Frequency. The membership (or nonmembership) witness of RSA accumulator should be updated whenever there are elements added or removed from the accumulator. Although the witness in MiniChain can be kept alive for N blocks, the update frequency of witness is still linearly related to the accumulator update. How to decrease the frequency of witness update to a lower lever, e.g., , is worth further studying.

Combination With Sharding. The sharding technology has been widely recognized as an effective method to improve the scalability of blockchain. However, reshuffling the network periodically makes it necessary to download the state of the new shard, resulting in a long startup time. Combining MiniChain with sharding technology can effectively solve the above problems.

8. Conclusion
In this work, we propose the MiniChain, a lightweight UTXO-based public blockchain to combat the state explosion problem. MiniChain introduces STXO commitment and TXO commitment to combine the ever-growing state into one short, constant-sized value, removing the current need for storing the large state and historical blocks. As a result, MiniChain can be fully run on ordinary machines, which can enhance the robustness of the network. We implement and test the MiniChain, the results show that the performance of accumulator update has been improved from 
 to  compared with the state-of-the-art stateless blockchain, which further improves the system throughput.