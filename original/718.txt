Abstract
Internet of things (IoT) is one of the main application scenarios of 5th generation mobile networks (5G). Along with the rapid development of 5G, IoT terminal devices will create big data. Generally, IoT terminal devices are lightweight user equipments, for example, wearable devices. In order to take use of these lightweight terminal devices, it is a feasible way to outsource these created big data to the public cloud. When these data are out of the client’s control, it is of crucial importance to ensure the remote data integrity. To solve the weaknesses of the existing remote data integrity checking schemes, we propose the concept of blockchain-based remote data integrity checking (RDIC) scheme for big data. The new concept makes use of blockchain technique which greatly improves the efficiency and security of RDIC. First, the system model and security definition are given for the proposed RDIC scheme by using blockchain. Then, by using efficient modular arithmetic, RSA digital signature, blockchain, etc, we construct a lightweight blockchain-based RDIC scheme. Finally, we analyze its security and performance. The detailed analysis shows that our scheme is provably secure and lightweight.

Previous
Next 
Keywords
Blockchain

Data integrity checking

RSA

IoT

5G

1. Introduction
By using the data capture and communication technology, IoT links physical world and virtual objects. Especially, 5G makes IoT become more and more universal. IoT can be used in the commercial and national security fields, such as smart and connected cities, industry 4.0, critical infrastructure, internet of battlefield and military things, etc. In the data processing flow (i.e., data collecting, data storing, data transferring, data processing), we have to consider data confidentiality, integrity, authentication and application. A valid method is to delegate the data management to cloud server, such as data storage, data computation, etc. By means of cloud computing, the clients no longer bear the burden of hardware cost, software cost, employee salary, etc. Without the burden of data management, the clients can have more money and energy to focus on their own professional things. When the big data is managed by the cloud, it is important to check whether the uploaded data are complete or not. To be applied to lightweight IoT terminal devices, RDIC scheme must be very efficient, such as wearable devices, radio frequency identification (RFID) devices, etc.

As a distributed ledger, blockchain has the characteristics of decentralization, non-tamperability, distributed storage. For the first time, blockchain is designed in Bitcoin. It is a chain of block. Each block represents a number of transactional records, and the “chain” component links them all together with a hash function. As records are created, they are confirmed by a distributed network of computers and paired up with the previous entry in the chain, thereby creating a chain of blocks, or a blockchain. The adjacent blocks are linked by using the hash function. It can be used to construct the trust among different entities. Architecture of blockchain is shown in Fig. 1. Two adjacent blocks are linked by using the hash function SHA256 (for bitcoin). One block comprises block head and block body. Block head comprises version number, hash value of the previous block head, random number, timestamp, difficulty value and the Merkle root. Block body comprises all the transactions. All the transactions are stored in the leaf nodes of the Merkle hash tree. For the lightweight IoT terminal devices, it can help them realize end-to-end authentication. In the whole data life cycle, blockchain can be used to realize the outsourced storage, outsourced computation, data transmission, etc. In order to solve the weaknesses of the existing RDIC schemes, we propose novel RDIC scheme by using the blockchain technique. The proposed RDIC scheme is provably secure and very efficient.

1.1. Related work
In 2008, Nakamoto invented blockchain which is used to construct the Bitcoin [21]. Blockchain is also called the distributed ledger. It can honestly record the transactions. In order to satisfy the properties of no-tampering, distributed ledger and decentralization, blockchain is built by using some cryptography tools, such as hash function, digital signature, Merkle hash tree, etc. Based on the blockchain, more cryptocurrencies are designed. By using the linkable ring signature and random addresses, Monero has been constructed [12], [25], [29]. In order to preserve the transaction privacy, Zerocoin has been proposed [20], [26]. In order to simulate the money properties of real world, the parties of the bitcoin transaction are designed to be anonymous. Regretfully, Meiklejohn et al. [19] and Ron et al. [24] showed that bitcoin transaction fails to protect the identities of parties of the bitcoin transaction. Anonymity is necessary for the digital currency. In order to further protect the identities of the parties, Mixcoin [3], Monero, Zerocoin, etc, have been proposed. In the vehicle-to-grid network [8] and vehicular ecosystem [5], [14], [17], [34], it is always an important problem to realize the anonymous payment. Bitcoin can be used to solve the privacy preserving payment for them. Apart from the digital currencies, blockchain has been applied into more wide fields, such as network security, incentive mechanism, etc. Anonymous reporting and incentive are always open problem until Wang et al. solved it by using blockchain incentive mechanism [35], [38]. Tong et al. proposed a hierarchical sharding protocol for internet of things blockchain [31], etc. Medhane et al. presented a blockchain-enabled distributed security framework by making use of edge cloud and software-defined networking. Their scheme can detect the security attack at the cloud layer while the security attacks can be reduced at the edge layer of the IoT network [18]. Liang et al. designed secure data storage and recovery scheme in industrial blockchain network environments [15]. Zhuang et al. surveyed the smart gird cyber security on blockchain [42].


Download : Download high-res image (127KB)
Download : Download full-size image
Fig. 1. Architecture of Blockchain.

Notes: 1. Block head. 2. Block body .

5G is the newest cellular mobile communication technology. It extends 4G (LTE-A, WiMax), 3G (UMTS, LTE) and 2G (GSM). The goals of 5G performance are high transfer rate, low latency, energy saving, high system capacity, large-scale equipment access, etc. The international standard organization 3GPP defines three applications scenarios for 5G. They include eMBB (Enhance Mobile Broadband), mMTC (Massive Machine Type Communication) and URLLC (Ultra-reliable and Low Latency Communications). Along with the rapid development of 5G, massive machine type terminal devices will connect to internet. 5G faces four types attacks, i.e., privacy attack, integrity attack, application attack and identification attack. Cryptography can satisfy the requirements of network authentication and privacy-protection in 5G [7], [16]. As a promising technology, D2D (Device-to-device) communication system must satisfy some security conditions, such as authentication, data confidentiality, data integrity, privacy, traceability, anonymity, non-repudiation, availability, revocability, fine-grained access control [9]. When the terminal devices collect massive data, it is necessary to take use of the cloud to manage these data. When the collected data are uploaded to the cloud, the client loses the control on its remote data. When the cloud server may intentionally or unintentionally break the clients’ data, how to get the corresponding evidence and the compensations for the client from the cloud server? It is important to construct a fair and secure RDIC scheme to protect the cloud and the client.

In 2007, by using homomorphic tag technique, Ateniese et al. proposed a novel model for remote data integrity checking, i.e., PDP (provable data possession) [1]. For the remote big data, PDP can be used to check the remote data integrity because it is a probabilistic checking model. Without downloading the whole remote data, the integrity can be checked efficiently with high probability. The first PDP scheme did not support the dynamic data, such as insert operation, delete operation, etc [2]. In order to solve it, by using the authenticated flip table technique, Erway et al. designed a full-dynamic PDP scheme [6]. Even earlier, Sebé et al. constructed RDIC scheme although their scheme has some security weaknesses [27]. In order to satisfy the integrity proof and retrievability proof simultaneously, based on the bilinear pairing, PoR (proof of retrievability) was proposed by Shacham [28]. After these pioneering works, many researchers proposed more PDP models which can solve many different application motivations. When the integrity checking task is delegated to the designated verifier, the proxy PDP model was proposed by Wang [32]. When the data was stored on the multi-cloud, the cooperative PDP model was given by Zhu et al. [41]. Some other motivations have also been studied, such as PDP for outsourced data transfer [33], PoR for large files [10], distributed PDP [11], key-exposure resilient PDP [39], identity-based PDP [40].

In order to improve the efficiency of the remote data integrity checking scheme, many researchers study the blockchain-based remote data integrity scheme. Wang et al. designed the blockchain-based private provable data possession. The proposed scheme saves the storage space and dramatically improves the computation efficiency [37]. Chen et al. presented a blockchain-based PDP model by using multireplica storage tricks. The proposed scheme can realize the decentralized outsourcing storage framework [4]. Wang et al. designed a blockchain-based fair payment scheme by using smart contract. Their scheme is given for public cloud auditing [36]. Along with the rapid development of 5G and IoT, remote storage will become more popular. Thus, lightweight remote data security will be more imperative.

1.2. Motivation
It is always an important research hot point to design lightweight RDIC scheme to satisfy all kinds of requirements. From 2007, a lot of RDIC schemes have been proposed. By analyzing the existing schemes, these designed RDIC schemes can be divided into two categories: (1) by using RSA without blockchain; (2) by using bilinear pairings without blockchain.

Type 1 schemes are impractical for lightweight IoT terminal devices. The typical schemes come from Sebé et al.’ scheme [27] and Ateniese et al.’s scheme [1]. The other schemes have the similar ideas and have the same flaws as [1], [27]. Sebé et al.’ scheme [27] has the following flaws: (1) It lacks the trust between the client and the cloud. When the remote data integrity checking cannot pass the verification, the authority cannot decide whether the cloud has broken the stored data. This verification result may be incurred by the cloud or the client. Since the client stores the block digests, if the digests are broken, the cloud’s response cannot also pass the verification. (2) When the digest becomes larger, lightweight clients have no ability to make use of this scheme. Ateniese et al.’s scheme will calculate a tag for each block which needs expensive exponentiation algorithm [1]. When the block size is big, it will cost more computation resource to get the corresponding tags. When the block size is small, the whole file will be divided into more blocks. More blocks need more tags, computation resource and communication resource. If the lightweight terminal devices get massive data every day, the schemes are impractical.

Type 2 schemes are more impractical for lightweight IoT terminal devices. The typical scheme was firstly put forward by Shacham et al. [28]. For this type scheme, the client will split the uploaded file into many blocks. For each block 
, the client has to create a corresponding tag 
. In order to make the proposed scheme secure, the size of the block 
 is less than the order of the prime-order elliptic curve cryptography. For the bilinear pairings, the corresponding elliptic curve cryptograph’s order is 160 bits and the basic finite field’s order is 512 bits. Thus, the size of 
 is less than 160 bits, i.e., 
 bits. Given the uploaded file whose size is 10 Tb, the file will be split into 
 blocks. The client will create a tag for each block. This procedure needs scalar multiplication, point addition, hash function. It is obvious that the computation cost is much larger than type 1. On the other hand, each tag is larger than each block 
. For most schemes, the corresponding tag is a point whose size is 1024 bits. Thus, the client has to create 64 Tb tags (i.e., 10*1024/160  64 Tb) for 10 Tb data. These tags will be uploaded to the cloud. It requires more communication costs. There exist many Type 2 schemes which are similar to Ref. [28]. They also have the same flaws.

Based on the flaws of the existing remote data integrity checking schemes, it is necessary to further study the problem. It is necessary to design more lightweight and secure schemes. Especially, along with the rapid development of 5G, more and more lightweight IoT terminal devices will create massive data. In order to satisfy these lightweight terminal devices, efficient and lightweight RDIC scheme is necessary. Taking use of the blockchain, this paper designs more efficient scheme: blockchain-based remote data integrity checking scheme.

1.3. Contributions
For lightweight terminal devices in 5G, it is necessary to design efficient and practical RDIC scheme. Our proposed RDIC scheme takes advantage of the blockchain technology, RSA public key cryptography and hash function. By using these techniques, we construct the blockchain-based RDIC scheme. Our contributions are given below:

(1)
Motivated by the flaws of the existing RDIC schemes and the rapid development of 5G, we further study RDIC scheme by using the blockchain technique. It solves the distrust problem between the client and the cloud. It also makes RDIC scheme more efficient.

(2)
We give the formal system model and security definition for our novel RDIC scheme.

(3)
By using blockchain, RSA and hash function, we construct the practical blockchain-based RDIC scheme.

(4)
Based on the provable security, computation cost and communication cost, we analyze the proposed scheme’s security and efficiency. The analysis and implementation show that the proposed RDIC scheme is provably secure and efficient.

(5)
Our scheme can also prevent the dishonest client and protect the honest cloud. It can also guard against the pretender when the client applies for the compensation from the cloud.

1.4. Paper organization
We give the outline of the paper as the following. Section 2 gives the formal system model and security definition. We design the practical blockchain-based RDIC scheme in Section 3. Provable security is given in Section 4. Section 5 gives the performance analysis for our scheme. Section 6 gives the application in the internet of vehicles. The conclusion and future works are given in Section 7.

2. System model and security definition
To construct and analyze the blockchain-based RDIC scheme, we formalize the corresponding system model and security definition in this section.

A blockchain-based RDIC scheme consists of six entities: System Manager, IoT, Client, Cloud, Blockchain and Verifier. These entities’ functions are described separately below:

(1)
System Manager: It creates the system parameters. For these system parameters, some are made public and some are kept secret. Then, it also helps the other entities create the corresponding parameters. Based on the practical system, System Manager sends the different secret parameters to the corresponding entity through the secret channel.

(2)
IoT: It is constructed by a lot of terminal nodes. Based on their functions, they are divided into public IoT, private IoT, community IoT, and hybrid IoT. For a client, he may have many different IoT terminal devices, for example, wearable devices, smart home equipments, etc. Generally, these terminal devices are capacity-limited and lightweight. They collected data from the designated environment for the client.

(3)
Client: It receives massive data from IoT. After data processing, based on the data types, it uploads these data to cloud and blockchain for maintenance and computation.

(4)
Cloud: It has significant storage space and computation resource to serve for its clients. In order to check data integrity, upon receiving the challenge from the verifier, Cloud responds the verifier with the corresponding data.

(5)
Blockchain: By using the property of non-tamperability, blockchain will preserve some data digests for the client. As the ancillary data, these preserved data digests are used in the process of integrity checking. As soon as receiving the challenge from the verifier, blockchain responds the verifier with the corresponding digests.

(6)
Verifier: It will check the remote data integrity for the clients. In order to perform the task, it will create the challenge and check whether the responded data satisfy the pre-defined equation. If the pre-defined equation holds, the remote data is inter; otherwise, the remote data has been broken.

First, we give the formal definition for our blockchain-based RDIC scheme. Second, we describe the security requirements and formalize the security model of our blockchain-based RDIC scheme.

Definition 1 Blockchain-Based RDIC Scheme

A blockchain-based RDIC scheme consists of four phases: Setup, DataCollect, DataUpload and Proof. They are separately described below.

(1)
: It determines the security parameter . Based on , the other system parameters are generated. In the system, some parameters are made known to the public, i.e., public parameters. Through the secret channel, some parameters are secretly sent to the entities, i.e., secret parameters.

(2)
: IoT terminal devices collect different data according to their different functions. Then, these data are processed and sent to the client. Specially, these data may be encrypted and sent to the client in the ciphertext.

(3)
: Upon receiving the collected data from IoT, the client processes these data and divides them into different types. Then, it creates a lot of blocks and the corresponding digests. Finally, it uploads them to cloud and blockchain, respectively.

(4)
: It is an interactive process among Verifier, Cloud and Blockchain. Verifier interacts with Cloud and Blockchain, respectively. Then, Verifier gets the responses from Cloud and Blockchain, respectively. By using the responses, Verifier checks whether the remote data are complete.

Besides the security requirements, a practical blockchain-based RDIC scheme must satisfy the performance requirements. We will consider the scheme’s performance from the computation overhead and communication overhead. From the security requirements, a blockchain-based RDIC scheme must satisfy the following conditions:

(1)
When Client, Verifier, Cloud and Blockchain honestly perform the scheme, and the stored data are complete, Cloud and Blockchain’s responses can pass the verification of verifier. In other words, the scheme is correct.

(2)
In order to be adapted to lightweight Client and Verifier, Verifier can perform the RDIC scheme without the local copy of the file(s) and metadata. In other words, it is a lightweight RDIC scheme.

(3)
If the challenged blocks are complete, the cloud’s response cannot pass the verification only with negligible probability. In other words, it can guard against the dishonest client.

(4)
When the challenged data are broken or lost, cloud can pass the verification with negligible probability. In other words, it can guard against the dishonest cloud, i.e., it satisfies the unforgeability.

(5)
If the stored data are broken or lost, it can be detected with very high probability.

We formalize the above security requirements below.

Definition 2 Unforgeability

Suppose that the challenged blocks have been broken. If the dishonest Cloud’s response can pass the verification only with negligible probability, we call our blockchain-based RDIC scheme satisfies unforgeability. Formally, we construct the game which is interacted between the adversary  (i.e., dishonest Cloud) and the challenger  (i.e., Verifier). The game is interacted below:

(1)
Setup: Input the security parameter , it outputs the public parameters and secret parameters.  keeps the secret parameters confidential and makes the public parameters public.

(2)
First-Phase Queries:  adaptively makes Hash queries and block-digest queries to .  responds ’s queries step by step.

(3)
Challenge:  sends the challenge to  and Blockchain where the challenge defines the challenged block-digest pairs.

(4)
Second-Phase Queries: It is similar to First-Phase Queries. The constraint is that there exists at least one challenged block-digest pair which does not belong to First-Phase Queries and Second-Phase Queries.

(5)
Forge:  and Blockchain respond ’s challenge.

When Blockchain and ’s response can pass ’s verification only with negligible probability, the proposed RDIC scheme satisfies the property of unforgeability.

For the challenged block-digest pairs, Definition 2 means that, the dishonest cloud cannot respond a valid proof of data integrity if the challenged blocks have been broken. It is also important to ensure the unchallenged blocks integral with high probability. In order to satisfy the purpose, the following definition is given.

Definition 3

 Security
If the cloud broken  fraction of the uploaded blocks, the probability that the broken blocks can be detected is not less than . In this case, we call the blockchain-based RDIC scheme satisfies the  security.

A secure RDIC scheme should be fair for both the cloud and the client. Definition 2 prevents the dishonest cloud. The following definition will prevent the dishonest client.

Definition 4 Dishonest Client Prevention

If the cloud does not break the client’s remote data, the client cannot swindle the cloud and get the compensation with non-negligible probability.

Definition 5 Compensation

If the stored data is broken by the cloud, no one can pass himself off as the client to get the compensation from the cloud. In other words, only the real data owner (i.e., the real client) can get the compensation from the cloud.

This paper makes use of a lot of notations. In order to improve the readability, Table 1 lists the notations and descriptions.


Table 1. Notations and descriptions.

Notations	Descriptions
The modulo of RSA which is the product of two big safe primes
Two safe primes where 
Two safe primes where 
, 
The set of quadratic residues modulo  which is also the unique cyclic subgroup of 
 with the order 
.
Euler function
The generator of 
The set of elements which have the inversions in 
The stored file which is divided into  blocks, i.e., 
The length of the block, i.e., 
.
Cryptographic hash function
Pseudo-random function
Pseudo-random permutation
Public key of client
Private key of client
The signature on 
chal	The challenge 
 where 
Blockchain	Store 
Cloud	Store 
3. The proposed blockchain-based RDIC scheme
In order to design a practical blockchain-based RDIC scheme, we give some preliminary tools which include RSA algorithm, RSA signature, quadratic residue group, etc. For our proposed blockchain-based RDIC scheme, the detailed phases are also presented in this section.

3.1. Preliminary tools
As the first efficient public key cryptography algorithm, RSA is widely used in all kinds of fields. RSA can be used to encrypt the message, to perform the signature on the message, to realize the key agreement among multiple parties, etc. Hash function can be used not only to realize the digital signature but also to realize the non-tamperability of blockchain. We describe them below.

Definition 6 RSA Encryption and Digital Signature

Let  be a product of two safe large primes , i.e., . Let  be the Euler function. Pick a random integer number  which is co-prime to . Compute the integer number  which satisfies . Thus, the client’s public key is  and private key is .

•
Encryption/Decryption: It is performed between the sender (Encryptor) and the client (Decryptor). The sender encrypts the message  and gets the ciphertext 
. It sends the ciphertext  to the client. The client decrypts  and gets the plaintext 
.

•
Signature/Verification: It is performed between the client (Signer) and the verifier. To sign a message , the client calculates the signature 
. Then, the client sends the message–signature pair  to the verifier. In the phase of verification, the verifier checks whether 
 holds. If it holds, the verifier accepts this signature; otherwise, the verifier rejects the signature.

Theorem 1

Unique Cyclic Subgroup of 
 [1]
Let 
 and 
 be two safe primes where 
 and 
 are also primes. Let  be an RSA modulus and 
 be the set of quadratic residues modulo . Then, 
 is the unique cyclic subgroup of 
 and 
’s order is 
.

For RSA cryptosystem,  and 
 are secret. Thus,  and 
 are also secret. In this paper, we also use hash function. Hash function can map arbitrary-length strings into equal-length strings. It is also one-way function and collision-resistant function.

3.2. The concrete blockchain-based RDIC scheme
This scheme comprises four phases: Setup, DataCollect, DataUpload and Proof. Fig. 2 outlines the scheme’s architecture. We describe the architecture figure below: (0) Initially, System Manager generates the system parameters. At the same time, it also generates the parameters for IoT devices, Client, Cloud and Blockchain, respectively. It corresponds to the phase Setup. (1) IoT devices collect the data and transfer them to Client. It corresponds to the phase DataCollect. (2) Client processes the collected data. Then, it classifies these data and uploads them to Cloud and Blockchain, respectively. It corresponds to the phase DataUpload. (3) In order to check the remote data integrity, Verifier interacts with Cloud and Blockchain, respectively. It corresponds to the phase Proof.

Without loss of generality, let the collected data be 
 where 
 comes from the th internet of things IoT
, 
. In order to protect the collected data, these data maybe the ciphertext and they are sent to the Client in the ciphertext. When Client receives the ciphertext 
 of the collected data , it decrypts them and gets the plaintext . Based on the collected data’ types and other purposes,  is divided into  blocks 
. In order to keep these data  confidential,  can be encrypted and the corresponding ciphertext is divided into  blocks. To simplify the algorithm, we omit the encryption process. Our simplified scheme can also be applied into the ciphertext. The different point is that the simplified scheme omits the procedures of encrypting  and decrypting the ciphertext. The detailed phases are presented below:

•
Setup: Let  be a modulus which is created by Client with two prime factors  and , i.e., . The two factors  can also be described as 
 where 
 are primes. Denote the Euler’s totient function as . Let  be an integer which can be used to trade off the storage requirements and the computational cost. Denote  where  denotes the bit length of the file . In addition, let  be a pseudo-random function and let  be a pseudo-random permutation. They are described below: 
 Denote  as a cryptographic hash function.  means the greatest common divisor between  and . Pick a prime  which satisfies . Compute  which satisfies . Client’s public key is  and private key is . Let 
 be the secure symmetric encryption/decryption algorithm pair where the symmetric secret key is . Let  be a generator of the square residue group 
 whose order is 
.

•
DataCollect: Based on the client’s requirements, IoT terminal devices collect the corresponding data and send them to Client. Denote the collected data as 
 from the th internet of things IoT
. These data 
 is encrypted into 
, i.e., 
 where  is known to IoT and Client. At last, the IoT terminal devices will send these data 
 to Client.

•
DataUpload: Upon receiving the collected data 
, Client decrypts them by using  and gets the plaintext 
 where 
 for 
. Based on their types, Client reconstructs 
 and gets the data . Then, Client performs the following procedures:

–
Divide the data  into -bit pieces, i.e., 
 where 
,  and 
.

–
For each block 
, compute the digest 
.

–
Compute the signature 
 of the data  where .

–
Upload the  blocks 
 and the hash value  to Cloud. Simultaneously, upload the  digests 
, hash value  and signature  to Blockchain.

Upon receiving 
, Cloud checks whether  holds. After that, Cloud checks whether  has been uploaded to Blockchain. If  holds and  is the same as the uploaded  on the Blockchain, Cloud accepts 
 and stores them on the cloud. Otherwise, Cloud rejects these data.
•
Proof: In order to verify whether the remote data is integer, Verifier interacts with Cloud and Blockchain respectively:

–
Verifier picks the random challenge 
 where 
. Then, it sends  to Cloud and Blockchain, respectively.

–
Upon receiving the challenge , for , Cloud computes 
Then, it computes 
. Finally, Cloud sends 
 to Verifier.

–
Upon receiving the challenge , for , Blockchain computes 
Then, it computes 
 and sends 
 to Verifier.

–
Verifier checks whether 
 holds. If it holds, output “success” which means the remote data are complete; otherwise, output “failure” which means the remote data are incomplete.

Notes: In the real system, the reward and punishment mechanism is necessary. In the phase Proof, when the responses from Cloud and Blockchain cannot pass the verification, Cloud and Blockchain respond the same challenge many times. If all the responses cannot pass the verification, Cloud will negotiate with Client to pay for the data loss.

4. Security analysis
For any cryptographic scheme, the most basic requirement is it must be correct. Correctness means that Cloud should be able to pass the verification if it stores the complete version of the data  in the phase Proof. Security means that Cloud cannot pass the verification if the stored data has been broken. We give the following theorems:

Theorem 2 Correctness

Supposed that the stored data  has not been broken, i.e.,  is complete on the cloud. If Cloud and Client honestly perform the proposed scheme, Cloud’s response can pass the verification.

Proof

   ■

Theorem 3 Unforgeability

Based on the non-modifiability of blockchain, the proposed blockchain-based RDIC scheme is existentially unforgeable. In other words, if Cloud has broken the challenged data, Cloud’s response can pass Verifier’s verification only with the probability no more than 
 
 which is negligible.

Proof

Based on the non-modifiability of blockchain, we take use of the proof by contradiction. We prove the unforgeability from the following two aspects.

(1) If the challenge is 
. Let the challenged block be 
 on the cloud. Suppose that 
 is broken into 
. If it can pass the verification, then 
 holds. We can get 
. Based on the non-modifiability of blockchain, 
 is correct and complete. Since  is secret, then 
 holds with the probability 
 
 which is negligible.

(2) Else, the challenge is 
 where . Suppose that many challenged blocks have been broken. Without loss of generality, we denote the broken blocks as 
. Then, the following formula holds: 
Since the numbers 
 are random, we can get 
 for all . Based on the proof (1), it holds only with negligible probability 
 
. The symbol  is the cardinality of the set .

Thus, our proposed blockchain-based RDIC scheme satisfies the unforgeability.  ■

Theorem 4 Detection Probability

Suppose that Client has uploaded  blocks to Cloud. Simultaneously, the corresponding  digests have been uploaded to Blockchain. If Cloud has broken  blocks and the challenge is 
, the broken blocks can be detected with the probability 
 

Proof

Let  be set for the challenged blocks. Let  be the set for the broken blocks. Denote  as the random variable  where  denotes the cardinality of the intersection of  and . Thus, we can get 
 
 
 
 
  ■

Fig. 3 shows the detection probability 
 where  and , , respectively. X-label denotes the number of broken blocks. Y-label denotes the probability that the broken blocks can be detected. It shows that when some blocks are broken, they can be detected with very high probability. For example, when , we get 
; when , we get 
. Fig. 3 shows that our scheme is lightweight and efficient.

Prevention of malicious client. When the malicious Client uploads the wrong blocks to Cloud, they cannot pass Cloud’s verification. If they are wrong, the computed hash value  is different from the value  which has been stored on Blockchain. Thus, the wrong blocks cannot pass Cloud’s verification. Since the blockchain is the trusted third party, it can prevent the malicious client. If Client is found to be malicious, it will also be penalized. For example, it will pay more fees for the same services.

Compensation. When the remote data is broken, Cloud must compensate for Client. In order to prevent the identity fraud, Cloud verifies the signature 
 by using the claimant’s public key. If it holds, Cloud must compensate for claimant;otherwise, reject. The cheater cannot get the compensation because its public key cannot pass the verification of the signature . Thus, the fake claimant is rejected.

Efficient private blockchain-based RDIC scheme. Our scheme can be easily transformed into efficient private blockchain-based RDIC scheme below.

(1)
The front three phases (i.e., Setup, DataCollect, DataUpload) are the same as our original scheme.

(2)
The phase Proof is performed below:

(a)
Client sends the challenge  to Cloud and Blockchain, respectively.

(b)
Cloud computes 
 and sends it to Client. At the same time, Blockchain computes 
 and sends it to Client.

(c)
Upon receiving 
 and 
, Client checks whether 
 holds. If it holds, “success”; otherwise, “failure”.

Because the transformed blockchain-based RDIC scheme eliminates the procedure 
 which needs expensive exponentiation algorithm for the cloud. It also eliminates the procedure 
 which needs expensive exponentiation algorithm for the client. Thus, the transformed scheme is more efficient. On the other hand, the transformed RDIC scheme is private because the procedure 
 needs the secret information 

5. Performance analysis
First, we analyze the computation cost and communication cost of our proposed scheme. Then, we give the implementation prototypal of the proposed scheme.

Computation cost: Let the uploaded file  be divided into  equal length blocks 
 where 
 and 
 
. Denote 
 as the computation cost of exponentiation modulo . Denote 
 as the computation cost of modulo . In order to preprocess the file  and generate the digests, signature and , Client’s computation cost is 
 plus one hash computation. In the interaction Proof, Cloud’s computation cost is 1
,  multiplications and  additions; Blockchain’s computation cost is  multiplications and  additions; and, Verifier’s computation cost is 1
+1
. We also implement our scheme in the environment below. Cloud and Blockchain work on the ASUS S56C Laptop with the following settings:


Download : Download high-res image (153KB)
Download : Download full-size image
Fig. 3. The probability curve 
 of detecting the corruption.

•
CPU: Intel Core i7-3517U @ 1.90 GHz

•
Physical Memory: 4GB DDR3 1600MHz

•
OS: Ubuntu 13.04 Linux 3.8.0-19-generic SMP i686

Client and Verifier work on the PC Laptop with the following settings:

•
CPU: CPU I PDC E6700 3.2 GHz

•
Physical Memory: DDR3 2G

•
OS: Ubuntu 11.10 over VMware-workstation-full-8.0.0

In the implementation, we use our protocol to process 1T bit file . We consider three different sizes of block, i.e., 
. Thus, we get three different block numbers, i.e., 
. In the phase DataUpload, only Client takes part in the data processing procedure. In the phase Proof, Verifier, Cloud and Blockchain interact each other to finish the remote data possession checking procedure. Let the challenged block number be 50, i.e., . Table 2 gives the concrete computation cost with the unit second. From the implementation, when the bit length of  is 19, Client’s computation cost is 100.7351 s and Verifier’s computation cost is 6.7715 s, Cloud and Blockchain’s computation cost are 8.1773 s and 1.023 s, respectively. Our scheme is very efficient.

Communication cost: National Bureau of Standards and ANSI X9 have determined the shortest key length requirements: RSA and DSA are 1024 bits, ECC is 160 bits [22]. Based on the standard, we analyze our protocol’s communication cost. In the phase DataUpload, Client uploads  bits to Cloud. At the same time, Client uploads  bits to Blockchain. In the phase Proof, Verifier sends  (i.e., 
) bits to Cloud and Blockchain, respectively. After that, Cloud sends about  bits to Verifier and Blockchain sends about  bits to Verifier where . When  increases,  decreases. The communication cost also decreases in the phase DataUpload. From the above analysis, our scheme’s communication efficiency is high.


Table 2. Computation cost of the parties (F  1T bit, c  50).

Size of 	Cloud	Blockchain	Client	Verifier
0.6702 s	0.0835 s	137.5732 s	0.6201 s
2.3254 s	0.3145 s	113.3259 s	2.1372 s
8.1773 s	1.023 s	100.7351 s	6.7715 s
Comparison: Compared to our scheme, Ref. [27]’s scheme did not satisfy the following conditions: (1) It cannot prevent the malicious clients. When the malicious Client uploads the illegal file  to Cloud, Cloud will face the risk of being framed up. (2) It lacks the credibility. Since Client and Cloud do not trust each other, when Cloud’s response cannot pass the verification, Cloud can deny the duty of breaking data. Cloud can argue that this case is incurred because Client can also break the stored digests. In other words, the “failure” may come from Cloud or Client. By using the trusted Blockchain, our scheme can solve the above two problems.

In Ref. [1], in order to save the computation cost on the client, the block size cannot be too big because the block is the index of exponentiation modular arithmetic. Let the block size be 1024 bits. In order to create a tag, the client needs 2 exponentiation modular arithmetic, 1 multiplication. In the proof, the cloud needs  exponentiation modular arithmetic,  multiplication; the verifier needs 1 exponentiation modular arithmetic, 1 inversion and 1 multiplication. In Ref. [28], compared to our scheme, their scheme incurred heavy computation cost and communication cost. The uploaded file must be divided into the block whose size is 160 bits. For every block, the corresponding tag is a point (1024 bits) on the elliptic curve. In order to generate a tag, 1 scalar multiplication and 2 point addition are needed. Thus, Ref. [28] needs more computation cost and communication cost than our scheme. We define the data expansion degree as 
 
 which shows the communication overhead. The communication overhead decreases along with  decreases. Specially,  for Ref. [1] and  for Ref. [28]. Fig. 4 shows the data expansion degree . For Fig. 4, x-label begins from 512 bits. From the figure, our scheme has more lower communication cost when the block length is larger than 1024 bits. Specially, when the processed data size is 1T bits, the final generated data size is 2T bits for Ref. [1] and 7.4T bits for Ref. [28]. In our scheme, when the block size is 100M bits, the final generated data size is (1+10−8)T bits. It is obvious that our scheme has very low communication overhead.

We analyze the computation cost of the phase DataUpload. For 1 Tb data, in our scheme, suppose the block size is 100M bits. Then, 1 Tb data is divided into 
 blocks and the time cost is about 80.351 s. For Ref. [28], 1 Tb data is divided into 
 blocks and the time cost is about 
 seconds. For Ref. [1], 1 Tb data is divided into 
 blocks and the time cost is about 
 seconds. In the phase Proof, Verifier only needs one exponentiation modular arithmetic in our scheme. It is obvious that our scheme is more efficient.

6. Applications in internet of vehicles
The main value expression of IoT is the internet of industrial things. Internet of industrial things can provide the value for the office, factory, retail business, etc. Internet of vehicles is one of the main types for the internet of industrial things. Fig. 5 gives the architecture of internet of vehicles in 5G. It comprises vehicles, cloud computing, 5G base station, GPS, etc. The interactions include V2P (Vehicle-to-Pedestrian), V2I (Vehicle-to-Infrastructure), V2V (Vehicle-to-Vehicle), V2H (Vehicle-to-Home), V2O (Vehicle-to-Office), vehicle to GPS, vehicle to 5G base station, etc. It all comes up to V2X (Vehicle-to-Everything). From these interactions, massive data will be generated and uploaded to the cloud computing server. At the same, the vehicle will respond based on the data from the stored data in the cloud server.

When the self-driving car runs at high speed on the road, it is important to remain the remote data integer. Otherwise, if the received data is modified, some terrible accidents will happen. It may cause significant casualties and economic losses. It is very important to frequently check the remote data integrity. As the vehicle units are limited to the computation capacity and storage capacity, lightweight RDIC scheme is necessary. Thus, our scheme can be applied into the field of internet of vehicles.


Download : Download high-res image (222KB)
Download : Download full-size image
Fig. 5. Internet of Vehicles in 5G.

In 5G, some researchers have constructed the security architecture of blockchain-based end-edge–cloud Integration [13], [23], [30]. Thus, it is feasible to make use of the blockchain technique in our scheme. In internet of vehicles, the vehicles take the role of Client. The vehicles process the generated data  and split  into  pieces 
. By using our RDIC scheme, the vehicles upload  and hash value  to Cloud. Simultaneously, they upload  digests, hash value  and signature  to Blockchain. Cloud server checks the validity of the received data. If they are valid, the cloud server accepts these data; otherwise, the cloud server rejects them. The vehicles or the trusted third party or the blockchain or the designated proxy can take the role of Verifier. By performing the interaction Proof of our RDIC scheme, the verifier interacts with the cloud server and the blockchain, respectively. After the interaction, the remote data integrity can be efficiently checked. Thus, the vehicles can receive the correct data and respond to the received instructions.

7. Conclusion and future work
In 5G, when the massive data from IoT is uploaded to cloud server, we have to solve the problem of remote data integrity checking. Based on the tamper-resistant property of blockchain, we propose the blockchain-based remote data integrity checking scheme for IoT. We study the system model, security model and formal definition of the novel scheme. Based on the blockchain, RSA, and cryptographic batch verification technique, we construct a concrete scheme. Security analysis, performance analysis and implementation show that our scheme is provably secure and efficient.

In the real world, data can be divided into many different types based on privacy requirement, security requirement, data ownership, etc. Different data types require different RDIC schemes. When the data owner delegates the proxy to process its data, it is necessary to study proxy-based RDIC scheme. When the data belongs to many entities, it is necessary to study multi-owners RDIC scheme by using the secure multi-party computation technique. For the reporting data, privacy and traceability are important security requirements. It is important to preserve the reporter’s privacy if it is honest and to trace the reporter’s identity if it is malicious. There exist the other data types which need different RDIC schemes. In the future, we will solve these problems for these different data types.