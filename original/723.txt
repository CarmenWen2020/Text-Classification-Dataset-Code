Abstract
The dispersion problem on graphs asks k≤n robots placed initially arbitrarily on the nodes of an n-node anonymous graph to reposition autonomously to reach a configuration in which each robot is on a distinct node of the graph. This problem is of significant interest due to its relationship to other fundamental robot coordination problems, such as exploration, scattering, load balancing, and relocation of self-driven electric cars (robots) to recharge stations (nodes). In this paper, we consider dispersion using the global communication model where a robot can communicate with any other robot in the graph (but the graph is unknown to robots). We provide two novel deterministic algorithms for arbitrary graphs in a synchronous setting where all robots perform their actions in every time step. Our first algorithm is based on a DFS traversal and guarantees (i) O(kΔ) steps runtime using O(log⁡(k+Δ))) bits at each robot and (ii) O(min⁡(m,kΔ)) steps runtime using O(Δ+log⁡k) bits at each robot, where m is the number of edges and Δ is the maximum degree of the graph. The second algorithm is based on a BFS traversal and guarantees O((D+k)Δ(D+Δ)) steps runtime using O(log⁡D+Δlog⁡k)) bits at each robot, where D is the diameter of the graph. Our results complement the existing results established using the local communication model where a robot can communication only with other robots present at the same node.

Keywords
Multi-agent systems
Autonomous mobile robots
Dispersion
Distributed algorithms
Time and memory complexity

1. Introduction
The dispersion of autonomous mobile robots to spread them out evenly in a region is a problem of significant interest in distributed robotics, e.g., see [16], [17]. Recently, this problem has been formulated by Augustine and Moses Jr. [1] in the context of graphs. They defined the problem as follows: Given any arbitrary initial configuration of  robots positioned on the nodes of an n-node anonymous graph, the robots reposition autonomously to reach a configuration where each robot is positioned on a distinct node of the graph (which we call the Dispersion problem). This problem has many practical applications, for example, in relocating self-driven electric cars (robots) to recharge stations (nodes), assuming that the cars have smart devices to communicate with each other to find a free/empty charging station [1], [19]. This problem is also important due to its relationship to many other well-studied autonomous robot coordination problems, such as exploration, scattering, load balancing, covering, and self-deployment [1], [19]. One of the key aspects of mobile-robot research is to understand how to use the resource-limited robots to accomplish some large task in a distributed manner [12], [13].

In this paper, we continue our study on the trade-off between memory requirement and time to solve Dispersion on graphs. We consider for the very first time the problem of dispersion using the global communication model where a robot can communicate with any other robot in the system (but the graph structure is not known to robots). The previous work [1], [19], [20] (details in Table 1 and related work) on Dispersion considered the local communication model where a robot can only communicate with other robots that are present at the same node. Although the global communication model seems stronger than the local model in the first sight, many challenges that occur using the local model also arise using the global model. For example, two robots in two neighboring nodes of G cannot figure out just by communication which edge of the nodes leads to each other. Therefore, the robots still need to explore through the edges as using the local model. The global communication model has been considered heavily in the past in distributed robotics, e.g., see [8], [15], [25], in addition to the local model, and our goal is to explore how much global communication helps for Dispersion in graphs compared to the local model.


Table 1. The results on Dispersion for k ≤ n robots on n-node arbitrary graphs with m edges, D diameter, and Δ maximum degree.

Algorithm	Memory/robot (in bits)	Time (in rounds)	Comm. Model/ Initial Conf.
Lower bound		Ω(k)	local
[1]1		O(mn)	local/general
[19]		O(m)	local/general
[19]		O(ΔD)	local/general
[19]		O(mk)	local/general
[20]			local/general

Lower bound 1		Ω(k)	global
Lower bound 2 (for trees)		Ω(D2)	global
Thm. 1.1(a)		O(kΔ)	global/general
Thm. 1.1(b)			global/general
Thm. 1.2(a)		O(DΔ(D + Δ))	local/rooted
Thm. 1.2(b)		O((D + k)Δ(D + Δ))	global/general
1
The results in [1] are only for .

In this paper, we provide two new deterministic algorithms for Dispersion using the global communication model for arbitrary graphs. Our first algorithm using a depth first search (DFS) traversal performs better than the state-of-the-art using the local communication model by a  factor; see Table 1. The second algorithm is the first algorithm designed for Dispersion using a breadth first search (BFS) traversal and provides different time-memory trade-offs. We also complement our algorithms by some lower bounds on time and memory requirement using the global model.

Overview of the Model and Results. We consider the same model (with the only difference as described in the next paragraph) as in Augustine and Moses Jr. [1], Kshemkalyani and Ali [19], and Kshemkalyani et al. [20] where a system of  robots is operating on an n-node graph G. G is assumed to be a connected, undirected graph with m edges, diameter D, and maximum degree Δ. In addition, G is anonymous, i.e., nodes have no unique IDs and hence are indistinguishable but the ports (leading to incident edges) at each node have unique labels from , where δ is the degree of that node. The robots are distinguishable, i.e., they have unique IDs in the range . The robot activation setting is synchronous – all robots are activated in a round and they perform their operations simultaneously in synchronized rounds. Runtime is measured in rounds (or steps).

The only difference with the model in [1], [19], [20] is they assume the local communication model – the robots in the system can communicate with each other only when they are at the same node of G, whereas we consider in this paper the global communication model – the robots in the system can communicate with each other irrespective of their positions. Despite this capability, robots are still oblivious to G and they will not know the positions of the robots that they are communicating with, except of those they are colocated with.

We establish the following two results for Dispersion in an arbitrary graph. The second result differentiates the initial configurations of  robots on G. We call the configuration rooted if all  robots are on a single node of G in the initial configuration. We call the initial configuration general, otherwise.

Theorem 1.1

Given any initial configuration of  mobile robots in an arbitrary, anonymous n-node graph G having m edges and maximum degree Δ:

a.
Dispersion can be solved in  time with  bits at each robot using the global communication model.

b.
Dispersion can be solved in  time with  bits at each robot using the global communication model.

Theorem 1.2

Given  mobile robots in an arbitrary, anonymous n-node graph G having m edges, diameter D, and maximum degree Δ:

a.
For the rooted initial configurations, Dispersion can be solved in  time with  bits at each robot using the local communication model.

b.
For the general initial configurations, Dispersion can be solved in  time with  bits at each robot using the global communication model.

Theorem 1.1 performs better than the  time best previously known algorithm [20] using the local communication model by a factor of  with an additional  bits (see Table 1). We also prove a time lower bound of  and memory lower bound of  bits at each robot for Dispersion on graphs using the global communication model. The implication is that, for constant-degree arbitrary graphs (i.e., when ), Theorem 1.1 is asymptotically optimal with respect to both memory and time, the first such result for arbitrary graphs. Theorem 1.2 gives significantly better run-time than the  algorithm [19] using the local communication model. We also prove a time lower bound of  for Dispersion on trees using the global communication model. This implies that the time in Theorem 1.2(a) is asymptotically optimal for constant-degree arbitrary graphs.

Although Theorem 1.2(b) has higher time and space complexity than Theorem 1.1, the algorithm for Theorem 1.2(b) is significant because: (i) it is the first algorithm that is based on a BFS approach (rather than DFS) to solve Dispersion and illustrates a new technique, (ii) it performs better than the  algorithm [19] using the local communication model, and (iii) it directly contributes to solving the problem of merging concurrently initiated BFS tree constructions and traversals in a distributed setting, which is a very broad problem with many applications.

Challenges and Techniques. The well-known DFS traversal approach [5] was used in the previous results on Dispersion [1], [19], [20]. If all k robots are positioned initially on a single node of G, then the DFS traversal finishes in  rounds solving Dispersion. If k robots are initially on k different nodes of G, then Dispersion is solved in a single round. However, if not all of them are on a single node, then the robots on nodes with multiple robots need to reposition to reach to free nodes and settle. The natural approach is to run DFS traversals in parallel to minimize time.

The challenge arises when two or more DFS traversals meet before all robots settle. When this happens, the robots that have not settled yet need to find free nodes. For this, they may need to re-traverse the already traversed part of the graph by the DFS traversal. Kshemkalyani et al. [20] designed a smarter way to synchronize the parallel DFS traversals so that the total time increases only by a factor of  to  rounds, in the worst-case, using the local communication model. However, removing the  factor seemed difficult due to the means of synchronization. We develop in this paper an approach (Algorithm 2) that allows to synchronize DFS traversals without re-traversing the already traversed part of the graph giving us  rounds, as if running DFS starting from all robots in the same node, using the global communication model. This gives an additive, not multiplicative, cost in synchronizing different DFS traversals. This is possible due to the information that can be passed to the robots to take their next actions, even if they do not know their positions on G. This passing of information among remotely located robots has not been possible using the local communication model in the literature, and does not seem to be possible because of the very nature of the local communication model. The best mechanism for synchronization in the local communication model incurred an  factor to synchronize  trees that might be formed in the dispersion process. Our time bound for the global communication model becomes  for constant-degree arbitrary graphs, which is asymptotically time-optimal. Our proposed technique in Algorithm 2 can be generalized and applied to any problem which requires merging concurrently-initiated and concurrently-growing DFS tree components into a single DFS component at an additive cost.

Despite efficiency in merging the DFS traversal trees due to global communication, the time bound of  seems to be inherent in algorithms based on a DFS traversal [5], [19], and even if using the global model. A natural way to circumvent this limitation is to run BFS traversal to reach many nodes at once. A naive approach of running BFS gives exponential 
 runtime. Here we design a smarter way (Algorithm 3, Algorithm 4) of performing BFS so that we can achieve dispersion in arbitrary graphs in  time in the rooted initial configuration. The general initial configuration introduces a  factor instead of the  factor in the time bound. Our proposed technique in Algorithm 3, Algorithm 4 can be generalized and applied to any problem which requires merging concurrently initiated and concurrently growing BFS tree components into a single BFS component.

Related Work. There are three previous studies focusing on Dispersion using the local communication model. Augustine and Moses Jr. [1] studied Dispersion assuming . They proved a memory lower bound of  bits at each robot and a time lower bound of  ( in arbitrary graphs) for any deterministic algorithm in any graph. They then provided deterministic algorithms using  bits at each robot to solve Dispersion on lines, rings, and trees in  time. For arbitrary graphs, they provided two algorithms, one using  bits at each robot with  time and another using  bits at each robot with  time.

Kshemkalyani and Ali [19] provided an  time lower bound for arbitrary graphs for . They then provided three deterministic algorithms for Dispersion in arbitrary graphs: (i) The first algorithm using  bits at each robot with  time, (ii) The second algorithm using  bits at each robot with 
 time, and (iii) The third algorithm using  bits at each robot with  time. Recently, Kshemkalyani et al. [20] provided an algorithm for arbitrary graph that runs in  time using  bits memory at each robot. For grid graphs, Kshemkalyani et al. [22] provided an algorithm that runs in  time using  bits memory at each robot using the local model and an algorithm that runs in  time using  bits memory at each robot using the global model. Randomized algorithms are presented in [24] to solve Dispersion from rooted initial configurations where the random bits are mainly used to reduce the memory requirement at each robot. In this paper, we present results using the global communication model. The previous results on arbitrary graphs are summarized in Table 1.

One problem that is closely related to Dispersion is the graph exploration by mobile robots. The exploration problem has been quite heavily studied in the literature for specific as well as arbitrary graphs, e.g., [2], [4], [9], [14], [18], [23]. It was shown that a robot can explore an anonymous graph using -bits memory; the runtime of the algorithm is 
 [14]. In the model where graph nodes also have memory, Cohen et al. [4] gave two algorithms: The first algorithm uses -bits at the robot and 2 bits at each node, and the second algorithm uses  bits at the robot and 1 bit at each node. The runtime of both algorithms is  with preprocessing time of . The trade-off between exploration time and number of robots is studied in [23]. The collective exploration by a team of robots is studied in [15] for trees. Another problem related to Dispersion is the scattering of k robots in an n-node graph. This problem has been studied for rings [11], [27] and grids [3]. Recently, Poudel and Sharma [26] provided a -time algorithm for uniform scattering in a grid [7]. Furthermore, Dispersion is related to the load balancing problem, where a given load at the nodes has to be (re-)distributed among several processors (nodes). This problem has been studied quite heavily in graphs, e.g., see [6]. We refer readers to [12], [13] for other recent developments in these topics.

Paper Organization. We discuss details of the model and some lower bounds in Section 2. We discuss the DFS traversal of a graph in Section 3. We present a DFS-based algorithm for arbitrary graphs in Section 4, proving Theorem 1.1. We then present a BFS-based algorithm for rooted arbitrary graphs in Section 5, proving Theorem 1.2(a). We then present a BFS-based algorithm for arbitrary graphs in Section 6, proving Theorem 1.2(b). Finally, we conclude in Section 7 with a short discussion.

2. Model details and preliminaries
Graph. We consider the same graph model as in [1], [19]. Let  be an n-node graph with m edges, i.e.,  and . G is assumed to be connected, unweighted, and undirected. G is anonymous, i.e., nodes do not have identifiers but, at any node, its incident edges are uniquely identified by a label (a.k.a. port number) in the range , where δ is the degree of that node. The maximum degree of G is Δ, which is the maximum among the degree δ of the nodes in G. We assume that there is no correlation between two port numbers of an edge. Any number of robots are allowed to move along an edge at any time. The graph nodes do not have memory, i.e., they are not able to store any information.

Robots. We also consider the same robot model as in [1], [19], [20]. Let 
 be a set of  robots residing on the nodes of G. For simplicity, we sometimes use i to denote robot 
. No robot can reside on the edges of G, but one or more robots can occupy the same node of G. Each robot has a unique -bit ID taken from . When a robot moves from node u to node v in G, it is aware of the port of u it used to leave u and the port of v it used to enter v. Furthermore, it is assumed that each robot is equipped with memory to store information, which may also be read and modified by other robots present on the same node.

Communication Model. We assume that robots follow the global communication model, i.e., a robot is capable to communicate with any other robot in the system, irrespective of their positions in the graph nodes. However, they will not have the position information, except for co-located robots, as graph nodes are anonymous. This is in contrast to the local communication model where a robot can only communicate with other robots present on the same node.

The global communication abstraction can be implemented by message-passing or through memory. In some of our algorithms, we also use message-passing for non-co-located robots, wherein a directed message to a destination robot can be sent or a broadcast can be performed. This can be simulated in the memory model as follows. If robot i wants to send to j, it writes “broadcast/j:〈message content〉” in its own memory and the receiver(s) j read this content from i's memory.

Time Cycle. At any time a robot 
 could be active or inactive. When a robot 
 becomes active, it performs the “Communicate-Compute-Move” (CCM) cycle as follows.

•
Communicate: For each robot 
 that is at some node 
, the robot 
 at node 
 can observe the memory of 
. In some of our algorithms, this communication is done by message-passing if 
 (
 does a send or broadcast and 
 does a receive) which can be simulated in the memory model. Robot 
 can also observe its own memory.

•
Compute: 
 may perform an arbitrary computation using the information observed during the “communicate” portion of that cycle. This includes determination of a (possibly) port to use to exit 
 and the information to store in the robot 
 that is at 
.

•
Move: At the end of the cycle, 
 writes new information (if any) in the memory of a robot 
 at 
, and exits 
 using the computed port to reach to a neighbor of 
.

A cycle may have  CCM sub-cycles.
Time and Memory Complexity. We consider the synchronous setting where every robot is active in every CCM cycle and sub-cycle and they perform the cycle and sub-cycles in synchrony. Therefore, time is measured in rounds or steps (a cycle is a round or step). Another important parameter is memory. Memory comes from a single source – the number of bits stored at each robot. The memory we count is persistent memory, which is the memory that needs to survive across rounds. This includes the read-only memory for the robot identifier.

Mobile Robot Dispersion. The Dispersion problem can be formally defined as follows.

Definition 1

Dispersion
Given any n-node anonymous graph  having  mobile robots positioned initially arbitrarily on the nodes of G, the robots reposition autonomously to reach a configuration where each robot is on a distinct node of G.

The goal is to solve Dispersion optimizing two performance metrics: (i) Time – the number of rounds (steps), and (ii) Memory – the number of bits stored at each robot.

2.1. Some lower bounds
We discuss here some time and memory lower bounds using the global communication model, which show the difficulty in obtaining fast runtime and low memory algorithms. Consider the case of any rooted initial configuration of  robots on a single node 
 of an arbitrary graph G with diameter D. A time lower bound of  is immediate since a robot initially at 
 needs to traverse  edges (one edge per time step) to reach a node that is  away from 
. For , we present the following lower bound.

Theorem 2.1

Any deterministic algorithm for Dispersion on graphs requires  steps using the global communication model.

Proof

Consider a line graph G and a rooted initial configuration of  robots on a single node 
 of G. In order for the robots to solve Dispersion, they need to settle at k distinct nodes of G, exactly one on each node. To reach a node to settle, some robot must travel  edges of G, taking  time steps. □

For , we present the following time lower bound for trees.

Theorem 2.2

For , there exists a tree T with n nodes and diameter (height) D such that any deterministic algorithm for Dispersion requires 
 steps using the global communication model.

Proof

We use the lower bound proof for exploration due to Disser et al. [10] to prove this lower bound. It has been argued in [1] that a lower bound for exploration applies to Dispersion. We argue here that the lower bound of [10] applies for Dispersion using the global communication model. Disser et al. [10] proved a lower bound for exploration assuming a rooted initial configuration in which  robots are on a single node 
 of tree T. Moreover, they assumed that the nodes of tree T have unique identifiers and the robots have global communication. Specifically, they showed that: Using  robots, there exists a tree T on n vertices and with diameter (height)  such that any deterministic exploration strategy requires at least 
 steps to explore T. As our model is weaker because the nodes are indistinguishable, the 
 steps lower bound applies to Dispersion in trees using the global communication model. □

We finally prove a lower bound of  bits at each robot for any deterministic algorithm for Dispersion on graphs.

Theorem 2.3

Any deterministic algorithm for Dispersion on n-node anonymous graphs requires  bits at each robot using the global communication model, where  is the number of robots.

Proof

From the system model, each robot must have its identifier in the range  and we count this memory space for the identifier which must survive across rounds as the space complexity. □

3. DFS traversal of a graph (Algorithm )
Consider an n-node arbitrary graph G as defined in Section 2. Let 
 be the initial configuration of  robots positioned on a single node, say v, of G. Let the robots on v be represented as 
, where 
 is the robot with ID i. We describe here a DFS traversal algorithm, , that disperses all the robots in the set  to k nodes of G guaranteeing exactly one robot on each node.  will be heavily used in Section 4 as a basic building block.

Each robot 
 stores in its memory four variables.

1.
 (initially assigned ⊥), for a settled robot denotes the port through which it first entered the node it is settled at.

2.
 (initially assigned −1), stores the port of the node where 
 is currently located, that it has last taken (while entering/exiting the node).

3.
 (initially assigned ) stores the ID of the smallest ID robot the tree is associated with.

4.
 (initially assigned ).  executes in two phases,  and  [5].

The algorithm pseudo-code is shown in Algorithm 1. The robots in  move together in a DFS, leaving behind the highest ID robot at each newly discovered node. They all adopt the ID of the lowest ID robot in  which is the last to settle, as their . Let the node visited have degree δ. When robots enter a node through port  either for the first time in forward mode or at any time in backtrack mode, the unsettled robots move out using port . However, when robots enter a node through port  in forward mode for the second or subsequent time, they change phase from forward to backtrack and move out through port . (It is straight-forward to modify Algorithm 1 so that the settled robot r also tracks in  the port through which the other robots last left the node except when they entered the node in forward mode for the second or subsequent time and hence backtracked through the port through which they entered that time.)

Algorithm 1
Download : Download high-res image (136KB)
Download : Download full-size image
Algorithm 1. Algorithm DFS(k) for DFS traversal of a graph by k robots from a rooted initial configuration. Code for robot i.

Theorem 3.1

Algorithm  correctly solves Dispersion for  robots initially positioned on a single node of a n-node arbitrary graph G in  rounds using  bits at each robot.

Proof

We first show that Dispersion is achieved by . Because every robot starts at the same node and follows the same path as other not-yet-settled robots until it is assigned to a node,  resembles the DFS traversal of an anonymous port-numbered graph [1] with all robots starting from the same node. Therefore,  visits k different nodes, where each robot is settled.

We now prove time and memory bounds. The DFS traversal may take up to  rounds, with each forward edge being traversed twice and each backward edge being traversed 4 times (once in either direction in the forward phase and once in either direction in the backward phase) [19]. However, in  rounds,  is guaranteed to visit at least k different nodes of G because in the DFS, each edge can be traversed at most 4 times and hence at most 4Δ traversals can visit a particular node [19]. If ,  visits all n nodes of G. Therefore, it is clear that the runtime of  is  rounds. Regarding memory, variable  takes  bits,  takes  bits, and  and  take  bits. The k robots can be distinguished through  bits since their IDs are in the range . Thus, each robot requires  bits. □

4. DFS-based algorithm for arbitrary graphs (Theorem 1.1)
We present and analyze Graph_Disperse_DFS, a DFS-based algorithm that solves Dispersion of  robots on an arbitrary n-node graph in (i)  time with  bits of memory at each robot and (ii)  time with  bits of memory at each robot using the global communication model. This algorithm has better run-time than the  time of the best previously known algorithm [19] for arbitrary graphs (Table 1) using the local communication model. We mainly discuss result (i) in Sections 4.1– 4.3. The last subsection, Section 4.4, discusses how to modify the approach of result (i), to obtain result (ii). Specifically, result (ii) achieves improved time of  in the expense of additional  bits per robot.

4.1. Basic idea
When k robots are located at more than one node in the initial configuration, multiple concurrent DFS traversals described in Section 3 are initiated. Two or more such DFSs collide when one DFS visits a node where another DFS has settled a robot or another DFS is also visiting in this round. The challenge is to combine these DFSs efficiently. Our algorithm operates in two phases: DFS Grow, and DFS Collect. The  described in Algorithm 1 is the DFS Grow and is associated with a component ID, CID, which is the . When two or more DFSs collide and form a connected component of DFSs, using global communication, a Subsume graph is constructed to represent which DFS has collided into which other one. One of the DFSs called the  DFS is chosen to subsume the others in the connected component of CIDs and collapses the others. An unsettled robot from the  DFS is chosen as leader and it traverses all the other connected DFS components of subsumed DFSs in G by entering the DFS Collect phase to collect all the settled and unsettled robots from those DFS components using a DFS traversal. Then they all switch to the DFS Grow phase of the  and continue its DFS Grow from the home node where it was interrupted by the collision. This process can repeat up to  times.

The algorithm has two nice properties based on how the winner component is chosen after each collision.

1.
All the settled nodes (defined as nodes with a settled robot) in all the subsumed components of DFSs (which are the nodes in the connected component of the Subsume graph) form a connected component in the network graph G.

2.
Hence it is possible for the leader to successfully traverse these nodes, and only these nodes (i.e., not traverse the nodes in the winner's component or any other nodes) in the DFS Collect phase, and collect their settled and unsettled robots to the home node from which the leader started the DFS Collect traversal.

A component CID may get subsumed multiple times before/while being collected because of possibly multiple collisions and multiple winners over time. However, the collection time of a subsumed DFS component is linear in the number of settled nodes in it. To see this, consider a component CID that is always a  across the lifetime of the execution.

1.
From the above properties, all the robots in all the components subsumed by the  over time get collected by the 's leaders without interruption of their DFS Collect phases. The total time cost of the DFS Collect phases of the  component is linearly additive, each term being the time for a DFS traversal of only the settled nodes in the subsumed components each time the leader of that  switches to DFS Collect phase. This is bounded by .

2.
In addition, the time cost of the DFS Grow phases of the winner is additive and hence the total cost is that for a DFS traversal of the maximum number of robots in that winner, which is bounded by .

The overall time cost is additive and hence bounded by .
4.2. The algorithm
The algorithm is based on DFS traversal. In general, a robot may operate in one of two interchangeable DFS phases: DFS Grow and DFS Collect. As these are independent, a separate set of DFS variables: , ,  is used for operating in the two phases. The following additional variables are used.

1.
: Tree ID, of type robot identifier, is the ID, i.e., , of the DFS tree in the GROW phase with which the robot is associated. Initially,  minimum ID among the colocated robots.

2.
: Tree ID, of type robot identifier, is the ID of the DFS tree in the DFS Collect phase with which the robot is associated. Initially, .

3.
CID: for component ID, of type robot identifier, is used to denote the component associated with the DFS Grow phase of the DFS. Initially, .

4.
: for earlier component ID, of type robot identifier, is used to denote the earlier value of component ID just before the most recent component ID (CID) update, associated with the DFS Grow phase of the DFS. Initially, .

5.
: of type robot identifier. When multiple components collide/merge, this is used to indicate the winning component ID that will subsume the other components. Initially, .

6.
: of type boolean. This is set to 1 if the robot is responsible for collecting the various robots distributed in the subsumed components. Initially, .

7.
: of type robot identifier. The robot identifier of a settled robot is used to identify the origin node of the leader robot that is responsible for collecting the scattered robots in the subsumed components back to this origin node. Initially, .

8.
: denotes the state of the robot and can be one of . Initially, .

9.
: of type boolean. A robot sets this when entering  and resets it when leaving . A robot is considered settled if . Initially, .

In the initial configuration, there are groups of robots at different nodes. Each robot has its  set to the minimum ID among the colocated robots, and its . The robots from a node move together in a DFS traversal, to locate free nodes and settle one by one. A free node is one where there is no robot having . As the robots do the DFS traversal , they extend the DFS tree that is associated with the . Each growing DFS tree is also associated with a component ID, CID, that is initialized to the . Multiple DFS trees associated with different CIDs may meet at a node in any round; specifically, a DFS tree for component CID may meet another component  for some other DFS tree, where r is the robot that is settled at that node or settles there in this round, defined as having . In this case, one robot from the newly arrived robots of the DFS tree component CID broadcasts a  message. This is to indicate that the component CID is subsuming the component . Multiple such  messages may get broadcast from different robots in different parts of the graph in any particular round.

All the robots listen to all such broadcasts in each round, and build a directed graph, , , where C is the set of component IDs, and edge 
 indicates that 
 message has been received. In this graph, each node may have at most one outgoing edge but may have multiple incoming edges. The  component ID corresponds to that node (in my connected component of S) that has the minimum CID among the nodes with no incoming edges (if such a node exists). Otherwise, all nodes (in my connected component) of the  graph must exist in one cycle, and the lowest valued CID node in the cycle is chosen as . The significance of the  is that its CID subsumes all other CIDs in its connected component of S; that is, all robots that are in the same connected component of S overwrite their current CID by  in their connected component of S and get collected by a leader robot from the  component.

The robot with the minimum ID among those with  and  changes its  to ,  to 1,  to , and embarks on the  phase. In the  phase, the leader does an independent DFS traversal  of the connected component of settled nodes of G which have settled robots which have newly changed their component ID CID to be the same as its own. And all (settled and unsettled) robots which have newly changed their CID to that of the  leader (hence , where  is the value of CID before the latest overwrite by ), also change their , whether , , , or  to  and stop movement until they are collected. Also, all unsettled robots with  and  but are not the leader change their  to  and stop movement until they are collected. In this DFS  traversal, the leader node collects all settled and unsettled robots with  and brings them back to its home node from where it began the  DFS traversal, while the thus collected robots change their  to  once they join the collection traversal. During the  traversal, if in some step the component being traversed gets subsumed by some other component, the robots in the component being traversed reset their  to . If the DFS  traversal completes successfully, the collected robots and the leader change  to , set their  to that of the leader, and resume DFS  after the leader resets its leader status. If the DFS  does not complete, it is because the component got subsumed by another  component; the robots in the interrupted DFS  change  to  and stop until they are themselves collected by the leader of the new .

Note that the DFS  is independent of the DFS , and thus an independent set of variables , ,  need to be used for the two different types of DFSs. Further, when a new instance of a DFS /DFS , as identified by a new value of / , is detected by a robot, the robot switches to the new instance and resets the old values of , ,  for that DFS search.

In the DFS  phase, the leader visits all nodes in its connected component of settled nodes having a settled robot that changed its component ID . (These are the settled robots where .) This excludes the nodes already visited in the DFS  phase having settled robots with the same CID as that of the leader before it become the leader. To confine the DFS  to such nodes, note that the leader may have to backtrack from a node v if the node (i) is free or (ii) has  or (iii) has . If the CID of the leader changes at the beginning of this round in which it was to backtrack (because it gets subsumed), before it can backtrack, the leader (and any accompanying robots having ) simply changes  to  and stops. In cases (i) and (iii), there may thus be stopped robots at a free node, or at a node that belongs to an adjoining, independent component. Such robots may be later collected by (a) a leader from its old component, or (perhaps earlier than that) (b) by a leader from the component where they stop. In the former case (a), it is execution as usual. In the latter case (b), there is no issue of violating correctness even though the robots jump from one connected component sharing a common CID to an adjacent one with a different CID.

4.3. Correctness and complexity
Lemma 4.1

Once a robot enters  for some value of , the DFS  completes within  rounds, or the robot moves out of that state within  rounds.

Proof

From Theorem 3.1, the DFS  can complete within  rounds and the robot goes to  state. Before this completion of the DFS, if the current component gets subsumed or subsumes another component, the robot moves to either  or  state. □

Lemma 4.2

Once a robot enters  for some value of , the DFS  completes in  rounds or the robot moves out of that state within  rounds.

Proof

The DFS traversal of a component completes within  rounds. It also completes within  rounds, as the collecting robot in the DFS traverses an edge at most 4 times, needs to visit each of the at most Δ neighbors of the at most k settled nodes in the component, until collection completes and the leader is back at the home node. At the completion of the DFS, the robot moves to  state; before this completion of the DFS, if the current component gets subsumed by another component, the robot moves to  state. □

Lemma 4.3

For a DFS Collect for a CID 
:

1.
The nodes in the DFS components of G subsumed by winner 
, corresponding to the nodes of S (in a connected component of S) subsumed by winner 
, form a connected component of G and for such nodes 
.

2.
The DFS Collect by the leader of winner 
 traverses all these nodes having 
 and their neighbors, and only these nodes.

Proof

(Part 1). There are two possibilities from Subsume_Graph_Processing. (a) All the nodes in the connected component of 
 are in a simple cycle. All the nodes in the cycle minus the 
 node form a connected component 
. (b) There exists a node in the connected component of 
 that has no incoming edges, and 
 is the CID of such a node. 
 is a connected component 
.

In either possibility, an edge 
 in 
, by definition of a  broadcast, indicates the nodes in G belonging to the two DFS components of 
 and 
 are reachable from one to the other. The connected component 
 therefore implies that the union of the nodes contained in G in each of these nodes in 
 is all reachable from one another. Furthermore, all these are subsumed nodes by 
 and from the algorithm, they set 
 and 
. The lemma Part (1) follows.

(Part 2). From the algorithm pseudocode, observe that the DFS Collect by the leader of winner 
 traverses all these nodes and their neighbors, and no other nodes. The lemma Part (2) follows. □

Theorem 4.4

The algorithm  solves Dispersion.

Proof

Each robot begins in . Let α denote . We make the following observations about the state transition diagram of a robot given in Fig. 1(a).

1.
A robot can enter  state at most  times. In  state, a robot can stay at most  rounds before it changes  to . This follows from Lemma 4.3 – the leader of the winner 
 will complete its DFS Collect of the connected component having 
 and collect the subsumed robot to its home node. This DFS Collect completes within α unless it gets serially subsumed by another winner, but such subsumptions can happen at most  times. In DFS Collect, robots from the subsumed component move along with the leader only when the leader is backtracking. So even if the DFS is interrupted by another winner 
, the partially completed DFS still belongs to a connected component having 
. Hence the new DFS Collect for 
 can complete, and as per Lemma 4.3, collect all subsumed robots.

Note that from  state, a robot x that has the same  as the leader at the time the leader was so selected and is at the leader's home node, but then stays back at the home node, changes state to  when the leader returns to the home node and has finished exploring all ports at the home node in DFS Collect() (hence is virtually backtracking to its “parent” in DFS Collect). This transition happens within α rounds unless x gets serially subsumed by another winner, but such subsumptions can happen at most  times.

2.
From  state, within α rounds, a robot can go to  state (which can happen at most  times), or go to  state (which can happen at most  times) (Lemma 4.2).

3.
In  state, a robot can remain for at most α rounds, by when it may go to either , , or  state for at most k times (Lemma 4.1).

4.
From  state, a robot goes to  at most  times, and each such transition must happen within what we denote as β rounds, or else the robot remains permanently in  state. We now bound β. If the robot makes a transition to , it is because it gets subsumed by some CID 
.

(a)
The maximum time that different robots with 
 spend in  state is kα, from (3) above.

(b)
The maximum time that different robots with 
 spend in  state is , from (2) above.

(c)
The maximum time that different robots with 
 spend in  state is , from (1) above.

Thus, the sum of the sojourns in  state is bounded by  which is .
Although there are cycles in the state transition diagram, a robot must exit  at most  times,  state at most  times,  state at most k times, and each stay has a bounded sojourn. Also, a robot must exit  state at most  times with the bounded sojourn in each, or else it remains permanently in  state. It then follows that within a finite, bounded number of rounds, a robot will be in  state permanently. It will be settled as part of the DFS  tree traversal it was last associated with within α further rounds (follows from Theorem 3.1). This is and will be the only robot in  state at the node. Thus, Dispersion is achieved within a finite, bounded number of rounds. □
We model the state of a particular value of CID 
 as follows, depending on the state of the least ID robot whose  value equals 
.

Definition 2

 

The state transition diagram for the state of a CID value is shown in Fig. 1(b).
Theorem 4.5

The algorithm  terminates in  rounds.

Proof

By Theorem 4.4, each robot settles permanently within a finite, bounded number of rounds. We now determine the number of rounds more precisely.

If the state of CID 
 ever enters SUBSUMED, the robots with 
 just before the transition would be subsumed, collected, and assigned a new CID 
 possibly  times. Let the final such CID assigned be 
. Note that 
 would never have entered SUBSUMED state. The robots in question get associated with CID 
, and the termination time is that of such a 
 that never entered  state.

Let 
 denote the CID of any robot that settles in the last round of Algorithm . This 
 has never entered SUBSUMED state and therefore its state has shuttled between GROW and COLLECT before reaching and ending in PASSIVE. We separately bound the number of rounds spent by 
 in GROW state and in COLLECT state.

Let the DFS tree in GROW state be associated with 
. Observe that multiple sojourns of 
 in GROW state are associated with the same 
. The DFS data structures associated with 
 are never overwritten by another DFS in GROW state as the component 
 is never subsumed (and independent DFS traversal data structures are maintained for the DFS Grow and DFS Collect phases). Within  rounds, possibly spread across multiple sojourns in GROW state, the DFS associated with 
 completes and every robot associated with it gets settled. Every robot associated with 
 also gets settled within  rounds, as the DFS Grow visits each edge at most 4 times, and hence within  rounds, at least k nodes get visited.

 can transit from GROW to COLLECT and back at most  times because that is the maximum number of times 
 can subsume another CID. Let the transition to COLLECT state occur  times, let the number of rounds spent in COLLECT state on the jth transition to it, , be 
. Each transition to COLLECT is followed by a successful DFS Collect traversal of the connected component 
 of nodes having 
 (from Lemma 4.3); denote by 
, the set of such nodes. These are the nodes in the subsumed DFS components that form the connected component 
, from Lemma 4.3.

In the DFS Collect traversal of 
 by the leader for the jth transition to COLLECT state, the leader visits from each node in 
, each adjacent edge at most 4 times. As 
, it follows that at most  edges are visited in DFS 
 across all transitions to COLLECT state. Hence,
 

The theorem follows by separately combining the number of rounds in DFS Grow and DFS Collect phases in terms of m, and separately combining the number of rounds in DFS Grow and DFS Collect phases in terms of kΔ. □

Theorem 4.6

Proof

Each set of , , ,  for the Grow and Collect phases takes  bits (follows from Theorem 3.1). CID, , , , , and  take  bits each. , , and  take  bits each. Thus, the theorem follows. □

Proof of Theorem 1.1(a): Follows from Theorem 4.4, Theorem 4.6.

4.4. A more time-efficient DFS_Collect
The DFS Collect traversal of 
 is a naive DFS traversal. There are four types of edges traversed in it.

1.
: Edge between two nodes in 
. These can be either forward tree edges or back edges.

2.
: Edge from a node in 
 to a node having 
, i.e., back to the 's component.

3.
: Edge from a node in 
 to a free node.

4.
: Edge from a node in 
 to a node in an adjacent component (having 
).

Let the numbers of these four types of edges be 
, 
, 
, 
. In the DFS Collect of 
, each 
 is traversed at most 4 times, whereas each 
, 
, and 
 is traversed exactly 2 times (once in the forward mode and once in the backtrack mode). This gives:

As 
 and 
 are not disjoint, it does not seem possible to bound 
, the cost of the Collect phases of a single , by . As a result, time complexity of Algorithm Graph_Disperse_DFS is . We now describe a more efficient DFS Collect procedure having time complexity , leading to the algorithm having  time. The  is obtained because 
 = 
 = 
 = 0 and only internal tree edges of 
 are traversed. The key idea is that only DFS tree edges of each subsumed component are traversed in collecting the robots in that tree. This lower time complexity comes at the cost of a space complexity of  because Δ bits are required at a settled robot to mark (in the DFS Grow phase) whether the Δ neighbors of the node are tree edges or not.

Let a junction node be one which has robots having two or more  values. When a leader x of the winner component is selected following a Subsume graph processing, it (serially) does a DFS Collect of each DFS tree of robot y having . This DFS Collect is outlined as follows.

1.
Go from the junction node to the root of the tree of y.

2.
Perform a DFS traversal of the tree (Algorithm 1) with a different set of variables than those used in the Grow phase of that tree, with the following main changes.

(a)
Explore an edge only if it marked as a tree edge or is marked by the  pointer of r in the DFS Grow phase.

This ensures that only tree edges are visited.

(b)
When backtracking to a node along an edge pointed to by  pointer of r in the DFS Grow phase, do not visit other edges in forward mode, but backtrack to the .

This ensures that only 
 edges are visited.

(c)
Collect all robots to the parent node when backtracking to the parent, except along the path from the junction node to the root node.

This ensures that the tree with TID  remains a tree. If this traversal is interrupted due to another Subsume_Graph_Processing, the next leader traversing the tree will use the  pointer of the DFS Collect phase to continue the DFS traversal from where it left off.

3.
When the DFS traversal returns to the root node, collect all robots from the root to the junction node, round-by-round, setting the current root as active node in each round.

This preserves the tree structure in  from root to the junction node in case of interruption by another Subsume_Graph_Processing.

During the DFS Collect traversal of a tree , if a junction node (where ) is encountered, a DFS Collect traversal of tree  is begun recursively. Cycles in these recursive calls are broken by broadcasting  whenever the DFS Collect of  is begun (and setting, using, and resetting the new  variable appropriately).
Proof of Theorem 1.1(b): For the modified DFS Collect algorithm outlined in this section, only tree edges of the subsumed DFS trees are visited. A DFS tree having 
 nodes is traversed in 
 rounds, collecting at least 
 robots to its root. Plus at most 
 rounds traversing from the junction node to the root node of the tree, and back. With a maximum of k robots being collected by the various 
, at most 4k rounds are required by the Collect phases for the various 
. From Theorem 4.5, the Grow phases of 
 take  time. This is the overall time complexity.

The modified algorithm requires Δ bits to mark tree edges in the Grow phase. The extra variables needed to implement the modified Collect phase require  space. Combining with this same space complexity shown in Theorem 4.6, the total space complexity of the modified algorithm is  bits per robot.

The theorem follows from the above reasoning and Theorem 4.4, Theorem 4.6.

5. BFS algorithm for rooted arbitrary graphs (Theorem 1.2(a))
In this section, we present and analyze Rooted_Graph_Disperse_BFS, a BFS-based algorithm that solves Dispersion of  robots on an arbitrary rooted n-node graph in  time with  bits of memory at each robot using the local communication model. This algorithm assumes all  robots are at a single node 
 in the initial configuration. In the next section, we show how to adapt this algorithm to the general case of robots on multiple nodes in the initial configuration.

5.1. Basic idea
The algorithm begins with all the robots at a single root node. A BFS tree is built level by level with the root at level 0. The graph is explored to identify the nodes at level . This exploration is initially carried out by doing a 2-neighborhood search by the robots settled at level i (
 rounds). This gives a count of the “demand” for robots to settle at level . The demand number of unsettled robots are borrowed from the root to try to settle at level . Unfortunately the demand is likely to be an overcount because a level  node may be reachable independently from multiple level i nodes. Yet that is not a big problem if the number of robots at the root exceeds this (overcount) demand.

The real problem arises if the number of robots at the root is less than this demand. Not having any topology information, the available robots at the root are distributed to the level i leaf nodes to only partially fulfill their demands. Now, (a) some level  nodes may not be reached at all because of the partial fulfillment – leading to a deficit of robots for level  nodes, while on the other hand, (b) some level  nodes may be reached via multiple level i nodes – leading to a surplus of robots for level  nodes. The biggest challenge is how to transfer robots efficiently from the surplus to the deficit without having any topology information. The procedure of returning the surplus robots to the root and redetermining demands by level i nodes, and borrowing robots from the root to meet these demands can be repeated multiple times but the problem of partially fulfilling the demands and resulting in problems (a) and (b) again, may occur again.

The algorithm cleverly bounds the number of iterations of this procedure to transfer robots from surplus to deficit to . In this process, the algorithm also simultaneously reduces the overcount demand to the actual demand. It does this by having the exploratory robots borrowed from the root perform some added rounds (2Δ) in each iteration to classify edges  from level i nodes to level  as (i) to be uniquely taken to reach the level  node v (type V for “valid”), or (ii) not to be taken in order that the level  node v is uniquely reachable from another level i node (type I for “invalid”), or (iii) it is yet undetermined whether the level  node v is uniquely reachable from u (type U for “unfinalized”). The movement of robots up and down the tree for meeting the demand and rebalancing the surplus/deficit to meet this goal takes 2i rounds. So the time complexity for extending the level i tree to level  is . This gives a  time algorithm.

The algorithm is presented assuming a global communication model for two reasons. It is more compact, and it can be directly adapted in the next section to the multi-rooted case for the global communication model. While proving the correctness of the algorithm, we show how the global communication can be replaced by the local communication model without increasing the asymptotic complexity.

5.2. The algorithm – rooted case
In the initial configuration, all  robots are at a single node 
. The synchronous algorithm proceeds in rounds and is described in Algorithm 3. The algorithm induces a breadth-first search (BFS) tree, level by level, in the graph. There are two main steps in the algorithm when extending the tree from level i to level : (i) the leaf nodes in the BFS tree at level i determine the number of edges going to level . This is done in procedure Determine_Leaf_Demand(i) and can be achieved in 
 rounds as a 2-neighborhood traversal is performed. The level i robot sets its demand for robots equal to the number of edges (ports) going to level . (ii) The leaf nodes at level i then populate the level  nodes in a coordinated manner, because there may be arbitrary number of edges and connectivity going from level i to level . This is done in procedure Populate_Next_Level(i) iteratively by borrowing robots for exploration from 
.

Algorithm 3
Download : Download high-res image (589KB)
Download : Download full-size image
Algorithm 3. Algorithm Rooted_Graph_Disperse_BFS to solve Dispersion in global model. r denotes a settled robot, if any, at that node.

The iterative borrowing of robots in Populate_Next_Level(i) is done as follows. In each iteration, the leaf nodes' demands are accumulated up the tree in a convergecast-like manner by doing a broadcast B1 as detailed in the algorithm. In this process, each node in the tree and the root learns of the demands of the sub-trees rooted at each of its children. In parallel, the unsettled robots, if any, at the leaf nodes move up to the root. When this completes in i rounds, the root redistributes the available robots among its children's sub-trees as per their accumulated demands, and so on, down the tree for rebalancing. The downward motion of the robots from root to the leaf nodes takes another i rounds. The number of robots assigned by the root to a leaf node at level i may be up to the demand of that node, which is the number of its incident edges going to level  nodes. As there may be edges from multiple nodes at level i to a node at level , only one robot can be earmarked to settle at that node. The robot earmarked to settle at the level  node does a 1-neighborhood traversal and invalidates (I) the ports of all other level i nodes leading to that level  node ( time). The robot does not actually settle at the level  node but participates in further computation. It then returns to the level i node it arrived from and designates the port used to go to the level  node as a valid (V) port. The settled robots at level i then re-evaluate the demand for robots, based on the number of unfinalized (U) ports (i.e., not validated and not invalidated ports going to level  nodes). All unsettled robots (including those that had been “earmarked” to settle at a level  node) return to 
 in the next iteration and they are reassigned for the next iteration based on the renewed (and decreased) values of net demand for exploratory robots and move to the level i leaf nodes. The upward and downward movement takes  time. The algorithm guarantees that  iterations suffice for setting to valid status a sufficient number of ports of level i nodes leading to level  nodes (sufficient to fill level  using the available number of robots), after which a final iteration of robot movements up and down the tree reassigns the final demand based on the number of valid ports (each of which leads to an unique level  node) and distributes up to those many robots among level  nodes. The procedure Populate_Next_Level(i) thus takes  time.

Due to the BFS nature of the tree growth, D iterations of the outer loop of Graph_Disperse_BFS suffice. Hence, the running time is 
.

The following variables are used at each robot.

1.
: the total number of robots at the root, 
. Initialize as defined.

2.
: the level of a robot/node in the BFS tree. Initialize to 0.

3.
i: the current maximum level of settled robots. Initialize to 0.

4.
, where

 for a non-leaf node u is the demand for robots to populate level  for sub-tree reachable via port j. Initialize to 
.

 for a leaf node u at level i has the following semantics.
  Initialize to 
.

If the node u being referred to is clear from context, we sometimes omit the subscript u.

5.
, where  is the ID of the child node (if any), reachable via port j. Initialize to 
 
.

6.
: the ID of the parent robot in the BFS tree. Initialize to ⊥.

7.
: to identify the port through which the parent node in the BFS tree is reached. Initialize to ⊥.

8.
: to uniquely select a robot among those that arrive at a level  node, to mark the edge/outgoing port along which it arrived as V and all other edges/outgoing ports from level i to that level  node as I. Initialize to 0.

9.
The variables  and , and the unique robot identifiers assumption, are strictly not necessary for the single-rooted case. Without  and , the broadcast function can be simulated by each settled robot moving up to its parent and back, to communicate the demand of its subtree. The unique robot identifiers assumption and  help in determining which robot should settle at the root, for assigning robots as per the demands, and for selecting . Without these, a simple randomized scheme can be used for the above determinations.

Lemma 5.1

The while loop of Populate_Next_Level(i) (in Algorithm 3) terminates within  iterations.

Proof

Let 
 denote 
, the number of unfinalized edges (i.e., not validated and not invalidated edges) going from level i to level .

1.
If 
, then each of the 
 unfinalized edges can be explored and all nodes in level  accounted for by validating exactly one edge each among the ports at level i nodes (and invalidating all other unfinalized edges at level i nodes) – thus, the while loop can be exited after one iteration as 
 for any u at level i and for any j and the first clause of the while loop condition is falsified.

2.
If 
, then  robots will be pressed into service for exploration of level , at least  nodes at level  will be visited uniquely in this iteration (i.e., not visited in earlier iterations) via unfinalized edges, and hence at least  ports (edges) at level i, that are currently marked as 
 will be validated with change 
. For the next iteration of the while loop, 
 will be decreased by at least this amount and  ports (edges) at level i will change 
 to V. It follows that within  iterations, one of the following will occur.

(a)
>  ports at level i will be validated. The second clause of the while loop condition is falsified and the loop is exited.

(b)
=  ports at level i will be validated and 
. This happens because no ports were validated in iteration  which is because in Δ iterations at least  ports could have been validated and if exactly  ports were validated, there were no remaining unfinalized ports in iteration . The first clause of the while loop condition is falsified and the loop is exited.

(c)
 within the first Δ iterations. By the reasoning given above in part (1), in one additional iteration, the loop is exited.

In all cases, the loop is exited within  iterations. □
Lemma 5.2

A BFS tree is induced in the underlying graph by Algorithm Rooted_Graph_Disperse_BFS given in Algorithm 3.

Proof

We show by induction on the hypothesis that “all nodes at distance i (along shortest path) from the root have a settled robot that is assigned , or there are no more robots to assign to some such nodes.” The hypothesis is clearly true for  and can be seen to be true for  by following the execution of the algorithm.

We now assume the hypothesis for  () and prove it true for . If level x is filled for iteration with  and some robots are left over, the algorithm moves to  iteration of the main loop, otherwise we are done with the proof. Procedure Determine_Leaf_Demand(x) correctly identifies all nodes at level  and the number of unfinalized edges going to such nodes from level x nodes is set to 
 = 
.

1.
If 
, then after one iteration of the while loop of Populate_Next_Level(x), all nodes of level  are assigned robots (i.e., all ports from level x leading to level  are marked V or I) as 
. After one traversal of robots up and down the tree for correct distribution of robots, robots settle at all the level  nodes. Each node at level  has its corresponding outgoing port j from level x parent u set to 
, with more robots left at 
 for populating higher levels if 
.

2.
If 
, then (as argued in the proof of Lemma 5.1), it follows that within  iterations of the while loop of Populate_Next_Level(x), one of the following will occur.

(a)
>  ports at level x will be validated. The second clause of the while loop condition is falsified and the loop is exited. All the remaining robots () can be accommodated at level  nodes and some nodes at level  will not be assigned any robots because the algorithm has run out of robots. There will be no further levels in the BFS tree.

(b)
=  ports at level i will be validated and 
. The first clause of the while loop condition is falsified and the loop is exited. Level  is filled and there are no remaining robots.

(c)
 gets decreased and 
 within the first Δ iterations. By the reasoning given above in part (1) for 
, in one additional iteration, the loop is exited. Now either

i.
≥  edges have been validated (adding those validated before this iteration to those validated in this iteration), in which case  robots are accommodated at level , and some nodes at level  remain free because the algorithm has run out of robots (if ≥ is strictly >), or

ii.
<  edges have been validated (adding those validated before this iteration and in this iteration), in which case all the nodes at level  will be assigned and settled with robots, with more robots left at 
 for populating higher levels.

The correctness of the induced BFS tree follows. □
Theorem 5.3

Algorithm 3 (Rooted_Graph_Disperse_BFS) solves Dispersion on single-rooted graphs in  rounds and requires  memory using the local communication model.

Proof

There is one robot settled at each node of the BFS tree induced (Lemma 5.2); hence dispersion is achieved.

In one iteration of the main while loop:

1.
Determine_Leaf_Demand(i) does 2-neighborhood traversals in parallel, and hence takes 
 rounds.

2.
In each of the  iterations of the while loop of Populate_Next_Level(i) (Lemma 5.1), the upward movement and the downward movement of the robots takes 2i rounds and the following code block based on the value of  takes 2Δ rounds. This is followed by one upward and downward movement of the robots outside the while loop, which takes 2i rounds.

So the time complexity for each iteration of the main while loop is 
. By Lemma 5.2, a BFS tree is induced and hence the maximum number of levels is D, which is the number of iterations of the while loop of Rooted_Graph_Disperse_BFS. Thus the overall time complexity is 
 = .
The variable  takes  bits,  and i take  bits each,  takes  bits,  takes  bits,  takes  bits,  takes  bits, and  takes 1 bit. The synchronize() can be implemented by a  bit counter.

The local communication model suffices because we can simulate the global communication in the pseudocode by local communication without increasing the asymptotic complexity.

1.
The directed broadcasts B1 can be simulated by each settled robot moving up to its parent and back, to communicate the demand of its sub-tree.

2.
Also, to evaluate the condition in line (11), leaf nodes trigger a convergecast up the tree wherein each settled robot moves one level up to its parent to convey its subtree variables; it waits there until the root evaluates the condition; the result is read in a tree broadcast-like action down the tree wherein each waiting child at the parent's original position locally reads the result and moves down one level to its original position to convey the result to its children who are waiting there.

3.
The synchronize can be implemented using a mechanism similar to that in point 2 above.

The theorem follows. □
6. BFS algorithm for arbitrary graphs (Theorem 1.2(b))
In this section, we adapt the single-rooted algorithm Rooted_Graph_Disperse_BFS (Algorithm 3) to the multi-rooted case. We present and analyze Graph_Disperse_BFS (Algorithm 4), which is a BFS-based algorithm that solves Dispersion of  robots on an arbitrary n-node graph in  time with  bits of memory at each robot using the global communication model. This algorithm has lower run-time than the 
 time of the best previously known algorithm [19] for arbitrary graphs (Table 1) using the local communication model. Furthermore, it is the first such algorithm using the BFS approach to solve Dispersion. This algorithm also contributes to BFS tree creation in distributed systems with concurrently initiated BFS tree creations from different nodes.

6.1. The algorithm – general case
We adapt the single-rooted algorithm to the multi-rooted case, see Algorithm 4. From each root, a BFS tree is initiated in parallel. A tree is identified by , the robot ID settled at the root. When two (or more) BFS trees meet at a node, a collision is detected and a Collide message is broadcast. This collision detection may happen in Determine_Leaf_Demand or in Populate_Next_Level. In Collision_Processing, a tree with the highest depth among the colliding trees is chosen to subsume the other tree(s) it has directly collided with, and a corresponding Subsume message(s) is broadcast. Settled robots in a subsumed tree change their state and are not settled any more, and all the trees that are subsumed disappear and join the subsuming tree which will have maximal depth. (All subsuming trees will have maximal depth because the others with lower depth are not active.) In Subsume_Processing, the robots of the other (subsumed) tree(s) are collected at the root of the subsuming tree. The subsuming tree then continues the BFS algorithm at the same depth by executing Populate_Next_Level again if  and  (which tracks if the level has not been filled completely), i.e., level  may not be fully populated yet, where i is the current maximum level of settled robots. Collisions may occur again in Populate_Next_Level and hence Collision_Processing and Subsume_Processing may have to be re-executed. This may repeat but each time, at least one BFS tree gets subsumed and hence the total number of serial executions of the three procedures is bounded by . In the execution of this algorithm, there are synchronize() statements to ensure all tree growths occur in lock-step. Such barrier synchronizations can be implemented in the global communication model by a -sized counter.

A collision is detected in tree with root  when a robot visits a node at level , where i is the current maximum level of settled robots, from node u along outgoing port 
. A 4-tuple collision record 
 is associated with this direction of the exploration collision. In the code, we refer to the third and fourth parameters as  and , respectively. A message Collide(
) is broadcast to indicate that the exploration denoted by the first parameter has collided with the second parameter exploration/tree.

A unique robot executes Collision_Processing to process the Collide messages. It creates an undirected Collision graph 
, where
⁎⁎
 It then creates a Maximal Independent Set (MIS) M from among those nodes  of 
 having , where i is the current maximum level of settled robots. For each tree identified by , it includes adjacent trees identified by 
 with which there has been a collision, in set . Such trees 
 may have 
. (If 
 then 
 is not active, (which can happen in line 28), and if 
 then 
 is active (first instance of broadcast in line 37) or inactive (second instance of broadcast in line 37).) For each , trees in  are asked to collapse and subsume into tree identified by x, by broadcasting Subsume(
); when they get subsumed by the tree , this unblocks the x tree. Note that if tree 
 is adjacent to multiple trees 
 M, the tree 
 will be asked to collapse and be subsumed in to only one of those trees in M. However, 
 no longer blocks both x and 
. The MIS construction guarantees that if there are two adjacent trees of depth  (hence active) in 
, either one will be subsumed into the other or at least one of them will get subsumed by yet other(s). Hence, unblocking occurs. For trees  such that , they must have a neighbor z such that  and tree z subsumes tree y. Thus, all active trees (which are those having level ), whether in or outside M, unblock or get subsumed.

In Subsume_Processing, for each received message Subsume(
), where 
 and 
, the path H from 
 to v is identified in a backwards manner, via parents, as follows. Nodes along H beginning from  leaf node v serially broadcast  progressively up the path from v to 
 ( serial broadcasts suffice). On receiving  at robot , the next node on the path H is x, reachable via outgoing port 
, and  also broadcasts B2( to continue identifying the previous nodes along the path. (The path H can alternately be identified by each robot beginning with v serially moving up to its parent (to let it identify which port to take towards v) and back to its original position.)

All robots in 
 except those along H move upwards and collect to 
. They move along H down to v, then to u, and upwards in T to . These movements take  steps.

Theorem 6.1

Algorithm 4 (Graph_Disperse_BFS) solves Dispersion in multi-rooted graphs in  rounds and requires  memory using the global communication model.

Proof

Each concurrently-initiated BFS tree grows until it collides with another (or runs out of robots). When two (or more) trees collide, then in the processing of the Collision graph we have the following. (1) For each , trees in  are asked to collapse and subsume into tree identified by x, by broadcasting a Subsume message; when they get subsumed by the tree , this unblocks the x tree. (2) For trees  such that , they must have a neighbor z such that  and tree z subsumes tree y. Thus, all active trees (which are those having level ) unblock or get subsumed. On unblocking, the tree continues to grow. It can collide at most  times, hence at most  invocations of Collision_Processing and Subsume_Processing. It continues to grow until termination (exhausting all the unsettled robots at its root). On termination, one robot is settled at each distinct node of the BFS tree(s). Hence Dispersion is achieved.

Building on the proof of Theorem 5.3 for Algorithm 3, in addition to 
  rounds, we have at most  executions of Populate_Next_Level, Collision_Processing, and Subsume_Processing. Let there be x such iterations corresponding to x serial subsumptions by the tree in question. Let the depth (level) of the tree for the jth subsumption be 
. Then the following additional time cost is incurred:
 
 
 
 and . Thus the additional time is 
). The total time complexity follows.

The logic introduced in the multi-rooted algorithm adds variables ( sized counters for synchronize()) that do not increase the bit complexity.

The global communication model needs to be used for issuing and processing the broadcasts. The theorem follows. □

Proof of Theorem 1.2: Follows from Theorem 5.3, Theorem 6.1.

7. Concluding remarks
We have presented two results for solving Dispersion of  robots on n-node arbitrary graphs. The first result is based on a DFS traversal and the algorithm performs better than the best previously known algorithm using the local communication model by a  factor, with an additional  bits in memory. The second algorithm is based on a BFS traversal and runs significantly faster than the 
 time of the previously known algorithm using the local communication model.

For future work, it will be interesting to solve Dispersion on arbitrary graphs using a DFS-based algorithm with time  or improve the existing time lower bound of  to . Furthermore, it will be interesting to achieve  time bound in Theorem 1.1(b) with only  bits per robot, removing the additional  bits factor. For BFS-based algorithms, it will be interesting to improve the  factor to  for arbitrary graphs. The fourth interesting direction will be to consider faulty robots. The fifth interesting direction will be to extend our algorithms to semi-synchronous and asynchronous settings.

CRediT authorship contribution statement
Ajay D. Kshemkalyani: Formal analysis, Investigation, Methodology, Writing – original draft, Writing – review & editing. Anisur Rahaman Molla: Formal analysis, Investigation, Validation. Gokarna Sharma: Conceptualization, Formal analysis, Investigation, Methodology, Project administration, Supervision, Writing – original draft.