Abstract
Elephant flows (elephants) refer to the sequences of packets that contribute only 10% of the total volume but consume over 90% of the network bandwidth. They often cause network congestion and should be efficiently managed. Present cloud data centers often involve host- and switch-based approaches to detect and schedule elephants, but suffer (1) each host and switch in the network needs to be customized, and (2) dynamic models and advanced policies are difficult to be applied. Software Defined Cloud (SDC) addresses these issues by enabling controller-based approaches. With the aid of Machine Learning (ML) technologies, SDC can achieve learning-based models, flexible deployment, and early detection and schedule of elephants for the optimization of network performance and energy usage in a dynamic and intelligent manner. On this purpose, this article emphases the significance of models describing elephants, surveys the mechanisms that may apply to model, detect, and schedule elephants for SDC to optimize the network performance and energy usage. To the best of our knowledge, this work is the first effort that reviews the techniques in all these related subtopics simultaneously in the context of energy cloud.


Keywords
Elephant flows
Modeling
Detection
Scheduling
Software defined energy cloud

1. Introduction
In Cloud Data Centers (CDCs), a flow is a sequence of packets from a source computer to a destination. Flows are typically grouped by the 5-tuple: source IP address, source port number, destination IP address, destination port number, IP protocol. Flows have widely various types and volumes. However, over 90% of the bandwidth in CDCs is typically consumed by the less than 10% of the flows [9], [13], [49]. Such flows are often called elephant flows (elephants), while the others are called mice flows (mice) [163]. Elephants often have a big size and a long duration in the network, but mice have a small size and live for a short time period. Elephants typically are bandwidth-hungry while mice are latency-sensitive. In general, elephants are generated by some certain types of applications such as file transferring, virtual machine migration, data backup, and scientific computing. As these applications are widely deployed in CDCs, traffic volume is significantly increased, causing link congestion that degrades the network performance and user experience. For Energy Cloud (EC), detecting and scheduling elephants is also a network planning technique that can achieve energy efficiency while meeting the demand of network Quality of Service (QoS) [41], [59], [112]. Accordingly, it is significant for EC to efficiently detect and schedule elephants to balance work load, mitigate network congestion, and optimize energy usage.

Present EC may involve host-[31], [178], [186] and switch-based [32], [61], [164] approaches according to the location in which elephants are detected and scheduled. In general, such detection and scheduling relies on the network traffic collected from devices. To catch every elephant in the network, the system of each host and switch in the network needs to be customized, which is not efficient. Since hosts and switches detect and schedule elephants based on their local traffic, host- and switch-based approaches cannot apply advanced models and actions to respectively describe and manage elephants, leading to a difficulty in energy management and accommodation of network evolution. Software Defined EC that applies Software Defined Networking (SDN) [52], [138] to CDC can address this issue by enabling controller-based approaches.

Controller-based approaches refer to the approaches that use the controllers in the SDN control plane to collect network traffic first, then detect and schedule elephants in the second [3], [6], [27], [50], [157]. This type of approaches takes the advantage of SDN that has layered architecture consisting of separated control and data planes [52], [138], as shown in Fig. 1. While the data plane is composed of many simple switches that rely on the flow entries maintained by the control plane to forward flows, the control plane consists of controllers that generate flow entries and install them to the simple switches. Standardized interfaces enable the controllers to abstract the global network view that contains network statistics, topology, and management policies. Thus, SDN controllers can bring intelligence to various network applications (such as elephants detection and scheduling, and energy management) in a global manner by programming the behaviors of switches and flows.

The detection and scheduling of elephants have been a hot research topic for years. Some surveys have been proposed in present literature, but few of them surveyed the models that catch the characteristics of elephants [4], [21], [33], [58], [70], [78], [109], [143], [173]. Constructing a suitable model to describe elephants is crucial to achieve a high detection accuracy while maintaining an efficient energy management meeting the demand of QoS. Fixed models [37], [74], [98], [108], [124], [130] that have been widely used by previous proposed approaches typically cannot describe elephants under highly dynamical EC environment. Some novel applications such as virtual reality and augmented reality may generate a new type of elephants that are both bandwidth-hungry and latency-sensitive, generating new challenges for the existing approaches to model, detect, and schedule elephants. Moreover, many elephant models are based on flow-level features [30], [65], [93], [161] extracted from the whole packets of a flow, leading to a late detection and making the schedule of the subsequent packets of elephants for a better energy saving meaningless [14], [66], [68], [119], [121], [126], [135]. Previously proposed surveys typically categorize the related approaches according to the locations in which the detection and schedule are proceeded, but other factors such as the completeness of the traffic and the adaptability of the models used for elephants detection should also be discussed.


Download : Download high-res image (255KB)
Download : Download full-size image
Fig. 1. SDN architecture.

Therefore, this article surveys the related state-of-art techniques and makes the following three major contributions:

•
it reviews almost all the proposed models that describe elephants, and techniques and solutions that detect and schedule elephants over SDN systems. To the best of our knowledge, this article is the first effort that simultaneously covers these three related topics;

•
it presents not only the classical approaches for CDC networks, but also the latest developments that apply Machine Learning (ML) and optimization techniques for energy saving;

•
it categorizes the approaches from different angles and provides the open issues for the future research.

The rest of this article is organized as follows: Section 2 reviews the related surveys, Section 3 summarizes the background of SDN, and Section 4 briefly introduces the related ML algorithms. In Sections 5, 6, and 7, the approaches that model, detect, and schedule elephants are surveyed, respectively. The potential research challenges and directions are presented in Section 8 followed by the conclusions drawn in Section 9.

2. Related surveys
2.1. Achieving energy saving in CDCs
Energy consumption is one of the largest problems faced by CDCs. Gulati et al. [56] highlighted the technologies of Dynamic Voltage Frequency Scaling (DVFS), CPU utilization predictor, resource allocation, workload consolidation, and task scheduling achieving energy saving in CDCs. While Shirvani et al. [141] focused on summarizing the DVFS technology using virtual machine migration and server consolidation; Hameed et al. [59] surveyed the resource allocation techniques for CDCs to achieve energy efficiency; and Gar’ et al. [54] surveyed the approaches using ML based autoscaling techniques to optimize workload of CDCs.

Modeling, detecting, and scheduling elephants can be a type of approaches combining all the above technologies for energy saving, although they are mainly used for traffic classification in current CDCs. Callado et al. [21], Dainotti et al. [33], and Mehta and Shah [109] respectively reviewed the related techniques in 2009, 2012, and 2017. They focus on the host- and switch-based approaches, and the models catching the features of elephants are not their major concern. No efforts have been made on utilizing elephants for energy saving.

2.2. Over SDN enabled systems
A tremendous studies have been done on surveying SDN’s architecture [80], interfaces [92], QoS management [79], and resource allocation [35]. Regarding extending the existing related mechanisms over CDC networks to SDN enabled systems, Yan and Yuan [173] reviewed the major approaches for the classification of traffic over SDN systems, Akyildiz et al. [70] reviewed the major mechanisms applying to traffic engineering for both CDC and SDN systems, and Iacovazzi and Elovici [69] reviewed the major watermarking algorithms implemented for traffic analysis purposes. Although such approaches may not design for the detection and schedule of elephants, they can be used for that purpose. While Rawat et al. [131] surveyed some energy efficiency approaches over SDN systems, they concern the trade-off of energy saving and network security but not elephants.

For the detection and schedule of elephants over SDN systems, Wang and Su [163] summarized the major techniques, Hafeez et al. [58] further reviewed the approaches that reduced network congestion, Karakus and Durres [78] comprehensively surveyed the relative studies in providing end-to-end QoS over both CDC and SDN systems, and Akyildiz et al. [4] summarized the potential challenges. However, all these works made no efforts on surveying the techniques and approaches for modeling, detecting, and scheduling elephants simultaneously.

2.3. Applying ML techniques
ML mechanisms can be used to adjust the thresholds, parameters, or policy of the models that describe, detect, and schedule elephants to fit the quickly changed networking environment. While Boutaba et al. [19] reviewed the applications that applied the various ML techniques in multiple networking scenarios, Xie et al. [171] made a comprehensive survey on applying ML techniques to SDN system, and Zhao et al. [187] reviewed not only the major ML algorithms but also based on which the network applications classified over SDN systems. However, there is no survey that reviewed the ML techniques for the models, detection, and schedule of elephants simultaneously.

3. SDN architecture and components
3.1. SDN architecture
SDN is a layered networking architecture that was officially standardized by Open Networking Foundation (ONF) in 2012 [52]. Basically, SDN architecture [52] has two planes: the control and data planes, and three layers: the infrastructure layer, control layer, and application layer, as shown in Fig. 1. The infrastructure layer constructs the data plane, and the control and application layers form the control plane. The infrastructure layer consists of many simple switches that rely on the flow entries generated by the control plane to determine the behaviors of flows in a network. The control layer may consist of multiple controllers, which collect network run-time states to form a global network view. Based on the view, various network applications in the application layer can provide fine-grained network management and optimization by generating and updating the flow entries that program the behaviors of flows at switches.

As shown in Fig. 2, the simple switches in the data plane typically consist of two major components: the secure channel and flow table pipeline. The secure channel communicates with the control plane using standardized protocols such as OpenFlow [122], [127]. The flow table pipeline matches a flow to a flow entry in the flow tables. The pipeline may have multiple flow tables, each of which stores flow entries generated, installed, and updated by the control plane. A flow entry consists of rules, actions, and statistics. The rules contain multiple headers used for flow matching, the actions describe the behaviors that the packets of a flow should be conducted, the statistics contain the run-time data of this entry.


Download : Download high-res image (487KB)
Download : Download full-size image
Fig. 2. Flow setup and statistics collection in SDN.

3.2. Flow setup and statistics collection
In SDN enabled systems, the controllers in the control plane have two basic responsibilities: flow setup and statistics collection. The process of flow setup, as shown by labels 1 to 6 in Fig. 2, is for controllers to generate and install flow entries for every new flow going through switches. Statistics collection is more crucial for the detection and schedule of elephants. Since SDN switches can store statistics at flow entries, controllers can gather them using active and passive methods. Active methods allow controllers to repeatedly poll the statistics from all the switches in the network, as shown by labels 6 and 7 in the top right oval of Fig. 2, while passive methods let each switch automatically report its statistics to controllers. Active methods have been standardized but incur a significant overhead on both control and data planes. Passive methods can use switches or dedicated hosts to aggregate statistics retrieved from the switches such that the volume of statistics sent to the control plane can be significantly reduced without impacting the ability to monitor the network state. However, passive methods have not been standardized. Enabling passive methods over an SDN system may have to customize the design of current SDN switches or deploy dedicated servers, resulting in compatibility issues and the increased deployment costs [11].

4. Machine learning algorithms
ML algorithms basically can be classified into 4 categories: supervised, unsupervised, semi-supervised, and reinforcement learning, and they are briefly introduced in the rest of this section.

4.1. Supervised learning
Supervised learning uses labeled training data sets to build the system models representing the learned relation between the input and output. In the detection of elephants, the typical supervised learning algorithms used include K-Nearest Neighbor (K-NN), Decision Tree (DT), Artificial Neural Network (ANN), Random Forest (RF), Support Vector Machine (SVM), Byes’ Theorem (BT), and so on.

K-NN classifies data samples based on their k nearest neighbors [36]. Given a data sample, if most of its k nearest neighbors in the training set belong to a certain class, the sample will be classified into that class. The value of k refers to the noise putting on the classification. A larger k means a less affection is put. The distance between an unlabeled sample and its labeled neighbors can be estimated using distance functions [29].

DT performs classification through a learning tree, in which each node represents a feature of the data, all branches represent the conjunctions of features that lead to classifications, and each leaf node is a class label. The unlabeled sample can be classified by comparing the values of its feature with the nodes of the decision tree [136].

ANN is a computing system made up of a large number of simple processing units, which operate in parallel to learn experiential knowledge from historical data. It is inspired by the human brain and may consist of multiple layers. The first layer is the input layer and the last layer is the output layer. Layers between are hidden layers. By changing the number of hidden layers, the number and weight of nodes in each layer, and the activation functions, complex models can be trained to represent almost all the systems in the world [60].

RF is also known as random decision forest. It is an ensemble learning method that consists of multitude decision trees and randomly chooses a subset of the feature space to construct each individual decision tree to mitigate the over fitting of DT and improve accuracy [20].

SVM finds a separating hyperplane in the feature space to maximize the margin between different classes. The margin is the distance between the hyperplane and the closest data points of each class, and the closest data points are defined as support vectors [53].

BT uses a training data set to learn a probability model in which the conditional probability is calculated based on the probability of an event occurring given the prior knowledge of conditions that might be related to the event. In a classification problem, the evidence  is a data sample, the hypothesis  is the class to assign for the data sample, and the posterior probability  represents the probability of a data sample belonging to a class. Given a training data set, ,  and  are computed to construct the learning process of the probability model. When classifying a new input data sample, the learned model is used to calculate the multiple posterior probabilities for different classes, and the data sample will be classified into the class with the highest posterior probability [132].

4.2. Unsupervised learning
Unsupervised learning is based on a set of inputs without labels. it basically aims to find patterns, structures, or knowledge in unlabeled data by clustering sample data into different groups according to the similarity between them.

K-Means groups unlabeled data into K clusters given K. It firstly randomly chooses K nodes from the unlabeled data, each node is initialed as the centroid of a group, then starts a loop, in which a distance function is firstly used to attach each unlabeled node to the closest centroid, then a new centroid of each group is recalculated based to the current node membership. Finally, two centroids of each group are compared. The loop stops if they match; otherwise, the loop starts from the beginning [160].

4.3. Semi-supervised learning
Semi-supervised learning uses a few labeled data together with a large collection of unlabeled data. It balances the cost in gathering data and the accuracy in detection, since labeled data is expensive but leads to a higher classification accuracy, while unlabeled data is cheap but gives a relatively lower accuracy [149]. The general principle underlying semi-supervised learning is that the marginal distribution, which can be estimated from unlabeled data alone, may suggest a suitable way to adjust the target function. Such distribution can be made explicitly or implicitly [110].

Co-training and tri-training assume the marginal distribution explicit, while Laplacian SVM makes the distribution implicit. Co-training uses two kinds of independent completed feature sets to describe objects based on the multi-view. In the process of co-training, every classifier selects and marks several samples with higher degree of confidence from unlabeled samples, and then adds labeled samples to labeled training sets of another classifier, which helps another classifier update with these new labeled samples. The process of co-training iterates continuously, until meeting pre-conditions. Under ideal condition, co-training requires two independent views (two independent feature sets) of data and a data set can be classified using the views [17].

Tri-training uses partially labeled data sets and leverages three identical classifiers. However, there will be small differences between the three classifiers during the training. In some cases, this characteristic will make the tri-training mechanism degenerate to self-learning which will lead to error accumulation. Heteroid Tri-training is an advanced tri-training mechanism that increases the difference among classifiers, improves the robustness of the system, and enhances the perception ability of fine-grained differences [189].

Laplacian SVM assumes the marginal probability distribution underlying the data is supported on or near a low-dimensional manifold, and the target function should change smoothly along the tangent direction [110]. Laplacian SVM uses the graph Laplacian for an approximation of the underlying manifold such that high dimensional points can be located in a low dimensional manifold without having to retrain the classifier or resort to various heuristics [190].

4.4. Reinforcement learning
RL is developed from the theories of animal learning, stochastic approximation, and optimization control [152]. RL involves an agent, a state space and an action space. The agent is a learning entity that contacts with its environment to learn the best action to maximize its long-term reward. The long-term reward is a cumulative discounted reward that relates to both the immediate and future rewards. RL approaches often have disadvantages such as low convergence rate to solve problems with high-dimensional state space and action space. Deep RL (DRL) addresses them by leveraging the powerful function approximation property of deep ANNs to estimate the value function. After training the deep ANNs, the long-term reward can be estimated for each state–action pair given. The estimated long-term reward guides the agent to choose the best action. DRL improves the learning speed and performance of RL algorithms. Deep Q-Learning (DQL) produces a Q-table such that an agent can use to find the best action to achieve the largest long-term reward. Q is the function that returns the reward given an action in a state. However, producing and updating the Q-table may become ineffective when solving problems with a big state space. To address this issue, deep ANN is used to approximate the Q-values for each action at each state.

5. Modeling elephants
5.1. Features of flows
A flow is a sequence of packets with the same 5-tuple: source IP address, source port number, destination IP address, destination port number, IP protocol. The features of a flow can be caught at the flow- and packet-level, and hence elephants can be modeled at both flow- and packet-level, as listed in Table 1.

5.2. Flow-level
Flow-level features typically consist of the total packet count, byte count, mean packet size, mean inter-arrival time, and flow duration. Since elephants often refer to the flows with a big size and long duration, the features of packet count and byte count are often used to model elephants. However, flow duration is hardly used due to the various types of applications originating elephants, leading to a wide range in elephants’ life time. In practice, flow-level models can be further divided into size- and rate-based.

5.2.1. Size-based models
Flow size refers to the total packet count or byte count of a flow. Mazel et al. [108] and Pan et al. [124] used the packet count to define the size of a flow, while Lassoued and Barakat [91], and Li and Qian [98] used the total byte count. The size of an active flow in a network is updated as its packets are arriving. If elephants are modeled by sizes, a flow is marked as an elephant as long as its size hits a threshold. The threshold can be a fixed number, or changed depending on the traffic, or the top-K flows based on the traffic share. While Mazel et al. [108] and Pan et al. [124] fixed the threshold respectively as 6 and 1000 packets, Raspall et al. [130] and Dashti et al. [37] fixed the threshold respectively as 1% and 10% of the link bandwidth, Li and Qian [98] fixed the threshold as 13 Kbytes, and Kalllitsis et al. [74] kept sorting the total bytes of flows, selected the top-K flows as the elephants (K is given).


Table 1. Models of elephants.

Solutions	Category	Models
[37], [74], [98], [108], [124], [130]	Flow	Fixed sized, packet/byte count, bandwidth usage
[30], [65], [93], [161]	Flow	Fixed rated, packet/byte count, bandwidth usage
[14], [119], [126], [174]	Packet	Payload/packet size
[68], [121], [135]	Packet	Negotiation packets
5.2.2. Rate-based models
Rate-based methods model elephants using the packet or byte count of flows within a fixed interval. The intervals can be selected variously. Hong et al. [65] selected 1 s as the interval, Cruz et al. [30] and Lee et al. [93] selected 5 s, and Wallerich et al. [161] determined the interval should be 1 min.

For each interval, the threshold given to detect elephants also can be fixed, depended on the traffic, or top-K flows based on traffic share in the previous interval. Lee et al. [93] fixed the threshold as 100 KB in the previous interval; Cruz et al. [30] and Hong et al. [65] considered the 5% and 10% of total traffic in the previous interval, respectively; and Wallerich et al. [161] sorted the total rates of flows within the previous interval, picking the top-K flows as the elephants (K is given).

5.3. Packet-level
Packet-level models use the features extracted from the packets in the early stage of flows. We further categorize these models into size-based and negotiation phase models.

5.3.1. Size-based models
Size-based models also use the features of flows such as packet count or byte count but extract them from the very limited number of packets in the early stage. Peng et al. [126] conducted extensive experiments and shown that traffic identification could be done within 5–7 packets using the application layer payload size of a packet. Bernaille et al. [14] presented a famous early stage traffic identification technique, in which the size of the first few data packets of each TCP flow were used to model elephants. Este et al. [119] analyzed round trip time, packet size, inter-arrival time and packet direction of early stage packets and found that the packet size was the most effective feature for early stage elephants detection.

5.3.2. Negotiation phase models
The negotiation phase of applications consists of the first few packets originated by the applications. Since such packets describe the features of applications, extracting features from them analyzes the negotiation behaviors of different applications, and using such features to model and detect elephants based on ML-based classifiers can achieve high detection performance [66]. Hullár et al. [68] modeled elephants from P2P traffic using the early stage packets in the negotiation process. Nguyen et al. [121] used statistical features derived from predefined sub-flows and timely identification of VoIP traffic which is also a type of elephants. Rizzi et al. [135] proposed a highly efficient neuro-fuzzy system for early stage elephants modeling and identification.

5.4. Summary
Elephants carry most of the traffic in the network and have a long duration. However, how much traffic elephants should carry in how long a time duration has yet to be determined. The models based on flow-level features can achieve a high detection accuracy, but often cannot determine elephants in their early stage, leading to an ineffective flow scheduling and energy saving. The models based on packet-level features may determine elephants in their early stage, however, the type of applications that originate elephants needs to be given and the detection accuracy is a big concern. The threshold of these models can be fixed or adaptive, but no general guideline has been proposed for choosing the right threshold in various scenarios. Since rate-based models use an interval as the time scale while size-based models use the whole life duration of a flow, rate-based models are supposed to identify elephants more quickly than size-based ones, but more work needs to be done in the future research. Heavy hitters are the big flows regardless of the flow duration. They may represent malicious traffic and must consequently be dropped [45], [90]. Differentiating elephants from heavy hitters is significant, since some attacking originating from multiple machines may slower down the packet sending rates to mimic P2P flows, such flows should not classified as elephants to have the priority in flow scheduling and routing.

6. Detecting elephants
The detection of elephants in CDC networks is typically categorized into host- and switch-based, according to the place in which the detection is done. As SDN has a centralized control plane separated from the data plane, the controllers in the control plane have the capability to enable a new type of detection approaches, the controller-based approaches that do the detection at controllers. However, elephants are detected based on the network traffic collected, and gathering the traffic adds extra overhead on networks. Since many extra mechanisms such as traffic sampling, traffic grouping, and ML techniques can apply to reduce such overhead, simply using the location where the jobs are done to categorize the detection approaches does not present the state of arts. Accordingly, the rest of this section categorizes the detection methods from the location where the jobs are done, the completeness of the gathered statistics, and the flexibility of the detection, as listed in Table 2.


Table 2. Detection solutions in SDN enabled systems.

Solutions	Location	Statistics	Static/dynamic
[31], [178], [186]	Host	Local & completed	Static
[2], [45]	Host	Local	Static
[32], [61], [107], [128], [129], [144], [146], [164]	Switch	Local & completed	Static
[102]	Switch	Local & completed	Global & sampled
[1], [86], [96], [151], [167]	Switch	Local & sampled	Static
[116]	Switch	Local & sampled	Dynamic
[2], [16], [71], [73], [114]	Two-level	Local/global & completed	Static
[67]	Two-level	Local/global & completed	dynamic
[3], [6], [27], [157]	Controller	Global & completed	Static
[15], [24], [26], [28], [34], [39], [44], [46], [47], [61], [62], [64], [84], [94], [97], [99], [104], [115], [125], [145], [150], [155], [158], [159], [162], [166], [168], [170], [174], [176], [177], [180], [181], [188]	Controller	Global & sampled	Dynamic
6.1. Locations
6.1.1. Host-based detection
Host-based approaches typically update the operating system of hosts to generate flow statistics and features and determine elephants based on the predefined models. Mahout [31] is a representative of such type of approaches. In Mahout, elephants were modeled by the byte count and a predefined threshold. Mahout counted the total bytes of flows using a shim layer inserted to the existing operating system. Similar to Mahout, MicroTE [178] collected the statistics of the entire network and detected elephants by designating the monitoring end-hosts in the top of rank switches. FlowWatcher [186] was also a host-based solution. However, it sent controllers a probe packet to indicate the coming of an elephant once the elephant had been determined, and let controllers timely distinguish the packets of the elephant and update its corresponding count, instead of using the shim layer to tag the subsequent packets of the elephant by updating the Differentiated Services Field (DS Field) of the IPv4 header in Mahout. FlowWatcher took the advantage of SDN in which controllers could program the behavior of flows dynamically, while Mahout and MicroTE did not.

Since host-based approaches are based on the hosts’ local traffic, they often use static and simple models such as the fixed threshold, and require to modify hosts, which is not practical for many CDCs.

6.1.2. Switch-based detection
Switch-based solutions do all the jobs at switches. They are based on the mechanism that SDN switches can tag network statistics to flow entries. Since each flow entry contains the latest flow statistics, switches can apply elephant models to identify elephants based on these statistics. After an elephant is determined, the switch can directly control the elephant’s forwarding by modifying the elephant’s packets, or place triggers on the flow entry to notify controllers. Switch-based approaches may need to customize the specification of switches, which is not practical for many data centers.

DevoFlow [32] is a representative of the switch-based detection. It updated the current OpenFlow protocol such that triggers could be held in flow entries to notify controllers for the identification of elephants. EffiVier [164] applied the similar triggers as DevoFlow but with lower cost. While Madanapalli et al. [107] proposed to detect elephants at switches in a real time manner, Haye et al. [61] proposed an auxiliary engine (DPAE) that was installed at switches to collect statistics and detect elephants. Although all these approaches rely on the fixed threshold to activate triggers on flow entries, Liu et al. [102] placed triggers on switches and combined weighted optimization based Gaussian distribution and smooth mechanism based on difference estimation to adjust the threshold in a dynamical manner.

Switch-based approaches can lead to a heavy burden on switches, and need special hardware support. FlowRadar [96] inserted a statistics sampler to the switches to maintain the statistics in a low cost and no modification needed to be made at switches. Planck [129] mirrored the outgoing packets from each port to the pre-specified monitoring port, at which the outgoing packets were sent to the controller. Programmable switches [18], [147] can greatly mitigate the limitation of placing triggers on flow entries by programming the switch pipelines. While HashPipe [146] and Hierarchical Heavy Hitter Detection [128] identified heavy hitters entirely at switches, IDEAFIX [144] identified elephants in IXP networks with a 95% detection accuracy in scenarios with scarce memory resources.

6.1.3. Controller-based detection
Controller-based detection uses controllers to collect flow statistics, extract traffic features, and detect elephants. It reduces the overhead of switches and does not need to customize switches and southbound interfaces. Controller-based detection is unique for SDN systems. Hedera [3] is a representative of such detection. It polled flow statistics from each of its edge-switches and used a small polling period for a high detection accuracy but incurred a huge overhead on the controllers and the control channel between controllers and switches. Helios [50] implemented the similar approach. However, too much polling statistics from switches leads to high traffic cost even potential network congestion between data and control planes. Therefore, PayLess [27] proposed an adaptive polling approach that adjusts its polling frequency as the network traffic varies. OpenTM [157] chose the optimal set of target switches, from which the statistics were polled to reduce the bandwidth usage by transferring the flow statistics. Flights [6] was a fast and lightweight elephant flow detection mechanism, which leveraged the TCP communication behavior.

6.1.4. Two-level detection
Two-level detection approaches balance the overhead on both controllers and switches/hosts while maintaining high detection accuracy. Such approaches often separate the detection into two phases: marking the candidates of elephants at switches or hosts and determining the elephants from the candidates at controllers. The former phase often uses the fixed threshold-based model to quickly locate the candidates, such that in the latter phase the controllers only need to poll the full statistics of the candidates to apply advanced model to accurately locate elephants.

Bi et al. [16] and Afak et al. [2] proposed two-level approaches, in which the flow statistics were quickly sampled to group the suspect elephants at switches firstly, then the completed statistics of the suspect flows were collected by controllers and the real elephants were determined secondly. J. Yan et al. [73] proposed a two-level approach, in which the suspect elephants were located by hosts based on the monitoring of the TCP queues in the first level, and the real elephants were identified by comparing the life time of the flows with the given threshold at controllers in the second level. Jang et al. [71] proposed RFlow that provided two-level (at switches and controllers) detection for wide area networks. Moore and Papagiannaki [114] proposed to classify the candidates at switches using port-based classification in the first level, and let the real elephants extracted from the candidates at controllers using payload-based classification in the second level. Huang et al. [67] proposed a two-level approach that applied port-based mechanism at switch-side while implementing ML-based at controller-side.

6.2. Statistics
The rest of this subsection categorizes the approaches according to the statistics used for the detection completed or not.

6.2.1. Completed-flow-statistics-based
Completed flow statistics lead to a high accuracy due to the removed detection error generated by the inaccuracy in the statistics. Host-based solutions can gather completed local statistics data set since network traffic is often originated by hosts. Switch-based solutions over SDN enabled system also can maintain completed local statistics data sets at switches, in which each flow entry updates its counters as it is matched to forward packets. SDN systems also support controllers to poll the statistics from all the switches in the network to generate global network view. Since the statistics counted by flow entries in the switches are completed, so are the statistics data set maintained by controllers. In fact, most of the detection solutions proposed in current literature are based on completed statistics data set. For instance, Mahout, DeveFlow, and Hedara maintained a complete statistics at hosts, switches, and controllers, respectively. However, hosts and switches can only gather their local statistics. Therefore, host- and switch-based approaches are often based on completed but local traffic statistics, while controller-based approaches can have completed and global traffic statistics due to the statistics gathered from all the switches in the network.

6.2.2. Uncompleted-flow-statistics-based
Collecting completed flow statistics may consume huge computation and bandwidth resources no matter which type of network devices is used. In many cases, such consumption may not be affordable. Therefore, the detection may be done based on uncompleted statistics data set. Packet sampling can generate uncompleted statistics. It reduces the bandwidth consumption and removes the limitation on network infrastructure.

NetFlow [120] and sFlow [139] are techniques for packet sampling. They typically provide agents that should be installed in switches. Such an agent in a switch captures one out of every k packets on each input port, then forwards the sampled packet’s header encapsulated with metadata to a collector immediately. The collector can be a host, the switch itself, or an SDN controller. The collector determines elephants based on the model. Since the packets sent to the collector are sampled, the statistics maintained by the collector are uncompleted. Detecting elephants based on such uncompleted statistics provides fine-grained network measurements without requiring per-flow statistics.

Present research has proposed some schemes based on NetFlow and sFlow, and they have shown a good balance between detection overheads and implementation difficulty. While Shirali-Shahreza and Ganjali [140], and Cao and Kodialam [22] classified host traffic based on statistics collected by NetFlow, Estan et al. [45], Afek et al. [2], and Suh ed al.[151] directly installed sFlow agents in switches to generate statistics based on sampled packets of flows. Mori et al. [116] applied Bayes’ theorem to find the threshold of packets sampled by sFlow. However, it could not reliably detect elephants before a flow had carried more than 10 K packets, or roughly 15 MB. To find elephants efficiently, Afaq and Song [1] used sFlow-RT to collect and analyze flow statistics in a real-time manner. While Knob et al. [86] applied sFlow to gather flow statistics for the detection of elephants over SDN-based IPX networks, Wang et al. [167] optimized the sampling rate by limiting the probability of missing elephants.

6.3. Static or dynamic
The rest of this subsection classifies the detection based on its capability in adapting to dynamic networking environment.

6.3.1. Port-based
Port-based approaches classify elephants by locating the ports of applications that originate the elephants [51], [113], since elephants are often generated by certain types of applications. Such approaches are typically static. As more types of applications, such as P2P, that generate elephants use dynamic port numbers to avoid being detected [10], port-based approaches face a big challenge to accurately classify network traffic [76], [137]. Current research has shown that the port-based methods achieve less than 70% classification accuracy by using well-known port list and 30%–70% of traffic flows cannot be classified [114].

6.3.2. Payload-based
Payload-based approaches are also known as content-based classification or Deep Packet Inspection(DPI). They classify traffic by inspecting packet payloads and compare with the known signatures of protocols. Since it is hard or impossible to update signatures in quickly evolved networking environment, payload-based approaches are often static. Payload-based approaches can overcome the limitation of port-based methods, but cannot deal with encrypted or proprietary protocols. Also, extracting signatures from flows is labor-intensive and time-consuming [114].

Moore et al. [114] summarized 9 distinct identification methods commonly used by payload-based classification. As listed in Table 3, method 1 detects flows based on their port number and only requires to access to the part of the packet header that contains the port numbers. Method 2 requires to access to the entire packet header for both directions. Methods 3 to 8 examine if a flow carries a well-known signature or follows well-known protocol semantics. Such methods often lead to a higher complexity and may require to access to multiple packets’ payloads. If flows cannot be classified using methods 1 to 6, they may require an inspection of their entire flow payload. In this case, method 7 may be performed to analyze a subset of the flows and method 8 may be applied to analyze all the packets of the flows based on some well-known port numbers. Method 9 checks the whole history of a host to determine the traffic of those application based on port-scanning. Payload-based approaches can perform traffic classification accurately, but lead to significant complexity and high computation cost [173]. Table 3 also summarized the amount of data that each method may access to and the approaches’ complexity.


Table 3. Classification methods.

No.	Methods	Data amount	Insp.	Compl.
1	Port-based only	Packet	Port	Low
2	Packet header (1 included)	Packet	Port	Low
3	Single packet signature	Packet	Signature	Medium
4	Single packet protocol	Packet	Protocol	High
5	Signature on the first KB	First KByte	Signature	Medium
6	First KB protocol	First KByte	Protocol	High
7	Selected flow(s) protocol	Selected flow(s)	Protocol	High
8	(all) flow protocol	(all) flows	Protocol	High
9	Host history	Host history	all	Very high

Table 4. Major scheduling solutions for elephants in SDN enabled systems.

Solutions	Cat.	Description
[31], [89]	host-based	Modify IP headers or split TCP connection
[111], [169]	switch-based	Rate limited queues or time division algorithm
IS-IS/SPF/[55]	controller-based	SPF for all flows in the network
[3], [93], [151]	controller-based	Elephants (ECMP), others (GFF)
[55], [154], [167]	controller-based	Rerouting scheduling for congestion reduction
[38], [48], [57], [75], [87], [95], [103], [133], [148], [156], [165], [179], [182]	controller-based	Rerouting scheduling for congestion reduction
[101], [175], [179], [183]	controller-based	Rerouting scheduling for latency reduction
[7], [81], [100]	controller-based	Rerouting scheduling for energy saving
Based on these requirements, Karagiannis et al. [77], and Moore et al. [114] proposed multi-level classification approaches, in which each identification method mentioned above was applied in turn and in such a way the more-complex or more-data-demanding methods were used only if no lower-level method could generate a match. These approaches achieved a near 100% accuracy. Payload-based approach can effectively detect the elephants generated by the Internet Chat [40], Youtube Streaming [72], P2P [76], [137], and scientific computing applications [172].

6.3.3. Machine learning-based
Since port- and payload-based approaches cannot effectively detect elephants under dynamic and encrypted circumstance, ML-based approaches are applied [134]. As shown in Fig. 3, applying ML-based approaches usually includes two main phases: training and decision making phases. In elephant flow detection, the training phase is to generate elephants models using the training flows, and the decision making phase is to apply the models to detect elephants from the new flows. According to the training set labeled or not, ML-based approaches can be categorized to supervised, unsupervised, semi-supervised, and RL. ML-based approaches are dynamic since the models used can be dynamically adjusted to meet the requirements of quickly changed networking environment.

6.3.3.1. Supervised learning.
Supervised learning uses labeled training data sets, and many related algorithms have been widely applied to classify traffic and detect elephants. Kim et al. [84] used K-NN to classify the flows of seven traces, and found that the accuracy obtained by K=1 was the highest. The similar K-NN approaches were applied by Stober et al. [150] to generate features of traffics based on a labeled data set.


Download : Download high-res image (303KB)
Download : Download full-size image
Fig. 3. Machine learning based elephant flow detection.

DT is also a supervised learning algorithm that has been widely used in detecting elephants for CDC networks [154] and SDN systems [28], [94], [125], [145], [158], [170], [177]. While Comaneci and Dobre [28], Xiao et al. [170], and Pasca S et al. [125] applied DT algorithms to classify elephants based on flow-level features over SDN systems, many more efforts have been made on using DT algorithms to identify elephants based on packet-level features [94], [145], [158], [177] in flows’ early stage.

While Refs. [24], [104], [159], [168] applied ANN to classify traffic, reference [15] studied the features of real traffic traces from Facebook data center networks. It applied FARIMA-RNN model, a combination of FARIMA and RNN to detect elephants. Wang et al. [166] applied RF to generate features of applications based on the training data set, Taylor et al. [155] proposed Appscanner that applied RF algorithms to automatically generate fingerprints of smartphone applications from encrypted network traffic.

While Este et al. [46] and Yuan et al. [181] applied SVM to classify the Internet traffic, Stober et al. [150] applied SVM to classify 3G traffic, and Hayes et al. [61] applied SVM to classify elephants for SDN system. Since SVM approaches often add a huge overhead on the control plane that often consists of only one controller, Quoc et al. [34] proposed a distributed SVM mechanism for classifying network traffic and used MapReduce for training to improve the controller’s scalability, though the convergence of multiple SVM algorithms is still a challenge [5].

Moore and Zuev in [115] applied a naive BT to classify network traffic based on flows’ statistical features, Herrmann et al. [64] used a multi-Naive-BT classifier to find the fingerprints of different websites. All these approaches are designed for classification traffic and can be directly applied to detect elephants.

6.3.3.2. Unsupervised learning.
Unsupervised learning is a type of methods that are given a set of inputs without labels. Unsupervised learning methods basically aim to find patterns, structures, or knowledge in unlabeled data by clustering sample data into different groups according to the similarity between them. K-Means is an unsupervised learning algorithm that has been widely used to classify application traffic and detect elephants. While Erman et al. [44] applied K-Means to group network traffic for Web and Peer-to-peer traffic in CDC networks, K-Means is widely used to solve the controller placement problems [83], [88], [191], address security issues [12], [25], [28], and classify network traffic [47], [99] over SDN systems. Specifically, Lin et al. [99] applied K-Means to find the features of flows, Fan et al. [47] combined DT and K-Means to achieve a higher accuracy and shorter convergence time in elephants detection, and Chhabra et al. [26], [85] applied soft K-Means to group flows generated by scientific computing applications.

6.3.3.3. Semi-supervised learning.
Semi-supervised learning uses both labeled and unlabeled training set, combines the benefits of both supervised or unsupervised learning, and has been used in traffic classifying over SDN enabled systems. While Li et al. [97] proposed co-training algorithms to identify and classify applications, Yan et al. [174] used co-training algorithms to construct a robust inter-packet time feature for online traffic classification, and He et al. [62] applied co-training algorithms to extract statistical characteristics of IP flows from the packet level traces to establish the feature set for the traffic classification. Zhao et al. [188] proposed a tri-training method to precisely detect unknown applications and extend labeled flows from a few labeled. Yu et al. [180] proposed a heteroid tri-training mechanism to train a classifier with partially labeled data sets generated by applying DPI. The classifier could sort flows into corresponding QoS categories, the DPI signature was updated after a certain time, and the training data set used was dynamic. Wang et al. [162] applied Laplacian SVM to accurately classify traffic over real Internet data. The QoS parameters might be used to effectively reroute elephant flows to meet the resource utilization goals.

6.3.3.4. Reinforcement learning.
When applying RL to SDN, the controller generally works as an agent and the network is the environment. The controller monitors the network status and learns to make decisions to control data forwarding. Over SDN systems, RL-based approaches are usually used for promoting resilience and scalability [185]-[118]. While Luong et al. [105] and He et al. [63] surveyed the applications that applied deep RL in various networking scenarios, Deng et al. [39] applied deep QL to sample statistics from edge devices in mobile edge computing over SDN enabled systems. An RL-based sampling strategy considering the iterative influences of nodes was used to maximize the long-term sampling accuracy for both mice and elephants. Yao et al. [176] applied deep RL to effectively solve real-time large scale network control problems without too much manual process and any assumptions of underlying network, where the deep RL agent could produce a near-optimal decision in real time.

However, RL only characterizes the interaction procedures instead of providing a learning method, and each learning algorithm can be transformed into a RL [134]. Although RL-based approaches have not seen directly used in detection of elephants in present literature, they should be able to apply to adjust the parameters of the models to fit the highly dynamic networking environment.

7. Scheduling
To optimize the network performance and energy usage, elephants should be efficiently scheduled after they are modeled and detected. In recent years, researchers have proposed many scheduling methods for SDN systems. As elephants can be detected at hosts, switches, and controllers, they also can be scheduled at hosts, switches, and controllers, respectively. Fig. 4 presents the major scheduling approaches used in SDN enabled systems, and we introduce each of them in the rest of this section. Table 4 lists some solutions related to each scheduling approach.

7.1. Host-based
Host-based scheduling approaches directly apply scheduling policies for the detected elephants at hosts. Mahout [31] identified elephants first, then modified the DS Field of the IP header of each packet of the elephants to ensure an routing priority for them in SDN systems. Kukreja et al. [89] allowed a single Transmission Control Protocol (TCP) connection to be split across multiple paths using multi-path TCP (an extension to TCP protocol) to reduce the congestion of SDN systems. However, the routing policy applied by these approaches is typically very simple, since hosts only enforce scheduling policy based on their local traffic.

7.2. Switch-based
Switch-based scheduling approaches directly schedule the elephants after they are detected by switches without involving controllers. Typically, every new flow in SDN systems has to involve controllers to generate its flow entry. However, switches often detect elephants after a sufficient number of packets of flows are arrived, meaning that a certain number of packets of that flow has been arrived when a flow is identified as an elephant. It suggests that switches have a matched flow entry for a detected elephant and can schedule the elephant without the aid of the controllers. However, to optimize the routing of detected elephants, switches may ask the controllers to generate new flow entries, or make use of the mechanisms provided by switches without bothering the controllers. Such approaches are respectively referred as the controller- and switch-based approaches in this article.

Switch-based scheduling approaches often leverage the en-queue action of SDN switches to apply traffic shaping to elephants in order to achieve QoS in terms of bandwidth without involving hosts and controllers. For instance, Afaq et al. [169] set rate limited queues to the ports of an SDN switch to handle elephants, Mizrahi and Moses [111] proposed to time-stamp packets at switches such that time division based mechanisms can be applied to balance packets. Although the proposed approach has not been prototyped, it should be implemented at switches to schedule elephants. Since switches do not provide advanced mechanisms to optimize the path of flows for the better usage of network resources, the benefits brought by switch-based scheduling approaches are limited.

7.3. Controller-based
As SDN systems provide a centralized control plane that has the ability to abstract the global network view and based on the view to program the behaviors of flows in the network, controllers in the control plane can schedule the identified elephants for the optimization of network resources. In the rest of this subsection, we introduce the Shortest Path First (SPF), Global First Fit (GFF), Equal Cost Multi-path (ECMP), and the rerouting methods.

7.3.1. SPF
SPF algorithm finds the shortest path between that node and every other in a network. It also can be used to find the shortest paths between a single source node to a single destination node by stopping the algorithm once the shortest path to the destination node has been determined. The notable Intermediate System to Intermediate System (IS-IS) [123] and Open Shortest Path First (OSPF) [117] apply SPF algorithms and they have been widely used in both conventional and SDN CDCs. Without any particular requirement, SDN controllers can apply SPF to find the shortest path for the flows in the network [55].

7.3.2. GFF
GFF firstly linearly searches all the possible paths to find one whose link components can all accommodate a new flow, then places the flow on it. To discover the possible paths,systems require to sort out both small and big links according to the reserved capacity. Every new flow will be matched from the smallest link until the reserved capacity meets the flow’s requirement. In this way GFF significantly reduces the computational complexity, saves operator time and improves the link utilization. Hedera [3] applied GFF for each identified elephant flow. However, GFF becomes difficult as the increase of network load. Links become saturated, especially when the updating of reserved capacity sorting cannot catch up with the real-time changed link capacity. OpenSample [151] also suffered the same problem due to applying GFF to the identified elephants.

7.3.3. ECMP
ECMP identifies a flow by hashing the header fields of the flow and uniformly distributes the flow across available multi paths. It can achieve the multi-path load balancing and link backup under equivalent circumstances. It not only increases the transmission bandwidth, but also can back up the data transmission of failed link without delay and packet loss. ECMP overcomes the limitation of GFF, and can be supported by static routing and OSPF protocols. ECMP can be used to schedule elephants.

Hedera [3] applied ECMP to the identified elephants while keeping GFF for mice. Hedera offered improvements in flow scheduling even with large number of hosts, while not requiring any modification at end hosts. However, the benefits of ECMP come at the cost of modest communication overhead. Besides, the bandwidth, delay, and reliability of different paths are considered to have the same cost, and therefore, the resources especially the great difference between paths may be wasted. Moreover, ECMP is a static scheduling method that neither considers the flow type nor the network static. Hash collisions are also possible resulting in scheduling of two elephants on the same out going link by the switch while there are other under-utilized paths still available. To avoid scheduling two elephants to the same path, some researchers split elephants into mice and applied ECMP to the split elephants [93]. However, frequently splitting elephants may disorder the destination hosts to receive packets correctly and lead to a high packet-loss rate.

7.3.4. Rerouting
Rerouting is not an algorithm but a policy that uses the existing routing algorithms to dynamically recompute the route of a flow given an objective. Rerouting elephants shows SDN systems have the ability to program the behavior of flows for the optimization of network management and resource usage. In the rest of this subsection, we categorize the previously proposed rerouting approaches according to their optimization objectives.

7.3.4.1. Reduce load imbalance and link congestion.
This type of approaches typically require to gather the network statistics first, then detect elephants and compute the usage of link and/or switches before applying rerouting algorithms to adjust the routes for the identified elephants, as elephants often have large size and long duration and are the major factor that causes link load imbalance and congestion.

ECMP reduces the load imbalance and link congestion, but it is static and does not really change the routing policy for any flows. Gholami et al. [55] and Song et al. [148] used controllers to identify congested links firstly based on the collected statistics from switches, and then performed the SPF algorithm to find the current shortest path to reroute the new flows (both elephants and mice) from the congested links. The congested links are the links with the transmitted bytes 70% higher than their capacity. Liu et al. [103] proposed to collect the resource usage at switches, links, and controllers to analyze the network status. They applied Parametric Minimum Cross Entropy (PMCE) algorithm to schedule the detected elephants through multiple paths, but leverage ECMP for mice. This approach not only reduced the load imbalance and link congestion, but also improved the control plane scalability. Knob et al. [87] computed the best alternative shortest path using IDEFIX [86] to reroute every detected elephant over SDN-based IPX networks. Wang et al. [165] dynamically partitioned the available paths into high throughout (HTP) and low latency paths (LLP), and scheduled the elephants and mice in HTPs and LLPs, respectively, to limit the conflicts. Wang et al. [167] implemented an Ant COlony (ACO) algorithm to calculate the K edge-disjoint paths (given K) for an identified elephant, such that the elephant can be split into these paths to reduce the impact on networks. Toosi and Buyya [156] proposed Acinonyx that applied Breadth First Search (BFS) to find the shortest paths to better use the link bandwidth for virtual machine migration traffic, which is a type of elephants. Tang et al. [154] identified that the coexistence of elephants and mice in CDCs poses challenges to efficient traffic scheduling, and proposed DiffSch that applied a graph match based method to assign each elephant to the path with closest distance to its bandwidth demand, while computing the least congested path based on the network information collected by SDN controllers for mice.

While all the above mentioned approaches are similar in limiting the traffic rate at the source or rescheduling the entire traffic through the available multi-paths starting from the source, Kanagevlu and Aung [75] proposed an local rerouting approach that locally re-forwarded (at the point of congestion) to other available paths based on their flow classification scheme for the elephants to effectively manage network congestion. Although Zang et al. [182] selectively rerouted some elephants via a source routing, Guo et al. [57] involved an ultra fast online timeslot allocator (TSA) to quickly allocate time slots of switches to elephants for faster scheduling.

Finding the best path to reroute elephants also can be formulated to an optimization problem that applies ML techniques and has various objectives. Ren et al. [133] formulated the scheduling task as an NP-hard problem that optimized the link utilization ratio and solved it using a chaos Genetic Algorithm (GA). The solution of the problem is a route that assigned traffic (a flow or a packet) should be forwarded along. Li et al. [95] implemented an optimal and dynamic elephant flow scheduling using GA and ACO algorithm under SDN architecture. Pellegrini et al. [38] proposed SOFIA to perform optimal online elephant flow segmentation based on stochastic approximation techniques. SOFIA was implemented at the switch level but updated by the controller with minimal signaling over the control channel. Fang et al. [48] designed a routing algorithm based on Q-learning to quickly schedule flows. Yu et al. [179] proposed DROM that applied RL techniques to reroute elephants. DROM used NN instead of Q-tables to reduce the storage overhead and time cost in looking up the large-scale Q table. DROM can be widely used since it does not rely on any specific network states and can effectively achieve black-box optimization in continuous time. However, DROM and any other ML-based rerouting approach have to balance the accuracy and efficiency such that the good quality routes can be found in a short time period to catch up the fast changed network flows.

7.3.4.2. Reducing network latency.
Properly compiling and installing paths for both mice and elephants dynamically can reduce the network delay. Yan et al. [175] proposed the HiQoS that identified multiple paths between source and destination nodes using queuing mechanisms to guarantee QoS for different types of traffic. Although HiQoS did not explicitly differentiate elephant and mice, it could reduce delays and increase throughput. Liu et al. [101] proposed a mix-flow scheduling scheme based on deep RL. This scheme established three private link sets for three types of flows. Deep RL was employed to adaptively and intelligently allocate bandwidth for each type of flows according to the traffic variations across time and space. A novel metric was designed as a function of deep RL’s reward to guide the process of simultaneously maximizing the deadline meet rate for mice and minimizing the flow completion time for elephants. DROM [179] considered both delay minimization and throughput maximization as the operation and maintenance strategy. It provided good convergence and effectiveness, and improved network performance with stable and superior routing services. Zaw and Maw [183] presented a traffic rerouting solution to reduce the delay of elephants by rerouting the elephants to the least delay path among available paths.

7.3.4.3. Reducing energy usage.
Link rate adaptive and sleep mode are two major methods to reduce energy consumption in CDCs [143]. While the former dynamically adjusts link rates according to traffic demand [23], the latter powers off some network components, or translates some non-working components into sleep mode to save energy. Ke et al. [81] proposed the Iterative Parallel Clustering Algorithm (IPGA) based on priority scheduling to save energy over SDN systems. Priority scheduling finds the flows having the highest QoS attributes and using minimum switches. Those flows are transmitted preferentially such that more additional switches can be shut down to reduce power consumption. However, it did not differentiate elephants and mice. Lin et al. [100] proposed to aggregate mice flows into a minimal set of links but reroute elephants in time. The unused switches/links could be put into the sleep mode for energy saving. All these approaches reroute every flow in the network, and they have shortcomings related to the large number of routing rules that the switches must handle, leading to extensive delays to mice flows that are typically latency-sensitive. To overcome the shortcomings, Amezwuita-Suarex et al. [7] proposed MiceDCER that efficiently routed mice flows aiming at reducing the number of routing rules at switches based on the information carried by the Address Resolution Protocol packets.

8. Research challenges and future directions
8.1. Challenges related to models
Elephants have not been defined exactly yet. Models based on fixed thresholds may only work under particular circumstance. Models picking the largest K flows as the elephants seem more general, but the determination of K is difficult. Constructing a general model to describe elephants under fast involved networking environment is very challenging. Applying ML techniques may address this challenge by keeping adjusting the models based on continuously updated training data sets.

8.2. Challenges related to detection
SDN systems can detect elephants at controllers based on the statistics collected from switches. However, the volume of the statistics increases as the network scale grows. Balancing the overhead and detection accuracy becomes very challenging in large-scaled SDN systems. Completed statistics can achieve higher detection accuracy, but potentially degrade network performance and user experience due to the significant overhead added on the network. Two-level detection may address this issue if an efficient communication mechanisms between controllers and switches are enabled. However, current southbound interfaces have no dedicated and efficient mechanism for statistics collection. Exploring the capability of programmable pipelines can be a way to enable efficient two-level detection approaches.

Detecting elephants in their early stage is very challenging. Previously proposed models using packet-level features typically assume the elephants are generated by a certain type of applications. However, determining the types of applications in a highly changed network is very difficult. Applying ML techniques may address this challenge by keeping learning the new types of elephants, but more efforts need to put on the establishment of high quality data sets for the train of the models [82]. Detecting elephants can help CDCs with SDN and Network Function Virtualization (NFV) capabilities to efficiently migrate states [184], offload network functions [43], and toward traffic aware placement of independent middle boxes [106]. NFV implements network functions (also called middle boxes) in virtual machines running on industry standard servers instead of proprietary hardware appliances. SDN CDCs with NFV capability achieve more flexible, programmable, and intelligent networking environments.

8.3. Challenges related to scheduling and energy saving
As networks scale up, it is difficult for a single controller to quickly manage the flows and frequently collect the statistics simultaneously over the entire network [41]. In this case a distributed control plane with multiple controllers is often involved. It is a challenge to develop scheduling algorithm that can take advantage of such distributed control plane, meanwhile finding the routes of elephants globally and fulfilling the predefined targets [8]. Carefully routing flows can achieve energy efficiency but need to meet the demand of QoS. Solving multi-objective optimization problems is challenging to achieve energy saving. Applying RL in scheduling can solve decision making problems automatically achieving energy saving. However, it is challenging to learn policies in parallel to explore deeply and quickly. Resource allocation mechanisms for energy saving [153], virtual machine allocation [42], and computing-plus-communication optimization [142] may be applied to maximize the energy efficiency.

9. Conclusions
This article surveys the mechanisms and solutions for modeling, detecting, and scheduling elephants in SDN enabled CDCs. It emphasizes the importance of elephant models and ML-based techniques in achieving general, adaptable, and efficient detection in new and dynamic networking scenarios. Besides using location to classify the detection of elephants, this article also categorizes the detection according to the completeness of the statistics and the flexibility of the approaches. It highlights the two-level approaches that use both controllers and switches/hosts to balance the detection overhead and accuracy, raises the issue that sampling statistics may cause detection inaccuracy and should be addressed by extra mechanisms, and emphasizes the importance of applying ML-based technologies in improving detection flexibility and robustness. While some elephant scheduling approaches optimize the network latency and energy consumption, many more target the reduction of load imbalance and link congestion. RL-based rerouting are widely used in elephants scheduling. For the future research, this article highlights the challenges in generally, efficiently, and intelligently modeling, detecting, and scheduling elephants under fast involved and large-scaled networking environment.

CRediT authorship contribution statement
Ling Xia Liao: Data curation, Formal analysis, Methodology, Writing - original draft. Han-Chieh Chao: Conceptualization,Methodology. Mu-Yen Chen: Investigation, Methodology.