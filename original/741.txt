Abstract
In the cryptocurrency literature, Proof-of-Space has been a potential alternative for permissionless distributed consensus protocols not only due to its recyclable nature but also the potential to support multiple chains simultaneously. Namely, the same storage resource can be contributed to the consensus of more than one chain. However, a direct shared proof of the same storage brings about newborn attacks on new chain launching since holders of a substantial amount of resources can easily devastate a new chain with minor underlying storage at almost no cost, deviating from the decentralized principle of cryptocurrencies. To fix this gap, we propose an innovative framework of single-chain Proof-of-Space and further present a novel multi-chain scheme which resists newborn attacks effectively by elaborately combining shared proof and chain-specific proof of storage. Our framework covers both classical Nakamoto consensus (with one leader per round) and hybrid consensus (with multiple leaders per round). Specific protocols for both cases are presented. A committee-based consensus is leveraged to realize the multiple leader case. We show that both consensus schemes have realized our desired functionality without compromising consistency or liveness.

Previous
Next 
Keywords
Blockchain

Mechanism design

Consensus

Cryptocurrency

Proof-of-Space

1. Introduction
Since the proposal of Bitcoin in 2008 [27], blockchain has been successfully providing a decentralized consensus on a distributive ledger in a permissionless environment through a peer-to-peer network. In a high level, blockchain is a chain of blocks, each containing certain linearly ordered transactions. The consensus of blockchain performs a “leader election” process and a “ledger extension” process for each round. The “leader election” process elects one or few leaders from all consensus participants (known as miners) according to their computing power, and then these leaders perform a “ledger extension” process via appending their proposed blocks to the rear of the blockchain. Since the specific computing power is evaluated by having miners work on finding certain hash functions preimages, such a way of leader election is called Proof-of-Work (PoW) [13]. The computing power of conducting PoW is referred to as hash power.

PoW suffers from notorious consumption of hash power which turns out to be a waste of natural resource. This circumstance has activated the investigation of alternative consensus schemes which are more energy-efficient. An alternative consensusscheme is Proof-of-Stake (PoS) [4], [6], [10], [12], [22], [30], [35]. In the “leader election” process of PoS consensus scheme, the leader is randomly selected proportionally to the stake that each miner holds, rather than the hash power. Another alternative to PoW is Proof-of-Space (a.k.a. Proof-of-Capacity, PoC). In PoC consensus, the one-time consumption of hash power is replaced by the holding of the storage resource, namely, recyclable hardware disks. Also, PoC is inherited with a nature of concurrency by providing resource proof for multiple chains simultaneously. With a shared nonce for the pebbling graph [14], [16], [17] (PG, the building block of most existing PoC-based consensus schemes), the claim on the same storage can be applied to the consensus of more than one PG-based blockchain. With such a shared proof of storage, the same storage contributes to the security of multiple chains — less total resource is required for the same security guarantee globally.

However, a direct shared proof of the same storage brings about newborn attacks, which makes new chains hard to launch since holders of large storage pools may attack a newly started chain with almost zero-cost. Namely, a newly launched chain often has a minor amount of total storage underlying its consensus and hence the security. Malicious holders of a substantial amount of total storage resource can duplicate the proof one more time and thereby devastate this chain at almost zero-cost, without removing any storage from other chains. This leads to a “rich gets richer” phenomenon and hence deviates from the decentralized principle of cryptocurrencies, which is less likely to happen to traditional consensus schemes since malicious holders have to convert certain resources from other chains to this chain to realize the same attack. Thereby, it has been expected to allow shared resource proof without compromising the security.

In this paper, we aim to address this issue by proposing an innovative multi-chain future of proof-of-space with a functionality. This functionality is built on a combination of a shared proof and a chain-specific proof of storage, which makes the same storage source contribute simultaneously to multiple blockchains, and the cost for an adversary to launch a newborn attack become enormous. The functionality covers both the single-leader case and the general multiple-leader case. However, it is far from trivial to actually realize the functionality of either case. Thereby, we present a Nakamoto-liked single-chain scheme based on the SpaceMint [28] protocol to realize the single-leader case and further construct the hybrid protocol via a committee-based consensus scheme to realize the multiple-leader case. Moreover, we prove that our scheme is incentive-compatible, which means participants can achieve their greatest utility with our desired strategy of storage resource partition.

1.1. High-level intuitions
In this part, we provide few high-level intuitions leading to our constructions.

•
Can multiple Po-X cryptocurrencies share the sameproof? A natural question is: why cannot multiple Po-X-based cryptocurrencies, say, all PoW-based cryptocurrencies adopting SHA-256, share the same proof and hence reach a higher security? Namely, it seems that the same proof of hash power can be applied to all PoW-based blockchains with the same hash oracle, and then all chains are secured up by the summation of hash power of all chains. This is not technically hard but is obviously not happening. Apart from commercial issues, from our perspective, one critical reason is the possibility of newborn attacks. If the same proof of power can be applied to more than one chain, it becomes too easy for large mining pools to devastate new-born chains with almost zero cost.

•
Newborn attacks can be resolved in PoC. However, newborn attacks can be resolved by our construction if chains are supported by existing PoC-based (especially pebbling graph-based) consensus schemes. Specifically, with the inherited properties of existing PoC schemes, we are allowed to require that all consensus participants claim on the storage resource they hold and such a claim can be easily verified due to the soundness of proof-of-space primitives (which will be defined in Section 2). From here, with our delicately devised mechanisms, we are allowed to ask participants to allocate an adequate portion of total storage resources for each chain and hence resolve newborn attacks.

•
Merits of PoC apart from environmental protection.

(1)
Industrial perspective of hardware disks. In the future, hardware disks may face a relatively slow consumption rate when the storage cost reaches the limitation of physical bounds and deviates from the Moore’s law. This may get worse since a dependable information storage service tolerates no commercial strategies like planned obsolescence. The slow consumption rate along with the large production rate of this industry will bring about a large amount of storage not in use. With consensus schemes based on PoC, all these resources can be valued and become a support of the security of world-wide cryptocurrencies.

(2)
PoC includes a proof of patience. PoC schemes require an initiation (e.g. pebbling graph generation of certain schemes) on all the claimed storage. Surprisingly, the time consumption of such an initiation is far from negligible. Say, we have an expense of $30000, assuming that the storage price is $30 per TB we are allowed to purchase  TB of storage. If we slice a whole pebbling graph sequentially into these disks without any data sharding, it takes 242.7 days to complete the pebbling graph generation with one single initiation devise (if the I/O rate between a single disk and an output device is limited to  MB/s). Obviously, 242.7 days of initiation is not tolerated in the commercial world of cryptocurrencies. However, if we pay $6000 for  output devices and purchase storage resource with remained $24000, such an initiation procedure can be reduced to around  days (with an adequate sharding algorithm for the pebbling graph storage which is non-trivial). Thereby, there is trade-off between purchasing the storage and buying output devices. Commercial powers with less faith on the cryptocurrency have less patience and hence will choose to spend less portion on storage for a faster initiation and those with faith are allowed to pay a greater portion for storage with the same expense. Somehow, in this way, more resource are held by those who have faith and hence the currency can be more steady and the consensus security is more reliable. As shown in Fig. 1 (the axis  denotes the total output rate and the axis  denotes the storage), with the same “patience” (measure in the time  to be spent for the initialization), only strategies corresponding to decision points under the blue line can be initiated in time. Also, with the same expense , for parameters , only strategies corresponding to decision points beneath the orange line can be purchased. Therefore, with the best strategy shown as the joint point of two lines, one with time  and expense  can have an initiated amount of storage 
 
 

•
The methodology in this paper cannot be directly applied to PoW. Obviously, such a methodology is supported by a verifiable claim on the total resource. This can be easily applied to PoC-based schemes and participants cannot successfully make faked claims except for a negligible probability or we can easily construct a simulator breaking the soundness of proof-of-space. However, verifiable hash power claim is not considered by any research known to us to date. It is feasible to have an estimation on the hash power of large mining pools from their mined blocks and the puzzle difficulty, but such a measurement is inaccurate and is not applicable to participants with less portion of power.

1.2. Technical contribution of the paper
Some of the main concepts presented in this paper have been already published in [39], the novel contributions of this paper are mainly concerned with our protocol realizing the general functionality. In the previous work of [39], the main functionality was proposed while the proposed protocol only realized a special case of that. In this paper, we propose the protocol that realizes the general functionality based on the framework of committee-based consensus, which is widely adopted in cryptocurrencies to bring about better scalability. We argue that both protocols have realized the main functionality and two basic security properties are guaranteed.

1.3. Related works
Proof-of-space is a category of interactive protocols between a prover  and a verifier  which ensures the prover  is storing some specific data or some data of a certain size. To our knowledge, previous works related to PoC protocols differ at least in two aspects, data in the proved space (useful or useless, persistent or transient, etc.) and security of the protocol.

Two PoC-based protocols were firstly proposed to allow space proofs over transient storage [3] and persistent storage [15], respectively. Proof of transient space (PoTS) by Ateniese et al. [3] enables efficient verification of memory-hard function [33],which is a function that needs a lot of space to compute. In this work, a verifier only needs  time and space to verify the claimed space usage of the prover, where  is the amount of storage the prover  wants to dedicate. Proof of persistent space (PoPS) by Dziembowski et al. [15] allows the verifier to repeatedly audit the prover. Only prover who stores the data persistently can pass the repeatedly audit. In contrast, Proof of retrievability (PoR) [21] enables a user who outsources some useful data to an untrusted server to repeatedly verify if the data is still existing in the server. A nonnegligible difference between PoPS and PoR is whether a large amount of initial data is transferred from verifier  to prover .

The second issue is about the security of PoC protocols. Pebbling graph (see Section 3.1) is the key building block of previous constructions of PoC protocols, and these constructions mainly differ in the topological structure of the pebbling graph .Different graphs naturally result in different security performance. Dziembowski et al. [15] proposed two constructions of PoC schemes in the random oracle model, using Merkle tree and graphs with high “pebbling complexity”. One is based on a graph with high pebbling complexity by Paul et al. [32], which is -secure (see definition in Section 2.2). Another one combines superconcentrators [1], [25], [38], random bipartite expander graphs [20], [40] and depth robust graphs [2], [18] and is -secure The construction of Ren and Devadas [36] uses stacked bipartite expander graphs, which is -secure for any . The labels of the graph are computed just as in [15], however the prover only stores the labels on top of this stack. The construction of Pietrzak [34] uses depth-robust graphs from [33] to realize PoC, which is -secure This construction has a tight bound, which means it can get security against adversary storing  fraction of the space. Moreover, this construction gets security against parallelism, which implies massive parallelism of oracle queries does not benefit the adversary. Besides, this work also introduces and constructs a new type of PoC, which allows the prover to store useful data at the same time.

1.4. Paper organization
The remainder of this paper is organized as follows. Section 2 introduces notations, building blocks and the background of PoC. Section 3 presents a single-chain PoC scheme built on SpaceMint — one of the most well-known PoC scheme today. Based on this, in Section 4, we describe our framework for the multi-chain PoC scheme both by a general functionality and a specific protocol realizing a naive case of the functionality. Afterwards, we propose the protocol realizing the general model of our multi-chain framework in Section 5. Finally, we analyze the incentive compatibility and security of our framework in Section 6.

2. Backgrounds

Table 1. Table of notations.

Notation	Description
A cryptographic hash function 
The ideal number of total participants
 or 
The pseudo-identity of participant , which is essentially the public key
 or 
The secret key of participant 
An amount of storage resource, manifesting as the size of a pebbling graph
, 
A space commitment and its corresponding private data
A space proof (or opening) for a challenge
A parameter from SpaceMint, see Section 3.2
The number of leaders per round
A resource partition strategy
The description of global resource distribution over all chains
 
 describes the portion of global resource underlying all chains
The th block (or epoch record) of the th chain
The committee of round  (if )
2.1. Notations
For a set ,  denotes the number of elements in . With “” we denote concatenation of strings. More generally, for any two tuples 
, 
 is the concatenation of them and for unary tuple 
, 
 is written as 
 (same to the case of 
). We ideally assume  participants and refer to them by either identities 
 or their public keys (
) interchangeably. The secret key corresponding to a public key  is denoted as 
 for simplicity, to further facilitate our description of a high-level framework. We assume a public-key infrastructure (PKI) among all participants, which is described by a functionality 
. Moreover, to any tuple of messages 
, we use 
 to signify the tuple along with the valid signature on the tuple hash from the participant of public key . For a set 
 of public keys, 
 denotes the tuple appended with the valid signatures from over  members of . In later descriptions, we may take the necessity of signing and verifying as granted and avoid redundant descriptions. We assume a hash function 
 simulating the random oracle [5]. Note that based on , we can build 
 for any message  as 
≔ [11]. 
 stands for an ordered list 
. More notations are listed in Table 1.

2.2. Proof-of-space
In this section, Proof-of-space (PoC) represents an interactive protocol between a prover  and a verifier  that demonstrates the prover  is storing some data of a certain size. The PoC protocol in [15] involves two phases: initialization phase and execution phase.

Initialization is an interactive process between the prover  and the verifier . It runs on shared inputs .  is an identifier to assure that the prover  cannot reuse the same disk space to run PoC for different statements.  is the amount of storage the prover  wants to dedicate. After the initialization phase, P stores some data F, whereas V only stores a commitment  to F.

Execution is also an interactive process between the prover  and the verifier . Typically, the verifier  sends challenges to the prover , and then the prover  should calculate with data F and send back the corresponding openings (proof for space commitments). At the end of execution,  verifies these openings based on commitment  and outputs  or .

The security of a PoC protocol was formally defined in [15]. Specifically, an 
-adversarial prover 
 was defined, which means 
’s storage after the initialization phase is bounded by 
, while during the execution phase it runs in storage at most 
 and time at most . Secure PoC protocols are required to have three properties, which are completeness, soundness and efficiency:

(1)
Completeness. We say a PoC protocol has completeness if the verifier always outputs  for any honest prover  with probability .

(2)
Soundness. We say a PoC protocol has soundness if the verifier  outputs  with a negligible probability for any 
-adversarial prover 
.

(3)
Efficiency. We say a PoC protocol has efficiency if the verifier  can run in time .

We say that a PoC protocol is 
-secure if the above three properties are satisfied. Formally, a PoC scheme built on a random oracle  is described as 
. Specifically,

(1)
Space Commitment. 
 inputs the size of the pebbling graph  and returns a pair 
 after building up the graph, where  is the commitment released to the publicity and 
 is a piece of private data to be locally stored by .

(2)
Commitment Opening. 
 takes as input the graph size , the private data 
, the challenge set  and returns a proof .

(3)
Verification. 
 verifies a proof  generated from the challenge set , the graph size  and public commitment .

Due to the fact that most existing schemes generate the challenge set  via a random seed , we write 
 (and 
) as 
 (and 
) to facilitate descriptions. Since this paper aims at a high-order methodology of constructing a fair multi-chain future of PoC-based cryptocurrencies, detailed protocols of the PoC primitive specific to the graph construction (like the specific graph pebbling game) are treated as blackboxes.

3. Single-chain proof-of-space
In this section, we describe SpaceMint protocol briefly, which is a building block of our multi-chain PoC scheme to be described in the following sections.

3.1. Graph pebbling game
At first, we introduce graph pebbling game (a.k.a. graph labeling game) (see [9], [37]), which is the building block of most PoC protocols. Let  be a directed acyclic graph (DAG) which has a vertex set  and an edge set . The label 
 for each vertex  is recursively computed as 
, where 
 are the parents of vertex  and  is a unique nonce. The general PoC protocol based on graph pebbling games can be described as follows:

(1)
Initialization: First,  computes the labels on all nodes of  based on graph pebbling, and then commits to them in  using Merkle-tree Commitment. After receiving ,  sends a challenge 
 containing  nodes in  to . For every challenge node in ,  opens the label of the specific node, as well as the labels of all its parent nodes. Finally,  checks not only whether the challenge nodes are computed correctly from their parents, but also the validity of the Merkle-tree leaves of all challenge nodes and their parents.

(2)
Execution:  chooses  challenge nodes randomly and sends them to . After receiving the above execution challenge,  sends the Merkle-tree leaves of all these challenge nodes to , which  can easily verify. This execution phase can be done repeatedly if this specific PoC protocol is designed for proving persistent storage.

3.2. SpaceMint
SpaceMint [28] is a PoC-based consensus protocol ofblockchain. In SpaceMint, the structure of blocks is identical to Bitcoin blockchain except for containing a space proof instead of a hash solution. Furthermore, the detailed protocol of SpaceMint is similar to any blockchain, in spite that the mining and chain-competition differ from that of PoW-based blockchains. Thereby, it is too redundant to cover every details to introduce the full scheme. To describe SpaceMint, we only need to enumerate all the differences between SpaceMint and the ordinary blockchain.

(1)
Initial Step. For a miner to dedicate  bits of storage to the blockchain network, it computes and stores the labels of their pebbling graph to get 
 at the initial stage. Afterwards 
 is broadcast to the network.

(2)
The Mining. Each miner maintains a main chain (the chain branch with the greatest total weight) in its view. We denote the chain as 
 and their corresponding proofs as 
 (). To mine the next block 
, the miner obtains 
 and assembles 
 with . This differs from PoW.

(3)
Block Verification. Different from the nonce verification in the existing blockchain, in SpaceMint we should check the open-up  of each block by 
.

(4)
Chain Weight. Assuming a block is followed by  sequential blocks 
, which have valid proofs 
 respectively, and that the corresponding space contributed by these miners are 
. The weight of 
 is defined as 
 
 It can be proved that the probability that 
 has the largest weight among these  blocks equals the portion of the global resource held by him, which is 
 
. In this way, in a chain competition, the chain branch with the greatest total weight outruns the others. This differs from the existing blockchain where the block weight is atomic (either one or zero).

4. The multi-chain framework
In this section, we introduce our framework for the multi-chain scheme of proof-of-space. To this end, we first describe our proposed functionality 
 parameterized by , i.e., the number of leaders corresponding to each ledger extension. Then we propose one possible realization of 
 for  based on the aforementioned SpaceMint-based single-chain protocol.

4.1. Functionalities
In a high level, as Fig. 2, we expect to have all participants pay half of the total storage for purchasing the upper bound of their admissible storage (the shared proof part, denoted as 
), and allocate the rest half of storage on each supportive chains respectively according to their market weight (
 for chain ). Specifically, to a chain  with 
 
 (
 is the sum of 
 for all participants) fraction of total storage proof, we stimulate the participant to allocate 
 storage on it. To allow for the start-up of new chains, we in actual ask that 
. Clearly, as an equilibrium of economics, the total storage proof behind a blockchain is proportional to the total market weight of the chain. Therefore, the market weight of each chain is described by the total storage proof behind the chain. Also, we assume that the amount of released coins and transaction fees is the same to all chains for each round and hence the per-coin value is proportional to our defined market weight.

In all, our system supports  different PoC-based blockchains. Each () of them elects leaders according to 
 of all participants. Specifically, each miner with resource partition strategy  has the chance of being the leader of each round by ≔ 
 
 
 where 
≔
, 
≔
 
, and 
≔
. The exact formula of 
 is easy to uncover by solving a quadratic equation (hence can be described in codes when implemented). However, we remain the current formulation for readability.

The detailed description of the functionality is shown in Fig. 3, where we aim to provide a framework more general than our specific way of realization so the size of leaders to be elected for each round is parameterized by . In fact,  of most existing blockchains and our realization based on SpaceMint is simply .

4.2. The protocol for 
To build our realization of the above functionality with  based on our SpaceMint-based single-chain PoC protocol in the previous section, most steps are natural implementations of our building block. However, few issues should be carefully considered alongside. To establish a commonly verifiable computation on the market weight  in a decentralized environment, we assume that the market weight of each chain is proportional to the summed weight of latest  consequent blocks by a constant factor . To make sure that each space proof is used for only one identity, there should be a pool  of space commits locally stored in each node. We have put the specific protocol in Fig. 4 and the scheme is described as follows.

4.2.1. Block format
The framework consists of  chains. Each chain consists of a linearly ordered sequence of blocks. The hash of each block is included by the successive block. Each block 
 of chain  consists of the following parts:

•
pk is the public key of the block proposer, which is also regarded as the pseudo identity in the anonymous network. Thereby, we will use the public key to refer to a participant if necessary.

•
rec is the log of newly appended transactions of the ledger, including transactions for block rewards and fees sent to . This log is often realized by a merkle tree of transactions to allow lightweight clients.

•
 is the hash of the previous block. In practice, this hash might be replaced by the hash of the “block header” (which, instead of the full log, includes a merkle root of ) to facilitate the block assembly phase.

•
 are the open for the challenge from chain . Specifically,  proves its claim on the resource allocation over chain  and 
 proves its claim on the shared resource allocation.

•
weight and com are the weight of the block and the resource partition commitment of the block proposer, respectively.

To facilitate descriptions, for a block , we denote ≔ and 
≔.

4.2.2. System setup
Each participant fetches its pair , denote 
≔, and determines its resource partition strategy . It generates 
 for each chain . Finally, it issues the resource partition commitment with its signature ≔
Each participant should maintain a map  from public key to resource partition commitments and a set  of  to make sure that each resource is claimed by one participant for one chain only. Before the execution of mining protocols, each chain has  start-up blocks, denoted as 
 for chain  and block .

4.2.3. The PoC mining
To mine a block for each chain  and round , each participant proceeds as follows. It firstly finds the current chain branch in view with the greatest total weight 
 and calculates the expected market weight of each chain, namely, 
≔
, let ≔
 
. Afterwards, it assembles its own block for the round 
≔
 
, where 
≔
, 
 are two opens 
, 
 and  has already included all newly appended transactions and the reward (including the block reward and fees) for pk. After the assembly, 
 is proposed.

4.2.4. Chain growth
Each participant parses every received block into 
, firstly verify the calculation of , integrity of , the hash, and the signature. For a block passing the above verification, add it into the current view of block branches if passing through the following verifications:

(1)
Parse 
, check 
.

(2)
Check 
 and 
.

(3)
Check whether each two elements in  are different.

(4)
Check whether  and for each 
, it holds 
. Reject if the above condition is not satisfied.

(5)
Update ≔ and ≔.

5. Realizing the general model
Classical Nakamoto-based consensus schemes (with one leader per round) are notorious for their limited throughput and slow rate of transaction confirmations. Devotions have been made to improve the throughput and speed up transaction confirmations by supporting a committee of leaders per round and hence leveraging a permissioned consensus within the committee. Therefore, it is crucial to realize the general model of 
 with a committee of leaders ().

5.1. Building blocks
To show our construction of the protocol, two concepts frequently discussed in the current cryptocurrency literature should be introduced, i.e., permissioned consensus and committee-based consensus.

5.1.0.1. Permissioned consensus.
Before the proposal of Bitcoin and its underlying blockchain in 2008, the terminology of “distributed consensus” often refers to the Byzantine fault-tolerant consensus protocols among a predetermined set of participants known to each of them (known as the permissioned environment). These protocols are efficient since their communication cost is determined by the actual network delay instead of a predetermined network delay upper-bound. In most schemes, the safety and liveness are guaranteed as long as over  participants are honest [7], [8]. However, they are not applicable to the permissionless environment which allows participants to dynamically spawn nodes and quit. In the following descriptions, we treat as blackbox a permissioned consensus protocol 
 with which a committee of participants are allowed to reach consensus on any length of information.

5.1.0.2. Committee-based consensus.
Committee-based consensusschemes (see [23], [24], [26], [29], [31], [41], [42]) aim to build the bridge between relatively efficient permissioned consensus and a permissionless environment. They dynamically maintain a committee of participants in a permissionless way (like an underlying blockchain) and have the committee verify and linearize all transactions via a permissioned consensus protocol. In this way, the efficiency of permissioned consensus is introduced to the permissionless world and the scalability can be greatly improved. We will adopt such a committee to construct the multi-leader protocol.

5.1.0.3. Distributed random generation.
In few committee-based consensus schemes, a randomness is required to be generated among a set of leaders (i.e., committee members). A naive idea is to have all participants propose their own random shares and take the xor-summation of them. However, an adversary has the potential of undermining the randomness of their xor-summation by pending to be the last sender. Namely, adversary nodes are allowed to take control of the finally generated randomness by waiting for the randomness of other nodes, take the xor-summation of their desired summation result and the current xor-summation, and then propose their faked randomness in the last. Another naive approach is to have participants commit on their random shares and open after all commitments. However, adversary nodes may still undermine few bits of the randomness. Since any fault-tolerant protocol can have few participants run faulty and fail to deliver their messages in time, adversary nodes are allowed to choose whether to perform faulty or open their commitments. In this way, one bit of the randomness is compromised by each malicious node in the participant set. In this work, we adopt a distributed random generation (DRG) based on verifiable secret sharing (VSS) in [19]. In our protocol construction, we will assume such a protocol and denote it by 
.

5.2. The protocol
Based on a permissioned consensus and the methodology from committee-based consensus, we are allowed to present the general scheme as follows.

5.2.1. System setup
Same to the  construction, each participant at first fetches its key pair  (
 stands for  for simplicity) and divides its total storage resource into . For each chain , it generates 
. Finally, it locally constructs the resource partition commitment ≔
.

The following descriptions are focused on one chain  among all  chains. The protocol of leader election is executed in epochs, each has a committee of leaders. The committee of each epoch reaches consensus on an epoch record and determine the committee of next epoch in a secure approach. The epoch record1 of epoch  is in the form of 
Here,  is the epoch number, rec includes all transactions verified and included in the epoch, 
 is the hash of the previous epoch record,  () is the set of PoC opens for resource commitment for chain  (shared proof) from all committee candidates for the epoch. 
 designates the committee of the next epoch. 
 is the set of resource partition commitments from members of all committee candidates for the epoch. Such an epoch record is issued by the committee via the intra-committee consensus 
 and has the signature of over  participants.

We assume a trusted bootstrap and an honest initial committee 
 for the first epoch. Let 
≔
  epoch corresponding to a committee 
 proceeds as follows.

5.2.2. Ledger extension
Committee members reach consensus on  (a predetermined parameter) newly added transactions via executing the intra-committee permissioned protocol 
 for  times and arrange  transactions, along with specially designed transactions sent to each member to allocate block rewards and received transaction fees, into a linear log .

5.2.3. Leader election
For simplicity, we focus on chain . During the ledger extension phase, each participant (either committee non-members or members) uploads to committee members its resource commitment 
. It then calculates 
and 
and issues 
 to committee members. During the leader election phase, committee members reach consensus of all received resource commitments and opens. They filter out all invalid messages, double claims from the same  and double claims 
 on the same resource. Finally, they securely negotiate a randomness via 
 and determine the next committee 
 following the rule that each participant with resource  has the possibility of entering the next committee proportional to 
. To determine members of 
 from a random number  from 
, committee members at first for each committee candidate (participants uploading to the committee their proof-of-space) calculate a 
≔
They sequentially map each candidate into an interval of 
≔
≔ 
≔
Supposing that there exists  candidates, they generate 
≔
for each . Members of the next committee are thereby 
≔ 
 

5.2.4. Epoch record generation
Finally, via another instance of 
, the committee releases the epoch record 
where 
 are set of chain-specific commitments,shared proof commitments, and resource partition commitments of determined members of all committee candidates for the epoch.

5.2.5. Fork resolution
We stipulate that in case of a fork on the epoch record, for example, two epoch records of the same height  
and 
are proposed after the same previous epoch record 
, the branch with a greater total weight outruns the other one, where the weight of each epoch record is the summation of all 
 of candidates in 
 or 
.

6. System analysis
The realization of our functionality in Fig. 3 should satisfy both safety and liveness. The analysis of basic safety and liveness is specific to the way of realization. In our protocol to realize the functionality with , the basic safety and liveness properties of the realization are inherited from SpaceMint. In this section, we focus on two higher-leveled properties of our general framework for a PoC multi-chain future, namely, incentive compatibility and the system security that a considerable fraction of global storage resource has to be held by an adversary to devastate any chain under the framework, even for newly launched chains or chains with the least market weight.

6.1. Incentive compatibility
In this part, we prove that our framework is incentive-compatible. Namely, participants achieve their greatest utility (the most expected revenue) with our desired strategy of storage resource partition. Without loss of generality, we consider  to simplify our proofs. Also, we assume 
 from time to time to simplify proofs. To begin with, we formally describe the partition strategy.

Definition 1 Capacity Resource Partition

For each participant with total capacity , all its admissible resource partitions form the space 
 that 
 for each 
. Furthermore, we introduce 
≔
.

Likewise, we denote 
 as the set of vectors 
 of length  that 
.

The utility function is a mapping from a partition strategy to the expected revenue for each round. To define the global utility function, we firstly introduce the chain-specific utility function.

Definition 2 Chain-specific Utility Function

The chain-specific utility function for chain  is ≔
Intuitively,  is a positive constant,  (proportionally) describes the probability of becoming the leader of each round, and the per-coin value of chain  is proportional to the market weight of the chain (hence is 
 for a positive constant ). Note that we have assumed that the minted coins and transaction fees are the same for each chain and for each round, hence it is not a necessity to add in another factor for it in the multiplication.

At a first glance, the formula above seems fit only into the scenario of . Actually, in the multi-leader case, each participant has  times the chance to become a leader while each leader (committee member) has only 
 
 fraction of total revenue. By 
 
 
 
, the expected revenue remains identical to the one-leader case.

Definition 3 The Utility Function

Thereby the final utility function is the sum of all chain-specific utility functions ≔

The optimal resource partition strategy is clearly depicted as below.

Definition 4 Optimal Resource Partition

To a participant with total storage resource , its optimal resource partition strategy in the environment where each chain  has market weight 
 is 
≔ 
 

We aim to show that our desired resource partition strategy optimizes the utility function. That is to have the optimal resource partition equals our desired one. We at first show the following theorem which was formally proved in [39].

Theorem 1

For any 
 and any 
, 
 
 
where 
 
.

Based on Theorem 1, we find that the optimization of strategy is indeed independent from the total resource . Hence we conclude that for any participant, the optimal strategy is to divide half resource for the shared proof and divide the rest part according to the market weight of each chain ≔
 
 
 

6.2. Consistency and liveness
The basic security properties characterizing a distributed consensus scheme are consistency and liveness. A network is consistent when two honest participants always reach consensus over the ledger except for a certain number of newest blocks (a.k.a. common prefix) and the local ledger of each participant is append-only (a.k.a. self-consistency). The liveness property guarantees that each proposed transaction is always comprehended into the ledger after a certain number of block generations. In fact, based on the basic security of the underlying pebbling graph-based PoC mechanism (completeness, soundness, and efficiency), the consistency and liveness of SpaceMint are guaranteed [28]. The basic security of the realizations of the  case is inherited from SpaceMint and guaranteed thereby, since the chain growth of our protocols resembles that of SpaceMint except for few more parameters. Likewise, the realization of the general model follows the paradigm of [29] where the security is formally proved.

6.3. Realizing the main functionality
The  protocol has realized a special case of the main functionality. We omit the proof for this protocol since the realization is obvious. We show that the general protocol has also securely realized each phase of the general model of the multi-chain functionality.

The realizations of the initialization and reward issuing are trivial. The ledger extension is efficiently performed by the intra-committee consensus and manifest as the record rec of each epoch. The leader election of each chain  is achieved fairly by having the current committee negotiate a random number and determine the next committee according to 
 of each 
 through the random number. A natural question is whether our ledger in the form of epoch records is hard-to-tamper. Namely, whether it is possible to have an adversary taking control of a small fraction of total storage resource to forge a fork on the ledger manifesting as epoch records. In fact, the hard-to-tamper property is guaranteed from the structure of epoch records in two ways.

Firstly, since each committee is determined by the consensus of the previous committee, the adversary has to take over at least 
 
 slots of all committee members of a round to create a fork with valid signatures (recall that each tuple for a round is valid only if appended with signatures from over 
 
 members). For any adversary with less than 
 
 total resource, its probability of achieving this goal in any round is negligible in . To show this, we assume that the adversary holds  total resources, and has taken  slots during a round. By Chernoff bound, 
for any positive . By assuming 
 
 and choosing 
 
, 
 

Secondly, it is hard to forge commitments for sufficient space. Suppose that each epoch record of round  and chain  is 
, which consists of space-proofs from all candidates. In case that an adversary epoch record 
 is proposed in attempt of cause a fork on the ledger, it has to have a substantial amount of storage resource to forge competitive space-commitments 
 and corresponding space-proofs in 
, which is hard to the adversary due to resource constraints.

There is a trade-off between security and efficiency concerning the rate of committee switchover. The communication overhead of performing a committee switchover is high. Therefore, the performance is compromised if the committee is switched at a high speed. However, security issues may arise if the committee is switched at too low a rate. A low rate of committee switchover means that a committee remains static for a long time period. In practice, committee members are vulnerable to targeted attacks from an adaptive adversary during this period and the system can be undermined if over  committee members are controlled by the adversary.

6.4. Resistance against newborn attacks
Our framework resists newborn attacks by having the price of launching a newborn attack sufficiently high. In this part, we show the price of devastating a chain (say,  chain of market weight 
) with 
 
 fraction of total market weight. To devastate chain , the adversary should occupy the total market weight with total storage resource over .2 That is to have 
 and at the same time 
 where 
 
. Thereby, 
 
and hence 
 
 
 
 
 
 
 For 
 
 and 
 
, 
 
. This tells that regardless of the market weight of the chain, the adversary has to devote more than 15% global storage resource (45% to ) to devastate a chain with even the slightest market weight.

7. Conclusion
In this paper, we have proposed a novel multi-chain scheme from the inherited merit of proof-of-space. With our framework, the same storage source contributes simultaneously to multiple blockchains and newly set up blockchains are hard to be devastated. We have proposed the full protocol to realize the functionality of both the single-leader case and the general case. Especially, a committee-based consensus is adopted to realize the general case.

7.1. Future works
In the future, we look forward to having both of our proposed protocols realized and evaluated by experiments. Due to the difficulty of realizing the general protocol, alternative protocols are expected to replace our proposed one while realizing the same main functionality. Moreover, we expect to have both protocols supported by formal security proofs.