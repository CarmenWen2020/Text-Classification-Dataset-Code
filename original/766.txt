Neural networks are known to be vulnerable to adversarial
examples: inputs that are close to natural inputs but classified incorrectly. In order to better understand the space of
adversarial examples, we survey ten recent proposals that
are designed for detection and compare their efficacy. We
show that all can be defeated by constructing new loss functions. We conclude that adversarial examples are significantly
harder to detect than previously appreciated, and the properties believed to be intrinsic to adversarial examples are in
fact not. Finally, we propose several simple guidelines for
evaluating future proposed defenses.
1 INTRODUCTION
Recent years have seen rapid growth in the area of machine
learning. Neural networks, an idea that dates back decades,
have been a driving force behind this rapid advancement.
Their successes have been demonstrated in a wide set of
domains, from classifying images [38], to beating humans at
Go [35], to NLP [32, 40], to self driving cars [6].
In this paper, we study neural networks applied to image
classification. While neural networks are the most accurate
machine learning approach known to date, they are against
an adversary who attempts to fool the classifier [5]. That is,
given a natural image ğ‘¥, an adversary can easily produce a
visually similar image ğ‘¥
â€²
that has a different classification.
Such an instance ğ‘¥
â€²
is known as an adversarial example [39],
and they have been shown to exist in nearly all domains that
neural networks are used.
The research community has reacted to this observation
in force, proposing many defenses that attempt to classify
adversarial examples correctly [3, 16, 20, 21, 31, 33, 34, 41].
Unfortunately, most of these defenses are not effective at
classifying adversarial examples correctly.
Due to this difficulty, recent work has turned to attempting
to detect them instead. We study ten detection schemes
proposed in seven papers over the last year [4, 11, 12, 15, 18] and compare their efficacy with the other defenses
in a consistent manner. With new attacks, we show that
in every case the defense can be evaded by an adversary
who targets that specific defense. On simple datasets, the
attacks slightly increase the distortion required, but on more
complex datasets, adversarial examples remain completely
indistinguishable from the original images.
By studying these recent schemes that detect adversarial
examples, we challenge the assumption that adversarial examples have intrinsic differences from natural images. We
also use these experiments to obtain a better understanding
of the space of adversarial examples.
We evaluate these defenses under three threat models. We
first consider a generic attacks that donâ€™t take any specific
measures to fool any particular detector. We show six of
the ten defenses are significantly less effective than believed
under this threat model. Second, we introduce novel whitebox attacks that break each defense when tailored to the
given defense; five of the defenses provide no increase in
robustness; three increase robustness only slightly; the final
two increase effective only on simple datasets. Our attacks
work by defining a special attacker-loss function that captures
the requirement that the adversarial examples must fool the
defense, and optimizing for this loss function. We discover
that the specific loss function chosen is critical to effectively
defeating the defense: choosing the immediately obvious loss
function often results in the defense appearing significantly
more robust than it actually is. Finally, we leverage the
transferability [39] property to work even when the adversary
does not have knowledge of the defenseâ€™s model parameters.
Our results further suggest that there is a need for better
ways to evaluate potential defenses. We believe our approach
would be a useful baseline: to be worth considering, a proposed defense should follow the approach used here as a first
step towards arguing robustness.
The code to reproduce our results is available online at
http://nicholas.carlini.com/code/nn breaking detection.
We make the following contributions:
âˆ™ We find that many defenses are unable to detect adversarial examples, even when the attacker is oblivious to the specific defense used.
âˆ™ We break all existing detection methods in the whitebox (and black-box) setting by showing how to pick
good attacker-loss functions for each defense.
âˆ™ We draw conclusions about the space of adversarial
examples, and offer a note of caution about evaluating solely on MNIST; it appears that MNIST has
somewhat different security properties than CIFAR.
âˆ™ We provide recommendations for evaluating defenses.
Session: Deep Learning AISecâ€™17, November 3, 2017, Dallas, TX, USA 3
2 BACKGROUND
The remainder of this section contains a brief survey of the
field of neural networks and adversarial machine learning.
We encourage readers unfamiliar with this area to read the
following papers (in this order): [39], [13], [29], and [8].
2.1 Notation
Let ğ¹(Â·) denote a neural network used for classification. The
final layer in this network is a softmax activation, so that the
output is a probability distribution where ğ¹(ğ‘¥)ğ‘– represents
the probability that object ğ‘¥ is labeled with class ğ‘–.
All neural networks we study are feed-forward networks
consisting of multiple layers ğ¹
ğ‘–
taking as input the result of
previous layers. The outputs of the final layer are known as
logits; we represent them by ğ‘(Â·). Some layers involve the
non-linear ReLU [27] activation. Thus the ğ‘–th layer computes
ğ¹
ğ‘–
(ğ‘¥) = ReLU(ğ´
ğ‘–
Â· ğ¹
ğ‘–âˆ’1
(ğ‘¥) + ğ‘
ğ‘–
)
where ğ´
ğ‘–
is a matrix and ğ‘
ğ‘–
is a vector. Let ğ‘(ğ‘¥) denote the
output of the last layer (before the softmax), i.e., ğ‘(ğ‘¥) =
ğ¹
ğ‘›
(ğ‘¥). Then the final output of the network is
ğ¹(ğ‘¥) = softmax(ğ‘(ğ‘¥)).
When we write ğ¶(ğ‘¥) we mean the classification of ğ¹(Â·) on ğ‘¥:
ğ¶(ğ‘¥) = arg maxğ‘–
(ğ¹(ğ‘¥)ğ‘–).
Along with the neural network, we are given a set of
training instances with their corresponding labels (ğ‘¥, ğ‘¦) âˆˆ ğ’³ .
2.2 Adversarial Examples
The security of machine learning is a well studied field: early
work considered this problem mostly on linear classifiers
[9, 25]; later work more generally examined the security of
machine learning [1, 2] to both evasion and poising attacks.
More recently, Biggio et al. and Szegedy et al. [5, 39]
demonstrated test-time evasion attacks on neural networks.
They were able to produce visually similar images that had
different labels assigned by the classifier.
We begin by defining an input to the classifier ğ¹(Â·) natural
if it is an instance that was benignly created (e.g., all instances
in the training set and testing set are natural instances).
Then, given a network ğ¹(Â·) and a natural input ğ‘¥ so that
ğ¶(ğ‘¥) = ğ‘™ we say that ğ‘¥
â€²
is an (untargeted) adversarial example
if ğ‘¥
â€²
is close to ğ‘¥ and ğ¶(ğ‘¥
â€²
) Ì¸= ğ‘™. A more restrictive case
is where the adversary picks a target ğ‘¡ Ì¸= ğ‘™ and seeks to
find ğ‘¥
â€²
close to ğ‘¥ such that ğ¶(ğ‘¥
â€²
) = ğ‘¡; in this case we call
ğ‘¥
â€²
a targeted adversarial example. We focus on targeted
adversarial examples exclusively in this paper. When we say
a neural network is robust we mean that it is difficult to find
adversarial examples on it.
To define closeness, most attacks use an ğ¿ğ‘ distance, defined as â€–ğ‘‘â€–ğ‘ = (âˆ‘ï¸€ğ‘›
ğ‘–=0 |ğ‘£ğ‘–|
ğ‘
)
1
ğ‘ . Common choices of ğ‘ include:
ğ¿0, a measure of the number of pixels changed [30]; ğ¿2, the
standard Euclidean norm [8, 26, 39]; or ğ¿âˆ, a measure of
the maximum absolute change to any pixel [13]. If the total
distortion under any of these three distance metrics is small,
the images will likely appear visually similar. We quantitatively measure the robustness of a defense in this paper by
measuring the distance to the nearest adversarial example
under the ğ¿2 metric.
One further property of adversarial examples we will make
use of is the transferability property [13, 39]. It is often
the case that, when given two models ğ¹(Â·) and ğº(Â·), an
adversarial example on ğ¹ will also be an adversarial example
on ğº, even if they are trained in completely different manners,
on completely different training sets.
There has been a significant amount of work studying
methods to construct adversarial examples [5, 8, 13, 26, 30,
39] and to make networks robust against adversarial examples
[3, 16, 20, 21, 31, 33, 34, 41]. To date, no defenses has been
able to classify adversarial examples correctly.
Given this difficulty in correctly classifying adversarial
examples, recent defenses have instead turned to detecting
adversarial examples and reject them. We study these defenses in this paper [4, 11, 12, 15, 18, 19, 24].
2.3 Threat Model
As done in Biggio et al. [5], we consider three different threat
models in this paper:
(1) An Zero-Knowledge Adversary generates adversarial examples on the unsecured model ğ¹ and is not
aware that the detector ğ· is in place. The detector is
successful if it can detect these adversarial examples.
(2) A Perfect-Knowledge Adversary is aware the neural network is being secured with a given detection
scheme ğ·, knows the model parameters used by ğ·,
and can use these to attempt to evade both the
original network ğ¹ and the detector simultaneously.
(3) A Limited-Knowledge Adversary is aware the neural network is being secured with a given detection
scheme, knows how it was trained, but does not
have access to the trained detector ğ· (or the exact
training data).
We evaluate each defense under these three threat models.
We discuss our evaluation technique in Section 2.7.
2.4 Datasets
In this paper we consider two datasets used throughout the
existing work in this field.
The MNIST dataset [23] consists of 70, 000 28Ã—28 greyscale
images of handwritten digits from 0 to 9. Our standard convolutional network achieves 99.4% accuracy on this dataset.
The CIFAR-10 dataset [22] consists of 60, 000 32Ã—32 color
images of ten different objects (e.g., truck, airplane, etc). This
dataset is substantially more difficult: the state of the art
approaches achieve 95% accuracy [36]. For comparison with
prior work, we use the ResNet [17] architecture from Metzen
et al. [18] trained in the same manner. This model achieves
a 91.5% accuracy.
The first row of Figure 1 shows natural examples drawn
from the test set of these datasets.
Session: Deep Learning AISecâ€™17, November 3, 2017, Dallas, TX, USA 4
2.5 Defenses
In order to better understand what properties are intrinsic of
adversarial examples and what properties are only artificially
true because of existing attack techniques, we choose the
first seven papers released that construct defenses to detect
adversarial examples.
Three of the defenses [12, 15, 18] use a second neural
network to classify images as natural or adversarial. Three
use PCA to detect statistical properties of the images or
network paramaters [4, 19, 24]. Two perform other statistical
tests [11, 15], and the final two perform input-normalization
with randomization and blurring [11, 24].
We summarize our results in Figure 1. Some defenses
can slightly increase distortion required for MNIST digits.
However, no defense makes CIFAR adversarial examples
visually distinguishable from the original image. We generate
adversarial examples as described below.
2.6 Generating Adversarial Examples
We use the ğ¿2 attack algorithm of Carlini and Wagner [8]
to generate targeted adversarial examples, as it is superior
to other published attacks. At a high level it is an iterative
attack as done in the initial work on constructing adversarial
examples [5, 38]. Given a neural network ğ¹ with logits ğ‘,
the attack uses gradient descent to solve
minimize â€–ğ‘¥
â€² âˆ’ ğ‘¥â€–
2
2 + ğ‘ Â· â„“(ğ‘¥
â€²
)
where the loss function â„“ is defined as
â„“(ğ‘¥
â€²
) = max(max{ğ‘(ğ‘¥
â€²
)ğ‘– : ğ‘– Ì¸= ğ‘¡} âˆ’ ğ‘(ğ‘¥
â€²
)ğ‘¡, âˆ’ğœ…).
We now give some intuition behind this loss function. The
difference max{ğ‘(ğ‘¥
â€²
)ğ‘– : ğ‘– Ì¸= ğ‘¡}âˆ’ğ‘(ğ‘¥
â€²
)ğ‘¡ is used to compare the
target class ğ‘¡ with the next-most-likely class. However, this
is minimized when the target class is significantly more likely
than the second most likely class, which is not a property we
want. This is fixed by taking the maximum of this quantity
with âˆ’ğœ…, which controls the confidence of the adversarial
examples. When ğœ… = 0, the adversarial examples are called
low-confidence adversarial examples and are only just classified as the target class. As ğœ… increases, the model classifies
the adversarial example as increasingly more likely, we call
these high-confidence adversarial examples.
The constant ğ‘ is chosen via binary search. If ğ‘ is too small,
the distance function dominates and the optimal solution will
not have a different label. If ğ‘ is too large, the objective term
dominates and the adversarial example will not be nearby.
Of critical importance is that the loss function operates
over the logits ğ‘, and not the probabilities ğ¹. As described
in [8], the optimal choice of the constant ğ‘ âˆ¼
1
|ğ›»â„“|
; therefore,
if ğ¹ were used instead of ğ‘, no â€œgoodâ€ constant ğ‘ would exist
since ğ‘“ varies by several orders of magnitude (and ğ‘ usually
only by one). When constructing attacks in later sections,
we often choose new loss functions â„“ that also do not vary in
their magnitude.
Aside from C&Wâ€™s attack, the Fast Gradient Sign attack
[13] and JSMA [30] are two attacks used by some defenses
for evaluation. These attacks are weaker than C&Wâ€™s attack
and we do not use them for evaluation [8].
2.7 Attack Approach
In order to evaluate the robustness of each of the above
defenses, we take three approaches to target each of the three
threat models introduced earlier.
Evaluate with a strong attack (Zero-Knowledge): In this
step we generate adversarial examples with C&Wâ€™s attack
and check whether the defense can detect this strong attack.
This evaluation approach has the weakest threat model (the
attacker is not even aware the defense is in place), so any
defense should trivially be able to detect this attack. Failing
this test implies that the second two tests will also fail.
Perform an adaptive, white-box attack (Perfect-Knowledge):
The most powerful threat model, we assume here the adversary has access to the detector and can mount an adaptive
attack. To perform this attack, we construct a new loss function, and generate adversarial examples that both fool the
classifier and also evade the detector.
The most difficult step in this attack is to construct a loss
function that can be used to generate adversarial examples.
In some cases, such a loss function might not be readily
available. In other cases, one may exist, but it may not be
well-suited to performing gradient descent over. It is of critical
importance to choose a good loss function, and we describe
how to construct such a loss function for each attack.
Construct a black-box attack (Limited-Knowledge): This
attack is the most difficult for the adversary. We assume the
adversary knows what type of defense is in place but does
not know the detectorâ€™s paramaters. This evaluation is only
interesting if (a) the zero-knowledge attack failed to generate
adversarial examples, and (b) the perfect-knowledge attack
succeeded. If the strong attack alone succeeded, when the
adversary was not aware of the defense, they could mount
the same attack in this black-box case. Conversely, if the
white-box attack failed, then a black-box attack will also fail
(since the threat model is strictly harder).
In order to mount this attack, we rely on the transferability
property: the attacker trains a substitute model in the same
way as the original model, but on a separate training set (of
similar size, and quality). The attacker can access substitute
modelâ€™s parameters, and performs a white-box attack on
the substitute model. Finally, we evaluate whether these
adversarial examples transfer to the original model.
When the classifier and detector are separate models, we
assume the adversary has access to the classifier but not the
detector (we are analyzing the increase in security by using
the detector).
If the detector and classifier are not separable (i.e., the
classifier is trained to also act as a detector), then to perform
a fair evaluation, we compare the adversarial examples generated with black-box access to the (unsecured) classifier to
adversarial examples generated with only black-box access
to both the classifier and detector.
Session: Deep Learning AISecâ€™17, November 3, 2017, Dallas, TX, USA 5
Reference
Unsecured
Grosse
Â§3.1
Gong
Â§3.1
Metzen
Â§3.2
Hendrycks
Â§4.1
Bhagoji
Â§4.2
Li
Â§4.3
Grosse
Â§5.1
Feinman
Â§5.2
Feinman
Â§6.1
Li
Â§6.2
Figure 1: Summary of Results: adversarial examples on the MNIST and CIFAR datasets for each defense we
study. The first row corresponds to the original images.
3 SECONDARY CLASSIFICATION
BASED DETECTION
We now turn to evaluating the ten defenses. The first category of detection schemes we study build a second classifier
which attempts to detect adversarial examples. Three of the
approaches take this direction.
For the remainder of this subsection, define ğ¹(Â·) to be the
classification network and ğ·(Â·) to be the detection network.
ğ¹(Â·) is defined as in Section 2.1 outputting a probability
distribution over the 10 classes, and ğ· : R
ğ‘¤Â·ğ‘•Â·ğ‘ â†’ (âˆ’âˆ, âˆ)
represent the logits of the likelihood the instance is adversarial. That is, sigmoid(ğ·(ğ‘¥)) : R
ğ‘¤Â·ğ‘•Â·ğ‘ â†’ [0, 1] represents the
probability the instance is adversarial.
3.1 Adversarial Retraining
Grosse et al. [15] propose a variant on adversarial re-training.
Instead of attempting to classify the adversarial examples
correctly (by adding adversarial examples to the training set,
with their correct labels), they introduce a new ğ‘ + 1st class
â€” solely for adversarial examples â€” and train the network to
detect adversarial examples. Specifically, they propose the
following procedure:
(1) Train a model ğ¹ğ‘ğ‘ğ‘ ğ‘’ on the training data ğ’³0 = ğ’³ .
(2) Generate adversarial examples on model ğ¹base for
each (ğ‘¥ğ‘–, ğ‘¦ğ‘–) âˆˆ ğ‘‹. Call these examples ğ‘¥
â€²
ğ‘–
.
(3) Let ğ’³1 = ğ’³0 âˆª {(ğ‘¥
â€²
ğ‘–
, ğ‘ + 1) : ğ‘– âˆˆ |ğ’³ |} where ğ‘ + 1
is the new label for adversarial examples.
(4) Train a model ğ¹secured on the training data ğ’³1.
Gong et al. [12] construct a very similar defense technique.
Instead of re-training the model ğ¹secured completely, they
construct a binary classifier ğ· that simply learns to partitions
the instances ğ‘¥ from ğ‘¥
â€² by training on the training set
ğ’³1 = {(ğ‘¥ğ‘–, 1) : ğ‘– âˆˆ |ğ’³ |} âˆª {(ğ‘¥
â€²
ğ‘–
, 0) : ğ‘– âˆˆ |ğ’³ |}.
We re-implement these two defenses and find that adversarial retraining is able to detect adversarial examples when
generated with the fast gradient sign and JSMA attacks with
near-100% accuracy.
Zero-Knowledge Attack Evaluation. We train these two
schemes on the entire MNIST training set, using C&Wâ€™s
attack to generate adversarial examples. In this way we
construct a model ğ¹secured and ğ·.
We then construct adversarial examples for ğ¹base from each
image in the test set using C&Wâ€™s attack. Both approaches
detect these previously unseen test adversarial examples.
Grosse et al. detects 98.5% of attacks as adversarial. Further,
it classifies half of the remaining 1.5% correctly. Gong et al.
achieve 98% accuracy in detecting adversarial examples.
Investigating further, we find that even if we train on
adversarial examples generated using an untargeted attack,
both schemes can detect targeted adversarial examples.
Session: Deep Learning AISecâ€™17, November 3, 2017, Dallas, TX, USA 6
Neither of these defenses claim robustness against CIFAR,
however when we perform this evaluation, we find to achieve
a 70% detection rate requires a 40% false positive rate. This
alone can be seen as a failure of these approaches on CIFAR.
Perfect-Knowledge Attack Evaluation. Next, we evaluate
these defenses assuming the adversary is aware of these defenses and parameters. That is, we directly attack the defended model. Our experiments revealed that these defenses
are ineffective and add almost no increase in robustness.
For Grosseâ€™s defense, we use C&Wâ€™s attack on ğ¹secured
to generate adversarial examples; it succeeds 100% of the
time. We computed the mean ğ¿2-distance from the original
sample to the adversarial example. Adversarial examples
against ğ¹base are at average ğ¿2 distance of 2.05 from the
original sample; adversarial examples against ğ¹secured have
an average distance of 2.26. Thus the defense has not reduced
the success rate at generating adversarial examples, and has
only increased the mean distortion by 10%.
Gongâ€™s defense does not fare any better. To help construct
adversarial examples that will simultaneously fool ğ¹base and
ğ·, we define a new function ğº(Â·) that represents the combination of the classifier (with logits ğ‘ğ¹ (Â·)) and detector (with
logits ğ‘ğ·(Â·)). In particular, we define
ğº(ğ‘¥)ğ‘– =
â§
â¨
â©
ğ‘ğ¹ (ğ‘¥)ğ‘– if ğ‘– â‰¤ ğ‘
(ğ‘ğ·(ğ‘¥) + 1) Â· max
ğ‘—
ğ‘ğ¹ (ğ‘¥)ğ‘— if ğ‘– = ğ‘ + 1
Effectively, ğº acts as a classifier on ğ‘ + 1 classes. It is
constructed to have two useful properties: if ğ‘ğ·(ğ‘¥) > 0 (i.e.,
if the detector classifies ğ‘¥ as malicious) then we will have
arg maxğ‘–
(ğº(ğ‘¥)ğ‘–) = ğ‘ + 1
(where ğ‘ is the new adversarial class), and if ğ‘ğ·(ğ‘¥) < 0 (i.e.,
if the detector classifies ğ‘¥ as natural) then we will have
arg maxğ‘–
(ğº(ğ‘¥)ğ‘–) = arg maxğ‘–
(ğ‘ğ¹ (ğ‘¥)ğ‘–).
Why did we choose this particular function ğº(Â·)? Recall
from earlier that when using a gradient-descent based attack
algorithm, there is a constant ğ‘ in the loss function that trades
off the relative importance of reducing the distance from the
natural instance vs. classifying the input as the target class.
If the value of the loss function changes by several orders
of magnitude, no value of ğ‘ will be optimal and adversarial
examples will be very hard to find. Therefore, we construct
ğº so that it is mostly linear.
Now we treat this function ğº as if it were a neural network,
and feed it directly into C&Wâ€™s attack algorithm instead
of the function ğ‘. It is easy to see that if an instance ğ‘¥
â€²
is classified by ğº as label ğ‘™ â‰¤ ğ‘ then both ğ¶(ğ‘¥
â€²
) = ğ‘™ and
the detector classifies ğ‘¥
â€²
as natural (non-adversarial). This
approach successfully generates adversarial examples against
Gongâ€™s defense with 100% success. The mean ğ¿2 distortion of
these adversarial examples is 2.31, an improvement of about
10% over the unprotected scheme.
We therefore conclude neither of these schemes are effective
on MNIST. While adversarial examples are detectable with
neural networks when not attempting to be evasive, it is
possible to construct evasive adversarial examples.
On CIFAR, the above attacks work in an identical manner
and give very similar results: the distortion is increased less
than 5%.
Limited-Knowledge Attack Evaluation. For brevity, we only
describe the attack on Grosseâ€™s scheme (Gongâ€™s results are
identical). We generate transferable adversarial examples
as described above. Instead of training one model on the
complete training set, we split the training set in half. We
assume the first half is known to the attacker and the second
half is used by the defender to train their network. Thus, we
construct two models ğ‘…1 and ğ‘…2 each trained on half of the
training data. We treat ğ‘…2 as the defenderâ€™s model (the target
model for which we want to produce adversarial examples)
and give the attacker white-box access to all parameters of
model ğ‘…1. Then we apply the C&W attack to each instance
in the test set to generate adversarial examples for ğ‘…1, and
we test whether they fool ğ‘…2.
As a baseline, we applied this procedure to the unsecured
model. The attack succeeded 98% of the time, with a mean
ğ¿2 distortion of 5.1. Then, we generated two secured models
ğ‘…1 and ğ‘…2 implementing Grosseâ€™s defense, and applied the
same attack. We observed a 98% success rate, with a mean ğ¿2
distortion of 5.3, which is only 4% higher than the baseline.
Therefore, we conclude that Grosseâ€™s defense is ineffective
and can be attacked even by an attacker who does not the
exact model parameters of the secured model.
3.2 Examining Convolutional Layers
In contrast to the prior approach, which attempts to detect
adversarial examples based on the contents of the image
itself, Metzen et al. [18] detect adversarial examples by looking at the inner convolutional layers of the network. They
augment the classification neural network with a detection
neural network that takes its input from various intermediate
layers of the classification network. This detection network
is trained identically to Gongâ€™s defense above. We refer interested readers to the original paper for complete details on
the detector setup [18]. This defense only argues robustness
against CIFAR, since it looks at the inner layers of a ResNet
(which are not usually used for MNIST).
We then train the detector by attaching it to the output
of the first residual block as done in [18]. We confirmed that
their detector is able to detect adversarial examples with 99%
probability on simple attacks (fast gradient sign or JSMA).
Zero-Knowledge Attack Evaluation. We found training the
detector to be very difficult and highly sensitive; we experimented with different optimizers, hyper-parameters, and
initializers to reduce the effect of this.
For evaluation, we generate adversarial examples for each
instance in the test set, using the C&W attack. The best
detector we were able to train correctly obtains an 81%
true positive rate at 28% false positive rate. This is in stark
contrast to the 99% success at detecting simpler attacks,
Session: Deep Learning AISecâ€™17, November 3, 2017, Dallas, TX, USA 7
which highlights that weak attacks give a biased view of
defense robustness.
Similar to the prior defense (that also had a high false
positive rate), this defense is unable to perform well even
when the adversary is not attempting to evade it.
Perfect-Knowledge Attack Evaluation. Our white-box attack completely defeats Metzenâ€™s defense: it is able to produce
adversarial examples that simultaneously are mis-classified
by the original network and evade the detector. We generate adversarial examples using C&Wâ€™s attack applied to the
same function ğº(Â·) defined in Section 3.1. The mean distance
to adversarial examples increases from 0.169 ğ¿2 distortion
on the unsecured model to 0.227 on the secured scheme, an
improvement of 34%. However, in absolute terms, the adversarial examples generated are still indistinguishable from the
original inputs.
Limited-Knowledge Attack Evaluation. To investigate if
this defense is robust to attacks in a black-box setting, we
perform a standard transferability test as done above. We split
the training data in half, and train two detector models, one
on each half of the training data. Then, we attack the second
detector given only white-box access to the first detector.
On MNIST, we found that even low-confidence adversarial
examples transfer 84% of the time between the two detectors
when the classifier network is known by the adversary. By
using high-confidence adversarial examples, the attack success
rate can be increased to 98% at the cost of increasing the
mean distortion by a further 28%, which is small enough
that adversarial examples remain indistinguishable from the
original images.
4 PRINCIPAL COMPONENT
ANALYSIS DETECTION
Principal Component Analysis (PCA) transforms a set of
points in a ğ‘›-dimensional space to a new set of points in a
ğ‘˜-dimensional space (ğ‘˜ â‰¤ ğ‘›) through a linear transformation.
We assume the reader is familiar with PCA for the remainder
of this section.
4.1 Input Image PCA
Hendrycks & Gimpel [19] use PCA to detect natural images
from adversarial examples, finding that adversarial examples
place a higher weight on the larger principal components than
natural images (and lower weight on the earlier principal
components).
Zero-Knowledge Attack Evaluation. We first reproduce
their results by running PCA on MNIST. To see if adversarial
examples really do use larger principal components more
often, we compute how much each component is used. Let
ğ‘‹1, . . . , ğ‘‹ğ‘› be the training set instances. We define the score
ğ‘†(ğ‘—) of the ğ‘—th PCA component as
ğ‘†(ğ‘—) = 1
ğ‘
âˆ‘ï¸ğ‘
ğ‘–=1
|ğ‘ƒ ğ¶ğ´(ğ‘‹ğ‘–)ğ‘— |.
0 200 400 600 800
Component 1umber
10âˆ’18
10âˆ’14
10âˆ’10
10âˆ’6
10âˆ’2
0ean AbVolute Value (log Vcale)
Valid
AdverVarial
Figure 2: PCA on the MNIST dataset reveals a difference between natural images and adversarial images, however this is caused by an artifact of MNIST:
border pixels on natural images are often 0 but
slightly-positive on adversarial examples.
We train a classification network on the training set and
compute the component scores ğ‘†(1), . . . , ğ‘†(784). Then, for
each image in the test set, we find the nearest adversarial
example with C&Wâ€™s attack and we compute the component
scores on these adversarial examples. The results are plotted
in Figure 2.
Our results agree with Hendrycks et. al [19]: there is no
difference on the first principal components, but there is a substantial difference between natural and adversarial instances
on the later components. On the MNIST data set, their defense does detect zero-knowledge attacks, if the attacker does
not attempt to defeat the defense.
Looking Deeper. At first glance, this might lead us to
believe that PCA is a powerful and effective method for
detecting adversarial examples. However, whenever there
are large abnormalities in the data, one must be careful to
understand their cause.
In this case, the reason for the difference is that there
are pixels on the MNIST dataset that are almost always
set to 0. Since the MNIST dataset is constructed by taking
24x24 images and centering them (by center-of-mass) on
a 28x28 grid, the majority of the pixels on the boundary
of natural images are zero. Because these border pixels are
essentially always zero for natural instances, the last principal
components are heavily concentrated on these border pixels.
This explains why the last 74 principal components (9.4% of
the components) contribute less than 10âˆ’30 of the variance
on the training set.
In short, the detected difference between the natural and
adversarial examples is because the border pixels are nearly
always zero for natural MNIST instances, whereas typical
adversarial examples have non-zero values on the border.
Session: Deep Learning AISecâ€™17, November 3, 2017, Dallas, TX, USA 8
While adversarial examples are different from natural images
on MNIST in this way, this is not an intrinsic property of
adversarial examples; it is instead due to an artifact of the
MNIST dataset. When we perform the above evaluation on
CIFAR, there is no detectable difference between adversarial
examples and natural data. As a result, the Hendrycks defense is not effective for CIFAR â€” it is specific to MNIST.
Also, this deeper understanding of why the defense works
on MNIST suggests that adaptive attacks might be able to
avoid detection by simply leaving those pixels unchanged.
Perfect-Knowledge Attack Evaluation. We found that the
Hendrycks defense can be broken by a white-box attacker with
knowledge of the defense. Details are deferred to Section 4.2,
where we break a strictly stronger defense. In particular, we
found in our experiments that we can generate adversarial
examples that are restricted to change only the first ğ‘˜ principal components (i.e., leave all later components unchanged),
and these adversarial examples that are not detected by the
Hendrycks defense.
4.2 Dimensionality Reduction
Bhagoji et al. [4] propose a defense based on dimensionality
reduction: instead of training a classifier on the original
training data, they reduce the ğ‘Š Â· ğ» Â· ğ¶ = ğ‘-dimensional
input (e.g., 784 for MNIST) to a much smaller ğ¾-dimensional
input (e.g., 20) and train a classifier on this smaller input.
The classifier uses a fully-connected neural network: PCA
loses spatial locality, so a convolutional network cannot be
used (we therefore consider only MNIST).
This defense restricts the attacker so they can only manipulate the first ğ¾ components: the classifier ignores other
components. If adversarial examples rely on the last principal
components (as hypothesized), then restricting the attack to
only the first ğ¾ principal components should dramatically
increase the required distortion to produce an adversarial
example. We test this prediction empirically.
We reimplement their algorithm with their same model (a
fully-connected network with two hidden layers of 100 units).
We train 26 models with different values of ğ¾, ranging from
9 to 784 dimensions. Models with fewer than 25 dimensions
have lower accuracy; all models with more than 25 dimensions
have 97% or higher accuracy.
Perfect-Knowledge Attack Evaluation. We evaluate Bhagojiâ€™s
defense by constructing targeted attacks against all 26 models
we trained. We show the mean distortion for each model in
Figure 3. The most difficult model to attack uses only the
first 25 principal components; it is nearly 3Ã— more robust
than the model that keeps all 784 principal components.
However, crucially, we find that even the model that keeps
the first 25 principal components is less robust than almost
any standard, unsecured convolutional neural network; an
unprotected network achieves both higher accuracy (99.5%
accuracy) and better robustness to adversarial examples
(measured by the mean distortion). In summary, Bhagojiâ€™s
defense is not secure against white-box attacks.
0 200 400 600
Number of Principle Components
0.0
0.5
1.0
1.5
2.0
Mean Distance to Adversarial Example
Baseline (CNN)
PCA Model (CNN)
PCA Model (FC)
Figure 3: Performing dimensionality reduction increases the robustness of a 100-100-10 fullyconnected neural network, but is still less secure
than just using an unsecured CNN (the baseline).
Dimensionality reduction does not help on a network
that is already convolutional.
Looking Deeper. Next, we show that this result is not an
artifact of the network architecture â€” it is not caused just
because fully-connected network are less robust than convolutional networks. We study a second algorithm that Bhagoji
et al. present but did not end up using, which combines PCA
with a convolutional neural network architecture. This allows
us to perform an experiment where the network architecture
is held fixed, and the only change is whether dimensionality
reduction is used or not. In particular, instead of using the
first ğ¾ principal components as features for a fully-connected
network, they use PCA to map each image into the reduceddimensionality PCA space, and then immediately map it back
to the image space. This effectively projects the image into
a reduced-dimension manifold. They train a convolutional
classifier on the projected images. This classifier achieves a
higher accuracy (99% when using at least 25 dimensions).
In our experiments we found that this approach is no more
robust than an unsecured convolutional network (applied to
the original image), despite only using a limited number of the
principal components. We conclude that defenses based on
limiting the adversary to only the first principal components
are not effective. It follows that Hendrycks et. alâ€™s defense is
broken as well, as the adversarial images generated in this
way change only the first ğ¾ components and leave all later
components unchanged.
4.3 Hidden Layer PCA
Li et al. [24] apply PCA to the values after inner convolutional
layers of the neural network, and use a cascade classifier
to detect adversarial examples. Specifically, they propose
building a cascade classifier that accepts the input as natural
Session: Deep Learning AISecâ€™17, November 3, 2017, Dallas, TX, USA 9
only if all classifiers ğ¶ğ‘– accept the input, but rejects it if any
do. Each classifier ğ¶ğ‘– a linear SVM that acts on the PCA of
the ğ‘–th convolutional layer of the network.
They evaluate their scheme on ImageNet. In the remainder
of this section we demonstrate their defense is not effective
on MNIST and CIFAR; others have shown that attacking an
ImageNet classifier would be even easier [8, 26].
Zero-Knowledge Attack Evaluation. Li et al. generated
adversarial examples with Szegedy et. alâ€™s L-BFGS algorithm [39] and found that the first linear SVM achieved 80%
true positive rate at 0% false positive rate â€“ an ideal use-case
for a cascade classifier. We evaluated the effectiveness of their
method at detecting adversarial examples generated with
C&Wâ€™s attack (when trained on adversarial examples generated with the C&W attack). For MNIST, their scheme only
achieves a 62% true positive rate at a 37% false positive rate
(and 56% at 40% on CIFAR) on the first layer of the cascade
classifier. This results causes the cascade classifiers to have
a 92% and 98% false positive rates on MNIST/CIFAR. We
conclude that Liâ€™s defense is not effective against the C&W
attack.
5 DISTRIBUTIONAL DETECTION
Next, we study two defenses that detect adversarial examples by comparing the distribution of natural images to the
distribution of adversarial examples. They use classical statistical methods to distinguish natural images from adversarial
images.
5.1 Maximum Mean Discrepancy
Grosse et al. [15] consider a very powerful threat model:
assume we are given two sets of images ğ‘†1 and ğ‘†2, such that
we know ğ‘†1 contains only natural images, and we know that
ğ‘†2 contains either all adversarial examples, or all natural
images. They ask the question: can we determine which of
these two situations is the case?
To achieve this, they use the Maximum Mean Discrepancy (MMD) test [7, 14], a statistical hypothesis test that
answers the question â€œare these two sets drawn from the
same underlying distribution?â€
The MMD is a theoretically useful technique that can be
formally shown to always detect a difference if one occurs.
However, it is computationally infeasible to compute, so a
simple polynomial-time approximation is almost always used.
In our experiments, we use the same approximation used by
Grosse et al. [14].
To test whether ğ‘‹1 and ğ‘‹2 are drawn from the same
distribution, Grosse et al. use Fisherâ€™s permutation test [28]
with the MMD test statistic. To do this, initially let ğ‘ =
ğ‘€ğ‘€ğ·(ğ‘‹1, ğ‘‹2). Then, shuffle the elements of ğ‘‹1 and ğ‘‹2
into two new sets ğ‘Œ1 and ğ‘Œ2, and let ğ‘ = ğ‘€ğ‘€ğ·(ğ‘Œ1, ğ‘Œ2). If
ğ‘ < ğ‘ then reject the null hypothesis, and conclude they are
drawn from different distributions. Repeat this process many
times, and repor the p-value as the fraction of times the null
hypothesis is rejected.
As a first step, we verified that MMD correctly detects
natural instances as being natural. To do this, we assign
ğ‘‹1 and ğ‘‹2 to be random samples from the test set. The
procedure above correctly fails to reject the null hypothesis
(ğ‘ > 0.05) in distinguishing the two distributions.
Zero-Knowledge Attack Evaluation. We repeated this experiment, this time producing targeted adversarial examples
with C&Wâ€™s attack algorithm. Even when using a set of 100
images, MMD fails to reject the null hypothesis (ğ‘ > 0.05).
MMD also fails to detect attacks on CIFAR, even with a set
size as large as 10, 000 (which uses every sample in the test
set). Since MMD is one of the most powerful multidimensional statistical tests, and even it is not effective, we argue
that without significant modification, statistical tests will not
be able to detect adversarial examples.
5.2 Kernel Density Estimation
Feinman et al. [11] present a defense they call kernel density
estimation. They use a Gaussian Mixture Model to model
outputs from the final hidden layer of a neural network,
and argue that adversarial examples belong to a different
distribution than that of natural images.
Specifically, given an instance ğ‘¥ classified as label ğ‘¡, kernel
density estimation estimates the likelihood of ğ‘¥ as
ğ¾ğ·ğ¸(ğ‘¥) = 1
|ğ‘‹ğ‘¡|
âˆ‘ï¸
ğ‘ âˆˆğ‘‹ğ‘¡
exp(|ğ¹
ğ‘›âˆ’1
(ğ‘¥) âˆ’ ğ¹
ğ‘›âˆ’1
(ğ‘ )|
2
ğœ2
)
where ğ‘‹ğ‘¡ is the set of training instances with label ğ‘¡ and
ğ¹
ğ‘›âˆ’1
(ğ‘¥) is the output of the final hidden layer on input ğ‘¥.
The detector is therefore constructed by selecting a threshold
ğœ and reporting ğ‘¥ as adversarial if ğ¾ğ·ğ¸(ğ‘¥) < ğœ , otherwise
reporting ğ‘¥ as natural.
The motivation behind this approach is that the later hidden layers of a neural network have been shown to capture
high-level semantic information about the input. Therefore,
using a simple classifier on this final layer will be more accurate than if it were applied to the original input images, as
the prior defense did.
Zero-Knowledge Attack Evaluation. Feinmanâ€™s defense is
able to detect C&W adversarial examples on MNIST, but
not on CIFAR. Looking deeper, on CIFAR, for each image in
the test set ğ‘¥ and closest adversarial example ğ‘¥
â€²
, we compare
ğ¾ğ·ğ¸(ğ‘¥
â€²
) to ğ¾ğ·ğ¸(ğ‘¥). Surprisingly, we find that 80% of
the time, the adversarial example has a higher likelihood
score than the original image.Therefore, Feinmanâ€™s defense
cannot work on CIFAR. In the remainder of this section, we
show how to break this defense on MNIST with increased
distortion.
Perfect-Knowledge Attack Evaluation. To mount a whitebox attack, we construct a new minimization formulation
that differs from the original only in that we introduce a
new loss term â„“2(ğ‘¥
â€²
) that penalizes being detected by the
detector:
minimize â€–ğ‘¥ âˆ’ ğ‘¥
â€²
â€–
2
2 + ğ‘ Â· (â„“(ğ‘¥
â€²
) + â„“2(ğ‘¥
â€²
))
Session: Deep Learning AISecâ€™17, November 3, 2017, Dallas, TX, USA 10
where we define
â„“2(ğ‘¥
â€²
) = max(âˆ’ log(ğ¾ğ·ğ¸(ğ‘¥
â€²
)) âˆ’ ğœ–, 0)
where ğœ– controls the likelihood measure of the adversarial examples. In our attack, we set ğœ– to the median of âˆ’ log(ğ¾ğ·ğ¸(Â·))
on the training set, so that â„“2(ğ‘¥
â€²
) â‰¤ 0 if and only if ğ¾ğ·ğ¸(ğ‘¥
â€²
)
is greater than half of the training instances KDE.
In practice, we mount this attack in two phases. First, we
solve the original C&W minimization formulation to obtain
an adversarial example ğ‘¥Ë†. Typically ğ‘¥Ë† will be detected by the
detector, so in the second phase we modify it to no longer be
detected: we use this ğ‘¥Ë† as the initial value of ğ‘¥
â€²
in the above
optimization problem and use gradient descent to improve
it. Performing this two-step optimization is useful to allow
for different constants ğ‘ chosen for initially generating an
adversarial example and for making it not detected.
This approach is effective at generating adversarial examples for MNIST that are not detected by Feinmanâ€™s defense.
The mean distortion is 3.81, up from 2.05 on an unsecured
network. In order to implement this attack more efficiently,
instead of computing the KDE across all training instances
during the inner optimization loop, we randomly sample 100
instances (< 5% of the total) at first and use only those.
A distortion of 3.81 begins to allow humans to notice the
adversarial nature of these images (Figure 1).
We believe the reason this defense is so much more effective
on MNIST than on CIFAR because this defense is effectively
a K-nearest-neighbor classifier with a neural network feature
extractor. In fact, prior work has shown that using an RBF
kernel SVM (essentially identical to what is done here) is
effective at defending MNIST to adversarial examples.
Limited-Knowledge Attack Evaluation. Again we only demonstrate the vulnerability on MNIST: the defense does not work
on CIFAR. Note that our white-box attack algorithm didnâ€™t
use the entire training set; it uses only a random sample
of 100 instances from the training set (less than 5% of the
training instances). This hints that black-box attacks might
succeed. This is indeed the case: we found that when the
defender uses the first 95% of the training data, and the last
5% of the training data is left for the adversary (who uses it
to form their own KDE estimator), the attack still succeeds
with equal distortion.
6 NORMALIZATION DETECTION
6.1 Dropout Randomization
Feinman et al. propose a second detection method called
Bayesian neural network uncertainty that measures the uncertainty of the neural network on the given input. Instead
of relying on the reported confidence of the network (which
can easily be controlled by an adversary), they add randomization to the network. The hope is that a natural image will
have the same (correct) label regardless of the random values
chosen, while adversarial examples wonâ€™t always be predicted
with the same label. Dropout [37] is used as the method of
adding randomness.
To determine the uncertainty of the network on a given
instance, we apply the randomized network ğ¹ğ‘Ÿ (with dropout
enabled) to the input ğ¿ times. Then, the uncertainty is
defined as
ğ‘ˆ(ğ‘¥) = (ï¸ƒ
1
ğ¿
âˆ‘ï¸ğ¿
ğ‘–=1
â€–ğ¹ğ‘Ÿ(ğ‘¥)â€–
)ï¸ƒ
âˆ’
âƒ¦
âƒ¦
âƒ¦
âƒ¦
âƒ¦
1
ğ¿
âˆ‘ï¸ğ¿
ğ‘–=1
ğ¹ğ‘Ÿ(ğ‘¥)
âƒ¦
âƒ¦
âƒ¦
âƒ¦
âƒ¦
where we take â€–ğ‘¦â€– to mean ğ‘¦
ğ‘‡
ğ‘¦ (the squared ğ¿2 norm). Notice
that if the predictions ğ¹ğ‘Ÿ(ğ‘¥) are the same every time, the
uncertainty is 0. In other words, the uncertainty is the sum
of the variances of each component of the output, computed
over the ğ¿ outputs from the randomized network.
To classify an input ğ‘¥ as adversarial or natural, we pick a
threshold ğœ and a number of times to evaluate the network
ğ¿ and compute ğ‘ˆ(ğ‘¥). We have found the algorithm is not
sensitive to the choice of ğ¿ as long as it is greater than 20
(and we pick ğ¿ = 30 for the remainder of this section). We
return â€œadversarialâ€ if ğ‘ˆ(ğ‘¥) > ğœ and â€œnaturalâ€ otherwise.
When we run this detection scheme on the adversarial
examples generated by the FGS and JSMA attack algorithms
on MNIST, it detects 96% of adversarial examples with a
false positive rate lower than 1% when ğœ = 0.02.
Zero-Knowledge Attack Evaluation. We generated adversarial examples with C&Wâ€™s attack and find 75% of these
adversarial examples are detected by this defense on MNIST.
Surprisingly, this defense is even more effective at detecting attacks on CIFAR: it detects 95% of C&W adversarial
examples.
Perfect-Knowledge Attack Evaluation. Our white-box attacks work by defining an objective function that combines
the model and detector. In an initial attempt, we follow the
approach taken to break the prior detection schemes, let
ğº(ğ‘¥)ğ‘– =
{ï¸ƒ
ğ‘(ğ‘¥)ğ‘– if ğ‘– â‰¤ ğ‘
(1 + ğ‘ˆ(ğ‘¥) âˆ’ ğœ ) Â· max
ğ‘–
ğ‘(ğ‘¥)ğ‘– if ğ‘– = ğ‘ + 1
(where ğ‘ + 1 is the new adversarial class). This objective
function is defined so that if ğ‘ˆ(ğ‘¥) > ğœ (i.e., ğ‘¥ is classified as
adversarial by Feinmanâ€™s defense) then we will have
arg maxğ‘–
(ğº(ğ‘¥)ğ‘–) = ğ‘ + 1,
and if ğ‘ˆ(ğ‘¥) < ğœ (i.e., ğ‘¥ is classified as natural) then
arg maxğ‘–
(ğº(ğ‘¥)ğ‘–) = arg maxğ‘–
(ğ¹(ğ‘¥)ğ‘–).
We then attempt to generated adversarial examples by
applying C&Wâ€™s attack to ğº(Â·). However, this attack fails:
the defense is still able to detect 60% of adversarial examples.
Looking Deeper. We investigate why this attack failed.
Because values of the function ğ‘ˆ(Â·) are computed by calling
ğ¹(Â·) (and not ğ‘(Â·)), there is no good constant ğ‘ that C&Wâ€™s
algorithm can select. This causes gradient descent to perform
poorly and rarely returns successful adversarial examples.
Therefore, for this defense, we abandon the approach of
constructing a single function to optimize over and instead
Session: Deep Learning AISecâ€™17, November 3, 2017, Dallas, TX, USA 11
change the loss function â„“ used by the attack. Recall that the
typical loss function used (for a given network ğ‘(Â·)) is
â„“ğ‘ (ğ‘¥
â€²
) = max(max{ğ‘(ğ‘¥
â€²
)ğ‘– : ğ‘– Ì¸= ğ‘¡} âˆ’ ğ‘(ğ‘¥
â€²
)ğ‘¡, âˆ’ğœ…).
If every prediction ğ¹ğ‘Ÿ(ğ‘¥) of the randomized network produced
a very similar result, the uncertainty value ğ‘ˆ(ğ‘¥) would be
very small.
We sample ğ¾ different deterministic networks {ğ‘ğ‘— (Â·) : ğ‘— âˆˆ
[1, ğ¾]} each with different randomness used during dropout.
If we were able to have arg maxğ‘–ğ‘ğ‘— (ğ‘¥)ğ‘– = ğ‘¡ for every network
ğ‘—, for ğ¾ big enough, it would be highly likely that ğ¹ğ‘Ÿ(ğ‘¥)
would always produce label ğ‘¡ for any randomness. Thus, we
construct a new loss function â„“
â€²
(ğ‘¥
â€²
) = âˆ‘ï¸€ğ¾
ğ‘—=1 â„“ğ‘ğ‘—
(ğ‘¥
â€²
) as the
average of the loss functions on each fixed model ğ‘ğ‘— . Then
we use C&Wâ€™s attack with this revised loss function.
This approach successfully generates adversarial examples
that fool the dropout defense with 98% success. On MNIST,
the mean ğ‘™2 distortion is 3.68, up from the baseline of 2.05.
This is the largest distortion required by any of the defenses
we have evaluated; the distortion here is nearing the levels of
human perceptibility (Figure 1). On CIFAR the distortion
required again increases to 1.1, a factor of 5Ã— larger, but is
still entirely imperceptible (Figure 1).
Limited-Knowledge Attack Evaluation. It turns out that
adversarial examples generated with the white-box approach
transfer with high probability across models. This is due to
the fact that our white-box attack assumes we do not know
the exact randomization settings, and therefore construct
adversarial examples that are effective regardless of randomization. This is similar to the black-box threat model, where
the adversary does not have access to the model parameters.
However, to improve the rate of transferability, we again
construct two models ğ¹(Â·) and ğº(Â·) on different subsets of
the training data. We provide the adversary access to the
parameters of ğ¹ and use the white-box attack above to
generate adversarial examples for ğ¹; we then test whether
they fool ğº.
On MNIST, we find that adversarial examples generated
with our algorithm transfer to ğº with 90% success. We can
increase the transfer rate to 98% at the cost of increasing the
mean distortion only 15%, to 4.23. While this 15% increase
may seem like a failure of this defense under the black-box
threat model, we see this instead as a success of defense
under the white-box threat model. It has made constructing
adaptive white-box attacks nearly as hard as constructing
black-box attacks.
In fact, we find that this is the reason why the CIFAR
network has such a larger increase in distortion: to obtain
transferable cifar adversarial examples requires a distortion
of approximately 4Ã— larger than non-transferable attacks.
We consider this the only defense we evaluate that is not completely broken (even though we still can generate adversarial
examples that are imperceptible on CIFAR).
6.2 Mean Blur
The second detection method proposed by Li et al. applies
a 3 Ã— 3 average filter to blur the image before applying the
classifier. The authors admit this defense is â€œoverly simplisticâ€
but still argue it is effective at alleviating adversarial examples. We confirm this simple defense can remove adversarial
examples generated with fast gradient sign, as they found in
their paper.
Zero-Knowledge Attack Evaluation. When we use C&Wâ€™s
attack, we find that this defense effectively removes lowconfidence adversarial examples: 80% of adversarial examples
(at a mean ğ¿2 distortion of 2.05) are no longer classified
incorrectly.
This attack can even partially alleviate high-confidence
adversarial examples. To ensure they remain adversarial after
blurring, we must increase the distortion by a factor of 3Ã—.
Perfect-Knowledge Attack Evaluation. Observe that taking
the mean over every 3 Ã— 3 region on the image is the same
as adding another convolutional layer to the beginning of
the neural network with one output channel that performs
this calculation. Given the network ğ¹, we define ğ¹
â€²
(ğ‘¥) =
ğ¹(blur(ğ‘¥)) and apply C&Wâ€™s attack against ğ¹
â€²
. When we do
so, we find that the mean distance to adversarial examples
does not increase. Therefore, blurring is not an effective
defense.
7 LESSONS
7.1 Properties of adversarial examples
After examining these ten defenses, we now draw conclusions
about the nature of the space of adversarial examples and
the ability to detect them with different approaches.
Randomization can increase required distortion. By
far the most effective defense technique, dropout randomization, made generating adversarial examples nearly five times
more difficult on CIFAR. In particular, it makes generating
adversarial examples on the network as difficult as generating transferable adversarial examples, a task known to be
harder [29]. Additionally, if it were possible to find a way
to eliminate transferability, a randomization-based defense
may be able to detect adversarial examples. At this time, we
believe this is the most promising direction of future work.
MNIST properties may not hold on CIFAR. Most
defenses that increased the distortion on MNIST had a significantly lower distortion increase on CIFAR. In particular, kernel density estimation, the most effective defense on
MNIST, was completely ineffective on CIFAR.
Detection neural networks can be bypassed. Across
all of the defenses we evaluate, the least effective schemes
used another neural network (or more neural network layers)
to attempt to identify adversarial examples. Given that adversarial examples can fool a single classifier, it makes sense
that adversarial examples can fool a classifier and detector.
Session: Deep Learning AISecâ€™17, November 3, 2017, Dallas, TX, USA 12
Operating on raw pixel values is ineffective. Defenses
that operated directly on the pixel values were too simple
to succeed. On MNIST, these defenses provided reasonable
robustness against weak attacks; however when evaluating
on stronger attacks, these defenses all failed. This should not
be surprising: the reason neural networks are used is that
they are able to extract deep and meaningful features from
the input data. A simple linear detector is not effective at
classification when operating on raw pixel values, so it should
not be surprising it does not work at detecting adversarial
examples. (This can be seen especially well on CIFAR, where
even weak attacks often succeed against defenses that operate
on the input pixel space.)
7.2 Recommendations for Defenses
We have several recommendations for how researchers proposing new defenses can better evaluate their proposals. Many of
these recommendations may appear to be obvious, however
most of the papers we evaluate do not follow any.
Evaluate using a strong attack. Evaluate proposed defenses using the strongest attacks known. Do not use fast
gradient sign or JSMA exclusively: most defenses that detect
these attacks fail against stronger attacks. In particular, Fast
gradient sign was not even designed to produce high-quality
attacks: it was created to demonstrate neural networks are
highly linear. Using these algorithms as a first test is reasonable first step, but is not sufficient. We recommend new
schemes evaluate against strong iterative attacks.
Demonstrate white-box attacks fail. It is not sufficient
to show that a defense can detect adversarial examples: one
must also show that a adversary aware of the defense can
not generate attacks that evade detection. We show how to
perform that kind of evaluation: construct a differentiable
function that is minimized when the image fools the classifier
and is treated as natural by the detector, and apply a strong
iterative attack (e.g., C&Wâ€™s attack) to this function.
Report false positive and true positive rates. When
constructing a detection-based defense, it is not enough to
report the accuracy of the detector. A 60% accuracy can
either be very useful (e.g., if it achieves a high true-positive
rate at a 0% false-positive rate) or entirely useless (e.g.,
if it detects most adversarial images as adversarial at the
cost of many natural images as adversarial). Instead, report
both the false positive and true positive rates. To allow for
comparisons with other work, we suggest reporting at least
the true positive rate at 1% false positive rate; showing a
ROC curve would be even better.
Evaluate on more than MNIST. We have found that
defenses that only evaluated on the MNIST dataset typically
either (a) were unable to produce an accurate classifier on
CIFAR, (b) were entirely useless on CIFAR and were not able
to detect even the fast gradient sign attack, or (c) were even
weaker against attack on CIFAR than the other defenses we
evaluated. Future schemes need to be evaluated on multiple
data sets â€” evaluating their security solely on MNIST is not
sufficient. While we have found CIFAR to be a reasonable
task for evaluating security, in the future as defenses improve
it may become necessary to evaluate on harder datasets (such
as ImageNet [10]).
Release source code. In order to allow others to build
on their work, authors should release the source code of their
defenses. Not releasing source code only sets back the research
community and hinders future security analysis. Seven of
the ten we evaluate did not release their code (even after
contacting the authors), requiring us to reimplement the
defenses before evaluation.
8 CONCLUSION
Unlike standard machine-learning tasks, where achieving a
higher accuracy on a single benchmark is in itself a useful
and interesting result, this is not sufficient for secure machine
learning. We must consider how an attacker might react to any
proposed defense, and evaluate whether the defense remains
secure against an attacker who knows how the defense works.
In this paper we evaluate ten proposed defenses and demonstrate that none of them are able to withstand a white-box
attack. We do this by constructing defense-specific loss functions that we minimize with a strong iterative attack algorithm. With these attacks, on CIFAR an adversary can create
imperceptible adversarial examples for each defense.
By studying these ten defenses, we have drawn two lessons:
existing defenses lack thorough security evaluations, and
adversarial examples are much more difficult to detect than
previously recognized. We hope that our work will help raise
the bar for evaluation of proposed defenses and perhaps
help others to construct more effective defenses. Further, our
evaluations of these defenses expand on what is believed to
be possible with constructing adversarial examples: we have
shown that, so far, there are no known intrinsic properties
that differentiate adversarial examples from regular images.
We believe that constructing defenses to adversarial examples
is an important challenge that must be overcome before these
networks are used in potentially security-critical domains,
and hope our work can bring us closer towards this goal.