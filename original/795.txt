The concept of a blockchain was invented by Satoshi Nakamoto to
maintain a distributed ledger. In addition to its security, important
performance measures of a blockchain protocol are its transaction
throughput and confirmation latency. In a decentralized setting,
these measures are limited by two underlying physical network
attributes: communication capacity and speed-of-light propagation delay. In this work we introduce Prism, a new proof-of-work
blockchain protocol, which can achieve 1) security against up to
50% adversarial hashing power; 2) optimal throughput up to the
capacity C of the network; 3) confirmation latency for honest transactions proportional to the propagation delay D, with confirmation
error probability exponentially small in the bandwidth-delay product CD; 4) eventual total ordering of all transactions. Our approach
to the design of this protocol is based on deconstructing Nakamoto’s
blockchain into its basic functionalities and systematically scaling
up these functionalities to approach their physical limits.
1 INTRODUCTION
In 2008, Satoshi Nakamoto invented the concept of a blockchain,
a mechanism to maintain a distributed ledger in a permissionless
setting. Honest nodes mine blocks on top of each other by solving
Proof-of-Work (PoW) cryptographic puzzles; by following a longest
chain protocol, they can come to consensus on a transaction ledger
that is difficult for an adversary to alter. Since then, many other
blockchain protocols have been invented.

1.1 Performance measures
The fundamental performance measures of a PoW blockchain protocol are:
(1) the fraction β of hashing power the adversary can control without compromising system security, assuming the rest of the
nodes follow protocol;
(2) the throughput λ, number of transactions confirmed per second;
(3) the confirmation latency, τ , in seconds, for a given probability
ε that a confirmed transaction will be removed from the ledger
in the future.
For example, Bitcoin is secure against an adversary holding up to
50% of the total network hash power (β = 0.5), has throughput λ
of a few transactions per seconds and confirmation latency of the
order of tens of minutes to hours. There is a tradeoff between the
confirmation latency and the confirmation error probability: the
smaller the desired confirmation error probability, the longer the
needed latency is in Bitcoin. For example, Nakamoto’s calculations
[16] show that for β = 0.3, while it takes a latency of 6 blocks (on
the average, 60 minutes) to achieve an error probability of 0.15, it
takes a latency of 30 blocks (on the average, 300 minutes) to achieve
an error probability of 10−4
.
1.2 Physical limits
Bitcoin has strong security guarantees but its throughput and latency performance are poor. In the past decade, much effort has
been expended to improve the performance in these metrics. But
what are the fundamental bounds that limit the performance of any
blockchain protocol?
Blockchains are protocols that run on a distributed set of nodes
connected by a physical network. As such, their performance is
limited by the attributes of the underlying network. The two most
important attributes are C, the communication capacity of the network, and D, the speed-of-light propagation delay across the network. Propagation delay D is measured in seconds and the capacity
C is measured in transactions per second. Nodes participating in a
blockchain network need to communicate information with each
other to reach consensus; the capacity C and the propagation delay D limit the rate and speed at which such information can be
communicated. These parameters encapsulate the effects of both
fundamental network properties (e.g., hardware, topology), as well
as resources consumed by the network’s relaying mechanism, such
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 585
as validity checking of transactions or blocks. 1 Assuming that
each transaction needs to be communicated at least once across the
network, it holds that λ, the number of transactions which can be
confirmed per second, is at most C, i.e.
λ < C. (1)
One obvious constraint on the confirmation latency τ is that
τ > D. (2)
Another less obvious constraint on the confirmation latency comes
from the network capacity and the reliability requirement ε. Indeed,
if the confirmation latency is τ and the block size is Bv transactions,
then at most C/Bv · τ mined blocks can be communicated across
the network during the confirmation period for a given transaction.
These mined blocks can be interpreted as confirmation votes for a
particular transaction during this period; i.e. votes are communicated at rate C/Bv and Cτ /Bv votes are accumulated over duration
τ . (The parameter Bv can be interpreted as the minimum block
size to convey a vote.) On average, a fraction β < 0.5 of these
blocks are adversarial, but due to the randomness in the mining
process, there is a probability, exponentially small in Cτ /Bv , that
there are more adversarial blocks than honest blocks; if this happens, confirmation cannot be guaranteed. Hence, this probability
is a lower bound on the achievable confirmation error probability,
i.e. ε = exp(−O(Cτ /Bv )). Turning this equation around, we have
the following lower bound on the latency for a given confirmation
probability ε:
τ = Ω

Bv
C
· log 1
ε

. (3)
Comparing the two constraints, we see that if
CD
Bv
≫ log 1
ε
,
the latency is limited by the propagation delay; otherwise, it is
limited by the confirmation reliability requirement. The quantity
CD/Bv is analogous to the key notion of bandwidth-delay product
in networking (see eg. [11]); it is the number of “in-flight" votes in
the network.
To evaluate existing blockchain systems with respect to these
limits, consider a global network with communication links of
capacity 20 Mbits/second and speed-of-light propagation delay D
of 1 second. If we take a vote block of size 100 bytes, then the
bandwidth-delay product CD/Bv = 25000 is very large. Hence,
the confirmation latency is limited by the propagation delay of 1
seconds, but not by the confirmation reliability requirement unless
it is astronomically small. Real-world blockchains operate far from
these physical network limits. Bitcoin, for example, has λ of the order
of 10 transactions per second, τ of the order of minutes to hours,
and is limited by the confirmation reliability requirement rather
than the propagation delay. Ethereum has λ ≈ 15 transactions per
second and τ ≈ 3 minutes to achieve an error probability of 0.04
for β = 0.3 [4].
1We define confirmation formally in Section 2, but informally, we say a node ε -confirms
a transaction if, upon successfully evaluating a confirmation rule under parameter ε ,
the transaction has a probability of at most ε of being reverted by any adversary.
�(�)
Bitcoin
Prism (order optimal) Latency
Security parameter: log (
)
�(��/�-)
Slope = �(D)
Slope = � /0
1
�(1)
Figure 1: Confirmation latency vs. security parameter for
Prism . The latency of Prism is independent of the security parameter value up to order CD/Bv and increases very slowly
after that (with slope Bv /C). For Bitcoin , latency increases
much more rapidly with the security parameter, with slope
proportional to D. (Since CD/Bv ≫ 1, this latter slope is
much larger.)
1.3 Main contribution
The main contribution of this work is a new blockchain protocol,
Prism, which, in the face of any powerful adversary2 with power
β < 0.5, can simultaneously achieve:
(1) Security: (Theorem 4.3) a total ordering of the transactions,
with consistency and liveness guarantees.
(2) Throughput: (Theorem 4.4) a throughput
λ = 0.9(1 − β)C transactions per second. (4)
(3) Latency: (Theorem 4.8) confirmation of all honest transactions
(without public double spends) with an expected latency of
E[τ ] < max 
c1(β)D,c2(β)
Bv
C
log 1
ε

seconds, (5)
with confirmation reliability at least 1 −ε (Figure 1). Here,c1(β)
and c2(β) are constants depending only on β
Notice that the worst-case optimal throughput of any protocol
with 1 − β fraction of hash power is (1 − β)C transactions/second,
assuming each transaction needs to be communicated across the
network. Hence, Prism’s throughput is near-optimal. At the same
time, Prism achieves a confirmation latency for honest transactions
matching the two physical limits (2) and (3). In particular, if the desired security parameter log 1
ε ≪ CD/Bv , the confirmation latency
is of the order of the propagation delay and independent of log 1/ε.
Put another way, one can achieve latency close to the propagation
delay with a confirmation error probability exponentially small
in the bandwidth-delay product CD/Bv . Note that the latency is
worst-case over all adversarial strategies but averaged over the
randomness in the mining process.
To the best of our knowledge, no other existing PoW protocol has
guaranteed performance which can match that of Prism. Two novel
ideas which enable this performance are 1) a total decoupling of
transaction proposing, validation and confirmation functionalities
in the blockchain, allowing performance scaling; 2) the concept of
confirming a list of possible ledgers rather than a unique ledger,
enabling honest non-double-spend transactions to be confirmed
quickly3
.
2The powerful adversary will be precisely defined in the formal model.
3This idea was inspired by the concept of list decoding from information theory.
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 586
1.4 Performance of existing PoW protocols
High forking protocols. Increasing the mining rate in Bitcoin
can decrease latency and improve throughput, however, this comes
at the expense of decreased security [25]. Thus, unlike Prism, the
throughput and latency of Bitcoin is security-limited rather than
communication-limited. To increase the mining rate while maintaining security, one line of work (GHOST [25], Inclusive [14], Spectre
[23], Phantom [24], Conflux [15]) in the literature has used more
complex fork choice rules and added reference links to convert the
blocktree into a directed acyclic graph (DAG). This allows blocks
to be voted on by blocks that are not necessarily its descendants.
While GHOST remains secure at low mining rates[10], there is
a balancing attack by the adversary [12, 17], which severely limits
the security at high mining rates. Thus, like Bitcoin, the throughput
of GHOST is security-limited. The other protocols Inclusive and
Conflux that rely on GHOST inherit this drawback. While Spectre
and Phantom improve latency and throughput, Spectre cannot provide a total order on all transactions (required for smart contracts)
and Phantom does not yet have a formal proof of security.
Decoupled consensus. Protocols such as BitcoinNG [7] decouple transaction proposal and leader election (which are coupled
together in Bitcoin). BitcoinNG elects a single leader to propose
many transaction blocks till the next leader is elected by PoW. While
this achieves high throughput, the latency cannot be reduced using
this approach. Furthermore, BitcoinNG is vulnerable to bribery
or DDoS attacks, whereby an adversary can corrupt a leader after learning its identity (unlike Bitcoin). Subchains [22] and weak
blocks [2, 26] both employ blocks with lower hash threshold (“weak
blocks”) along with regular blocks in an attempt to scale throughput. However, since weak blocks are required to form a chain, it
does not achieve the optimal throughput.
Hybrid blockchain-BFT consensus. Several protocols combine
ideas from Byzantine fault tolerant (BFT) based consensus into a
PoW setting [1, 13, 20, 21]. ByzCoin [13] and its predecessor DiscCoin [6] attempt to address the latency shortcoming of BitcoinNG
but is proven in a later paper [20] to be insecure when the adversarial fraction β > 0.25. Hybrid consensus uses a combination
of proof-of-work based committee selection with Byzantine fault
tolerance (BFT) consensus [20]. However, this protocol is secure
only till β = 0.33. While the protocol latency is responsive, i.e., it
decreases with network delay linearly, for a known network delay,
it has similar non-optimal dependence on ε as Bitcoin.
A closely-related protocol called Thunderella [21] achieves very
low latency under optimistic conditions, i.e., when the leader is honest and β < 0.25. However even when β is very small, a dishonest
leader can keep delaying transactions to the Bitcoin latency (since
such delaying behavior is detected by a slow PoW blockchain).
1.5 Our Approach
Increasing the mining rate is critical to improving the throughput
and latency of blockchain protocols. The challenges facing the DAG
approaches arise from the fact that the DAG is unstructured, due to
the excessive random forking when the mining rate is increased.
In contrast, Prism is based on a structured DAG created by cryptographic sortition of the mined blocks into different types of different
functionalities and scaling these functionalities separately.
Deconstructing Blockchain
Decoupling Transactions Decoupling Voting
� � � �
L
L
L
L
L
L
L
L
Proposer block
Transaction block
Leader block L
Voter block
Parent Link
Reference Link
Figure 2: Deconstructing the blockchain into transaction
blocks, partially ordered proposal blocks arranged by level,
and voter blocks organized in a voter tree. The main chain
is selected through voter blocks, which vote among the proposal blocks at each level to select a leader block. For example, at level 3, block b is elected the leader over block a.
L
L
L
L
Proposer block
Transaction block
Leader block L
Voter block
Parent Link
Reference Link
Chain 1 Chain 2 Chain �
Figure 3: Prism. Throughput, latency and reliability are
scaled to the physical limits by increasing the number of
transaction blocks and the number of parallel voting chains.
Deconstruction. We start by deconstructing the basic blockchain
structure into its atomic functionalities, illustrated in Figure 2. The
selection of a main chain in a blockchain protocol (e.g., the longest
chain in Bitcoin) can be viewed as electing a leader block among
all the blocks at each level of the blocktree, where the level of
a block is defined as its distance (in number of blocks) from the
genesis block. Blocks in a blockchain then serve three purposes:
they stand for election to be leaders, they add transactions to the
main chain, and they vote for ancestor blocks through parent link
relationships. We explicitly separate these three functionalities
by representing the blocktree in a conceptually equivalent form
(Figure 3). In this representation, blocks are divided into three
types: proposer blocks, transaction blocks and voter blocks. The
voter blocks vote for transactions indirectly by voting for proposer
blocks, which in turn link to transaction blocks . Proposer blocks
are grouped according to their level in the original blocktree, and
each voter block votes among the proposer blocks at the same level
to select a leader block among them. The elected leader blocks can
then bring in the transactions to form the final ledger. The valid
voter blocks are the ones in the longest chain of the voter tree, and
this longest chain maintains the security of the whole system.
Scaling. This alternative representation of the traditional blockchain,
although seemingly more complex than the original blockchain
representation, provides a natural path for scaling performance
to approach physical limits (Figure 3). To increase the transaction
throughput, one can simply increase the number of transaction
blocks that a proposer block points to without compromising the
security of the blockchain. This number is limited only by the physical capacity of the underlying communication network. To provide
fast confirmation, one can increase the number of parallel voting
trees, voting on the proposal blocks in parallel to increase the voting
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 587
rate, until reaching the physical limit of confirming with speed-oflight latency and extremely high reliability. Note that even though
the overall block generation rate has increased tremendously, the
number of proposal blocks per level remains small and manageable, and the voting blocks are organized into many separate voting
chains with low block mining rate per chain and hence little forking.
The overall structure, comprising of the different types of blocks
and the links between them, is a structured DAG.
Sortition. The sortition of blocks into the three types of blocks, and
further into blocks of different voting trees, can be accomplished by
using the random hash value when a block is successfully mined.
This sortition splits the adversary power equally across the structures and does not allow it to focus its power to attack specific
structures. This sortition is similar to the 2-for-1 PoW technique
used in [9], which is also used in Fruitchains [19] for the purpose
of providing fairness in rewards. In fact, the principle of decoupling
functionalities of the blockchain, central to our approach, has already been applied in Fruitchains, as well as other works such as
BitcoinNG. The focus of these works is only on decoupling the
transactions-carrying functionality. In our work, we broaden this
principle to decouple all functionalities.
Concurrent work. We were made aware of two independent but
related works [8, 27] which appeared after we posted this work online. [8] proposes two protocols, one achieves high throughputO(C)
but Bitcoin latency, and the other achieves low latencyO(1/
√
C) but
low throughput O(1). In contrast, Prism achieves simultaneously
high throughput O(C) and even lower latency O(1/C). Although
[8] also uses the concept of multiple chains, the key difference with
Prism is that there is no decoupling: the blocks in each chain both
carry transactions and vote. Thus, either different transactions are
put on the different chains to increase throughput, but the voting
rate is low and hence the latency is poor, or the same transaction
is repeated across all the chains to increase the voting rate, but
the throughput is poor. In contrast, Prism decouples blocks into
transaction blocks and voter blocks, tied together through proposer
blocks, and allocate a fraction of the network capacity to each to
deliver both low latency and high throughput. The protocol in [27]
is similar to first one in [8], achieving high throughput but only
Bitcoin latency.
1.6 Outline of paper
Section 2 presents our model. It is a combination of the synchronous
model used in [9] and a network model that ties the blockchain
parameters to physical parameters of the underlying network. In
Section 3, we give a pseudocode description of Prism. The analysis
of the security, throughput and latency of Prism is outlined in
Section 4 and the outline of the proofs are presented in Appendices
D, E and F. The full proofs can be found in our extended manuscript
due to space constraints [3]. Section 5 contains simulation results.
2 MODEL
We consider a synchronous, round-based network model similar
to that of Garay et al. [9]. We define a blockchain protocol as a
pair (Π,д), where Π is an algorithm that maintains a blockchain
data structure C consisting of a set of blocks. The function д(tx, C)
encodes a ledger inclusion rule; it takes in a transaction tx and a
blockchain C, and outputs д(tx, C) = 1 if tx is contained in the
ledger defined by blockchain C and 0 otherwise. For example, in
Bitcoin, д(tx, C) = 1 iff tx appears in any block on the longest chain.
If there are multiple longest chains, д can resolve ties deterministically, e.g., by taking the chain with the smallest hash value.
The blockchain protocol proceeds in rounds of ∆ seconds each.
Letting κ denote a security parameter, the environment Z(1
κ
) captures all aspects external to the protocol itself, such as inputs to the
protocol (i.e., new transactions) or interaction with outputs.
Let N denote the set of participating nodes. The set of honest
nodes H ⊂ N strictly follow the blockchain protocol (Π, f ). Corrupt nodes N \H are collectively controlled by an adversarial party
A. Both honest and corrupt nodes interact with a random function
H : {0, 1}
∗ → {0, 1}
κ
through an oracle H(x), which outputs H(x).
In each round, each node n ∈ N is allowed to query the oracle H(·)
at most q times. The adversary’s corrupt nodes are collectively allowed up to βq|N | sequential queries to oracle H(·), where β < 0.5
denotes the fraction of adversarial hash power, i.e., 1 −
|H |
|N | = β.
4
Like [9], the environment is not allowed to access the oracle. These
restrictions model the limited hash rate in the system.
In an execution of the blockchain protocol, the environment Z
first initializes all nodes as either honest or corrupt; like [9], once
the nodes are initialized, the environment can adaptively change
the set H between rounds, as long as the adversary’s total hash
power remains bounded by β. Thereafter, the protocol proceeds
in rounds. In each round, the environment first delivers inputs to
the appropriate nodes (e.g., new transactions), and the adversary
delivers any messages to be delivered in the current round. Here,
delivery means that the message appears on the recipient node’s
input tape. Nodes incorporate the inputs and any messages (e.g.,
new blocks) into their local blockchain data structure according to
protocol Π. The nodes then access the random oracle H(·) as many
times as their hash power allocation allows. Hence, in each round,
users call the oracle H(·) with different nonces s in an attempt to
find a valid proof of work. If an oracle call produces a proof of work,
then the node can deliver a new block to the environment. Note
that the computational constraints on calling oracle H(·) include
block validation. Since each block only needs to be validated once,
validation represents a small fraction of computational demands.
Since each node is allowed a finite number of calls to H(x) in each
round, the number of blocks mined per round is a Binomial random
variable. To simplify the analysis, we consider a limit of our model
as the number of nodes |N | → ∞. As |N | grows, the proof-of-work
threshold adjusts such that the expected number of blocks mined
per round remains constant. Hence, by the Poisson limit theorem,
the number of voter blocks mined per round converges to a Poisson
random variable.
All messages broadcast to the environment are delivered by the
adversary. The adversary has various capabilities and restrictions.
(1) Any message broadcast by an honest node in the previous round
must be delivered by the adversary at the beginning of the current
round to all remaining honest nodes. However, during delivery,
the adversary can present these messages to each honest node in
whatever order it chooses. (2) The adversary cannot forge or alter
4β for bad. Like [9], we have assumed all nodes have the same hash power, but this
model can easily be generalized to arbitrary hash power distributions.
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 588
any message sent by an honest node. (3) The adversary can control
the actions of corrupt nodes. For example, the adversary can choose
how corrupt nodes allocate their hash power, decide block content,
and release mined blocks. Notably, although honest blocks publish
mined blocks immediately, the adversary may choose to keep blocks
they mined private and release in future round. (4) The adversary
can deliver corrupt nodes’ messages to some honest nodes in one
round, and the remaining honest nodes in the next round. We
consider a “rushing” adversary that observes the honest nodes’
actions before taking its own action for a given round. Notice that
we do not model rational users who are not necessarily adversarial
but nevertheless may have incentives to deviate from protocol.
Physical Network Constraints. To connect to the physical parameters of the network, we assume a simple network model. Let B be
the size of a block, in units of number of transactions. The network
delay ∆ (in seconds) is given by:
∆ =
B
C
+ D (6)
i.e. there is a processing delay of B/C followed by a propagation
delay of D seconds. This is the same model used in [25], based on
empirical data in [5], as well in [22]. Notice that the network delay
∆ is by definition equal to the duration of a single round.
In practice, networks cannot transport an infinite number of
messages at once. We model this by allowing the environment to
transport only a finite volume of messages per round. This volume is parametrized by the network capacity C, measured in units
of transactions per second. Hence, during each round, the environment can process a message volume equivalent to at most ∆C
transactions. This puts a constraint on the number of blocks mined
per unit time in any protocol. This stability constraint differentiates our model from prior work, which has traditionally assumed
infinite network capacity; in particular, this gives us a foothold for
quantifying physical limits on throughput and latency.
For simplicity, we assume that the dissemination of new transactions consumes no bandwidth. Instead, the cost of communicating
transaction messages is captured when the environment transmits
blocks carrying transactions. In other words, we assume that the
cost of transmitting transactions is counted only once.
Metrics. We let random variable VIEWΠ, A, Z denote the joint
view of all parties over all rounds; here we have suppressed the
dependency on security parameter κ. The randomness is defined
over the choice of function H(·), as well as any randomness in the
adversary A or environment Z. Our goal is to reason about the
joint view for all possible adversaries A and environments Z. In
particular, we want to study the evolution of C
r
i
, or the blockchain
of each honest node i ∈ H during round r. Following the Bitcoin
backbone protocol model [9], we consider protocols that execute
for a finite execution horizon rmax, polynomial in κ. Our primary
concern will be the efficiency of confirming transactions.
Definition 2.1. We say a transaction tx is (ε, A, Z,r0,κ)-cleared
iff under an adversary A, environment Z, and security parameter κ,
PVIEWΠ,A,Z
©
­
­
­
«
Ù
r ∈ {r0,...,rmax }
i ∈H

д(tx, C
r
i
) = b
	
ª
®
®
®
¬
≥ 1 − ε − negl(κ),
G G
Proposer blocktree Voter blocktree � Proposer block
Voter block
Voter block mined
Votes
Proposer block mined
�#$% Reference Link
Transaction block
Trans. block mined
Parent blocks
�(
�)
�#$%
(
Figure 4: Snapshot of a miner’s blocktree: The previously
mined blocks have solid boundary whereas blocks which
are being mined have dotted-boundary. A miner simultaneously mines on p1, parent on proposer blocktree, v
i
, parent
on voter block blocktree i(∀i ∈ [m]).
where b ∈ {0, 1}; b = 1 corresponds to confirming the transactions
and b = 0 corresponds to rejecting the transaction.
That is, a transaction is considered confirmed (resp. rejected) if
all honest party will include (resp. exclude) it from the ledger with
probability more than ε plus a term negligible in κ resulting from
hash collisions, which we ignore in our analysis. We suppress the
notation κ from here on.
Our objective is to optimize two properties of a blockchain protocol: the throughput and latency of confirming transactions. We
let |S | denote the number of elements in set S. We let T denote the
set of all transactions generated during the execution horizon, and
T
r denote all transactions delivered up to and including round r.
Definition 2.2 (Throughput). We say a blockchain protocol
Π supports a throughput of λ transactions per round if there exists
Uε ,linear in log(1/ε), such that for all environments Z that produce
at most λ transactions per round, and for ∀ r ∈ [1,rmax],
max
A



tx ∈ Tr
: tx is not (ε, A, Z,r)-cleared	
 < λUε . (7)
The system throughput is the largest throughput that a blockchain
protocol can support.
Notice that although |Tr
| grows with r, the right-hand side of
(7) is constant in r; this implies that the system throughput λ is
the expected rate at which we can clear transactions maintaining
a bounded transaction queue, taken worst-case over adversary A
and environments Z producing at most λ∆ transactions per round.
Definition 2.3 (Latency). For a transaction tx, let r(tx) denote
the round in which the transaction was first introduced by the envioronment, and let random variable Rε (tx) denote the smallest round
r for which tx is (ε, A, Z,r)-cleared. The expected ε-latency of transaction tx is defined as:
τε (tx) ≜ max
Z, A
EVIEWΠ,A,Z
[Rε (tx) − r(tx)]
(8)
Note that if all transactions have finite ε-latency, it implies that
the blockchain has both consistency and liveness properties.
3 PROTOCOL DESCRIPTION
We first describe the content and roles of three types of blocks in
the Prism(Π,д) blockchain. We then present Algorithm 1, which
defines the protocol Π and the blockchain data structure C. We
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 589
then define the ledger inclusion rule, д, in Algorithm 2. Due to space
constraints, all pseudocode for these algorithms can be found in
Appendix A. Prism’s blockchain data structure, C, has one proposer
blocktree and m voter blocktrees, as shown in Figure 3. We use
these different blocktrees to maintain three distinct types of blocks:
Proposer blocks: Proposer blocks represent the skeleton of the
Prism blockchain and are mined on the proposer blocktree according to the longest-chain rule. The level of a proposer block is defined
as its distance from the proposer genesis block. The blocktree structure is only utilized in our protocol as a proof of level of a given
proposal block. To construct the ledger, our protocol selects proposal block sequences where one block is chosen at each level.
Proposer blocks can refer to transaction blocks and other proposer
blocks by including pointers to referred blocks in their payload. For
example, in Fig 4, the proposer blocktree has two proposer blocks
mined at level 1, and one proposer block mined at levels 2 and 3,
and they point to five transaction blocks in total.
Voter blocks: Voter blocks are mined on m separate voter blocktrees, each with its own genesis block, according to the longest
chain rule. We say a voter block votes on a proposer block B if it
includes a pointer to B in its payload. Note that unlike many BFT
consensus protocols, a malicious miner in Prism cannot equivocate
when voting because voter blocks are sealed by proof of work. Even
if a miner mines conflicting voter blocks and tries to send them
to disjoint sets of honest users, all users will receive both blocks
within one round. Each longest chain from each voter blocktree
can cast at most one vote for each level in the proposer blocktree.
More precisely, a voter block votes on all levels in the proposer
tree that are unvoted by the voter block’s ancestors. Therefore,
the voter trees collectively cast at most m votes on a given level
of the proposer blocktree. Fig. 3 shows voter blocktree i and its
votes (dotted arrows) on each level of the proposer blocktree. For
each level ℓ on the proposer blocktree, the block with the highest
number of votes is defined as the leader block of level ℓ.
Transaction blocks: Transaction blocks contain transactions and
are mined on the proposer blocktree as in Fig. 3. Although transaction blocks are not considered part of the proposer blocktree, each
transaction block has a proposer block as its parent.
The process by which a transaction is included in the ledger is
as follows: (1) the transaction is included in a transaction block BT .
(2) BT is referred by a proposer block BP . (3) Proposer block BP is
confirmed, either directly (by becoming a leader) or indirectly (e.g.,
by being referred by a leader).
3.1 Protocol Π
Algorithm 1 presents Prism’s protocol Π. The protocol begins with
a trusted setup, in which the environment generates genesis blocks
for the proposer blocktree and each of the m voter blocktrees. Once
the trusted setup completes, the protocol enters the mining loop.
Whereas Bitcoin miners mine on a single blocktree, Prism miners simultaneously mine one proposer block, one transaction block,
and m voter blocks, each with its own parent and content. This
simultaneous mining happens via cryptographic sortition. Roughly,
a miner first generates a “superblock” that contains enough information for all m + 2 blocks simultaneously. It then tries different
nonce values; upon mining a block, the output of the hash is deterministically mapped to either a voter block (in one of the m trees),
a transaction block, or a proposer block (lines 41-47 in Algorithm
1). After sortition, the miner discards unnecessary information and
releases the block to the environment.
More precisely, while mining, each miner maintains outstanding
content for each of the m + 2 possible mined blocks. In Bitcoin, this
content would be the transaction memory pool, but since Prism
has multiple types of blocks, each miner stores different content for
each block type. For transaction blocks, the content consists of all
transactions that have not yet been included in a transaction block.
For proposer blocks, the content is a list of transaction blocks and
proposer blocks that have not been referred by any other proposer
block. For voter blocks in the ith voter tree, the content is a list
of proposer blocks at each level in the proposer blocktree that has
not yet received a vote in the longest chain of the ith voter tree.
If a miner observes multiple proposer blocks at the same level, it
always votes on the first one it received. For example, in Figure
4, voter block v
i
new votes on one proposer block on levels 3 and 4
because its ancestors have voted on level 1 and 2.
Upon collecting this content, the miner generates a block. Instead
of naively including all them+2 parents5
and content hashes in the
block, Prism’s header contains a) the Merkle root of a tree withm+2
parent blocks, b) the Merkle root of a tree with m + 2 contents, and
c) a nonce. Once a valid nonce is found, the block is sortitioned into
a proposer block, a transaction block, or a voter block on one of the
m voter trees. The mined, sortitioned block consists of the header,
the appropriate parent and content, and their respective Merkle
proofs. For instance, if the mined block is a proposer block, it would
contain only the proposer parent reference, proposer content, and
appropriate Merkle proofs; it would not store transactions or votes.
While mining, nodes may receive blocks from the network,
which are processed in much the same way as Bitcoin. Upon receiving a new block, the miner first checks validity. A block B is valid if
it satisfies the PoW inequality and the miner has all the blocks (directly or indirectly) referred by B. If the miner lacks some referred
blocks, it requests them from the network. Upon receiving a valid
transaction block B, the miner removes the transactions in B from
its transaction pool and adds B to the unreferred transaction block
pool. Upon receiving a valid voter block, the miner updates the
longest chain if needed, and updates the vote counts accordingly.
Upon receiving a valid proposer block B at a level ℓ higher than the
previous highest level, the miner makes B the new parent proposer
block, and updates all m voter trees to vote on B at level ℓ.
3.2 Ledger confirmation rule д
As defined before, the proposer block with the most votes on level ℓ
is defined as the leader block of level ℓ. The leader block for a fixed
level ℓ can initially fluctuate when the voter blocktrees start voting
on level ℓ. However, as the voter blocktrees grow, these votes on
level ℓ are cemented deeper into their respective voter blocktrees
and the leader fluctuation ceases and thus we can confirm the leader
block at level w.h.p. The sequence of leader blocks for each level of
the proposer blocktree is defined as the leader sequence.
5Proposer and tx block share the same parent and are included twice for simplicity.
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 590
(b) Transaction
block ordered list
(a) Leader Blocks +
Transaction blocks
(c) Ordered
transactions
Step 1 Step 2
Propose block
Reference Link
Transaction blocks
Epochs
Figure 5: BuildLedger(): The proposer blocks for a given
proposer block sequence are blue, and the referenced transaction blocks are green. Each shade of gray region is all the
tx blocks referred by the proposer block.
Confirmation and Ordering: A set of transactions can often be
individually confirmed before being ordered among themselves.
For this reason, confirming transactions is easier than ordering
the transactions. For example, consider the following two transactions a) Alice pays Bob $10, and b) Carol pays Drake $10. Both
these transactions can be individually confirmed without deciding
which transaction occurred first. In Bitcoin, transactions are simultaneously confirmed and ordered; however, in Prism, transactions
can be confirmed before being ordered. The procedure IsTxConfirmed() in Algorithm 2 defines the transaction confirmation rule
д and the procedure GetOrderedConfirmedTxs() defines the rule
for ordering the confirmed transactions. Both these procedures use
BuildLedger() which is described next.
BuildLedger(): Given a proposer block sequence from levels 1
to ℓ, {p1, · · · ,pℓ }, represented by blue blocks in Fig. 5(a). Let Lpi
,
represented by green blocks in the grey shaded area in Fig. 5(a), be
an ordered list of all the transaction blocks directly or indirectly
referred by block pi
. Note that a transaction block t is indirectly referred by proposer block pi
if pi
includes a reference link to another
proposer block p
′
that directly referst. Since honest proposer blocks
link to any unreferenced transaction blocks and proposer blocks,
this ensures that the transaction blocks not referred by the proposer
leader sequence are also included in the ledger. Let {Lp1
, · · · , Lpℓ
}
be the transaction block list of sequence {p1, · · · ,pℓ } as shown in
Fig. 5(b). The procedure then expands this transaction-block list and
remove all the duplicate and double-spent transactions to output
ordered-transaction list as shown in Fig. 5(c).
IsTxConfirmed(): While confirming a leader block can take
some time6
, we quickly narrow down a set of proposer blocks,
defined as proposer-set, which is guaranteed to contain the leader
block for that level. The proposer-set is realized using Def. (4.5).
This procedure first gets all the votes from the voter trees and then
gets the proposer-set for each level from the genesis to the last level
for which the proposer-set can be realized (lines:5-9). It then takes
the outer product of these proposer-sets and enumerates many
proposer block sequences (line:11). Note that by design, one of
these sequences will be the leader block sequence in the future. It
then builds a ledger for each proposer block sequence and confirms
the transaction if it is present in all of the ledgers (lines:12-14).
GetOrderedConfirmedTxs(): First obtain a leader block for
each level on proposer blocktree from genesis up until the level
which has a confirmed leader block (line:40). Then return the ledger
built from these leader blocks.
6
In absence of an active attack, it will be fast, as described in Section 4.
4 ANALYSIS
In this section, we analyze three aspects of Prism: security, throughput, and latency. Before listing the formal guarantees satisfied by
Prism, we first describe at an intuitive level why Prism is able to
achieve good latency without sacrificing security.
4.1 Intuition and Sketch of Proofs
In the longest-chain protocol, for a fixed block size and network,
the maximum tolerable adversarial hash power β is governed by the
block production rate; the faster one produces blocks, the smaller
the tolerable β [9, 18]. In Prism, we need to be able to tolerate
β adversarial hash power in each of the voter trees and and the
proposer tree. Hence, following the observations of [9, 18] each of
these trees individually must operate at the same rate as a single
longest-chain blocktree in Bitcoin in order to be secure.
The security of Prism is provided by the voter trees; a proposer
block is confirmed by votes which are on the longest chains of
these voter trees. Consider a conservative confirmation policy for
Prism, where we wait for each vote on each voter tree to reach a
confirmation reliability 1 −ε before counting it. This would require
us to wait for each vote to reach a depth of k(ε) in its respective tree,
where k(ε) denotes the confirmation depth for reliability 1 −ε. This
conservative confirmation rule immediately implies that Prism has
the same security guarantee as that of each of the voter tree, i.e. that
of Bitcoin. However, this rule has as poor a latency as Bitcoin’s. For
example, for ε = 10−3
and the tolerable adversary power β = 0.3,
the vote has to be 24 blocks deep [16]. With a more intelligent
transaction confirmation rule, we can do far better. The key insight
is that even though each vote individually stabilizes at the same
rate at Bitcoin (i.e., slowly), the aggregate opinion can converge
much faster because there are many voter trees.
Public blocks
Private blocks
List of confirmed
proposer blocks
�
�
Honest prop block
Adversarial prop block
�
Level 1
�
TB
(a)
�#
�$
�#
Level 1
Level 2
�
�
TB
(b)
Figure 6: (a) Transaction block is referred to by an isolated
honest proposer block. (b) Transaction block is referred to
by a non-isolated proposer block but on the next level there
is an isolated proposer block. Note that the link from H2
to TB is implicit; since H2 is honest, it refers to all unreferenced transaction and proposer blocks, i.e., H1 and A1. Since
H1 refers TB, H2 implicitly does too (Section 3.2)
.
4.1.1 Case 1: Isolated Proposer Block
Consider first the situation when a transaction block TB is referred
to by a honest proposer block H which is currently isolated at its
level, i.e. no other public proposal block exists at the same level for
a certain fixed number of rounds. See Figure 6(a). This case is quite
common since the mining rate of the proposer blocks is chosen
such that there is little forking in the proposer tree. Block H will
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 591
start collecting votes, each of which is on the longest chain of its
respective voter tree. Over time, each of these votes will become
deeper in its voter chain. An attack by the adversary is to mine a
private proposal block A at the same level, and on each of the voter
trees fork off and mine a private alternate chain and send its vote
to the block A. After leader block H is confirmed, the adversary
continues to mine on each of the voter alternate chains to attempt
to overtake the public longest chain and shift the vote from H to A.
If the adversary can thereby get more votes on A than on H, then
its attack is successful.
This can be viewed as the m-chain analog to Nakamoto’s private
attack on a single chain [16], where instead of having one race
between the honest chain and the attack chain we have m such
races. In fact, Nakamoto’s calculations on the success probability of
an attack on a single chain can help us determine how deep we need
to wait for the votes to become to confirm the proposer block H.
At tolerable adversary power β = 0.3, the reversal probability in a
single chain is 0.45 when a block is 2-deep [16]. Withm = 1000 voter
chains and each vote being 2-deep, the expected number of chains
that can be reversed by the adversary is 450. The probability that
the adversary got lucky and can reverse more than half the votes,
i.e. 500, is about 10−3
. Hence to achieve ε = 10−3
, we only need to
wait for 1000 votes each 2-deep. This incurs much shorter latency
than the 24 block depth needed for each vote to be reversed with
probability 10−3
. This reduction in latency is conceptually similar
to averaging many unreliable classifiers to form a strong aggregate
classifier: the more voter chains there are, the less certainty of
permanence each individual vote needs to be, thereby reducing
confirmation time. This gain comes without sacrificing security:
each voter chain is operating slowly enough to tolerate β adversarial
hash power.
Just like Nakamoto’s private attack, the attack considered here
is a particular attack. Our formal security analysis, sketched in
Section 4.1.3, consider all possible attacks in the model. In particular,
the attacker can correlate its actions on the different voter chains.
However, the confirmation latency behaves similarly to the latency
under this attack.
4.1.2 Case 2: Non-isolated Proposer Block
Consider now the case when the the transaction block TB is referred
to by a honest proposal block H1 which is not isolated at its level,
i.e. H1 is matched by an adversarial public proposer block A1 (the
competing proposer block could also be honest). This matching
could persist for L levels until reaching a level when there is an
isolated honest proposal block. See Figure 6(b) for the special case
of L = 1. Let us separately consider the life cycle of an honest
transaction vs. a double-spent one.
Honest Transaction:A naive approach for confirming TB would
be to wait until we can definitively confirm H1 or A1. However, this
may be slow because of adversarial attacks that try to balance votes.
A key insight is that for honest (non-double-spent) transactions, we
do not need to know which of H1 and A1 is confirmed—only that
one of them will be confirmed. This weaker form of list confirmation works because if A1 eventually gets confirmed, a later honest
proposer block can still refer to H1 and include TB (Section 3.2). To
confirm an honest transaction at level i, we need two events: (1) list
confirmation of all levels up to i; (2) an isolated honest proposer
at level i. Once we have list-confirmed a set of proposer blocks
at level i referring TB (e.g., either H1 or A1 will be the leader), we
know that no other block can be the leader at that level. However,
list confirmation alone is not enough for honest transaction confirmation if the transaction is not present in all ledgers. In that case,
we also need to wait for an isolated honest proposer level, where
the proposer block will implicitly or explicitly include TB in the
ledger. Once this isolated honest proposer level is confirmed and
all the preceding levels are list-confirmed, we can be sure that TB
will appear in the final ledger. The confirmation latency is thus the
maximum of two parts:
(1) List confirmation. We fast confirm that the adversary cannot
produce a private block A with more votes than the votes of public
blocks H1 and A1. The logic is similar to the case of isolated honest
proposer block discussed above, viewing the situation as a race
between honest nodes voting for the public blocks H1 or A1 and
adversary voting for A. Adversarial actions (e.g., presenting first
H1 to half the honest nodes and A1 to the other half) can cause the
number of votes to be evenly split between H1 and A1, which can
slow down list confirmation, albeit not significantly.
(2) Isolated honest proposer level. In Figure 6(a), if we wait until
level 2, we see an isolated public proposer block H2 which can be
fast confirmed (Section 4.1.1). At this point, we know that the final
leader sequence at levels 1, 2 is either H1,H2 or A1,H2, both of
which contain our honest transaction since H2 refers to all previous
unreferred proposer blocks. Since isolated honest proposer blocks
happen frequently (Section 4.1.3), this step is fast.
Double-Spent Transaction: To confirm double-spent transactions, we need stronger conditions than those listed above: namely,
instead of list confirmation, we need unique block confirmation,
confirming which block at a proposer level will be the ultimate
leader. This is achieved once list confirmation occurs and one of
the list-confirmed blocks can be reliably declared the winner. If one
of the public proposer blocks H1 or A1 gathers many more votes
than the other block, then we can fast confirm a unique leader, even
for double-spent transactions; this happens both in the absence of
active attacks and under some classes of attacks (Section 5). However, other adversarial attacks (such as balancing the votes on H1
and A1) can cause the number of votes to be evenly split between
H1 and A1, so we cannot fast confirm a leader block. In this case,
we must wait until every vote on H1 and A1 stabilizes, in which
case either H1 or A1 is confirmed and only one of the double-spent
transactions is accepted. A content-dependent tie breaking rule can
be used to break ties after votes are stabilized.
4.1.3 Sketch of Security and Latency Proofs
CP: Leader sequence
Voter blocktrees
1 2 �
. . . . . .
Bitcoin backbone Common Prefix (CP) Chain Quality (CQ)
Proposer blocktree
CP CQ CP CQ CP CQ
CQ: Leader sequence
Figure 7: Common-prefix and chain-quality properties of
voter chains imply common-prefix and chain-quality properties of the proposer leader sequence.
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 592
We next provide a sketch of the proof structure. Due to space constraints, the outline of the proofs are presented in Appendices D,
E, and F; all full proofs can be found in our extended technical
report [3]. To translate the above intuitive arguments into formal
security and latency proofs, we borrow key ideas from [9], but
also require several new insights. [9] proves the consistency and
liveness of the Bitcoin backbone protocol by first proving two key
properties: common-prefix and chain-quality. Similarly, to show
that Prism achieves consistency and liveness, we need to show that
the proposer leader sequence satisfies these properties. The results
of [9] do not directly apply because the proposer leader sequence
is not determined by a single longest-chain protocol; rather, it is
determined by a combination of the proposer tree and the aggregate
voter tree votes. As shown in Figure 7, we prove the two properties for the proposer and the voter trees and use them to prove
corresponding properties for the leader sequence. Specifically:
(1) Each voter tree is constructed according to the backbone
protocol, and hence satisfies the chain-quality and common-prefix
property. Chain-quality of the voter trees implies that honest nodes
will continually be able to vote for proposer blocks from every voter
tree and at every proposer level . Common-prefix implies that all
these votes will eventually stabilize. This further implies that the
leader sequence satisfies the common-prefix property (Theorem
4.1), since the leader block at each level will eventually stabilize.
Hence, the resulting ledger is consistent. The leader-sequence also
can be shown to have a certain chain quality (Lemma D.6) and this
ensures liveness of the ledger (Theorem 4.2).
(2) To show fast confirmation of all honest transactions, we follow the intuitive arguments above. We first show that an isolated
proposer block, or an honest proposer block that does not have a
competing adversarial proposer block for a certain duration of time,
appears in constant expected time (independent of ε). Specifically,
the honest users are mining proposer blocks at the rate (1 − β)
¯fp
whereas the adversary is mining at rate β
¯fp . Since β < 0.5, the adversary is mining slower than the honest users, and within the next
1
1−2β
levels in expectation, there is a level on which the adversary
cannot immediately create a competing block with the honest block
7
. Similarly, an isolated level on which the adversary cannot match
the honest block for next R rounds after the honest block is mined
happens within 1+2R ¯fv
1−2β
levels in expectation.
(3) We next show that we can fast confirm an isolated public
honest proposer block. The argument has two parts: i) the isolated
honest block wins enough votes; 2) the leader block persists, i.e.,
wins the vote race against a private adversarial proposer block
for all time. The first part follows from the chain-quality of the
voter chains, which ensures that there is a steady stream of honest
votes for the public proposer block until it gathers a sufficiently
large fraction of total votes (Lemma E.7). The second part follows
from common-prefix of the voter trees, which ensures that a large
fraction of votes cannot be reversed by the adversary (Lemma E.9).
(4) Fast list confirmation of proposer blocks at all previous levels
can be proved similarly (see Lemma E.10 and Theorem 4.6). Now,
Prism ensures that at each proposer level, one of the list-confirmed
blocks will remain in the ledger. This, combined with the assurance
that every transaction will be either directly or indirectly referred by
7Random walk analysis
the isolated proposal block, ensures that all honest transactions are
entered into the ledger. This lets Prism confirm honest transactions
within a short time (see Theorem 4.7).
Note that [9] proves the k-common-prefix property is satisfied
with high probability only for large k. Similarly, chain-quality is
shown to be satisfied with high probability only over a large number
of blocks. While this is sufficient to prove (1) and (2) above for the
consistency and liveness of the eventual ledger, it is not sufficient to
prove (4) and (5) for fast confirmation latency, since we need these
two properties over short latencies, i.e. windows of few blocks. In
these small time windows, these properties do not hold with high
probability microscopically, for every individual voter tree. However,
since the proposer leader block depends only on the macroscopic
vote counts, we only need to show that these properties hold with
high probability macroscopically, for a good fraction of voter trees.
4.2 Parameter Selection
We first specify the parameters of Prism in terms of the parameters
of the physical network. First, recall that the network delay of a
block containing B transactions is given by ∆ =
B
C
+ D. Let Bt
,
Bv , and Bp be the size of transaction, voter, and proposer blocks
respectively, in units of number of transactions. The network delays
∆t
, ∆v , and ∆p for each type of block are thus given by:
∆t =
Bt
C
+ D, ∆v =
Bv
C
+ D, ∆p =
Bp
C
+ D. (9)
Given that different block types have different sizes and network
delays, what is a reasonable choice for ∆, the duration of a round?
Since the synchronous model is used for security analysis, and
the security of Prism depends only on the network delay of the
proposer and voter blocks but not of the transaction blocks, we
choose: ∆ = max{∆p, ∆v }. Moreover, the voter blocks and the
proposer blocks contain only reference links and no transactions,
so their sizes are expected to be small. Assuming the bandwidthdelay product CD/max{Bv , Bp } ≫ 1, we have that the network
delay ∆ = max{
Bv
C
,
Bp
C
} + D ≈ D, the smallest possible.
To provide security, we set the mining rate ¯fv := fvD on each
voter tree such that each voter tree is secure under the longest
chain rule. According to [9] it should satisfy
¯fv <
1
1 − β
log 1 − β
β
. (10)
We also set the proposer and voter mining rates to be the same, i.e.
fp = fv . This is not necessary but simplifies the notation.
Third, to utilize 90% of the communication bandwidth for carrying transaction blocks, we set ft Bt = 0.9C. The individual choices
of ft and Bt are not very important, but choosing large Bt and
small ft
is preferable to ensure that the number of reference links
to transaction blocks per proposer block is small, thus giving a
small proposer block size Bp .
Finally, speed up voting, we maximize the number of voter chains
subject to the stability constraint of Sec. 2: fpBp+m fv Bv+ft Bt < C.
Substituting the values of fv , fp and ft Bt
, we get
m =
0.1CD
¯fv Bv
−
Bp
Bv
≥
(1 − β)
log(
1−β
β
)
·
CD
Bv
−
Bp
Bv
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 593
i.e. the number of voter trees is at least proportional to CD/Bv , the
bandwidth-delay product in unit of voting blocks. This number is
expected to be large, which is a key advantage. The only degree of
freedom left is the choice of ¯fv , subject to (10). We will return to
this issue in Section 4.5 when we discuss fast confirmation latency.
4.3 Total Ordering
In this subsection, we show that Prism can achieve total transaction
ordering for any β < 0.5 using the procedure GetOrderedConfirmedTxs() in Algorithm 2. That is, as long as the adversary’s
hash power is less than 50%, transactions can be ordered with consistency and liveness guarantees. Following [9], we do so by first
establishing two backbone properties: common-prefix and chain
quality of the proposer leader sequence. Let P(r) denote the set of
proposer blocks mined by round r. Let Pℓ
(r) ⊆ P(r) denote the
set of proposer blocks mined on level ℓ by round r. Let the first
proposer block on level ℓ be mined in round Rℓ
. Let Vp (r) denote
the number of votes on proposer block p ∈ P(r) at round r. Recall that only votes from the main chains of the voter trees are
counted. The leader block on level ℓ at round r, denoted by p
∗
ℓ
(r),
is the proposer block with maximum number of votes in the set
Pℓ
(r) i.e, p
∗
ℓ
(r) := argmax
p ∈Pℓ (r)
Vp (r), where tie-breaking is done in a
hash-dependent way. The leader sequence up to level ℓ at round r,
denoted by LedSeq ℓ
(r) is:
LedSeq ℓ
(r) := [p
∗
1
(r),p
∗
2
(r), · · · ,p
∗
ℓ
(r)]. (11)
The leader sequence at the end of round rmax, the end of the
horizon, is the final leader sequence, LedSeq ℓ
(rmax).
Theorem 4.1 (Leader seqence common-prefix property).
Suppose β < 0.5. For a fixed level ℓ, we have
LedSeq ℓ
(r) = LedSeq ℓ
(rmax) ∀r ≥ Rℓ + r(ε) (12)
with probability 1 − ε, where r(ε) =
1024
¯fv (1−2β)
3
log 8mrmax
ε
, and Rℓ
is
the round in which the first proposer block on level ℓ was mined.
Proof. See Appendix D. □
Theorem 4.2 (Liveness). Assume β < 0.5. Once a transaction
enters into a transaction block, w.p 1 − ε it will eventually be pointed
to by a permanent leader sequence block after
O

log(1/ε)
(1 − 2β)
4

rounds.
Proof. See Appendix D. □
Theorems 4.1 and 4.2 yield the following:
Theorem 4.3. The ledger has consistency and liveness with the expected ε-latency for all transactions (Def. 8) to be at mostO (log(1/ε))
for β < 0.5.
4.4 Throughput
We now analyze the transaction throughput of Prism. The leader
sequence blocks of Prism orders all the transactions in the transaction blocks they refer to. Due to liveness, all transaction blocks are
referred to by some proposer blocks. Since the transaction block
generation rate ft Bt
is chosen to be 0.9C transactions per second,
Adversary: �
0.9�
Throughput
1 −
0.9(1 − �)�
1
�
�
0.49 0.5
Bitcoin
Prism
Bitcoin operating
point
0.05�
Ghost
Figure 8: Throughput versus β tradeoffs of Prism, Bitcoin and
GHOST. The tradeoffs for the baseline protocols are upper
bounds, while that for Prism is exact.
assuming a worst case that only honest blocks carry transactions
yield a throughput of 0.9(1 − β)C transactions per seconds.
This seems to give the advertised goal, but there is a catch: blocks
mined in the same round may contain the same transactions, since
transactions are broadcast to the entire network. To achieve the
full throughput, one can minimize the transaction redundancy in
the blocks by scheduling different transactions to different blocks.
Concretely, we split the transactions randomly into q queues, and
each honest block is created from transactions drawn from one
randomly chosen queue. Thinking of each transaction queue as a
color, we have transaction blocks of q different colors.
We will only have honest blocks with redundant transactions
if two or more blocks of the same color are mined in the same
round. The number of honest blocks of the same color mined at
the same round is distributed as Poisson with mean (1 − β)ft ∆/q,
and so the throughput of non-redundant blocks of a given color
is the probability that at least one such block is mined in a round,
i.e. 1 − e
−(1−β)ft ∆/q blocks per round. The total throughput of
non-redundant honest blocks of all colors is
q
h
1 − e
−(1−β)ft ∆/q
i
blocks per round. (13)
For large q, this approaches (1 − β)ft ∆ blocks per round, which
equals 0.9(1 − β)C transactions per second when we set ft =
0.9C/Bt
. Thus, we achieve the claimed result (4).
Theorem 4.4 (Throughput). Theorem 4.8 guarantees that all
the transactions proposed before round r −O (log(1/ε)) are confirmed
by round r. Therefore Prism can support λ = 0.9(1 − β)C throughput
(Def. 7), where Uε = O (log(1/ε)).
Note that the throughput of Prism as a fraction of capacity does
not vanish as β → 0.5, unlike Bitcoin (Figure 8). Indeed, in order
for Bitcoin to be secured against Nakamoto’s private attack [16] in
that regime, it is necessary that f ∆, the expected number of blocks
mined per network delay round, approaches 0 so that very little
forking occurs among the honest nodes and the honest nodes can
grow the longest chain faster than the adversary. Note that for a
given block size B, the throughput is bounded by:
f B = f ∆ · B/∆ = f ∆ · B/(B/C + D) < f ∆C tx/second
Hence, in the regime where β → 0.5, Bitcoin can only achieve a
vanishing fraction of the network capacity. Because the mining rate
of GHOST is similarly security-limited, its throughput has similar
behavior as Bitcoin (see [12] and Appendix I in [3]).
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 594
# Votes
Private hidden block
�" �# �$ �% �& �'()*+,-
Πℓ(�) : Confirmed proposer list
V1(r)
Blocks
Vn(r)
V n(r)
Vn(r)
Figure 9: Public proposer block p1 has the largest lower confidence bound, which is larger than the upper confidence
bound of the private block. So list confirmation is possible
and the set confirmed is Πℓ
(r) = {p1,p2,p3}.
4.5 Fast confirmation latency
4.5.1 List confirmation latency
We convert the intuition from Section 4.1 to a formal rule for fast
confirming a set of proposer blocks, which enables confirming a
list of proposer sequences. The idea is to have confidence intervals
around the number of votes cast on each proposer block. Figure
9 gives an example where there are 5 proposal blocks in public
at a given level, and we are currently at round r. The confidence
interval [Vn
(r),Vn(r)] for the votes on proposer block pn bounds
the maximum number of votes the block can lose or gain from
uncast votes and votes reversed by the adversary. We also consider
a potential private proposer block, with an upper bound on the
maximum number of votes it can accumulate in the future. We can
fast confirm a set of proposal blocks whenever the upper confidence
bound of the private block is below the lower confidence bound of
the public proposal block with the largest lower confidence bound.
More formally: As defined earlier, Pℓ
(r) = {p1,p2...} is the set
of proposer blocks at level ℓ at round r. Let V
d
n
(r) be the number of
votes at depth d or greater for proposer block pn at round r. Define:
δd
:= max 
1
4
¯fvd
,
1 − 2β
8 logm

,ε
′ = 1 − r
2
maxe
−
(1−2β)m
16 logm ,
Vn
(r) := max
d ≥0

V
d
n
(r) − 2δdm

+
,
Vn(r) := m −
Õ
pn′ ∈Pℓ (r)\{pn }
Vn
′(r),
Vprivate(r) := 0, V private(r) := m −
Õ
pn′ ∈Pℓ (r)
Vn
′(r).
Definition 4.5. Proposer set confirmation policy: If
max
n
Vn
(r) > V private(r), (14)
then we confirm the the set of proposer blocks Πℓ
(r), where
Πℓ
(r) := {pn : Vn(r) > max
i
Vi
(r)}. (15)
Confirmation Latency 1
Confirmation Latency 2
Round �: �� is part of
a transaction block
Proposer block referring
�� is mined at level ℓ'
Leader block at
level ℓ' is confirmed
All leader block lists up
to level ℓ' are confirmed
rounds
Figure 10: Components of the latency: a) Confirmation latency 1 is analyzed in Theorem 4.7, and b) Confirmation latency 2 is analyzed in Theorem 4.6.
Next, we show that we can confirm proposer sets up to level
ℓ with an expected latency independent of ε, and the final leader
sequence is contained in the outer product of the confirmed sets.
Theorem 4.6 (List common-prefix property ). Suppose β < 0.5.
Suppose the first proposer block at level ℓ appears at round Rℓ
. Then
w.p. ε
′
, we can confirm proposer sets Π1(r)), . . . , Πℓ
(r) for all rounds
r ≥ Rℓ + R
conf
ℓ
, where
E[R
conf
ℓ
] ≤ 2808
(1 − 2β)
3 ¯fv
log 50
(1 − 2β)
+
256
(1 − 2β)
6 ¯fvm2
, (16)
and p
∗
ℓ
′
(rmax) ∈ Πℓ
′(r) ∀ℓ
′ ≤ ℓ and r ≥ Rℓ + R
conf
ℓ
.
Proof. See Appendix E. □
Let us express the latency bound (16) in terms of physical parameters. If we set the voting rate ¯fv equal to the largest possible given
the security constraint (10):
¯fv =
1
1−β
log 1−β
β
, then according to
(11), we have
m =
0.1(1 − β)
log(
1−β
β
)
·
CD
Bv
−
Bp
Bv
.
With this choice of parameters, and in the regime where the bandwidthdelay product CD/Bv is large so that the second term in (16) can be
neglected, the expected latency for list confirmation is bounded by
c1(β)D seconds, i.e. proportional to the propagation delay. Here,
c1(β) :=
2808(1 − β)
(1 − 2β)
3
log 1−β
β
log 50
(1 − 2β)
and is positive for β < 0.5. The confirmation error probability is exponentially small in CD/Bv . This is the constant part of the latency
versus security parameter tradeoff of Prism in Fig. 1. Since CD/Bv
is very large in typical networks, a confirmation error probability
exponentially small in CD/Bv is already very small. To achieve an
even smaller error probability ε we can reduce the voting rate ¯fv
smaller below the security constraint (10) and increase the number
of voter chains. More specifically, we set
¯fv =
0.1CD
Bv log 1
ε
, (17)
resulting in m = log 1
ε
−
Bp
Bv
≈ log 1
ε
, yielding the desired security
parameter. Again neglecting the second term in (16), the corresponding latency bound is
c2(β)Bv
C
log 1
ε
seconds,
where c2(β) :=
54000
(1−2β)
3
log 50
(1−2β)
. This is the linearly increasing
part of the Prism curve in Figure 1, with slope inversely proportional
to the network capacity C/Bv .
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 595
4.5.2 Fast confirmation of honest transactions
In the previous subsection we have shown that one can fast confirm
a set of proposer block sequences which is guaranteed to contain the
prefix of the final totally ordered leader sequence. As discussed in
Section 3, each of these proposer block sequence creates an ordered
ledger of transactions using the reference links to the transaction
blocks. In each of these ledgers, double-spends are removed to
sanitize the ledger. If a transaction appears in all of the sanitized
ledgers in the list, then it is guaranteed to be in the final total ordered
sanitized ledger, and the transaction can be fast confirmed. All
honest transactions without double-spends eventually have this listliveness property; when only a single honest proposer block appears
in a level and becomes the leader, it adds any honest transactions
that have not already appeared in at least one ledger in the list.
Due to the positive chain-quality of the leader sequence (Theorem
4.2), an isolated honest level eventually occurs. The latency of
confirming honest transactions is therefore bounded by the sum of
the latency of list confirmation in Theorem 4.6 plus the latency of
waiting for this event to occur (Fig. 10). The latter is given by:
Theorem 4.7 (List-liveness). Assume β < 0.5. If an honest
transaction without double spends is mined in a transaction block in
round r, then w.p. 1 −r
2
maxe
−
m
16 logm it will appear in all of the ledgers
corresponding to proposer block sequences after an expected latency
no more than
2592
(1 − 2β)
3 ¯fv
log 50
(1 − 2β)
rounds.
Proof. See Appendix F. □
Figure 10 shows the various components of the overall latency
we analyzed. We can see that the confirmation latency from the
time an honest transaction enters a blocks to the time it is confirmed
is bounded by the sum of the latencies in Theorem 4.6 and 4.7.
Repeating the analysis of Thm. 4.3, we get the following:
Theorem 4.8 (Latency). Theorems 4.6 and 4.7 guarantee that the
expected ε-latency for all honest transactions (Def. 8) is at most r(β)
rounds for β < 0.5, where
r(β) := max 
c1(β),c2(β)
Bv
DC
log 1
ε

,
where
c1(β) :=
5400(1 − β)
(1 − 2β)
3
log 1−β
β
log 50
(1 − 2β)
c2(β) :=
54000
(1 − 2β)
3
log 50
(1 − 2β)
,
Therefore the honest transactions are confirmed in
max 
c1(β)D, c2(β)
Bv
C
log 1
ε

seconds.
5 SIMULATIONS
Theorem 4.8 provides a theoretical upper bound on the expected
latency, which matches the physical limit of propagation time up
to constant factors. Characterizing the exact constants is an interesting research direction, but outside the scope of this paper. On
the other hand, one can empirically estimate the average latency
values by simulating the Prism protocol and its confirmation rule.
The purpose of this section is to conduct such a simulation in the
honest setting as well as a variety of adversarial settings.
Setup. We simulate a network with m = 1, 000 voter chains, in
which D ≈ ∆ = 1 sec. We run our proposer tree and each voter
tree at a rate of ¯f = 1 block /10 sec. Our simulations measure
the latency for transaction confirmation under three scenarios: no
attack, a balancing attack, and a censorship attack. By design, our
confirmation rule is simultaneously robust against the common
private Nakamoto attack [16], where the adversary withholds a
proposer block as well as corresponding forked voter blocks in
order to reverse a confirmed proposal block. In this section, we
show figures for an adversary deploying ˜β = 0.25 fraction of total
hash power, where ˜β denotes the fraction of hash power being
actually used for the attack (whereas β is the maximum tolerable
fraction of adversarial hash power, without losing consistency and
liveness). We set the confirmation reliability conservatively at ε =
e
−20. Experiments for additional parameter settings can be found in
the Appendix in [3]. We compare against the longest-chain protocol,
for the same block generation rate of 1 block per 10 seconds.
No Attack. We start by considering a setting where Prism’s
parameters are chosen to withstand an attacker of hash power
β, but the adversary is not actively conducting any attack. Since
the confirmation rule must still defend against β adversarial hash
power, latency depends on β. Honest nodes vote on the earliestseen proposer block, with results shown in Figure 11(a). In Bitcoin,
a confirmed transaction has to be deeper in the chain for larger β;
in Prism, the voter blocks have to be deeper. We see that Prism’s
latency is significantly smaller than that of Nakamoto’s longest
chain protocol, and much closer to the physical limit. Note that
since there is no active adversary, double-spend transactions can
be resolved with the same latency as honest transactions.
Balancing Attack. In a balancing attack, the goal of the adversary is to prevent confirmation by casting all of its votes so
as to compete with the current proposer leader block. We begin
this attack with two competing proposer blocks at the same level
(say level 0), A and B. Consider an honest (non-double-spent) transaction that is referred by at least one of the two proposer blocks.
The adversary’s goal is to prevent the system from confirming this
transaction by balancing votes on the two proposer blocks. That
is, if block A currently has the majority of votes and the adversary
mines a voter block in the ith voter tree: (1) If voter tree i has not
yet voted on level 0, the adversary votes on the minority block, B.
(2) If voter tree i voted on level 0 for block B, the adversary appends
its block to the longest chain, thereby reinforcing the vote for the
losing proposer block. (3) If voter tree i voted on level 0 for block A,
the adversary tries to fork the ith voter tree to vote for B instead. If
there is no vote for B in the voter tree, the adversary creates one. If
there is already a fork voting for B, the adversary appends to this
fork. The balancing attack is one of the most severe and natural
attacks on Prism. The results of this simulation are shown in Figure
11(b). Notice that the latency of honest transaction confirmation
increases by a factor of about 2x under a balancing attack, but does
not affect the longest-chain protocol. Despite this, Prism’s latency
is still far lower than that of the longest-chain protocol.
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 596
(a) (b) (c)
Figure 11: (a) Confirmation latency of honest transactions with no attack. The x-axis denotes the maximum tolerable fraction
of adversarial hash power β. (b) Transaction latency in the presence of an adversarial balancing attack from ˜β = 0.25 active
hash power, for honest and double-spent transactions. (c) Confirmation latency under a censorship attack with ˜β = 0.25 hash
power. Honest and double-spent transactions have the same latency, both for Prism and for longest chain.
Next, we consider double-spent transactions. The latency for
double-spent transactions is the same as honest transactions in the
longest-chain protocol, so the blue curve does not change. However,
the double-spent transaction latency for Prism grows substantially,
approaching that of the longest-chain protocol. Indeed, as the active ˜β fraction approaches 0.5, Prism’s latency on double-spent
transactions in the presence of attacks on the confirmation process
actually exceeds that of the longest-chain protocol, as discussed in
Section 4.1.
Censorship Attack Finally, we consider an attacker whose goal
is simply to slow down the confirmation of blocks by proposing
empty proposer and voter blocks. This has two effects: (1) it delays
the creation of a proposer block referencing the transaction block
containing the transaction, and (2) it delays the confirmation of
such a proposer block by delaying the creation of votes on the
proposer tree. The results of this attack are shown in Figure 11(c).
The censorship attack adds a delay of between 15-20 seconds to
Prism’s confirmation delay compared to the non-adversarial setting.
The effect is smaller for the longest-chain protocol, since the only
delay comes from delaying the insertion of a transaction into a
block. Under a censorship attack, double-spent transactions have
the same latency as honest ones.