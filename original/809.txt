Blockchain interoperability, which allows state transitions across
different blockchain networks, is critical functionality to facilitate major blockchain adoption. Existing interoperability protocols
mostly focus on atomic token exchanges between blockchains. However, as blockchains have been upgraded from passive distributed
ledgers into programmable state machines (thanks to smart contracts), the scope of blockchain interoperability goes beyond just
token exchanges. In this paper, we present HyperService, the first
platform that delivers interoperability and programmability across
heterogeneous blockchains. HyperService is powered by two innovative designs: (i) a developer-facing programming framework that
allows developers to build cross-chain applications in a unified programming model; and (ii) a secure blockchain-facing cryptography
protocol that provably realizes those applications on blockchains.
We implement a prototype of HyperService in approximately 35,000
lines of code to demonstrate its practicality. Our experiments show
that (i) HyperService imposes reasonable latency, in order of seconds, on the end-to-end execution of cross-chain applications; (ii)
the HyperService platform is scalable to continuously incorporate
new large-scale production blockchains.
CCS CONCEPTS
• Security and privacy → Distributed systems security; Security protocols.
KEYWORDS
Blockchain Interoperability; Smart Contract; Cross-chain dApps

1 INTRODUCTION
Over the last few years, we have witnessed rapid growth of several flagship blockchain applications, such as the payment system
Bitcoin [53] and the smart contract platform Ethereum [27]. Since
then, considerable effort has been made to improve the performance and security of individual blockchains, such as more efficient consensus algorithms [3, 8, 32, 43], improving transaction
rate by sharding [20, 44, 51, 60] and payment channels [37, 40, 52],
enhancing the privacy for smart contracts [29, 39, 45], and reducing
their vulnerabilities via program analysis [24, 46, 50].
As a result, in today’s blockchain ecosystem, we see many distinct blockchains, falling roughly into the categories of public, private, and consortium blockchains [6]. In a world deluged with isolated blockchains, interoperability is power. Blockchain interoperability enables secure state transitions across different blockchains,
which is invaluable for connecting the decentralized Web 3.0 [26].
Existing interoperability proposals [21, 36, 38, 61] mostly center
around atomic token exchange between two blockchains, aiming to eliminate the requirement of centralized exchanges. However, since smart contracts executing on blockchains have transformed blockchains from append-only distributed ledgers into programmable state machines, we argue that token exchange is not the
complete scope of blockchain interoperability. Instead, blockchain
interoperability is complete only with programmability, allowing
developers to write decentralized applications executable across
those disconnected state machines.
We recognize at least two categories of challenges for simultaneously delivering programmability and interoperability. First,
the programming model of cross-chain decentralized applications
(or dApps) is unclear. In general, from developers’ perspective,
it is desirable that cross-chain dApps could preserve the same
state-machine-based programming abstraction as single-chain contracts [59]. This, however, raises a virtualization challenge to abstract away the heterogeneity of smart contracts and accounts on
different blockchains so that the interactions and operations among
those contracts and accounts can be uniformly specified when writing cross-chain dApps.
Second, existing token-exchange oriented interoperability protocols, such as atomic cross-chain swaps (ACCS) [5], are not generic
enough to realize cross-chain dApps. This is because the “executables” of those dApps could contain more complex operations than
token transfers. For instance, our example dApp in § 2.3 invokes
a smart contract using parameters obtained from smart contracts
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 549
Phase A. HSL Program Compilation
Client VES
T1
T3
T2
T4
……
A.1 HSL Program
A.2 Executable Graph
A.3 Insurance Smart Contract
if CorrectExecution:
 Pay service fee
else:
 Revert effective fund
 Enforce accountability
Phase B. Cross-Chain Execution Phase C. Insurance Claim
Client VES
State Channel
BN A BN B BN C
B.2 Post T3
B.1 Post T1
B.3 T2
B.4 T4
Network Status Blockchain
(NSB)
Action
PoA
Action
Overall Architecture
HyperService
Zoom-In
PoA
dApp
Clients
VESes
Blockchain
Networks
BN A BN B … BN Z
Universal State Model
BN A BN B … BN Z
HSL
Program
HSL
Program
HSL
Program
HSL Executables
Cross-chain Execution Reachability
Client VES
Security
Attestations
Security
Attestations
NSB or any mutual-agreed BN
Figure 1: The architecture of HyperService.
deployed on different blockchains. The complexity of this operation is far beyond mere token transfers. In addition, the executables of cross-chain dApps often contain transactions on different
blockchains, and the correctness of dApps requires those transactions to be executed with certain preconditions and deadline
constraints. Another technical challenge is to securely coordinate
those transactions to enforce dApp correctness in a fully decentralized manner with zero trust assumptions.
To meet these challenges, we propose HyperService, the first
platform for building and executing dApps across heterogeneous
blockchains. At a very high level, HyperService is powered by two
innovative designs: a developer-facing programming framework for
writing cross-chain dApps, and a blockchain-facing cryptography
protocol to securely realize those dApps on blockchains. Within this
programming framework, we propose Unified State Model (USM),
a blockchain-neutral and extensible model to describe cross-chain
dApps, and the HSL, a high-level programming language to write
cross-chain dApps under the USM programming model. dApps
written in HSL are further compiled into HyperService executables
which shall be executed by the underlying cryptography protocol.
UIP (short for universal inter-blockchain protocol) is the cryptography protocol that handles the complexity of cross-chain execution.
UIP is (i) generic, operating on any blockchain with a public transaction ledger, (ii) secure, the executions of dApps either finish with
verifiable correctness or abort due to security violations, where misbehaving parties are held accountable, and (iii) financially atomic,
meaning all involved parties experience almost zero financial losses,
regardless of the execution status of dApps. UIP is fully trust-free,
assuming no trusted entities.
Contributions. To the best of our knowledge, HyperService is
the first platform that simultaneously offers interoperability and
programmability across heterogeneous blockchains. Specifically, we
make the following major contributions in this paper.
(i) We propose the first programming framework for developing cross-chain dApps. The framework greatly facilitates dApp
development by providing a virtualization layer on top of the underlying heterogeneous blockchains, yielding a unified model and
a high-level language to describe and program dApps. Using our
framework, a developer can easily write cross-chain dApps without
implementing any cryptography.
(ii) We propose UIP, the first generic blockchain interoperability protocol whose design scope goes beyond cross-chain token
exchanges. Rather, UIP is capable of securely realizing complex
cross-chain operations that involve smart contracts deployed on
heterogeneous blockchains. We express the security properties of
UIP via an ideal functionality FUIP and rigorously prove that UIP
realizes FUIP in the Universal Composability (UC) framework [28].
(iii) We implement a prototype of HyperService in approximately
35,000 lines of code, and evaluate the prototype with three categories of cross-chain dApps. Our experiments show that the end-toend dApp execution latency imposed by HyperService is in the order
of seconds, and the HyperService platform has sufficient capacity
to continuously incorporate new production blockchains.
2 HYPERSERVICE OVERVIEW
2.1 Architecture
As depicted in Figure 1, architecturally, HyperService consists of
four components. (i) dApp Clients are the gateways for dApps to
interact with the HyperService platform. When designing HyperService, we intentionally make clients to be lightweight, allowing both
mobile and web applications to interact with HyperService. (ii) Verifiable Execution Systems (VESes) conceptually work as blockchain
drivers that compile the high-level dApp programs given by the
dApp clients into blockchain-executable transactions, which are
the runtime executables on HyperService. VESes and dApp clients
employ the underlying UIP cryptography protocol to securely execute those transactions across different blockchains. UIP itself has
two building blocks: (iii) the Network Status Blockchain (NSB) and
(iv) the Insurance Smart Contracts (ISCs). The NSB, conceptually,
is a blockchain of blockchains designed by HyperService to provide
an objective and unified view of the dApps’ execution status, based
on which the ISCs arbitrate the correctness or violation of dApp
executions in a trust-free manner. In case of exceptions, the ISCs
financially revert all executed transactions to guarantee financial
atomicity and hold misbehaved entities accountable.
2.2 Universal State Model
A blockchain, together with smart contracts (or dApps) executed
on the blockchain, is often perceived as a state machine [59]. We
desire to preserve the similar abstraction for developers when writing cross-chain dApps. Towards this end, we propose Unified State
Model (USM), a blockchain-neutral and extensible model for describing state transitions across different blockchains, which in
essential defines cross-chain dApps. USM realizes a virtualization
layer to unify the underlying heterogeneous blockchains. Such
virtualization includes: (i) blockchains, regardless of their implementations (e.g., consensus mechanisms, smart contract execution
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 550
Table 1: Example of entities, operations and dependencies in USM
Entity Kind Attributes Operation Kind Attributes Dependency Kind
account address, balance, unit payment from, to, value, exchange rate precondition
contract address, state variables[], interfaces[], source invocation interface, parameters[const, Contract.SV, ...], invoker deadline
environment, programming languages, and so on), are abstracted
as objects with public state variables and functions; (ii) developers
program dApps by specifying desired operations over those objects,
along with the relative ordering among those operations, as if all
the objects were local to a single machine.
Formally, USM is defined as M = {E, P, C} where E is a set
of entities, P is a set of operations performed over those entities,
and C is a set of constraints defining the dependencies of those
operations. Entities are to describe the objects abstracted from
blockchains. All entities are conceptually local to M, regardless
of which blockchains they are obtained from. Entities come with
kinds, and each entity kind has different attributes. The current
version of USM defines two concrete kinds of entities, accounts
and contracts, as tabulated in Table 1 (we discuss the extensions of
USM in § 6.1). Specifically, an account entity is associated with a
uniquely identifiable address, as well as its balance in certain units.
A contract entity, besides its address, is further associated with a
list of public attributes, such as state variables, callable interfaces,
and its source code deployed on blockchains. Entity attributes are
crucial to enforce the security and correctness of dApps during
compilation, as discussed in § 2.3.
An operation in USM defines a step of computation performed
over several entities. Table 1 lists two kinds of operations in USM: a
payment operation that describes the balance updates between two
account entities at a certain exchange rate; an invocation operation
that describes the execution of a method specified by the interface
of a contract entity using compatible parameters, whose values
may be obtained from other contract entities’ state variables.
Although operations are conceptually local, each operation is
eventually compiled into one or more transactions on different
blockchains, whose consensus processes are not synchronized. To
honor the possible dependencies among events in distributed computing [47], USM, therefore, defines constraints to specify dependencies among operations. Currently, USM supports two kinds of
dependencies: preconditions and deadlines, where an operation can
proceed only if all its preconditioning operations are finished, and
an operation must be finished within a bounded time interval after
its dependencies are satisfied. Preconditions and deadlines offer
desirable programming abstraction for dApps: (i) preconditions enable developers to organize their operations into a directed acyclic
graph, where the state of upstream nodes is persistent and can be
used by downstream nodes; (ii) deadlines are crucial to ensure the
forward progress of dApp executions.
2.3 HyperService Programming Language
To demonstrate the usage of USM, we develop HSL, a programming
language to write cross-chain dApps under USM.
2.3.1 An Introductory Example for HSL Programs
Financial derivatives are among the most commonly cited blockchain
applications. Many financial derivatives rely on authentic data feed,
i.e., an oracle, as inputs. For instance, a standard call-option contract
1 # Import the source code of contracts written in different languages.
2 import (“broker.sol”, “option.vy”, “option.go”)
3 # Entity definition.
4 # Attributes of a contract entity are implicit from its source code.
5 account a1 = ChainX::Account(0x7019..., 100, xcoin)
6 account a2 = ChainY::Account(0x47a1..., 0, ycoin)
7 account a3 = ChainZ::Account(0x61a2..., 50, zcoin)
8 contract c1 = ChainX::Broker(0xbba7...)
9 contract c2 = ChainY::Option(0x917f...)
10 contract c3 = ChainZ::Option(0xefed...)
11 # Operation definition.
12 op op1 invocation c1.GetStrikePrice() using a1
13 op op2 payment 50 xcoin from a1 to a2 with 1 xcoin as 0.5 ycoin
14 op op3 invocation c2.CashSettle(10, c1.StrikePrice) using a2
15 op op4 invocation c3.CashSettle(5, c1.StrikePrice) using a3
16 # Dependency definition.
17 op1 before op2, op4; op3 after op2
18 op1 deadline 10 blocks; op2, op3 deadline default; op4 deadline 20 mins
Figure 2: A cross-chain Option dApp written in HSL.
needs a genuine strike price. Existing oracles [13, 62] require a smart
contract on the blockchain to serve as the front-end to interact with
other client smart contracts. As a result, it is difficult to build a
dependable and unbiased oracle that is simultaneously accessible to
multiple blockchains, because we cannot simply deploy an oracle
smart contract on each individual blockchain since synchronizing
the execution of those oracle contracts requires blockchain interoperability, i.e., we see a chicken-and-egg problem. This limitation, in
turn, prevents dApps from spreading their business across multiple blockchains. For instance, a call-option contract deployed on
Ethereum forces investors to exercise the option using Ether, but
not in other cryptocurrencies.
As an introductory example, we shall see how conceptually
simple, yet elegant, it is, from developers’ perspective, to build a
universal call-option dApp that allows investors to natively exercise options with the cryptocurrencies they prefer. The code snippet shown in Figure 2 is the HSL implementation for the referred
dApp. In this dApp, both Option contracts deployed on blockchains
ChainY and ChainZ rely on the same Broker contract on ChainX to
provide the genuine strike price (lines 14 and 15 in Figure 2). Detailed
HSL grammar is given in Grammar 1.
2.3.2 HSL Program Compilation
The core of HyperService programming framework is the HSL
compiler. The compiler performs two major tasks: (i) enforcing
security and correctness checks on HSL programs and (ii) compiling
HSL programs into blockchain-executable transactions.
One of the key differentiations of HyperService is that it allows dApps to natively define interactions and operations among
smart contracts deployed on heterogeneous blockchains. Since
these smart contracts could be written in different languages, HSL
provides a multi-language front end to analyze the source code
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 551
of those smart contracts. It extracts the type information of their
public state variables and functions, and then converts them into
the unified types defined by HSL (§ 3.1). This enables effective correctness checks on the HSL programs (§ 3.3). For instance, it ensures
that all the parameters used in a contract invocation operation are
compatible and verifiable, even if these arguments are extracted
from remote contracts written in languages different from that of
the invoking contract.
Once a HSL program passes the syntax and correctness checks,
the compiler will generate an executable for the program. The executable is structured in the form of a Transaction Dependency
Graph, which contains (i) the complete information for computing a
set of blockchain-executable transactions, (ii) the metadata of each
transaction needed for correct execution, and (iii) the preconditions
and deadlines of those transactions that honor the dependency
constraints specified in the HSL program (§ 3.4).
In HyperService, the Verifiable Execution Systems (VESes) are
the actual entities that own the HSL compiler and therefore resume the aforementioned compiler responsibilities. Because of this,
VESes work as blockchain drivers that bridge our high-level programming framework with the underlying blockchains. Each VES
is a distributed system providing trust-free service to compile and
execute HSL programs given by dApp clients. VESes are trust-free
because their actions taken during dApp executions are verifiable.
Each VES defines its own service model, including its reachability (i.e., the set of blockchains that the VES supports), service fees
charged for correct executions, and insurance plans (i.e., the expected compensation to dApps if the VES’s execution is proven to
be incorrect). dApps have full autonomy to select VESes that satisfy
their requirements. In § 6.3, we lay out our visions for VESes.
Besides owning the HSL compiler, VESes also participate in the
actual executions of HSL executables, as discussed below.
2.4 Universal Inter-Blockchain Protocol (UIP)
To correctly execute a dApp, all the transactions in its executable
must be posted on blockchains for execution, and meanwhile their
preconditions and deadlines are honored. Although this executing
procedure is conceptually simple (thanks to the HSL abstraction),
it is very challenging to enforce correct executions in a fully trustfree manner where (i) no trusted authority is allowed to coordinate
the executions on different blockchains and (ii) no mutual trust
between VESes and dApp clients are established.
To address this challenge, HyperService designs UIP, a cryptography protocol between VESes and dApp clients to securely execute
HSL executables on blockchains. UIP can work on any blockchain
with public ledgers, imposing no additional requirements such as
their consensus protocols and contract execution environment. UIP
provides strong security guarantees for executing dApps such that
dApps are correctly executed only if the correctness is publicly verifiable by all stakeholders; otherwise, UIP holds the misbehaving
parties accountable, and financially reverts all committed transactions to achieve financial atomicity.
UIP is powered by two innovative designs: the Network Status
Blockchain (NSB) and the Insurance Smart Contract (ISC). The NSB
is a blockchain designed by HyperService to provide objective and
unified views on the status of dApp executions. On the one hand,
the NSB consolidates the finalized transactions of all underlying
blockchains into Merkle trees, providing unified representations for
transaction status in form of verifiable Merkle proofs. On the other
hand, the NSB supports Proofs of Actions (PoAs), allowing both
dApp clients and VESes to construct proofs to certify their actions
taken during cross-chain executions. The ISC is a code-arbitrator. It
takes transaction-status proofs constructed from the NSB as input
to determine the correctness or violation of dApp executions, and
meanwhile uses action proofs to determine the accountable parities
in case of exceptions.
In § 4.6, we define the security properties of UIP via an ideal
functionality and then rigorously prove that UIP realizes the ideal
functionality in UC-framework [28].
2.5 Assumptions and Threat Model
We assume that the cryptographic primitives and the consensus protocol of all underlying blockchains are secure so that each of them
can have the concept of transaction finality. On Nakamoto consensus based blockchains (typically permissionless), this is achieved by
assuming that the probability of blockchain reorganizations drops
exponentially as new blocks are appended (common-prefix property) [35]. On Byzantine tolerance based blockchains (usually permissioned), finality is guaranteed by signatures from a quorum of
permissioned voting nodes. For a blockchain, if the NSB-proposed
definition of transaction finality for the blockchain is accepted by
users and dApps on HyperService, the operation (or trust) model
(e.g., permissionless or permissioned) and consensus efficiency (i.e.,
the latency for a transaction to become final) of the blockchain
have provably no impact on the security guarantees of our UIP
protocol. We also assume that each underlying blockchain has a
public ledger that allows external parties to examine and prove
transaction finality and the public state of smart contracts.
The correctness of UIP relies on the correctness of the NSB.
An example implementation of NSB is a permissioned blockchain,
where any information on NSB becomes legitimate only if a quorum of consensus nodes that maintain the NSB have approved the
information. We thus assume that at least K consensus nodes of
the NSB are honest, where K is the quorum threshold (e.g., the
majority). In this design, an NSB node is not required to become
either a full or light node for any of the underlying blockchains.
We consider a Byzantine adversary that interferes with our UIP
protocol arbitrarily, including delaying and reordering network
messages indefinitely, and compromising protocol participants. As
long as at least one protocol participant is not compromised by the
adversary, the security properties of UIP are guaranteed.
3 PROGRAMMING FRAMEWORK
The design of the HyperService programming framework centers
around the HSL compiler. Figure 3 depicts the compilation workflow. The HSL compiler has two frond-ends: one for extracting
entities, operations, and dependencies from a HSL program and
one for extracting public state variables and methods from smart
contracts deployed on blockchains. A unified type system is designed to ensure that smart contracts written in different languages
can be abstracted as interoperable entities defined in the HSL program. Afterwards, the compiler performs semantic validations on
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 552
HSL
Front-End
Unified Types Entities Operations Dependencies
Dependency
Validation
Operation
Validation
Entity
Validation
HSL Front Ends
HSL
Program
Multi-language
Front-End
HSL Validation and Compilation
Contract
Solidity
Contract
Vyper
Contract
Go
…
Transaction
Compilation
Transaction Dependency Graph
Figure 3: Workflow of HSL compilation.
all entities, operations and dependencies to ensure the security and
correctness of the HSL program. Finally, the compiler produces an
executable for the HSL program, which is structured in the form
of a transaction dependency graph. We next describe the details of
each component.
3.1 Unified Type System
The USM is designed to provide a unified virtualization layer for
developers to define invocation operations in their HSL programs,
without handling the heterogeneity of contract entities. Towards
this end, the programming framework internally defines a Unified
Type System so that state variables and methods of all contract
entities can be abstracted using the unified types when writing HSL
programs. This enables the HSL compiler to ensure that all arguments specified in an invocation operation are compatible (§ 3.3).
Specifically, the unified type system defines nine elementary
types, as shown in Table 2. Data types that are commonly used in
smart contract programming languages will be mapped to these unified types during compilation. For example, Solidity does not fully
support fixed-point number, but Vyper (decimal) and Go (f loat)
do. Also, Vyper’s string is fixed-sized (declared via string[Inteдer]),
but Solidity’s string is dynamically-sized (declared as string). Our
multi-lang front-end recognizes these differences and performs
type conversion to map all the numeric literals including integers
and decimals to the Numeric type, and the strings to the Strinд
type. For types that are similar in Solidity, Vyper, and Go, such
as Boolean, Map, and Struct, we simply map them to the corresponding types in our unified type system. Finally, Solidity and
Vyper provide special types for representing contract addresses,
which are mapped to the Address type. But Go does not provide a
type for contract addresses, and thus Go’s Strinд type is mapped
to the Address type. The mapping of language-specific types to
the unified type system is tabulated in Table 2. Our unified type
system is horizontally scalable to support additional strong-typed
programming languages. Note that the use of complex data types
as contract function parameters has not been fully supported yet
in production. We thus leave complex types in HSL to future work.
Table 2: Unified type mapping for Solidity, Vyper, and Go
Type Solidity Vyper Go
Boolean bool bool bool
Numeric int, uint int128, uint256, decimal, unit type
int, uint, uintptr, float
Address address address string
String string string string
Array array, bytes array, bytes array, slice
Map mapping map map
Struct struct struct struct
Function function, enum def func
Contract Contract file type
⟨hsl⟩ ::= (⟨import⟩)+ (⟨entity_def ⟩)+ (⟨op_def ⟩)+ (⟨dep_def ⟩)*
Contract Imports:
⟨import⟩ ::= ‘import’ ‘(’ ⟨file⟩ (‘,’ ⟨file⟩)* ‘)’
⟨file⟩ ::= ⟨string⟩
Entity Definition:
⟨entity_def ⟩ ::= ⟨entity_type⟩ ⟨entity_name⟩ ‘=’ ⟨chain_name⟩ ‘::’
⟨constructor⟩
⟨entity_name⟩ ::= ⟨id⟩
⟨chain_name⟩ ::= ‘Chain’ ⟨id⟩
⟨constructor⟩ ::= ⟨contract_type⟩ ‘(’ ⟨address⟩, (⟨unit⟩)? ‘)’
⟨contract_type⟩ ::= ‘Account’ | ⟨id⟩
⟨entity_type⟩ ::= ‘account’ | ‘contract’
Operation Definition:
⟨op_def ⟩ ::= ⟨op_payment⟩ | ⟨op_invocation⟩
⟨op_payment⟩ ::= ‘op’ ⟨op_name⟩ ‘payment’ ⟨coin⟩ ⟨accts⟩ ⟨exchange⟩
⟨op_name⟩ ::= ⟨id⟩
⟨coin⟩ ::= ⟨num⟩ ⟨unit⟩
⟨accts⟩ ::= ‘from’ ⟨acct⟩ ‘to’ ⟨acct⟩
⟨acct⟩ ::= ⟨id⟩
⟨exchange⟩ ::= ‘with’ ⟨coin⟩ ‘as’ ⟨coin⟩
⟨op_invocation⟩ ::= ‘op’ ⟨op_name⟩ ‘invocation’ ⟨call⟩ ‘using’ ⟨acct⟩
⟨call⟩ ::= ⟨recv⟩ ‘.’ ⟨method⟩ ‘(’ (arg)*‘)’
⟨arg⟩ ::= ⟨int⟩ | ⟨float⟩ | ⟨string⟩ | ⟨state_var⟩
⟨state_var⟩ ::= ⟨varname⟩ ‘.’ ⟨prop⟩
Dependency Definition:
⟨dep_def ⟩ ::= ⟨temp_deps⟩ | ⟨del_deps⟩
⟨temp_deps⟩ ::= ⟨temp_dep⟩ (‘;’ ⟨temp_dep⟩)*
⟨temp_dep⟩ ::= ⟨op_name⟩ (‘before’ | ‘after’) ⟨op_name⟩ (‘,’
⟨op_name⟩)*
⟨del_deps⟩ ::= ⟨del_dep⟩ (‘;’ ⟨del_dep⟩)*
⟨del_dep⟩ ::= ⟨op_name⟩ (‘,’ ⟨op_name⟩)* ‘deadline’ ⟨del_spec⟩
⟨del_spec⟩ ::= ⟨int⟩ ‘blocks’| ‘default’ | ⟨int⟩ ⟨time_unit⟩
Grammar 1: Representative BNF grammar of HSL
3.2 HSL Language Design
The language constructs provided by HSL are coherent with USM,
allowing developers to straightforwardly specify entities, operations, and dependencies in HSL programs. One additional construct,
import, is added to import the source code of contract entities, as
discussed below. Grammar 1 shows the representative rules of HSL.
We omit the terminal symbols such as ⟨id⟩ and ⟨address⟩.
Contract Importing. Developers use the ⟨import⟩ rule to include
the source code of contract entities. Depending on the programming language of an imported contract, HSL’s multi-lang front end
uses the corresponding parser to parse the source code, based on
which it performs semantic validation (§ 3.3). For security purpose,
the compiler should verify that the imported source code is consistent with the actual deployed code on blockchain, for instance, by
comparing their compiled byte code.
Entity Definition. The ⟨entity_def⟩ rule specifies the definition of
an account or a contract entity. An entity is defined via constructor,
where the on-chain (⟨address⟩) of the entity is a required parameter.
An account entity can be initialized with an optional unit (⟨unit⟩) to
specify the cryptocurrency held by the account. All contract entities
must have the corresponding contract objects/classes in one of the
imported source code files. Each entity is assigned with a name
(⟨entity_name⟩) that can be used for defining operations.
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 553
Operation Definition. The ⟨op_def⟩ rule specifies the definition
of a payment or an invocation operation. A payment operation
(⟨op_payment⟩) specifies the transfer of a certain amount of coins
(⟨coin⟩) between two accounts that may live on different blockchains
(⟨accts⟩). Note that no new coins on any blockchains are ever created during the operation. The ⟨exchange⟩ rule is used to specify
the exchange rate between the coins held by the two accounts. An
invocation operation (⟨op_invocation⟩) specifies calling one contract
entity’s public method with certain arguments (⟨call⟩). The arguments passed to a method invocation can be literals (⟨int⟩, ⟨float⟩,
⟨string⟩), and state variables (⟨state_var⟩) of other contract entities.
When using state variables, semantic validation is required (§ 3.3).
Dependency Definition. The ⟨dep_def⟩ specifies the rule of defining preconditions and deadlines for operations. A precondition
(⟨temp_deps⟩) specifies the temporal constraints for the execution
order of operations. A deadline (⟨del_deps⟩) specifies the deadline
constraints of each operation. The deadline dependency may be
given either using the number of blocks on NSB (⟨int⟩ blocks) or
in absolute time (⟨int⟩ ⟨time_unit⟩), as explained in § 3.4.
3.3 Semantic Validation
The compiler performs two types of semantic validation to ensure
the security and correctness of HSL programs. First, the compiler
guarantees the compatibility and verifiability of the arguments used
in invocation operations, especially when those arguments are obtained from other contract entities. For compatibility check, the
compiler performs type checking to ensure the types of arguments
and the types of method parameters are mapped to the same unified type. For verifiability check, the compiler ensures that only
literals and state variables that are publicly stored on blockchains
are eligible to be used as arguments in invocation operations. For
example, the return values of method calls to a contract entity are
not eligible if these results are not persistent on blockchains. This
requirement is necessary for the UIP protocol to construct publicly verifiable attestations to prove that correct values are used to
invoking contracts during actual on-chain execution. Second, the
compiler performs dependency validation to make sure that the
dependency constraints defined in a HSL program uniquely specify
a directed acyclic graph connecting all operations. This ensures
that no conflicting temporal constraints are specified.
3.4 HSL Program Executables
Once a HSL program passes all validations, the HSL compiler generates executables for the program in form of a transaction dependency graph GT . Each vertex of GT , referred to as a transaction
wrapper, contains the complete information to compute an on-chain
transaction executable on a specific blockchain, as well as additional
metadata for the transaction. The edges in GT define the preconditioning requirements among transactions, which are consistent
with the dependency constraints specified by the HSL program.
Figure 4 show the GT generated for the HSL program in Figure 2.
A transaction wrapper is in form of T := [from,to,seq, meta],
where the pair <from,to> decides the sending and receiving addresses of the on-chain transaction, seq (omitted in Figure 4) represents the sequence number of T in GT , and meta stores the
structured and customizable metadata for T. Below we explain
Transaction T1 on ChainX:
 from: a1.address
 to: c1.address
Meta:
 data: c1.getStrikePrice
 <amt, dst>: <0.1 ncoin, 0x1…>
 state_proof: collect from NSB
Transaction T2 on ChainX:
 from: a1.address
 to: VES.relayX.address
Meta:
 value: 50 xcoin
 <amt, dst>: <25 ncoin, 0x2…>
 deadline: 4 NSB blocks
Transaction T3 on ChainY:
 from: VES.relayY.address
 to: a2.address
Meta:
 value: 25 ycoin
 <amt, dst>: <5 ncoin, 0x3…>
 deadline: 6 NSB blocks
Transaction T4 on ChainY:
 from: a2.address
 to: c2.address
Meta:
 data: c2.CashSettle(10, c1.StrikePrice)
 <amt, dst>: <0.1 ncoin, 0x4…>
 value_proof: T1.meta.state_proof
Transaction T5 on ChainZ
Figure 4: GT generated for the example HSL program.
the fields of meta. First, to achieve financial atomicity, meta must
populate a tuple ⟨amt, dst⟩ for fund reversion. In particular, amt
specifies the total value that the from address has to spend when T
is committed on its destination blockchain, which includes both the
explicitly paid value in T, as well as any gas fee. If the entire execution fails with exceptions whereas T is committed, the dst account
is guaranteed to receive the amount of fund specified in amt. As
we shall see in § 4.4, the fund reversion is handled by the Insurance
Smart Contract (ISC). Therefore, the unit of amt (represented as
ncoin in Figure 4) is given based on the cryptocurrency used by the
blockchain where the ISC is deployed, and the dst should live on
the hosting blockchain as well.
Second, for a transaction (such as T1) whose resulting state is
subsequently used by other downstream transactions (such as T4),
its meta needs to be populated with a corresponding state proof.
This proof should be collected from the transaction’s destination
blockchain after the transaction is finalized (c.f., § 4.2.3). Third,
a cross-chain payment operation in the HSL program results in
multiple transactions in GT . For instance, to realize the op1 in
Figure 2, two individual transactions, involving the relay accounts
owned by the VES, are generated. As blockchain drivers, each VES
is supposed to own some accounts on all blockchains that it has
visibility so that the VES is able to send and receive transactions on
those blockchains. For instance, in Figure 4, the relayX and relayY
are two accounts used by the VES to bridge the balance updates
between ChainX::a1 and ChainY::a2. Because of those VES-owned
accounts, GT is in general VES-specific.
Finally, the deadlines of transactions could be specified using
the number of blocks on the NSB. This is because the NSB constructs a unified view of the status of all underlying blockchains
and therefore can measure the execution time of each transaction.
Specifically, the deadline of a transaction T is measured as the
number of blocks between two NSB blocks B1 and B2 (including
B2), where B1 proves the finalization of T’s last preconditioned
transaction and B2 proves the finalization of T itself. We explain in
detail how the finality proof is constructed based on NSB blocks in
§ 4.2.2. Transaction deadlines are indeed enforced by the ISC using
the number of NSB blocks. Note that to improve expressiveness,
the HSL language also allows developers to define deadlines in time
intervals (e.g., minutes). The compiler will then convert those time
intervals into numbers of NSB blocks.
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 554
In summary, the executable produced by the HSL complier defines the blueprint of cross-blockchain execution to realize the HSL
program. It is the input instructions that direct the underlying
cryptography protocol UIP, as detailed below.
4 UIP DESIGN DETAIL
UIP is the cryptography protocol that executes HSL program executables. The main protocol ProtUIP is divided into five preliminary
protocols. In particular, ProtVES and ProtCLI define the execution
protocols implemented by VESes and dApp clients, respectively.
ProtNSB and ProtISC are the protocol realization of the NSB and
ISC, respectively. Lastly, ProtUIP includes ProtBC, the protocol realization of a general-purposed blockchain. Overall, ProtUIP has two
phases: the execution phase where the transactions specified in the
HSL executables are posted on blockchains and the insurance claim
phase where the execution correctness or violation is arbitrated.
4.1 Protocol Preliminaries
4.1.1 Runtime Transaction State
During the execution phase, a transaction may be in any of the following state {unknown, init, inited, open, opened, closed}, where
a latter state is considered more advanced than a former one. The
state of each transaction must be gradually promoted following the
above sequence. For each state (except for the unknown), ProtUIP
produces a corresponding attestation to prove the state. When the
execution phase terminates, the final execution status of the HSL
program is collectively decided by the state of all transactions, based
on which ProtISC arbitrates its correctness or violation.
4.1.2 Off-Chain State Channels
The protocol exchange between ProtVES and ProtCLI can be conducted via off-chain state channels for low latency. One challenge,
however, is that it is difficult to enforce accountability for nonclosed transactions without preserving the execution steps by both
parties. To address this issue, ProtUIP proposes Proof of Actions
(PoAs), allowing ProtVES and ProtCLI to stake their execution steps
on NSB. As a result, the NSB is treated as a publicly-observable
fallback communication medium for the off-chain channel. The
benefit of this dual-medium design is that the protocol exchange
between ProtVES and ProtCLI can still proceed agilely via off-chain
channels in typical scenarios, whereas the full granularity of their
protocol exchange is preserved on the NSB in case of exceptions,
eliminating the ambiguity for accountability enforcement.
As mentioned in § 4.1.1, ProtUIP produces security attestations
to prove the runtime state of transactions. As we shall see below, an
attestation may come in two forms: a certificate, denoted by Cert,
signed by ProtVES or/and ProtCLI during their off-chain exchange,
or an on-chain Merkle proof, denoted by Merk, constructed using
the NSB and underlying blockchains. An Cert and its corresponding
Merk are treated equivalently by the ProtISC in code arbitration.
4.1.3 Architecture of the NSB
The NSB is a blockchain designed to provide an objective view on
the execution status of dApps. Figure 5 depicts the architecture
of NSB blocks. Similar to typical blockchain blocks, an NSB block
contains several common fields, such as the hash fields to link blocks
Block Number: N + 1
ActionRoot … StatusRoot
PrevHash Block Number: N
ActionRoot
Hash
CommonRoots StatusRoot
Blockchain X
BlockID: 2012
StateRoot: 0x1…
TxRoot: 0xf…
Blockchain X
BlockID: 2019
StateRoot: 0x2…
TxRoot: 0xe… Cert(a) Cert(z)
Figure 5: The architecture of NSB blocks.
together and the Merkle trees to store transactions and state. To
support the extra functionality of the NSB, an NSB block contains
two additional Merkle tree roots: StatusRoot and ActionRoot.
StatusRoot is the root of a Merkle tree (referred as StatusMT)
that stores transaction status of underlying blockchains. The NSB
represents the transaction status of a blockchain based on the TxRoots and StateRoots retrieved from the blockchain’s public ledger.
Although the exact namings may vary on different blockchains,
in general, the TxRoot and StateRoot in a blockchain block represent the root of a Merkle tree storing transactions and storage
state (e.g., account balance, contract state), respectively. Note that
the NSB only stores relevant blockchain state, where a blockchain
block is considered to be relevant if the block packages at least one
transaction that is part of any dApp executables.
ActionRoot is the root of a Merkle tree (referred to as ActionMT)
whose leaf nodes store certificates computed by VESes and dApp
clients. Each certificate represents a certain step taken by either
the VES or the dApp client during the execution phase. To prove
such an action, a party needs to construct a Merkle proof to demonstrate that the certificate mapped to the action can be linked to a
committed block on the NSB. These PoAs are crucial for the ISC to
enforce accountability if the execution fails. Since the information
of each ActionMT is static, we lexicographically sort the ActionMT
to achieve fast search and convenient proof of non-membership.
Note that the construction of StatusMT ensures that each underlying blockchain can have a dedicated subtree for storing its transaction status. This makes the NSB shardable on the granularity of
individual blockchains, ensuing that the NSB is horizontally scalable
as HyperService continuously incorporates additional blockchains.
ProtNSB, discussed in § 4.5, is the protocol that specifies the detailed
construction of both roots and guarantees their correctness.
4.2 Execution Protocol by VESes
The full protocol of ProtVES is detailed in Figure 6. Below we clarify
some technical subtleties.
4.2.1 Post Compilation and Session Setup
After GT is generated, ProtVES initiates an execution session for
GT in the PostCompiliation daemon. The primary goal of the initialization is to create and deploy an insurance contract to protect
the execution of GT . Towards this end, ProtVES interacts with the
protocol ProtISC to create the insurance contract for GT , and further deploys the contract on NSB after the dApp client D agrees
on the contract. Throughout the paper, Cert([∗]; Sig) represents a
signed certificate proving that the signing party agrees on the value
enclosed in the certificate. We use SigV
sid and SigD
sid to represent the
signature by ProtVES and ProtCLI, respectively.
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 555
1 Init: Data := ∅
2 Daemon PostCompiliation():
3 generate the session ID sid ← {0, 1}
λ
4 call [cid, contract] := ProtISC.CreateContract(GT )
5 send Cert([sid, GT , contract]; SigV
sid) to ProtCLI for approval
6 halt until Cert([sid, GT , contract]; SigV
sid, SigD
sid) is received
7 package contract as a valid transaction contract  8 call ProtNSB.Exec(contract ) to deploy the contract  9 halt until contract is initialized on ProtNSB
10 call ProtISC.StakeFund to stake the required funds in ProtISC
11 halt until D has staked its required funds in ProtISC
12 initialize Data[sid] := {GT , cid, SCert=∅, SMerk=∅ }
13 Daemon Watching(sid, {ProtBC, ...}) private:
14 (GT , _, SCert, SMerk) := Data[sid]; abort if not found
15 for each T ∈ GT :
16 continue if T.state is not opened
17 identify T’s on-chain counterpart Te
18 continue if ProtBC.Status(Te) is not committed
19 get tsclosed := ProtNSB.BlockHeight()
20 compute C
T
closed := Cert([Te, closed, sid, T, tsclosed], SigV
sid)
21 call ProtCLI.CloseTrans(C
T
closed) to negotiate the closed attestation
22 call ProtBC.MerkleProof(Te) to obtain a finalization proof for Te
23 denote the finalization proof as Merkc1
T
(Figure 7)
24 update SCert.Add(C
T
closed) and SMerk .Add(Merkc1
T
)
25 Daemon Watching(sid, ProtNSB) private:
26 (GT , _, SCert, SMerk) := Data[sid]; abort if not found
27 watch four types of attestations {Certid
, Certo
, Certod
, Certc
}
28 process fresh attestations via corresponding handlers (see below)
29 # Retrieve alternative attestations if necessary.
30 for each T ∈ GT :
31 if T.state = opened and Merkc1
T
∈ SMerk :
32 retrieve the roots [R, ...] of the proof Merkc1
T
33 call ProtNSB.MerkleProof([R, ...]) to obtain a status proof Merkc2
T
34 continue if Merkc2
T
is not available yet on ProtNSB
35 compute the complete proof Merkc
T
:= [Merkc1
T
, Merkc2
T
]
36 update T.state := closed and SMerk .Add(Merkc
T
)
37 compute eligible transaction set S using the current state of GT
38 for each T ∈ S:
39 continue if T.state is not unknown
40 if T.from = ProtCLI:
41 compute Certi
T
:= Cert([T, init, sid]; SigV
sid)
42 call ProtCLI.InitTrans(Certi
T
) to request initialization
43 call ProtNSB.AddAction(Certi
T
) to prove Certi
T
is sent
44 update SCert.Add(Certi
T
) and T.state := init
45 non-blocking wait until ProtNSB.MerkleProof(Certi
T
) rt. Merki
T
46 update SMerk .Add(Merki
T
)
47 else: call self.SInitedTrans(sid, T)
48 Upon Receive SInitedTrans(sid, T) private: Northbound
49 (GT , _, SCert, SMerk) := Data[sid]; abort if not found
50 compute and sign the on-chain counterpart Te for T
51 compute Certid
T
:= Cert([Te, inited, sid, T]; SigV
sid)
52 call ProtCLI.InitedTrans(Certid
T
) to request opening of initialized T
53 call ProtNSB.AddAction(Certid
T
) to prove Certid
T
is sent
54 update SCert.Add(Certid
T
) and T.state := inited
55 non-blocking wait until ProtNSB.MerkleProof(Certid
T
) returns Merkid
T
56 update SMerk .Add(Merkid
T
)
57 Upon Receive RInitedTrans(Certid
T
) public: Southbound
58 assert Certid
T
has the valid form of Cert([Te, inited, sid, T]; SigD
sid)
59 (_, _, SCert, SMerk) := Data[sid]; abort if not found
60 abort if the Certi
T
corresponding to Certid
T
is not in SCert
61 assert Te is correctly associated with the wrapper T
62 get tsopen := ProtNSB.BlockHeight()
63 compute Certo
T
:= Cert([Te, open, sid, T, tsopen]; SigV
sid)
64 call ProtCLI.OpenTrans(Certo
T
) to request opening for T
65 call ProtNSB.AddAction(Certo
T
) to prove Certo
T
is sent
66 update SCert.Add(Certo
T
) and T.state := open
67 non-blocking wait until ProtNSB.MerkleProof(Certo
T
) returns Merko
T
68 update SMerk .Add(Merko
T
)
69 Upon Receive OpenTrans(Certo
T
) public: Northbound
70 assert Certo
T
has valid form of Cert([Te, open, sid, T, tsopen]; SigD
sid)
71 (_, _, SCert, SMerk) := Data[sid]; abort if not found
72 abort if the Certid
T
corresponding to Certo
T
is not in SCert
73 assert tsopen is within a bounded range with ProtNSB.BlockHeight()
74 compute Certod
T
:= Cert([Te, open, sid, T, tsopen]; SigD
sid, SigV
sid)
75 call ProtBC.Exec(Te) to trigger on-chain execution
76 call ProtCLI.OpenedTrans(Certod
T
) to acknowledge request
77 call ProtNSB.AddAction(Certod
T
) to prove Certod
T
is sent
78 update SCert.Add(Certod
T
) and T.state := opened
79 non-blocking wait until ProtNSB.MerkleProof(Certod
T
) returns Merkod
T
80 update SMerk .Add(Merkod
T
)
81 Upon Receive OpenedTrans(Certod
T
) public: Southbound
82 ast.Certod
T
has valid form ofCert([Te, open, sid, T, tsopen]; SigV
sid, SigD
sid)
83 (_, _, SCert, _) := Data[sid]; abort if not found
84 abort if the Certo
T
corresponding to Certod
T
is not in SCert
85 update SCert.Add(Certod
T
) and T.state := opened
86 Upon Receive CloseTrans(C
T
closed) public: Bidirectional
87 assert C
T
closed has valid form of Cert([Te, closed, sid, T, tsclosed], SigD
sid)
88 assert Te is finalized on its destination blockchain and obtain Merkc1
T
89 assert tsclosed is within a bounded margin with ProtNSB.BlockHeight()
90 (_, _, SCert, SMerk) := Data[sid]; abort if not found
91 compute Certc
T
:= Cert([Te, closed, sid, T, tsclosed], SigD
sid, SigV
sid)
92 call ProtCLI.ClosedTrans(Certc
T
) to acknowledged request
93 update SCert.Add(Certc
T
), SMerk .Add(Merkc1
T
) and T.state := closed
94 Upon Receive ClosedTrans(Certc
T
) public: Bidirectional
95 ast.Certc
T
has valid form ofCert([Te, closed, sid, T, tsclosed], SigV
sid, SigD
sid)
96 (_, _, SCert, _) := Data[sid]; abort if not found
97 abort if Cert([Te, closed, sid, T, tsclosed], SigV
sid) is not in SCert
98 update SCert.Add(Certc
T
) and T.state := closed
99 Daemon Redeem(sid) private:
100 # Invoke the insurance contract periodically
101 (GT , cid, SCert, SMerk) := Data[sid]; abort if not found
102 for each unclaimed T ∈ GT :
103 get the CertT from SCert Ð
SMerk with the most advanced state
104 call ProtISC.InsuranceClaim(cid, CertT) to claim insurance
Figure 6: Protocol description of of ProtVES. Gray background denotes non-blocking operations triggered by status updates
on ProtNSB. Handlers annotated with northbound and southbound process transactions originated from ProtVES and ProtCLI,
respectively. Handlers annotated with bidirectional are shared by all transactions.
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 556
Additionally, both ProtVES and ProtCLI are required to deposit
sufficient funds to ProtISC to ensure that ProtISC holds sufficient
funds to financially revert all committed transactions regardless
of the step at which the execution aborts prematurely. Intuitively,
each party would need to stake at least the total amount of incoming funds to the party without deducting the outgoing funds.
This strawman design, however, require high stakes. More desirably, considering the dependency requirements in GT , an party X
(ProtVES or ProtCLI) only needs to stake
max
s ∈GS
Õ
T ∈s ∧ T.to=X
T.meta.amt −
Õ
T ∈s ∧ T.from=X
T.meta.amt
where GS is the set of all committable subsets in GT , where a subset
s ⊆ GT is committable if, whenever T ∈ s, all preconditions of T
are also in s. For clarity of notation, throughout the paper, when
saying T.from =ProtVES or T is originated from ProtVES, we mean
that T is sent and signed by an account owned by ProtVES. Likewise,
T.from =ProtCLI indicates that T is sent from an account entity
defined in the HSL program. ProtISC refunds any remaining funds
after the contract is terminated.
After the contract is instantiated and sufficiently staked, ProtVES
initializes its internal bookkeeping for the session. The two notations SCert and SMerk represent two sets that store the signed
certificates received via off-chain channels and on-chain Merkle
proofs constructed using ProtNSB and ProtBC.
4.2.2 Protocol Exchange for Transaction Handling
In ProtVES, SInitedTrans and OpenTrans are two handlers processing northbound transactions which originates from ProtVES. The
SInitedTrans handling for T is invoked when all its preconditions
are finalized, which is detected by the watching service of ProtVES
(c.f., § 4.2.3). The SInitedTrans computes Certid
T
to prove T is in
the inited state , and then passes it to the corresponding handler of
ProtCLI for subsequent processing. Meanwhile, SInitedTrans stakes
Certid
T
on ProtNSB, and later it retrieves a Merkle proof Merki
T
from
the NSB to prove that Certid
T
has been sent. Merkid
T
essentially is a
hash chain linking Certid
T
back to an ActionRoot on a committed
block of the NSB. The proof retrieval is a non-blocking operation
triggered by the consensus update on the NSB.
The OpenTrans handler pairs with SInitedTrans. It listens for a
timestamped Certo
T
, which is supposed to be generated by ProtCLI
after it processes Certid
T
from ProtVES. OpenTrans performs special
correctness check on the tsopen enclosed in Certo
T
. In particular,
ProtVES and ProtCLI use the block height of the NSB as a calibrated
clock. By checking that tsopen is within a bounded range of the
NSB height, ProtVES ensures that the tsopen added by ProtCLI is
fresh. After all correctness checks on Certid
T
are passed, the state
of T is promoted from open to opened. OpenTrans then computes
certificate to prove the updated state and posts Te on its destination
blockchain for on-chain execution. Throughout the paper,Tedenotes
the on-chain executable transaction computed and signed using
the information contained in T. Note that the difference between
the Certo
T
received from ProtCLI and a post-open (i.e., opened)
certificate Certod
T
computed by ProtVES is that latter one is signed by
both parties. Only the tsopen specified in Certod
T
is used by ProtISC
when evaluating the deadline constraint of T.
TxRoot: Rx StateRoot: Ry
TxHash: 0x3…
Value A
StatusRoot
Blockchain X
BlockID: 2019
StateRoot: Ry
Value B TxRoot: Rx
Blockchain X The NSB
… … … …
Figure 7: The complete on-chain proof (denoted by Merkc
T
)
to prove that the state of a transaction is eligible to be promoted as closed. The left-side part is the finalization proof
(denoted by Merkc1
T
) for the transaction collected from its
destination blockchain; the right-side part is the blockchain
status proof (denoted by Merkc2
T
) collected from the NSB.
Southbound transactions originating from ProtCLI are processed
by ProtVES in a similar manner as the northbound transactions, via
the RInitedTrans and OpenedTrans handlers. We clarify a subtlety
in the RInitedTrans handler when verifying the association between
Te and T (line 61). If Te depends on the resulting state from its upstream transactions (for instance, T4 depends on the resulting state
of T1 in Figure 4), ProtVES needs to verify that the state used by Te
is consistent with the state enclosed in the finalization proofs of
those upstream transactions.
4.2.3 Proactive Watching Services
Cross-chain execution makes forward progress when all sessionrelevant blockchains and the NSB make progress on transactions.
As the driver of execution, ProtVES internally creates two watching
services to proactively read the status of those blockchains.
In the watching daemon to one blockchain, ProtVES mainly reads
the public ledger of ProtBC to monitor the status of transactions
that have been posted for on-chain execution. If ProtVES notices
that an on-chain transaction Te is recently finalized, it requests the
closing process for T by sending ProtCLI a timestamped certificate
Cclosed. The pair of handlers, CloseTrans and ClosedTrans, are used
by both ProtVES and ProtCLI in this exchange. Both handlers can
be used for handling northbound and southbound transactions,
depending on which party sends the closing request. In general, a
transaction’s originator has a stronger motivation to initiate the
closing process because the originator would be held accountable
if the transaction were not timely closed by its deadline.
In addition, ProtVES needs to retrieve a Merkle Proof from ProtBC
to prove the finalization ofTe. This proof, denoted by Merkc1
T
, serves
two purposes: (i) it is the first part of a complete on-chain proof
to prove that the state Te can be promoted to closed, as shown in
Figure 7; (ii) if the resulting state of Te is used by its downstream
transactions, Merkc1
T
is necessary to ensure that those downstream
transactions indeed use genuine state.
In the watching service to ProtNSB, ProtVES performs following
tasks. First, as described in § 4.1.2, NSB is treated as a fallback
communication medium for the off-chain channel. Thus, ProtVES
searches the sorted ActionMT to look for any session-relevant certificates that have not been received via the off-chain channel. Second, for each opened T whose closed attestation is still missing
after ProtVES has sent Cclosed (indicating slow or no reaction from
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 557
1 Init: Data := ∅
2 Upon Receive CreateContract(GT ):
3 generate the arbitration cod, denoted by contract, as follows
4 initialize three maps Tstate, Arevs and Fstake
5 for each T ∈ GT :
6 compute an internal identifier for T as tid := H(T)
7 initialize Tstate[tid] := [unknown, T, tsopen=0, tsclosed=0, stproof]
8 retrieve tid’s fund-reversion account, denoted as dst
9 initialize Arevs[tid] := [amt=0, dst]
10 compute an identifier for contract as cid := H(
−→0 , contract)
11 initialize Data[cid] := [GT , Tstate, Arevs, Fstake]
12 send [cid, contract] to the requester for acknowledgment
13 Upon Receive StakeFund(cid):
14 (_, _, _, _, Fstake) := Data[cid]; abort if not found
15 update Fstake[msg.sender] := Fstake[msg.sender] + msg.value
16 Upon Receive InsuranceClaim(cid, Atte):
17 (_, _, Tstate, _, _) := Data[cid]; abort if not found
18 compute tid := H(Atte.T); T := Tstate[tid] abort if not found
19 abort if T.state is more advanced the state enclosed by Cert
20 if Atte is a certificate signed by both parties :
21 assert SigVerify(Atte) is true
22 if Atte is Certod
T
: update T.state := opened; T.tsopen := Atte.tsopen
23 else : update T.state := closed; T.tsclosed := Atte.tsclosed
24 else : # Atte is in form of a Merkle proof
25 assert MerkleVerify(Atte) is true
26 if Atte is a Merki
T
or Merkid
T
or Merko
T
:
27 retrieve the certificate Certi
T
or Certid
T
or Certo
T
from Atte
28 assert the Te enclosed in Certid
T
or Certo
T
is genuine
29 assert the tsopen enclosed in Certo
T
is genuine
30 update T.state := Atte.state
31 elif Atte is Merkod
T
:
32 retrieve the certificate Certod
T
from Atte
33 update T.state := opened and T.tsopen := Certod
T
.tsopen
34 elif Atte is Merkc
T
:
35 update T.stproof based on Merkc1
T
if necessary
36 update T.tsclosed as the height of the block attaching Merkc2
T
37 update T.state := closed
38 Upon Timeout SettleContract(cid): Internal Daemon
39 (GT , Tstate, Arevs, Fstake) := Data[cid]; abort if not found
40 for (tid, T) ∈ Tstate :
41 continue if T.state is not closed
42 update Arevs[tid].amt := T.T.meta.amt
43 if DeadlineVerify(T) = true : update T.state := correct
44 compute S := DirtyTrans(GT , Tstate) # non-empty if execution fails.
45 execute fund reversion for non-zero entries in Arevs if S is not empty
46 initialize a map resp to record which party to blame
47 for each (tid, T) ∈ S :
48 if T.state = closed | open | opened : resp[tid] := T.T.from
49 elif T.state = inited : resp[tid] := T.T.to
50 elif T.state = init : resp[tid] := D
51 else : resp[tid] := V
52 return any remaining funds in Fstake to corresponding senders
53 call Data.erase[cid] to stay silent afterwards
Figure 8: ProtISC: the protocol realization of the ISC arbitrator.
ProtCLI), ProtVES tries to retrieve the second part of Merkc
T
from
ProtNSB. The second proof, denoted as Merkc2
T
, is to prove that the
Merkle roots referred in Merkc1
T
are correctly linked to a StatusRoot
on a finalized NSB block (see Figure 7). Once Merkc
T
is fully constructed, the state of T is promoted as closed. Finally, ProtVES may
find a new set of transactions that are eligible to be executed if their
preconditions are finalized due to any recently-closed transactions.
If so, ProtVES processes them by either requesting initialization
from ProtCLI or calling SInitedTrans internally, depending on the
originators of those transactions.
4.2.4 ProtISC Invocation
ProtVES periodically invokes ProtISC to execute the contract. All
internally stored certificates and complete Merkle proofs are acceptable. However, for any T, ProtVES should invoke ProtISC only using
the attestation with the most advanced state, since lower-ranked
attestations for T are effectively ignored by ProtISC (c.f., § 4.4).
4.3 Execution Protocol by dApp Clients
ProtCLI specifies the protocol implemented by dApp clients. ProtCLI
defines the following set of handlers to match ProtVES. In particular, the InitedTrans and OpenedTrans match the SInitedTrans
and OpenTrans of ProtVES, respectively, to process Certid and
Certod sent by ProtVES when handling transactions originated from
ProtVES. The InitTrans and OpenTrans process Certi
and Certo
sent
by ProtVES when executing transactions originated from ProtCLI.
The CloseTrans and ClosedTrans of ProtCLI match their counterparts in ProtVES to negotiate closing attestations.
For usability, HyperService imposes smaller requirements on
the watching daemons implemented by ProtCLI. Specially, ProtCLI
still proactively watches ProtNSB to have a fallback communication medium with ProtVES. However, ProtCLI is not required to
proactively watch the status of underlying blockchains or dynamically compute eligible transactions whenever the execution status
changes. We intentionally offload such complexity on ProtVES to
enable lightweight dApp clients. ProtCLI, though, should (and is
motivated to) check the status of self-originated transactions in
order to request transaction closing.
4.4 Protocol Realization of the ISC
Figure 8 specifies the protocol realization of the ISC. The CreateContract handler is the entry point of requesting insurance contract
creation using ProtISC. It generates the arbitration code, denoted
as contract, based on the given dApp executable GT . The contract
internally uses Tstate to track the state of each transaction in GT ,
which is updated when processing security attestations in the InsuranceClaim handler. For clear presentation, Figure 8 extracts
the state proof and fund reversion tuple from T as dedicated variables stproof and Arevs. When the ProtISC times out, it executes the
contract terms based on its internal state, after which its funds
are depleted and the contract never runs again. Below we explain
several technical subtleties.
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 558
Correct Close /
Opened
No party to
blame
Open
Originator:
Violated deadline
Inited
Originator: Failed
to dispatch
Init
Dest: Failed to
request opening
dApp: Failed to
initialize
Unknown
VES: Failed to
proactively drive
Negative Branch Positive Branch
Figure 9: The decision tree to decide the accountable party
for a dirty transaction.
4.4.1 Insurance Claim
The InsuranceClaim handler processes security attestations from
ProtVES and ProtCLI. Only dual-signed certificates (i.e., Certod and
Certc
) or complete Merkle proofs are acceptable. Processing dualsigned certificates is straightforward as they are explicitly agreed
by both parties. However, processing Merkle proof requires additional correctness checks. First, when validating a Merkle proof
Merki
T
, Merkid
T
or Merko
T
, ProtISC retrieves the single-party signed
certificate Certi
T
, Certid
T
or Certo
T
enclosed in the proof and performs the following correctness check against the certificate. (i) The
certificate must be signed by the correct party, i.e., Certi
T
is signed
by ProtVES, Certid
T
is signed by T’s originator and Certo
T
is signed
by the destination of T. (ii) The enclosed on-chain transaction Tein
Certid
T
and Certo
T
is correctly associated with T. The checking logic
is the same as the on used by ProtVES, which has been explained
in § 4.2.2. (iii) The enclosed tsopen in Certo
T
is genuine, where the
genuineness is defined as a bounded difference between tsopen and
the height of the NSB block that attaches Merko
T
.
4.4.2 Contract Term Settlement
ProtISC registers a callback SettleContract to execute contract terms
automatically upon timeout. ProtISC internally defines an additional
transaction state, called correct. The state of a closed transaction
is promoted to correct if its deadline constraint is satisfied. Then,
ProtISC computes the possible dirty transactions in GT , which are
the transactions that are eligible to be opened, but with non-correct
state. Thus, the execution succeeds only if GT has no dirty transactions. Otherwise, ProtISC employs a decision tree, shown in Figure 9,
to decide the responsible party for each dirty transaction. The decision tree is derived from the execution steps taken by ProtVES and
ProtCLI. In particular, if a transaction T’s state is closed, opened or
open, then it is T’s originator to blame for either failing to fulfill the
deadline constraint or failing to dispatch Te for on-chain execution.
If a transaction T’s state is inited, then it is T’s destination party’s
responsibility for not proceeding with T even though Certid
T
has
been provably sent. If a transaction T’s state is init (only transactions originated from dApp D can have init status), then D (the
originator) is the party to blame for not reacting on the Certi
T
sent
by V. Finally, if transaction T’s state is unknown, then V is held
accountable for not proactively driving the initialization of T, no
matter which party originates T.
4.5 Specification of ProtNSB and ProtBC
ProtBC specifies the protocol realization of a general-purpose blockchain where a set of consensus nodes run a secure protocol to agree
upon the public global state. In this paper, we regard ProtBC as a
conceptual party trusted for correctness and availability, i.e., ProtBC
guarantees to correctly perform any predefined computation (e.g.,
Turing-complete smart contract programs) and is always available to handle user requests despite unbounded response latency.
ProtNSB specifies the protocol realization of the NSB. ProtNSB is
an extended version of ProtBC with additional capabilities. Due
to space constraint, we move the detailed protocol description of
ProtBC and ProtNSB to our technical report that is available on both
our source code repository [4] and arXiv.
4.6 Security Theorems
To rigorously prove the security properties of UIP, we first present
the cryptography abstraction of the UIP in form of an ideal functionality FUIP. The ideal functionality articulates the correctness
and security properties that UIP wishes to attain by assuming a
trusted entity. Then we prove that ProtUIP, our the decentralized
real-world protocol containing the aforementioned preliminary
protocols, securely realizes FUIP using the UC framework [28], i.e.,
ProtUIP achieves the same functionality and security properties as
FUIP without assuming any trusted authorities. Since the rigorous
proof requires non-trivial simulator construction within the UC
framework, we defer detailed proof to a dedicated section § 8.
5 IMPLEMENTATION AND EXPERIMENTS
In this section, we present the implementation of a HyperService
prototype and report experiment results on the prototype. At the
time of writing, the total development effort includes (i) ∼1,500
lines of Java code and ∼3,100 lines of ANTLR [54] grammar code
for building the HSL programming framework, (ii) ∼21,000 lines of
code, mainly in Go and Python, for implementing the UIP protocol;
and ∼8,000 lines of code, mainly in Go, for implementing the NSB;
and (iii) ∼1,000 lines of code, in Solidity, Vyper, Go and HSL, for
writing cross-chain dApps running on HyperService. The released
source code is available at [4]. The HyperService Consortium is
under active development for HyperService.
5.1 Platform Implementation
To demonstrate the interoperability and programmability across
heterogeneous blockchains on HyperService, our current prototype incorporates Ethereum, the flagship public blockchain, and a
permissioned blockchain built atop the Tendermint [17] consensus
engine, a commonly cited cornerstone for building enterprise blockchains. We implement the necessary accounts (wallets), the smart
contract environment, and the on-chain storage to deliver the permissioned blockchain with full programmability. The NSB is also
built atop Tendermint with full support for its claimed capabilities,
such as action staking and Merkle proof retrieval.
For the programming framework, we implement the HSL compiler that takes HSL programs and contracts written in Solidity,
Vyper, and Go as input, and produces transaction dependency
graphs. We implement the multi-lang front end and the HSL front
end using ANTLR [54], which parse the input HSL program and
contracts, build an intermediate representation of the HSL program,
and convert the types of contract entities into our unified types.
We also implement the validation component that analyzes the
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 559
intermediate representation to validate the entities, operations, and
dependencies specified in the HSL program.
Our experience with the prototype implementation is that the
effort for horizontally scaling HyperService to incorporate a new
blockchain is lightweight: it requires no protocol change to both UIP
and the blockchain itself. We simply need to add an extra parser
to the multi-lang front end to support the programming language
used by the blockchain (if this language is new to HyperService),
and meanwhile VESes extend their visibility to this blockchain. The
HyperService consortium is continuously working on on-boarding
additional blockchains, both permissioned and permissionless.
5.2 Application Implementation
Besides the platform implementation, we further implement and
deploy three categories of cross-chain dApps on HyperService.
Financial Derivatives. Financial derivatives are among the mostly
cited blockchain applications. However, external data feed, i.e., an
oracle, is often required for financial instructions. Currently, oracles are either built atop trusted third-party providers (e.g., Oraclize [11]), or using trusted hardware enclaves [62]. HyperService,
for the first time, realizes the possibility of using blockchains themselves as oracles. With the built-in decentralization and correctness
guarantees of blockchains, HyperService fully avoids trusted parties
while delivering genuine data feed to smart contracts. In this application sector, we implement a cross-chain cash-settled Option dApp
in which options can be natively traded on different blockchains (a
scaled-up version of the introductory example in § 2.3).
Cross-Chain Asset Movement. HyperService natively enables
cross-chain asset transfers without relying on any trusted entities,
such as exchanges. This primitive could power a wide range of
applications, such as a global payment network that interconnects
geographically distributed bank-backed consortium blockchains [9],
an initial coin offering in which tokens can be sold in various
cryptocurrencies, and a gaming platform where players can freely
trade and redeem their valuables (in form of non-fungible tokens)
across different games. In this category, we implement an asset
movement dApp with hybrid operations where assets are moved
among accounts and smart contracts across different blockchains
Federated Computing. In a federated computing model, all participants collectively work on an umbrella task by submitting their
local computation results. In the scenario where transparency and
accountability are desired, blockchains are perfect platforms for
persisting both the results submitted by each participant and the
logic for aggregating those results. In this application category, we
implement a federated voting system where delegates in different
regions can submit their votes to their regional blockchains, and
the logic for computing the final votes based on the regional votes
is publicly visible on another blockchain.
5.3 Experiments
We ran experiments with three blockchain testnets: one private
Ethereum testnet, one Tendermint-based blockchain, and the NSB.
Each of those testnets is deployed on a VM instance of a public cloud
on different continents. For experiment purposes, dApp clients and
VES nodes can be deployed either locally or on cloud.
Financial
Derivatives
CryptoAsset
Movement
Federated
Computing
Mean % Mean % Mean %
HSL Compilation 1.1769 ∼16 0.2598 ∼4 1.095 ∼15
Session Creation 4.2399 ∼58 4.1529 ∼67 4.2058 ∼60
Action/Status Staking 0.6754 ∼10 0.7295 ∼12 0.7592 ∼11
Proof Retrieval 1.0472 ∼15 1.0511 ∼17 0.9875 ∼14
Total 7.1104 6.1933 7.0475
Table 3: End-to-end dApp execution latency on HyperService, with profiling breakdown. All times are in seconds.
 0
 200
 400
 600
 800
 1000
 1200
 0 20 40 60 80 100 120 140
Throughput (KB/s)
Batch Size
Cert. Size 200 Bytes
Cert. Size 250 Bytes
Cert. Size 500 Bytes
Figure 10: The throughput of the NSB, measured as the total
size of committed certificates on the NSB per second.
5.3.1 End-to-End Latency
We evaluated all three applications mentioned in § 5.2 and reported
their end-to-end execution latency introduced by HyperService in
Table 3. The reported latency includes HSL program compiling,
dApp-VES session creation, and (batched) NSB action staking and
proof retrieval during the UIP protocol exchange. All reported
times include the networking latency across the global Internet.
Each datapoint is the average of more than one hundred runs.
We do not include the latency for actual on-chain execution since
the consensus efficiency of different blockchains varies and is not
controlled by HyperService. We also do not include the time for
ISC insurance claims in the end-to-end latency because they can
be done offline anytime before the ISC expires.
These dApps show similar latency profiling breakdown, where
the session creation is the most time consuming phase because it
requires handshakes between the dApp client and VES, and also
includes the time for ISC deployment and initialization. The CryptoAsset dApp has a much lower HSL compilation latency since its
operation only involves one smart contract, whereas the rest two
dApps import three contracts written in Go, Vyper, and Solidity. In
each dApp, all its NSB-related operations (e.g., action/status staking and proof retrievals) are bundled and performed in a batch for
experiment purpose, even though all certificates required for ISC
arbitration have been received via off-chain channels. The sizes of
actions and proofs for three dApps are different since their executables contain different number of transactions.
5.3.2 NSB Throughput and HyperService Capacity
The throughput of the NSB affects aggregated dApp capacity on
HyperService. In this section, we report the peak throughput of
the currently implemented NSB. We stress tested the NSB by initiating up to one thousand dApp clients and VES nodes, which
concurrently dispatched action and status staking to the NSB. We
batched multiple certificate stakings by different clients into a single
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 560
NSB-transaction, so that the effective certificate-staking throughput perceived by those clients can exceed the consensus limit of the
NSB. Figure 10 plots the NSB throughput, measured as the total size
of committed certificates by all clients per second, under different
certificate and batch sizes. The results show that as the batch size
increases, regardless of the certificate sizes, the NSB throughput
converged to about 1000 kilobytes per second. Given any certificate
size, further enlarging the batch size cannot boost the throughput,
whereas the failure rate of certificate staking increases, indicating
that the NSB is fully loaded.
Given the above NSB throughput, the actual dApp capacity of the
HyperService platform further depends on how often the communication between dApp clients and VESesfalls back to the NSB. In particular, each dApp-transaction spawns at most six NSB-transactions
(five action stakings and one status staking), assuming that the
off-chain channel is fully nonfunctional (zero NSB transaction if
otherwise). Thus, the lower bound of the aggregate dApp capacity
on HyperService, which would be reached only if all off-chain channels among dApp clients and VESes were simultaneously broken, is
about 170000
s
transactions per second (TPS), where s is the (average)
size (in bytes) of a certificate. This capacity and the TPS of most
PoS production blockchains are of the same magnitude. Further,
considering (i) the NSB is horizontally shardable at the granularity
of each underlying blockchain (§ 4.1.3) and (ii) not all transactions
on an underlying blockchain are cross-chain related, we anticipate
that the NSB will not become the bottleneck as HyperService scales
to support more blockchains in the future.
6 DISCUSSION
In this section, we discuss several aspects that have not been thoroughly addressed in this paper, and present our vision for future
work on HyperService and its impact.
6.1 Programming Framework Extension
HSL is a high-level programming language designed to write crosschain dApps under the USM programming model. The language
constructs provided by HSL allow developers to directly specify
entities, operations, and dependencies in HSL programs. To ensure
the determinism of operations, which is an important property
for the NSB and the ISC to determine the correctness or violation of dApp executions, the language constructs do not include
control-flow operations such as conditional branching, looping, and
calling/returning from a procedure. Additionally, dynamic transaction generation is also not supported by HSL, since it has led
to a new class of bugs known as re-entrancy vulnerabilities [55].
These design choices are consistent with the recent blockchain
programming languages that emphasize on safety guarantees, such
as Move [22] for Facebook’s Libra blockchain.
In future work, we plan to extend the design of the UIP protocol
to support dynamic transaction graphs, which allows conditional
execution of operations and certain degree of indeterminism of
operation executions, such as repeating an operation for a specific
times based on the values of state variables computed from previous
operations. With those extensions, we are able to implement controlflow operations into HSL and provide both static and dynamic
verification to ensure the correctness of dApps.
6.2 Cross-Shards and Cross-Worlds
HyperService is motivated by heterogeneous blockchain interoperation. Thanks to its generic design, HyperService can also enable
cross-shard smart contracting and transactions for sharded blockchain platforms (e.g., OmniLedger [44] and RapidChain [60]). On the
one hand, the HSL programming framework is blockchain-neutral
and extensible. Thus, writing dApps that involve smart contracts
and accounts on different blockchains is conceptually identical
to writing dApps that operate contracts and accounts on different shards. In fact, given that most of those sharded blockchains
are homogeneously sharded (i.e., all shards have the same format
of contracts and accounts), developing and compiling cross-shard
dApps using HSL are even simpler than cross-chain dApps. On the
other hand, realizing UIP on sharded blockchains also requires less
overhead since maintaining an NSB for all (homogeneous) shards
is more lightweight than maintaining an NSB supporting heterogeneous blockchains. In fact, many sharded blockchain platforms
already maintain a dedicated global blockchain as their trust anchor
(e.g., the identity chain of OmniLedger [44] and the beacon chain
of Harmony [2]), to which the NSB functionality can be ported.
Additionally, we envision that the fully connected Web 3.0 should
also include centralized platforms (i.e., Cloud) to compensate for
functionality (e.g., performing computationally intensive tasks) that
is difficult to execute on-chain. We recognize that two additional
capabilities, with minimal distribution of their operation models,
are required from those centralized platforms to make them compatible with HyperService: (i) any public state they publish should be
coupled with verifiable proofs to certify the correctness of the state
(where the definition of correctness could be application-specific),
and (ii) all published state should have the concept of finality. With
such capabilities, dApps on HyperService can trustlessly incorporate the state published by those centralized platforms.
6.3 Interoperability Service Providers
VESes play vital roles on HyperService platform. We envision that
VESes would enter the HyperService ecosystem as Cross-chain
Interoperability Service Providers (CSPs) by providing required
services to support cross-chain dApps, such as compiling HSL programs into transaction dependency graphs and speaking the UIP
protocol. This vision is indeed strengthened by the practical architectures of production blockchains, where all peer-to-peer nodes
evolve into a hierarchy of stakeholders and a number of organizations operate (without necessarily owning) most of the mining
power for Proof-of-Work blockchains or/and stakes for Proof-ofStake blockchains (whether such a hierarchical architecture undermines decentralization is debatable, and beyond the scope of HyperService). Those organizations are perfectly qualified to operate
as CSPs since they have good connectivity to multiple blockchains
and maintain sufficient token liquidity to support insurance staking,
contract invocation, and token transfers that are required in a wide
range of cross-chain dApps.
CSPs (VESes) could be found via a community-driven directory
(similar to Tor’s relay directories [18, 31]), which we envision to be
an informal list of CSPs. Each CSP has its own operation models,
including the set of reachable blockchains, service fees charged
for correct dApp executions, and insurance plans to compensate
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 561
for CSP-induced dApp failures. Developers have full autonomy
to select CSPs based on their dApp requirements. Since all dApp
execution results are publicly verifiable, it is possible to build a CSP
reputation system to provide a valuable metric for CSP selection.
CSPs thus misbehave at their own risk.
Because a CSP may wish to limit its staked funds at risk in the
ISC, a dApp may be too large for any single CSP. Alternatively, a
dApp may span a set of blockchains such that no single CSP has
reachability to all of them. In such cases, a cross-chain dApp could
be co-executed by a collection of VESes. By design, HyperService
allows multi-VES executions since the UIP protocol does not restrict
the number of VESes or dApp clients.
We envision the industrial impact of HyperService to be the
birth of a CSP-formed liquidity network interconnected by the UIP
protocol, powering a wide range of cross-chain dApps.
6.4 Complete Atomicity for dApps
In the context of cross-chain applications, dApps should be treated
as first-class citizens because the success or failure of any individual
transaction cannot fully decide the state of a dApp. HyperService
follows this design philosophy by providing security guarantees
at the granularity of dApps. However, the current version of HyperService is not fully dApp-atomic since UIP is unable to revert
any state update to smart contracts when a dApp terminates prematurely. We recognize this as a fundamental challenge due to the
finality guarantee of blockchains.
To deliver full dApp-atomicity on HyperService, we propose the
concept of stateless smart contracts where contracts are able to their
load state from the blockchain before execution. As a result, even
if the state persistent on block Bn for a smart contact C eventually
becomes dirty due to dApp failure, subsequent dApps can still load
clean state for the contract C from a block (prior to Bn) agreed by all
parties. Although this design imposes additional requirements on
underlying blockchains, it is practical and deliverable using “layertwo” protocols where smart contract executions could be decoupled
from the consensus layer, for instance, via the usage of Trusted
Execution Environment (e.g., Intel SGX [30] and Keystone [48]).
6.5 Privacy-Preserving Blockchains
The primary challenge of supporting privacy-preserving blockchains on HyperService is the lack of a generic abstraction for
those systems. In particular, various designs have been proposed
to enhance blockchain privacy, such as encrypting blockchain
state [29], obfuscating and mixing transactions via cryptography
signature [58]. As a result, none of those blockchains can be abstracted as generic programmable state machines. Therefore, our approach towards interoperating privacy-preserving blockchains will
be dApp-specific, such as relying on fast zero-knowledge proofs [25]
to allow dAppsto certify the state extracted from those blockchains.
7 RELATED WORK
Blockchain interoperability is often considered as one of the prerequisites for the massive adoption of blockchains. The recent
academic proposals have mostly focused on moving tokens between two blockchains via trustless exchange protocol, including side-chains [21, 36, 41], atomic cross-chain swaps [5, 38], and
cryptocurrency-backed assets [61]. However, programmability, i.e.,
smart contracting across heterogeneous blockchains, is largely ignored in those protocols.
In industry, Cosmos [7] and Polkadot [12] are two notable projects
that advocate blockchain interoperability. They share the similar
spirit: each of them has a consensus engine to build blockchains (i.e.,
Tendermint [17] for Cosmos and Substrate [16] for Polkadot), and
a mainchain (i.e., the Hub in Cosmos and RelayChain for Polkadot)
to bridge individual blockchains. Although we do share the similar
vision of “an Internet of blockchains”, we also notice two notable
differences between them and HyperService. First and foremost,
the cross-chain layer of Cosmos, powered by its Inter-blockchain
Communication Protocol (IBC) [15], mainly focuses on preliminary
network-level communications. In contrast, HyperService proposes
a complete stack of designs with a unified programming framework
for writing cross-chain dApps and a provably secure cryptography
protocol to execute dApps. Further, at the time of writing, the most
recent development of Cosmos and industry adoption are heading
towards homogeneity where only Tendermint-powered blockchains
are interoperable [1]. This is in fundamental contrast with HyperService where the blockchain heterogeneity is a first-class design
requirement. Polkadot proceeds relatively slower than Cosmos:
Substrate is still in early stage [16].
Existing blockchain platforms such as Ethereum [59] and Nebulas [10] allow developers to write contracts using new languages
such as Solidity [14] and Vyper [19] or a tailored version of the
existing languages such as Go, Javascript, and C++. Facebook recently released Move [22], a programming language in their blockchain platform Libra, which adopts the move semantics of Rust
and C++ to prohibit copying and implicitly discarding coins and
allow only move of the coins. To unify these heterogeneous programming languages, we propose HSL that has a multi-lang front
end to parse those contacts and convert their types to unified types.
Although there exist domain-specific languages in a variety of
security-related fields that have a well-established corpus of low
level algorithms, such as secure overlay networks [42, 49], network intrusions [23, 56, 57], and enterprise systems [33, 34], these
languages are explicitly designed to solve their domain-specific
problems, and cannot meet the needs of the unified programming
framework for writing cross-chain dApps.
8 SECURITY THEOREMS
In this section, we present the main security theorems for UIP, and
rigorously prove them using the UC-framework [28].
8.1 Ideal Functionality FUIP
We first present the cryptography abstraction of the UIP in form of
an ideal functionality FUIP. The ideal functionality articulates the
correctness and security properties that HyperService wishes to
attain by assuming a trusted entity. The detailed description of FUIP
is given in Figure 11. Below we provide additional explanations.
Session Setup. Through this interface, a pair of parties (Pa, Pz )
(e.g., a dApp client and a VES) requests FUIP to securely execute a
dApp executable. They provide the executable in form of a transaction dependency graph GT , as well as the correctness arbitration
code contract. As a trusted entity, FUIP generates keys for both
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 562
1 Init: Data := ∅
2 Upon Receive SessionCreate(GT , contract, Pa, Pz ):
3 generate the session ID sid ← {0, 1}
λ
and keys for both parties
4 send Cert([sid, GT , contract]; SigPz
sid , SigPa
sid ) to both parties
5 halt until both parties deposit sufficient fund, denoted as stake
6 start a blockchain monitoring daemon for this session
7 set an expiration timer timer for executing the contract term
8 for T ∈ GT : initialize the annotations for T
9 update Data[sid] := {GT , contract, stake, timer}
10 Upon Receive ReqTransInit(T, sid, P):
11 (GT , _, _, _) := Data[sid]; abort if not found
12 assert P is Pz
13 assert T is eligible to be opened according the state of GT
14 update T.state := init
15 compute Certi
T
:= Cert([T, init, sid]; SigPz
sid )
16 send Certi
T
to both {Pa, Pz } to inform action
17 Upon Receive ReqTransInited(T, sid, P)
18 (GT , _, _, _) := Data[sid]; abort if not found
19 assert P = T.from and T.state = init
20 compute the on-chain transaction Te for T
21 update T.state := inited and T.trans := Te
22 compute Certid
T
:= Cert([Te, inited, sid, T]; SigP
sid)
23 send Certid
T
to both {Pa, Pz } to inform action
24 Upon Receive ReqTransOpen(T, sid, Te, P):
25 (GT , _, _, _) := Data[sid]; abort if not found
26 assert P = T.to, T.state = inited and T.trans = Te
27 update T.state = open and get tsopen := now()
28 compute Certo
T
:= Cert([Te, open, tsopen, sid, T]; SigP
sid)
29 send Certo
T
to both {Pa, Pz } to inform action
30 Upon Receive ReqTransOpened(T, sid, Te, P, tsopen):
31 (GT , _, _, _) := Data[sid]; abort if not found
32 assert P = T.from, T.state = open and T.trans = Te
33 assert tsopen is within the error boundary with now()
34 update T.state = opened and get T.tsopen := tsopen
35 post Te on Fblockchain for on-chain execution
36 compute Certod
T
:= Cert([Te, open, tsopen, sid, T); SigPa
sid , SigPz
sid )
37 send Certod
T
to both {Pa, Pz } to inform action
38 Upon Receive ReqTransClose(T, sid, Te, tsclosed):
39 (GT , _, _, _) := Data[sid]; abort if not found
40 assert T.state = opened and T.trans = Te
41 query the ledger of Fblockchain for Te’s status
42 abort if T is not finalized on Fblockchain
43 assert tsclosed is within the error boundary with current time now()
44 update T.state := closed and T.tsclosed := tsclosed
45 compute Certc
T
:= Cert([T, closed, tsclosed, sid, T); SigPa
sid , SigPz
sid )
46 send Certc
T
to both {Pa, Pz } to inform action
47 Upon Receive TermExecution(sid, P ∈ (Pa, Pz )) public:
48 (GT , contract, stake, timer) := Data[sid]; abort if not found
49 abort if timer has not expired
50 # The following is the arbitration logic specified by contract
51 initialize a map resp to record which party to blame
52 compute eligible transactions set S given current state of GT
53 for T ∈ S :
54 if T.state = unknown : update resp[T] := Pz
55 elif T.state = init : update resp[T] := Pa
56 elif T.state = inited : update resp[T] := T.to
57 elif T.state = open and T.state = opened :
58 update resp[T] := T.from
59 elif T.state = closed and deadline constraint fails :
60 update resp[T] =: T.from
61 financially revert all closed transactions if resp is not empty
62 return any remaining funds in stake to corresponding senders
63 remove the internal bookkeeping of sid from Data
Figure 11: The ideal functionality FUIP.
parties, allowing FUIP to sign transactions and compute certificates
on their behalf. Both parties are required to stake sufficient funds,
derived from the contract, into FUIP. FUIP annotates each transaction wrapper T in GT with its status (initialized to be unknown),
its open/close timestamps (initialized to 0s), and its on-chain counterpart Te (initialized to be empty). To accurately match FUIP with
the real-world protocol ProtUIP, in Figure 11, we assume that Pa is
the dApp client and Pz is the VES.
Since FUIP does not impose any special requirements on the
underlying blockchains, we model the ideal-world blockchain as an
ideal functionality Fblockchain that supports two simple interfaces:
(i) public ledger query and (ii) state transition triggered by transactions (where FUIP imposes no constraint on both the ledger format
and the consensus logic of state transitions).
Transaction State Updates. FUIP defines a set of interfaces to
accept external calls for updating transaction state. In each interface,
FUIP performs necessary correctness check to guarantee that the
state promotion is legitimate. In all interfaces, FUIP computes an
attestation for the corresponding transaction state, and sends it to
both parties to formally notify the actions taken by FUIP.
Financial Term Execution. Upon the expiration of timer, both
parties can invoke the TermExecution interface to trigger the contract code execution. The arbitration logic is also derived from
decision tree mentioned in Figure 9. However, FUIP decides the
final state of each transaction merely using its internal state due to
the assumed trustiness.
Verbose Definition of FUIP. We intentionally define FUIP verbosely (that is, sending many signed messages) in order to accurately match FUIP to the real world protocol ProtUIP. For instance,
in the SessionCreate interface, FUIP certifies (GT ,contract,sid) on
behalf of both parties to simulate the result of a successful handshake between two parties in the real world. Another example is
that the attestations generated in those state update interfaces are
not essential to ensure correctness due to the assumed trustiness
of FUIP. However, FUIP still publishes attestations to emulate the
side effects of ProtUIP in the real world. As we shall see below, such
emulation is crucial to prove that FUIP UC-realizes ProtUIP.
Correctness and Security Properties of FUIP.With the assumed
trustiness, it is not hard to see that FUIP offers the following correctness and security properties. First, after the pre-agreed timeout,
the execution either finishes correctly with all precondition and
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 563
deadline rules satisfied, or the execution fails and is financially
reverted. Second, regardless of the stage at which the execution
fails, FUIP holds the misbehaved parties accountable for the failure.
Third, if Fblockchain is modeled with bounded transaction finality
latency, Op is guaranteed to finish correctly if both parties are
honest. Finally, FUIP, by design, makes the contract public. This is
because in the real world protocol ProtUIP, the status of execution
is public both on the ISC and the NSB. We leave the support for
privacy-preserving blockchains on HyperService to future work.
8.2 Main Security Theorems
In this section, we claim the main security theorem of HyperService.
The correctness of Theorem 8.1 guarantees that ProtUIP achieves
same security properties as FUIP.
Theorem 8.1. Assuming that the distributed consensus algorithms
used by relevant BNs are provably secure, the hash function is preimage resistant, and the digital signature is EU-CMA secure (i.e.,
existentially unforgeable under a chosen message attack), our decentralized protocol ProtUIP securely UC-realizes the ideal functionality
FUIP against a malicious adversary in the passive corruption model.
We further consider a variant of ProtUIP, referred to as H-ProtUIP,
that requires PVES and PCLI to only use PNSB as their communication medium.
Theorem 8.2. With the same assumption of Theorem 8.1, the UIP
protocol variant H-ProtUIP securely UC-realizes the ideal functionality
FUIP against a malicious adversary in the Byzantine corruption model.
8.3 Proof Overview
We now the prove our main theorems. We start with Theorem 8.1. In
the UC framework [28], the model of ProtUIP execution is defined
as a system of machines (E, A, π1, ..., πn) where E is called the
environment, A is the (real-world) adversary, and (π1, ..., πn) are
participants (referred to as parties) of ProtUIP where each party may
execute different parts of ProtUIP. Intuitively, the environment E
represents the external system that contains other protocols, including ones that provide inputs to, and obtain outputs from, ProtUIP.
The adversary A represents adversarial activity against the protocol execution, such as controlling communication channels and
sending corruption messages to parties. E and A can communicate freely. The passive corruption model (used by Theorem 8.1)
enables the adversary to observe the complete internal state of
the corrupted party whereas the corrupted party is still protocol
compliant, i.e., the party executes instruction as desired. § 8.6 discusses the Byzantine corruption model, where the adversary takes
complete control of the corrupted party.
To prove that ProtUIP UC-realizes the ideal functionality FUIP,
we need to prove that ProtUIP UC-emulates IFUIP , which is the ideal
protocol (defined below) of our ideal functionality FUIP. That is, for
any adversary A, there exists an adversary (often called simulator)
S such that E cannot distinguish between the ideal world, featured
by (IFUIP , S), and the real world, featured by (ProtUIP, A). Mathematically, on any input, the probability that E outputs
−→1 after
interacting with (ProtUIP, A) in the real world differs by at most
a negligible amount from the probability that E outputs
−→1 after
interacting with (IFUIP , S) in the ideal world.
The ideal protocol IFUIP is a wrapper around FUIP by a set of
dummy parties that have the same interfaces as the parties of
ProtUIP in the real world. As a result, E is able to interact with
IFUIP in the ideal world the same way it interacts with ProtUIP in
the real world. These dummy parties simply pass received input
from E to FUIP and relay output of FUIP to E, without implementing
any additional logic. FUIP controls all keys of these dummy parties.
For the sake of clear presentation, we abstract the real-world participants of ProtUIP as five parties {PVES, PCLI, PISC, PNSB, PBC }.
The corresponding dummy party of PVES in the ideal world is
denoted as P
I
VES. This annotation applies for other parties.
Based on [28], to prove that ProtUIP UC-emulates IFUIP for any
adversaries, it is sufficient to construct a simulator S just for the
dummy adversary A that simply relays messages between E and
the parties running ProtUIP. The high-level process of the proof
is that the simulator S observes the side effects of ProtUIP in the
real world, such as attestation publication on the NSB and contract
invocation of the ISC, and then accurately emulates these effects
in the ideal world, with the help from FUIP. As a result, E cannot
distinguish the ideal and real worlds.
8.4 Construction of the Ideal Simulator S
Next, we detail the construction of S by specifying what actions S
should take upon observing instructions from E. As a distinguisher,
E sends the same instructions to the ideal world dummy parities
as those sent to the real world parties.
• Upon E gives an instruction to start an inter-BN session between
P
I
CLI and P
I
VES, S emulates the GT and contract setup (c.f., § 8.5)
and constructs a SessionCreate call to FUIP with parameter (GT ,
contract, P
I
CLI, P
I
VES).
• Upon E instructs P
I
VES to send an initialization request for a
transaction intent T, S extracts T and sid from the instruction
of E, and constructs a ReqTransInit call to FUIP with parameter
(T,sid, P
I
VES). Other instructions in the same category are handled similarly by S. In particular, for instruction to SInitedTrans,
S calls ReqTransInited of FUIP; for instructions to RInitedTrans,
S calls ReqTransOpen of FUIP; for instructions to OpenTrans, S
calls ReqTransOpened of FUIP; for instructions to CloseTrans, S
calls ReqTransClose of FUIP. S ignores instructions to OpenedTrans and ClosedTrans. S may also extract the Te from the instruction, which is used by some interfaces of FUIP to ensure the
association between T and Te.
• Due to the asymmetry of interfaces defined by P
I
CLI and P
I
VES, S
acts slightly differently when observing instructions sent to P
I
VES.
In particular, for instructions to InitTrans, S calls ReqTransInited
of FUIP; for instructions to InitedTrans, S calls ReqTransOpen
of FUIP; for instructions to OpenTrans, S calls ReqTransOpened
of FUIP. The rest handlings are the same as those of P
I
VES.
• Upon E instructs P
I
VES to invoke the smart contract, S locally
executes the contract and the instructs FUIP to published the
updated contract to P
I
ISC.
8.5 Indistinguishability of Real and Ideal Worlds
To prove indistinguishability of the real and ideal worlds from
the perspective of E, we will go through a sequence of hybrid
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 564
arguments, where each argument is a hybrid construction of FUIP,
a subset of dummy parties of IFUIP , and a subset of real-world
parties of ProtUIP, except that the first argument that is ProtUIP
without any ideal parties and the last argument is IFUIP without
any real world parties. We prove that E cannot distinguish any
two consecutive hybrid arguments. Then based on the transitivity
of protocol emulation [28], we prove that the first argument (i.e.,
ProtUIP) UC-emulates the last argument (i.e., IFUIP ).
Real World. We start with the real world ProtUIP with a dummy
adversary that simply passes messages to and from E.
Hybrid A1. Hybrid A1 is the same as the real world, except that the
(PVES, PCLI) pair is replaced by the dummy (P
I
VES, P
I
CLI) pair. Upon
observing an instruction from E to execute some dApp executables
GT , S calls the CreateContract interface of PISC (living in the
Hybrid A1) to obtain the contract code contract. Upon contract is
received, S calls the SessionCreate interface of FUIP with parameter
(GT , contract, P
I
VES, P
I
CLI), which will output a certificate to both
dummy parties to emulate the handshake result between PVES and
PCLI in the real world. S also deploys contract on PNSB or PBC in
the Hybrid A1. Finally, S stakes required funds into FUIP to unblock
its execution.
Upon observing an instruction from E (sent to either dummy
parties) to execute a transaction in GT , based on its construction
in § 8.4, S has enough information to construct a call to FUIP
with a proper interface and parameters. If the call generates a
certificate Cert, S retrieves Cert to emulate the PoAs staking in
the real world. In particular, if in the real world, PVES (and PCLI)
publishes a certificate on PNSB after receiving the same instruction
from E, then S publishes the corresponding certificate on PNSB
in the Hybrid A1 as well. Otherwise, S skip the publishing. Later,
S retrieves (and stores) the Merkle proof from PNSB, and then
instructs FUIP to output the proof to the dummy party which, from
the point view of E, should be the publisher of Cert.
Upon observing an instruction from E (to either dummy party)
to invoke the smart contract, S uses its saved certificates or Merkle
proofs to invoke PISC in the Hybrid A1 accordingly.
Note that in the real world, the execution of GT is automatic in
the sense that GT can continuously proceed even without additional
instructions from E after successful session setup. In the Hybrid A1,
although PVES and PCLI are replaced by dummy parties, S, with
fully knowledge of GT , is still able to drive the execution of GT so
that from E’s perspective, GT is executed automatically. Further,
since PISC still lives in the Hybrid A1, S should not trigger the
TermExecution interface of FUIP to avoid double execution on the
same contract terms. S can still reclaim its funds staked in FUIP via
“backdoor” channels since S and FUIP are allowed to communicate
freely under the UC framework.
Fact 1. With the aforementioned construction of S and FUIP, it is
immediately clear that the outputs of both dummy parties in the
Hybrid A1 are exactly the same as the outputs of the corresponding
actual parties in the real world, and all side effects in the real world
are accurately emulated by S in the Hybrid A1. Thus, E cannot
distinguish with the real world and the Hybrid A1.
Hybrid A2. Hybrid A2 is the same as the Hybrid A1, expect that
PISC is further replaced by the dummy P
I
ISC. As a result, S is
required to resume the responsibility of PISC in the Hybrid A2.
In particular, when observing an instruction to execute a GT , S
computes the arbitration code contract, and then instructs FUIP to
publish the contract on P
I
ISC, which is observable by E. For any
instruction to invoke contract, S locally executes contract with the
input and then publishes the updated contract to P
I
ISC via FUIP.
Finally, upon the predefined contract timeout, S calls the TermExecution interface of FUIP with parameter (sid, P
I
VES) or (sid, P
I
CLI)
to execute the contract, which emulates the arbitration performed
by PISC in the Hybrid A1.
It is immediately clear that with the help of S and FUIP, the output of the dummy P
I
ISC and all effects in the Hybrid A2 are exactly
the same as those in the Hybrid A1. Thus, E cannot distinguish
these two worlds.
Hybrid A3. Hybrid A3 is the same as the Hybrid A2, expect that
PNSB is further replaced by the dummy P
I
NSB. Since the structure of
PNSB and messages sent to PNSB are public, simulating its functionality by S is trivial. Therefore, Hybrid A3 is identically distributed
as Hybrid A2 from the view of E.
Hybrid A4, i.e., the ideal world. Hybrid A4 is the same as the
Hybrid A3, expect that PBC (the last real-world party) is further
replaced by the dummy P
I
BC. Thus, the Hybrid A4 is essentially
IFUIP . Since the functionality of PBC is a strict subset of that of
PNSB, simulating PBC by S is straightforward. Therefore, IFUIP is
indistinguishable with the Hybrid A3 from E’s perspective.
Then given the transitivity of protocol emulation, we show that
ProtUIP UC-emulates IFUIP , and therefore prove that ProtUIP UCrealizes FUIP. Throughout the simulation, we maintain a key invariant: S and FUIP together can always accurately simulate the
desired outputs and side effects on all (dummy and real) parties
in all Hybrid worlds. Thus, from E’s view, the indistinguishability
between the real and ideal worlds naturally follows.
8.6 Byzantine Corruption Model
Theorem 8.1 considers the passive corruption model. In this section,
we discuss the more general Byzantine corruption model for PVES
and PCLI (by assumption of this paper, blockchains and smart contracts are trusted for correctness). Previously, we construct S and
FUIP accurately to match the desired execution of ProtUIP. However,
if one party is Byzantinely corrupted, the party behaves arbitrarily.
As a result, a Byzantine-corrupted party may send conflicting messages to off-chain channels and PNSB. Note that for any transaction
state, ProtUIP always processes the first received attestation (either
a certificate from channels or Merkle proof from the PNSB) and
effectively ignores the other one. The adversary could then inject
message inconsistency to make the protocol execution favors one
type of attestations over the other. This makes it impossible for S
to always accurately emulate its behaviors, resulting in difference
between the ideal world and the real world from E’s view.
To incorporate the Byzantine corruption model into our security
analysis, we consider a variant of ProtUIP, referred to as H-ProtUIP,
that requires PVES and PCLI to only use PNSB as the communication
medium. Thus, the full granularity of protocol execution is guaranteed to be public and unique, allowing S to emulate whatever
actions a (corrupted) part may take in the real world. Therefore, it
is not hard to conclude the Theorem 8.2.
Session 3B: Blockchain I CCS ’19, November 11–15, 2019, London, United Kingdom 565
9 CONCLUSION
In this paper, we presented HyperService, the first platform that
offers interoperability and programmability across heterogeneous
blockchains. HyperService is powered by two innovative designs:
HSL, a programming framework for writing cross-chain dApps by
unifying smart contracts written in different languages, and UIP,
the universal blockchain interoperability protocol designed to securely realize the complex operations defined in these dApps on
blockchains. We implemented a HyperService prototype in approximately 35,000 lines of code to demonstrate its practicality, and ran
experiments on the prototype to report the end-to-end execution
latency for dApps, as well as the aggregate platform throughput.