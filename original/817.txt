Blockchains and more general distributed ledgers are becoming
increasingly popular as efficient, reliable, and persistent records of
data and transactions. Unfortunately, they ensure reliability and correctness by making all data public, raising confidentiality concerns
that eliminate many potential uses.
In this paper we present Solidus, a protocol for confidential transactions on public blockchains, such as those required for asset
transfers with on-chain settlement. Solidus operates in a framework based on real-world financial institutions: a modest number
of banks each maintain a large number of user accounts. Within
this framework, Solidus hides both transaction values and the transaction graph (i.e., the identities of transacting entities) while maintaining the public verifiability that makes blockchains so appealing.
To achieve strong confidentiality of this kind, we introduce the
concept of a Publicly-Verifiable Oblivious RAM Machine (PVORM).
We present a set of formal security definitions for both PVORM
and Solidus and show that our constructions are secure. Finally, we
implement Solidus and present a set of benchmarks indicating that
the system is efficient in practice.
CCS CONCEPTS
• Security and privacy → Domain-specific security and privacy architectures;
Keywords: Confidential Transactions; Oblivious RAM; Blockchain
1 INTRODUCTION
Blockchain-based cryptocurrencies, such as Bitcoin, allow users to
transfer value quickly and pseudonymously on a reliable distributed
public ledger. This ability to manage assets privately and authoritatively in a single ledger is appealing in many settings beyond
cryptocurrencies. Companies already issue shares on ledgers [27]
and financial institutions are exploring ledger-based systems for
instantaneous financial settlement.
For many of these companies, confidentiality is a major concern
and Bitcoin-type systems are markedly insufficient. Those systems
expose transaction values and the pseudonyms of transacting entities, often permitting deanonymization [45]. Concerns over this
leakage are driving many financial institutions to restrict on-chain
storage to transaction digests, placing details elsewhere [12, 36, 60].
Such architectures discard the key benefits of blockchains as centralized authoritative ledgers and reduce them to little more than a
timestamping service.
The overall structure of current blockchains additionally misaligns with that of the modern financial system. The direct peer-topeer transactions in Bitcoin and similar systems interfere with the
customer-service role and know-your-customer regulatory requirements of financial institutions. Instead, the financial industry is
exploring a model that we call bank-intermediated systems [36, 60].
In such systems a small number of entities—which we call banks—
manage transactions of on-chain assets on behalf of a large number
of users. For example, a handful of retail banks could use a bankintermediated ledger to authoritatively record stock purchases by
millions of customers. By design, bank-intermediated systems faithfully replicate asset flows within modern financial institutions.
While a number of bank-intermediated blockchain systems have
been proposed, e.g., [1, 26, 62], these systems either do not provide inherently strong confidentiality or do so by sequestering data
off-chain, preventing on-chain settlement. Coin mixes, e.g., [30, 41,
54, 61], and cryptocurrencies such as Monero [3] and Zcash [7] do
improve confidentiality, but with notable limitations. Coin mixes
and Monero provide only partial confidentiality, with demonstrated
weaknesses [45, 48, 57]. Zero-knowledge Succinct Non-interactive
ARguments of Knowledge (zk-SNARKs) [8], on which Zcash is
built, provide strong confidentiality. Proof generation, however, is
very expensive, requiring over a minute on a consumer machine
for Zcash [7]. While this is feasible for a single client performing
infrequent transactions, we show experimentally in this paper that
adapting zk-SNARKs to a bank-intermediated system would be prohibitively expensive. zk-SNARKs also require an undesirable trusted
setup and introduce engineering complexity and cryptographic
hardness assumptions that financial institutions are reluctant to
embrace [36].
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 701
To address these concerns we present Solidus,
1
a system supporting strong confidentiality and high transaction rates for bankintermediated ledgers. Solidus not only conceals transaction values,
but also provides the much more technically challenging property
of transaction-graph confidentiality.
2 This means that a transaction’s sender and receiver cannot be publicly identified, even by
pseudonyms. They can be identified by their respective banks, but
other entities learn only the identities of the banks.
Solidus takes a fundamentally different approach to transactiongraph confidentiality than previous systems such as Zcash. As the
technical cornerstone of Solidus, we introduce a new primitive
called Publicly-Verifiable Oblivious RAM Machine or PVORM, an
idea derived from previous work on Oblivious RAM (ORAM). In
previously proposed applications, ORAM is used by a single client
to outsource storage; only that client needs to verify the integrity of
the ORAM. In Solidus, the ORAM stores user account balances. This
means that any entity in the system must be able to verify (in zeroknowledge) that bank B’s ORAM reflects precisely the set of valid
transactions involving B. To meet this novel requirement, a PVORM
defines a set of legal application-specific operations and all updates
must be accompanied by ZK proofs of correctness. Correctness
includes requirements that account balances remain non-negative,
that each transaction updates a single account, and so forth. We
offer a formal and general definition of PVORM and describe an
implementation incorporated into Solidus.
The introduction of PVORM provides several benefits to Solidus.
First, a PVORM can be constructed with either zk-SNARKs or NIZK
proofs based on Generalized Schnorr Proofs (GSPs) [16, 18]. GSPs
are more efficient to construct than zk-SNARKs and do not require
trusted setup, but are much slower to verify, so we explore both options. Second, unlike Zcash, Solidus’s core data structure grows only
with the number of user accounts, not the number of transactions
over the system’s lifetime. This property is especially important in
high-throughput systems and minimizes performance penalties for
injecting of “dummy” transactions to mitigate timing side-channels.
Finally, Solidus maintains all balances as ciphertexts on the ledger.
This approach supports direct on-chain settlement—a feature many
systems, like Zcash, do not aim for. It also permits decryption of
balances by authorized parties and allows users to prove their own
balances if, for example, they wish to transfer funds away from
unresponsive banks.
In addition to the PVORM component, we present a formal security model for Solidus as a whole in the form of an ideal functionality.
This presentation may be of independent interest as a specification
of the security requirements of bank-intermediated ledger systems.
We prove the security of Solidus in this model.
Further, while Solidus targets a permissioned ledger model, it
requires only a permissioned group; it is agnostic to the implementation of the underlying ledger, whether centralized or distributed.
Therefore, we use the generic term ledger to denote a blockchain
substrate that can be instantiated in a wide variety of ways.
Our contributions can be summarized as follows:
1The solidus was a solid gold coin in the late Roman Empire.
2Pseudonymous cryptocurrencies such as Bitcoin are often viewed as graphs where
nodes represent keys and edges transactions. The term transaction-graph confidentiality means concealing the graph’s edges to guard against deanonymization attacks
exploiting its structure [45].
• Bank-intermediated ledgers. Our work on Solidus represents the
first formal treatment of confidentiality on bank-intermediated
ledgers—a new architecture that closely aligns with the settlement process in the modern financial system. Our work provides
a formal security model that broadly captures the requirements
of financial institutions migrating assets onto ledgers.
• PVORM. We introduce Publicly-Verifiable Oblivous RAM Machines,
a new construction derived from ORAM and suitable for enforcing transaction-graph confidentiality in ledger systems. We offer
formal definitions and efficient constructions using Generalized
Schnorr Proofs.
• Implementation and Experiments. We report on our prototype implementation of Solidus and present results of benchmarking expreiments, demonstrating a lower bound on Solidus performence.
We also provide a performance comparison with zk-SNARKs.
Our results are not just a new technical approach to transactiongraph confidentiality on ledgers. They also show the practicality of
bank-intermediated ledger systems with full on-chain settlement.
2 BACKGROUND
We now review existing cryptocurrency schemes and approaches
to their confidentiality. We then give some background on bankintermediated system modeling and describe the technical building
blocks used to achieve security and confidentiality in Solidus.
2.1 Existing Cryptocurrencies
Many popular cryptocurrencies are based on the same general transaction mechanism popularized by Bitcoin. Any user U may create
an account (“address” in Bitcoin) with a public/private key pair. To
transfer money, U creates a transaction T by signing a request to
send some quantity of coins to a recipient.3 Miners sequence transactions and directly publish T to the blockchain, an authoritative
append-only record of transactions. Since only transactions are
recorded, to determine the balance of U, it is necessary to tally all
transactions involving U in the entire blockchain. As a performance
optimization, many entities maintain a balance summary—called
an unspent transaction (UTXO) set in Bitcoin.
This setup publicizes all account balances and transaction details.
The only confidentiality stems from the pseudonymity of public
keys which are difficult—though far from impossible [45]—to link
to real-world identities.
To conceal balances and transaction values, Maxwell proposed a
scheme called Confidential Transactions (CT) [42]. CT operates in
a Bitcoin-like model, but publishes only Pedersen commitments of
balances. Transaction values are similarly hidden and balances are
updated using a homomorphism of the commitments and proven
non-negative using Generalized Schnorr Proofs (see below). Solidus
uses an El-Gamal-based variant of CT to conceal transaction values.
Several decentralized cryptocurrency schemes aim to provide
partial or full transaction-graph confidentiality. (See Section 8 for
a brief overview.) As noted above, though, only those involving
zk-SNARKs provide strong confidentiality of the type we seek for
3This is a simplification and details vary between systems. For example, a basic transaction in Bitcoin (“Pay-to-PubkeyHash”), takes a reference to the output from a previous
transaction and includes a small script restricting the user of outputs and a mining fee.
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 702
Solidus. Zcash and offshoots such as Hawk [37], for example, conceal balances, transfer amounts, and the transaction graph. They
do not, however, aim to align with the financial settlement system.
Additionally, they require trusted setup and store authoritative
state in a Merkle tree that grows linearly with the total system
transaction history, drawbacks we avoid in the design of Solidus.
As a basis for performance comparison, we describe and evaluate a
zk-SNARK-based version of Solidus in Section 7.3.
2.2 Bank-intermediated Systems
Managing assets on ledgers is appealing to the financial industry.
The transfer of assets in financial markets today involves a laborious three-step process. Execution denotes a legally enforceable
agreement between buyer and seller to swap assets, such as a security for cash. Clearing is updating a ledger to reflect the transaction
results. Settlement denotes the exchange of assets after clearing.
Multiple financial institutions typically act as intermediaries; when
a customer buys a security, a broker or bank will clear and settle
on her behalf via a clearinghouse.
Today, the full settlement process typically takes three days
(T+3) for securities. This delay introduces systemic risk into the
financial sector. Government agencies such as the Securities and
Exchange Commission (SEC) are trying to reduce this delay and are
looking to distributed ledgers as a long-term option. If asset titles—
the authoritative record of ownership—are represented on a ledger,
then trades could execute, clear, and settle nearly instantaneously.
Existing cryptocurrencies such as Bitcoin can be viewed as titles
of a digital asset. Execution takes the form of digitally signed transaction requests, while clearing and settlement are simultaneously
accomplished when a block containing the transaction is mined4
Today, however, banks intermediate most financial transactions.
Even with Bitcoin, ordinary customers often defer account management to exchanges (e.g. Coinbase). Additionally, a labyrinthine
set of regulations, such as Know-Your-Customer [49], favors bankintermediated systems. Thus existing cryptocurrencies do not align
well with either financial industry or ordinary customer needs.
Solidus aims to provide fast transaction settlement in a bankintermediated ledger-based setting. As in standard cryptocurrencies, Solidus assumes that each user has a public/private key pair
and digitally signs transactions. Solidus, however, conceals account
balances and transaction amounts as ciphertexts. To do so and
provide public verifiability at the same time, it relies on PVORM.
2.3 Oblivious RAM
As PVORM is heavily inspired by Oblivious RAM (ORAM), we provide some background here.
An ORAM is a cryptographic protocol that permits a client to
safely store data on an untrusted server. The client maintains a map
from logical memory addresses to remote physical addresses and
performs reads and writes remotely. Ensuring freshness, integrity,
and confidentiality of data in such a setting is straightforward
using authenticated encryption and minimal local state. The key
property of ORAM is concealment of memory access patterns; a
4
Strictly speaking, settlement involves an exchange of assets, and thus two transactions,
but this issue lies outside the scope of our work.
polynomially-bounded adversarial server cannot distinguish between two identical-length sequences of client operations.
These properties provide an appealing building block for Solidus.
Identifying an edge in the system’s transaction graph can easily
be reduced to identifying which account’s balance changed with
a transaction. Thus placing all balances in an ORAM immediately
provides transaction graph confidentiality. Moreover, recent work
has drastically improved the performance of ORAM. The most
practical ORAM constructions maintain a small local cache on the
client known as a stash and either organize the data blocks as a
tree allowing logarithmic work on each access [58, 63], or write to
completely randomized locations, resulting in constant-time writes
but linear reads (so-called “write-only” ORAM) [11].
Unfortunately, standard ORAM is insufficient for Solidus. Because ORAM is designed for a client using an untrusted server,
correctness simply means the ORAM reflects the client’s updates.
There is no notion of “valid” updates, let alone means for a client to
prove an update’s validity. In Solidus, clients (banks) must prove an
application-defined notion of correctness for each update. Banks
also cannot store a local stash, as we would no longer have all data
on the ledger. To address these concerns we introduce PVORM—
detailed in Section 4—a new construction inspired by ORAM.
2.4 Generalized Schnorr Proofs
Solidus makes intensive use of Generalized Schnorr Proofs (GSPs), a
class of Σ-protocol for which practical honest-verifier zero-knowledge
arguments (or proofs) of knowledge can be constructed.
Notation introduced in [16, 18] offers a powerful specification
language for GSPs that call the PoK language. Using multiplicative
group notation, let G = ⟨д⟩ be a cyclic group of prime order p.
5
If
x ∈ Zp and y = д
x
, then PoK(x : y = д
x
) represents a ZK proof of
knowledge of x such that y = д
x where д and y are known to the
verifier. (This is the Schnorr identification protocol.)
The PoK specification language for GSPs is quite rich; it supports
arbitrary numbers of variables as well as conjunctions and disjunctions among predicates. It has a set of corresponding standard tools
based on the Schnorr identification protocol for efficient realization
in practice whenG has known order [16]. It is possible, additionally,
using the Fiat-Shamir heuristic [29], to render GSPs non-interactive,
i.e., to generate NIZK proofs of knowledge.
Solidus uses GSPs in a variety of ways to ensure account balances
and PVORMs are properly updated and remain valid.
3 SOLIDUS OVERVIEW
Before delving into technical details, we give an overview of Solidus,
including basic notation, trust assumptions, and security goals. We
also give an architectural sketch. First, however, we give a concrete
target application as motivation.
Example 3.1 (TradeWind Markets). TradeWind Markets, whose
use case helped inform the design of Solidus, offers an example
of how Solidus might support management of asset titles [60].
TradeWind is building an electronic communication network (ECN)
for physical gold bullion to be traded using a bank-intermediated
5
Solidus uses the group for elliptic curve secp256k1. We make this choice for performance, so despite elliptic curve groups typically using additive notation, we will use
multiplicative notation for simplicity and generality.
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 703
ledger for settlement and title management. The physical bullion
is managed by a custodian who is trusted to track inflows and
outflows to and from a specifically designated vault. Each user
has an account with a holding bank—generally a large commercial
bank—which manages trades. A user may additionally buy gold
from outside, send it to the vault, and sell it on the TradeWind
ECN—requiring the custodian to create a record of the asset—or
buy gold on the TradeWind ECN, remove it from the vault, and sell
it elsewhere—requring the custodian to destroy the asset record.
Holdings are represented on the ledger as fractional ounces of
gold held by individual users. To trade gold, a user authorizes her
holding bank to transfer the gold to another user. Holding banks
may also provide other services, such as holding gold as collateral
against a loan. In such cases the bank may freeze assets, for example,
until the loan is repaid.
As we shall show, Solidus can support the full asset lifecycle
of a system like the TradeWind ECN while providing practical
performance and strong confidentiality and verifiability guarantees.
3.1 Design Approach
Solidus has two important features that differ from existing ledger
systems and make it more amenable to the financial industry.
The first is its bank-intermediated design: unlike nearly all systems proposed by the research community (see Section 8), Solidus
aligns with the structure of the modern financial system. Each bank
in Solidus has a set of customers or users who hold shares of some
asset (e.g., securities, cryptocurrency, or gold) in their accounts.
Specially designated entities called asset notaries record the injection of assets into the system, as we discuss below. Second, unlike
other bank-intermediated systems, Solidus provides strong confidentiality. It conceals account balances and transaction details from
non-transacting entities, placing them on the ledger as ciphertexts.
It is for these reasons that Solidus uses PVORM. Each bank maintains its own PVORM on the ledger to record the identities and
balances of its account.
Each transaction involves a sending user at a sending bank, and
a receiving user at a receiving bank. When a user (sender) Us signs
a transaction and gives it to her (sending) bank Bs
, Bs first verifies
the validity of the transaction—that it is correctly signed and Us
possesses the funds $v to be sent—then updates its PVORM to
reflect the results of the transaction. The receiving bank performs
a corresponding update on the receiving user’s account.
The confidentiality properties of PVORM ensure that another
entity can learn only the identities of the sending and receiving
banks, not $v or the identities of the transacting users. Indeed,
even the sending bank cannot identify the receiving user nor the
receiving bank the sending user.6 The public verifiability of PVORM
ensures that any entity with access to the ledger can verify that
each transaction is correctly processed by both banks.
Solidus is designed to be agnostic to the implementation of the
underlying ledger. While it does require a mutually-aware group of
banks and transaction validation by the ledger maintainers, those
6
It is desirable for receiver to be able to verify the sender’s identity. The sender can
easily acquire a receipt by retaining a proof that she authorized the transaction.
Ledger
PVORM PVORM
pks
1
$b
s
1
Us
1
pks
2
$b
s
2
Us
2
pkr
1
$b
r
1
Ur
1
pkr
2
$b
r
2
Ur
2
Bs Br
T : Us
2 → Ur
1
: $v
pks
1
$b
s
1
pks
2
$b
s
2
pkr
1
$b
r
1
pkr
2
$b
r
2
(−$v) (+$v)
T : Bs → Br
+ZK-Proofs
Figure 1: An example transaction T where Us
2
at Bs sends $v to
Ur
1
at Br and each bank has two users. The upper boxes are the
logical (plaintext) memory of each bank’s PVORM, and the lower
boxes are the associated public (encrypted) memories. Entities other
than Bs
, Br
, Us
2
, and Ur
1
learn only that a user at Bs sent money
to a user at Br and both banks updated their PVORMs correctly.
maintainers can be a “permissioned” (fixed-entity) group, an “unpermissioned” (fully decentralized) ledger (a blockchain), or any
other trustworthy append-only data structure.
3.2 Architectural Model
In Solidus, a predetermined set of banks B1, . . . , Bm maintain asset
titles on a ledger. Each bank Bi has a public/private key pair for
each of encrypting and signing. It also has up to n users {Ui
j
}
n
j=1
each with a signature key pair. Each account is publicly associated
with one bank, so bank(Ui
j
) = Bi
is well-defined.
Each bank Bi maintains its own private data structure Mi containing each user’s balance and public key. It maintains a corresponding public data structure Ci
, placed on the ledger, whose elements are encrypted under Bi
’s encryption key. Mi and Ci together
constitute the memory in a PVORM, which we describe in Section 4.
Solidus uses this structure to ensure that updates to Ci reflect valid
transactions processed in Mi while concealing transaction details
and the transaction graph.
A transaction T is a digitally signed request by user Ui
j with
balance $b
i
j
to send some amount $v of asset to another user Ui
′
j
′ .
The transaction is valid if $b
i
j ≥ $v ≥ 0. To process a transaction,
Bi updates Mi to set $b
i
j ← $b
i
j − $v and Bi
′ updates Mi
′ to set
$b
i
′
j
′ ← $b
i
′
j
′ + $v. They generate publicly verifiable ZK-proofs that
$v ≥ 0 and that they updated their respective PVORMs correctly
using $v. Figure 1 depicts a simple Solidus transaction.
We treat the ledger as a public append-only memory which verifies transactions. All banks have asynchronous authenticated read
and write access and the ledger accepts only well-formed transactions not already present. We model this by an ideal functionality
FLedger, detailed in Section 5, which any bank can invoke.
Notarizing New Asset Titles. As described above, all user transactions must be zero-sum; Ui
j
sends money (that she must have)
to Ui
′
j
′ . Financial systems are generally not closed, though. That
is, assets can enter and leave the system through specific channels. To support this, Solidus defines a fixed set of asset notaries
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 704
{U$
1
, . . . , U$
ℓ
}. These are accounts with no recorded balance, but
the authority to create and destroy asset titles. To ease auditing of
this sensitive action, transactions involving U$
i
reveal its identity.
Asset notaries clearly must be restricted; it would make no sense
to allow arbitrary users to create and destroy asset titles. In Example 3.1, Solidus would designate the custodian as the sole notary
responsible for acknowledging receipt and removal of the physical
asset (gold) and guaranteeing its physical integrity.
3.3 Trust Model
Solidus assumes that banks respect the confidentiality of their own
users but otherwise need not behave honestly. They may attempt
to steal money, illicitly give money to others, manipulate account
balances, falsify proofs, etc. Banks (respectively, users) can also
attempt to violate the confidentiality of other banks’ users (respectively, other users) passively or actively. We assume no bound on
the number of corrupted banks or users, which may collude freely.
The Ledger. We assume the ledger abstraction given in Section 3.2.
In practice, the ledger can, but need not, be maintained by the
banks themselves. If not maintained by the banks, the ledger’s trust
model is independent from the higher-level protocol. It may be
constructed using a (crash-tolerant) consensus protocol such as
Paxos [38], ZooKeeper [32], or Raft [51], a Byzantine consensus
protocol such as PBFT [20], a decentralized consensus protocol such
as Nakamoto consensus [50], or even a single trustworthy entity.
We simply assume that the ledger maintainers satisfy the protocol’s
requirements and the ledger remains correct and available.
We regard the ledger together with the public PVORM data structures {Ci} as a replicated state machine. Despite this, Solidus’s flexible design allows us to treat the consensus and application layers
as entirely separate for the majority of our discussion.
Availability. We assume that the ledger remains available at all
times; it is not susceptible to denial-of-service attacks and enough
consensus nodes will remain non-faulty to maintain liveness. A
bank, however, can be unavailable in two ways: it can freeze a user’s
assets by rejecting transactions or it can go offline entirely.
Asset freezing can be a feature. For certain types of assets (e.g. gold,
as in Example 3.1) a user may wish to use her balance as collateral
against a loan. A bank could, however, maliciously freeze a user’s
assets or go offline due to a technical or business failure. In either
case, an auditor with the bank’s decryption key (see below) could
enable a user to prove her balance and recover funds despite being
unable to transact directly.
Auditing. Regulators and auditors play a pivotal role in the financial sector. While Solidus does not include explicit audit support,
it enables banks to prove correct decryption of on-chain data or
share their private decryption key. In the first case, the auditor
can acquire a transaction log on demand and verify its correctness
and completeness. In the second case, the auditor can directly and
proactively monitor activity within the bank and its accounts.
Network. We do not assume a network adversary. An active network adversary would make the availability requirement of the
ledger impossible, while a passive adversary can be mostly mitigated simply by securing all messages with TLS. The existence
of communication between users and their banks could still leak
information, but this is inherent in any bank-intermediated system
and could be mitigated using Tor [28] or similar protocols.
3.4 Security Goals
Solidus aims to provide very strong safety and confidentiality guarantees for both individual users and the system as a whole.
Safety Guarantees. Solidus provides a very simple but strong set
of safety guarantees. First, no user’s balance may decrease without
explicit permission of that user (in the form of a signature), and such
authorization can be used only once; there are no replay attacks.
Second, account balances can never be negative, ensuring that no
user can spend money she does not have. Finally, transactions that
do not include asset notaries must be zero-sum.
To ensure the above properties hold, we require that the correctness of every transaction be proved in a publicly-verifiable fashion
(via ZK-Proof). If the ledger checks these proofs before accepting—
and settling—the transaction, then every transaction will maintain
these guarantees. Solidus places all proofs on the ledger, meaning
an auditor can verify them offline.
Maintaining these guarantees requires all transactions involving
a single bank to be serialized. Banks can use the serialization provided by the ledger or another locking mechanism to accomplish
this, but everyone must agree on the ordering.
Confidentiality Guarantees. To facilitate audits and asset recovery against malicious banks, Solidus places all account balances
and transaction details directly on the ledger. Despite this persistent public record, Solidus provides a strong confidentiality for all
users. First, account balances are visible only to the user’s bank
(and authorized auditors). Second, while transactions do reveal the
sending and receiving banks, there is no way to determine if two
transactions involving the same bank involved the same account.
We use a hidden-public-key signature scheme (see Appendix A.3)
to enforce the publicly-verifiable authorization requirement above
without revealing identities. This second feature is often referred to
astransaction graph confidentiality. It precludes use of the pseudonymous schemes employed by Bitcoin and similar systems, and is the
challenge specifically addressed by PVORM.
We do not directly address information leaked by the timing
of transactions. These channels and the bank-level transaction
graph can, however, be eliminated by requiring each bank to post
transactions at regular intervals in batches of uniform size. These
batches would be padded out by “dummy” transactions of value 0
to obscure which banks conducted real transactions.
We present a formal model in Section 5 that encompasses all of
these security and confidentiality goals.
4 PVORM
As discussed in Section 2.3, ORAM presents a means to conceal
the Solidus transaction graph, but lacks the public verifiability that
Solidus requires. To overcome this limitation, we introduce the
Publicly-Verifiable Oblivious RAM Machine (PVORM).
As with ORAMs, PVORMs have a private logical memory M and
corresponding encrypted physical memory C. There are, however,
four key differences:
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 705
• Constrained Updates. Write operations are constrained by a public
function f . In Solidus, for example, M contains account IDs and
balances and f updates a single balance to a non-negative value.
• Publicly Verifiable Updates. Whenever the client modifies C, it
must publicly prove (in zero-knowledge) that the change reflects
a valid application of f .
• Client Maintains All Memory. Instead of a client maintaining M
and a server maintaining C, the client maintains both directly.
While M remains hidden, C is now publicly visible (e.g., on a
ledger in Solidus).
• No Private Stash. Any data in M not represented in C would
prevent the client from proving correctness of writes. Instead of
a variable-size private stash, PVORM includes a fixed-size public
encrypted stash.
To achieve public verifiability, our PVORM construction relies
on public-key cryptography. Another example of an ORAM scheme
that uses public key cryptography is Group ORAM [40], which does
so for a more standard cloud setting, rather than our setting here.
In fact, while traditional ORAMs generally uses symmetric-key
primitives, this difference is not fundamental. One could construct
a PVORM using symmetric-key encryption and zk-SNARKs, but as
we see in Section 7.3, such a construction performs poorly.
We also leverage the fact that PVORM is designed for public
verifiability and not storage outsourcing to improve efficiency. In
ORAM, reads incur a cost as the client must retrieve data from
the server. In PVORM, reads are “free” in that they require only
reading public state—the ledger in Solidus—which leaks nothing.
Writes, however, are still publicly visible. Second, since PVORM
does not aim to reduce local memory usage, we assume that the
client locally maintains a full copy of the PVORM including private
data and metadata. This allows clients to perform updates much
more efficiently by avoiding unnecessary decryption.
These features are nearly identical to those leveraged by writeonly ORAM, but those techniques do not apply. Write-only ORAM
requires simple writes, but we implement updates as read-updatewrite operations to prove properties about changes in values.
4.1 Formal Definition
We now present a formal definition of PVORM. We let M represent
a private array of values from a publicly-defined space (e.g. N) and
C be the public (encrypted) representation of M. U is the space of
update specifications (e.g., account ID, balance change pairs).
Definition and Correctness. We first define the public interface
of a PVORM and its correct operation. A PVORM consists of the
following operations.
• Init(1
λ
,n,m0,U )
$
−→ (pk,sk,C), a randomized function that initializes the PVORM with security parameter 1
λ
, n data elements,
initial memory M = (m0, . . . ,m0), and valid update values U .
• An update constraint function f (u, M) → M′
that updates M
according to update u ∈ U . Note that f may be undefined on
some inputs (invalid updates), and must be undefined if u < U .
• Update(sk,u,C)
$
−→ (C
′
, e, proof ), a randomized update function
that takes an update u and a public memory and emits a new
public memory, a ciphertext e of u, and a zero-knowledge proof
of correct application.
• Ver(pk,C,C
′
, e, proof ) → {true, false}, a deterministic update
verification function.
We also define Read(sk,C) → M and Dec(sk, e) → u, two deterministic functions that read every value from aC as a plaintext memory
M and decrypt an update ciphertext, respectively. We employ these
operations only in our correctness and security definitions; they
are not part of the core PVORM interface.
We define correctness of a PVORM with respect to valid update
sequences. An update sequence {u0}
k
i=1
is valid for m0 if, when
M0 = (m0, . . . ,m0) and Mi = f (ui
, Mi − 1), then Mi
is defined for
all 0 ≤ i ≤ k. A PVORM is correct if for all initial values m0 and all
update sequences {ui}
k
i=1
valid for m0,
Pr[ExpCorrect(λ,n,m0, {ui}
k
i=1
)] = 1
where ExpCorrect(λ,n,m0, {ui}
k
i=1
) is defined as
Experiment ExpCorrect(λ, n, m0, {ui }
k
i=1
):
(pk, sk, C0)
$←− Init(1
λ
, n, m0, U )
if Read(sk, C0) , M0, return false
for i = 1 to k :
(Ci
, ei
, proof i
)
$←− Update(sk, ui
, Ci−1)
if f
(Read(sk, Ci
) , Mi
) ∨ (Dec(sk, ei
) , ui
)
∨ ¬Ver(pk, Ci−1, Ci
, ei
, proof i
)
g
return false
return true
with {M0, . . . , Mk
} defined as above. In other words, the PVORM
is correct if Update correctly transforms C as defined by f and Ver
verifies these updates.
Obliviousness. Solidusrequires a structure that can realize ORAM
guarantees in a new setting against even an adaptive adversary. Intuitively, we require the PVORM to guarantee that any two adaptivelychosen valid update sequences result indistinguishable output. Formally, we say that a PVORM is oblivious if for all PPT adversaries
A, there is a negligible negl(λ) such that for all n ∈ N, m0, and U ,




Pr f
ExpObliv(0, A, λ,n,m0,U ) = 1
g
− Pr f
ExpObliv(1, A, λ,n,m0,U ) = 1
g 



≤ negl(λ)
where ExpObliv(b, A, λ,n,m0,U ) is defined by
Experiment ExpObliv (b, A, λ, n, m0, U ):
(pk, sk, C)
$←− Init(1
λ
, n, m0, U )
return AOb,sk,C (·,·)
(1
λ
, pk, C)
where Ob,sk,C (·, ·) is a stateful oracle with initial state S ← C. On
input (u0,u1), Ob,sk,C executes (C
′
, e, proof )
$←− Update(sk,ub
, S),
updates S ← C
′
, and returns (C
′
, e, proof ). The experiment aborts
if any C
′
is ever undefined.
This definition is an adaptive version of those presented in the
ORAM literature [56, 58, 63].
Public Verifiability. The final piece of our security definition is
that of public verifiability. Intuitively, we require that each update
produce a proof that the update performed was valid and is the
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 706
Stash · · ·
Fixed
block
· · ·
· · ·
· · ·
· · ·
· · · · · · · · ·
e
Modify
cipher
Buckets
Figure 2: An update for a Circuit ORAM-based PVORM with buckets of size 2. Colors indicate the blocks involved in each operation
of the read-modify-write structure. Read moves one block from
the read path (shaded) into the distinguished fixed block. Then
modify combines it (homomorphically) with the modify ciphertext
(dashed). Finally write evicts the resulting value into the tree along
two eviction paths (thick bordered).
one claimed. Formally, a PVORM is publicly verifiable if for all PPT
adversaries A,
Pr[ExpPubVer(A, λ,n)] ≤ negl(λ)
where ExpPubVer(A, λ,n) is defined as
Experiment ExpPubVer(A, λ, n):
(pk, sk, _)
$←− Init(1
λ
, n, _, _);
(C, C
′
, e, proof )
$←− A(1
λ
, n, pk, sk);
return Ver(pk, C, C
′
, e, proof )
∧

f (Dec(sk, e ), Read(sk, C)) , Read(sk, C
′
)

This corresponds to the soundness of the ZK-proof that an update
was performed correctly.
4.2 Solidus Instantiation
In Solidus we instantiate a PVORM by combining the structure of
Circuit ORAM [63] with several GSPs. Circuit ORAM places data
blocks into buckets organized as a binary tree. It performs updates
by swapping pairs of blocks along paths in that tree. This structure leads to good performance for two reasons: updates require
logarithmic work in the number of accounts, and pairwise swaps
of public-key ciphertext admit efficient ZK-proofs of correctness.
Figure 2 shows how Solidus’s PVORM is structured and updated.
Each data block holds an account’s unique identifier and balance.
This pair of values must move in tandem as blocks are shuffled,
so Solidus employs a verifiable swap algorithm for El Gamal ciphertexts [34] augmented to swap ordered pairs of ciphertexts (see
Appendix A.4).
Solidus constrains each update to modify one account balance
and requires that balances remain in a fixed range [0, N]. To make
updates publicly verifiable, a bank first moves the desired account
to a deterministic fixed block by swapping that position with each
block along the Circuit ORAM access path. Next the bank updates
the account balance and generates a set inclusion proof on the resulting ciphertext to prove it is in the legal range (see Appendix A.5).
Finally, the bank performs Circuit ORAM’s eviction algorithm to
reinsert the updated account. This again requires swapping the
fixed block with a set of tree paths.
In Appendix B we concretize this construction. We prove it
correct, oblivious, and publicly verifiable in the extended paper [21].
Stash Overflow. Circuit ORAM assumes a stash of bounded size,
but data loss is possible if the stash overflows, resulting in a probabilistic definition of correctness; correct behavior occurs only when
data is not lost. Since the probability of data loss is negligible in the
size of the stash, the definition is reasonable for the setting.
In Solidus the stash must be placed on the ledger, so to prevent
leaking information we also bound the stash size. Data loss is,
however, catastrophic no matter how infrequent. When the stash
would overflow, instead of losing data we insert one account deeper
into the tree. This insertion is public, so it does leak that regular
eviction was insufficient as well as the location of a single account
(though not the account’s identity).
Solidus inherits the stash overflow probability of Circuit ORAM,
which is negligible in the stash size [63]. As we show in Section 7,
the PVORM update performance is linear in the stash size, giving
Solidus a direct performance-privacy trade-off. Pleasantly, modest
stash sizes make overflow exceedingly unlikely. With buckets of
size 3, a stash of size 25 reduces overflow probability to near 2
−64
.
5 SOLIDUS PROTOCOL
We now present the Solidus protocol. This construction relies heavily on cryptographic primitives that we describe in Appendix A.
We make this choice to simplify the explanation and leave abstract
operations with several instantiations—such as range proofs.
Bank State. The state of a bank Bi consists of an encryption
key pair (ePKi
, eSKi
), a signing key pair (sPKi
,sSKi
), and a set of
accounts. Each account Uj has a unique account identifier and a
balance. For simplicity, we use Uj
’s public key pkj
as its identifier.
Each bank maintains its own PVORM, updated on every transaction, containing the information of each of its accounts. Section 4.2
describes the PVORM structure.
Requesting Transactions. As Solidus is bank-intermediated, Us
at Bs must send a request to Bs
in order to send $v to Ur at Br
.
The request consists of:
• A unique ID txid
• Enc(ePKs
, $v), $v encrypted under Bs
’s public key
• Enc(ePKr
, pkr
), a ciphertext of Ur
’s ID under Br
’s public key
• A hidden-public-key signature signed with sks
(see Appendix A.3).
On receipt of a request, Bs must validate the request—check that
txid is globally unique and 0 ≤ $v ≤ $bs—and initiate the transaction settlement process.
Settling Transactions. Figure 3 shows the structure of settling a
transaction. Bs generates a proof that $v ≥ 0, reencrypts $v under
ePKr
, and sends (txid, Enc(ePKr
, $v), Enc(ePKr
, pkr
)) to Br
. Then
both banks (concurrently) update their respective PVORMs, sign
their updates, and post all associated proofs and signatures onto
the ledger. Once the full transaction is accepted by the ledger, the
assets have been transferred and the transaction has settled.
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 707
Ledger
Us Bs Br
Transaction from Us to Ur
Request
Verify &
Prepare
PVORM
Update
PVORM
Update
Sign Sign
Settle
.
.
.
.
.
.
Time
Figure 3: The lifecycle of a transaction in Solidus. An arrow from
one operation to another means the second depends on the first.
Note that Ur does not appear. The receiving user plays no role in
settling transactions.
Transaction IDs. To prevent replay attacks, Solidus includes a
globally unique ID with each transaction. This ID could simply
be a random bit string (eg., a GUID), but then verification would
require the ID of every transaction over the lifetime of the system.
To avoid this growing cost, Solidus uses a two-part transaction ID:
a timestamp and a random number. Transactions are only valid
within a time window T∆. If txid = (T, id), the transaction is only
valid at timeTnow ifTnow −T∆ < T < Tnow. This allows verification
to only store IDs for T∆ and still properly prevent replay attacks.
Opening and Closing Accounts. Banks are constantly opening
new accounts, so Solidus must support this. To create an account,
bank Bi must insert the account into its PVORM. Our construction
makes this simple. Bi publishes the new ID with a verifiable encryption of the ID and balance 0. It then inserts this ciphertext pair
into its PVORM by replacing a dummy value. To close an account
Bi simply publicly verifies the identity of an account and replaces
it in the PVORM with a dummy value.
5.1 FLedger-Hybrid Functionality
For simplicity we define the Solidus protocol, ProtSol, using a trust
initializer and an idealized ledger. We could instantiate the trusted
initializer using existing PKI systems and, as mentioned above,
Solidus is agnostic to the ledger implementation so we wish to
leave that abstract. We present the trusted initializer FInit in Figure 4
and the ledger FLedger in Figure 5. Throughout the protocol, users
employ hidden-public-key signatures (see Appendix A.3) and banks
employ Schnorr signatures [16, 55], denoted (sGen, Sign,sVer).
The FLedger functionality has two operations: posting a completed transaction and aborting an in-progress transaction. The
need for the first is obvious; the ledger is the authoritative record
of transactions and is responsible for their verification. The second
FInit 
λ,
(
Bi
)k
i=1
,
(
Ui
)n
i=1

Init:
for i ∈ [1, n]:
Generate key pair (pki
, ski
)
$←− hGen(1
λ
)
send pki
to each user and bank and (pki
, skk ) to Ui
for i ∈ [0, k]:
Generate key pair (sPKi
, sSKi
)
$←− sGen(1
λ
)
(ePKi
, eSKi
, Ci
)
$←− Init(1
λ
, |Bi
|, 0, U )
send (“initBank”, ePKi
, sPKi
, Ci
) to each user and bank
send all five values to Bi
Figure 4: Solidus ideal initializer with banks {Bi} and users {Ui}.
FLedger (
Bi
)k
i=1
,
(
Ui
)n
i=1

Init: TXID = ∅ and LEDGER = ϵ
On receive (“approveRecvTxn”, txid, txn):
assert txid < TXID
Parse txn → (Bs , Br, txdatas , σs , txdatar, σr )
assert sVer(Bs , txdatas , σs ) ∧ sVer(Br, txdatar, σr )
∧ VerTxn(Bs , Br, txn, LEDGER[Bs , Br ])
TXID ← TXID ∪ {txid}
LEDGER ← LEDGER ∥ (txid, txn)
broadcast (“postTxn”, txid, txn) to all banks
On receive (“abortTxn”, abort) from B:
Parse abort → (txid, (C, e, proof ), pf ⋆)
assert txid < TXID
assert Ver(ePK, LEDGER[B], C, e, proof )
assert pf ⋆ proves e is a no-op
TXID ← TXID ∪ {txid}
LEDGER ← LEDGER ∥ (abort)
broadcast (“abortTxn”, abort) to all banks
Figure 5: Solidus ideal ledger with banks {Bi} and users {Ui}.
LEDGER[Bs
, Br ] denotes the most recent PVORM states for each
bank in LEDGER, and VerTxn verifies all proofs associated with a
given transaction, which requires the public keys and preceding
PVORM state of each bank involved.
helps guard against malicious activity. As we see below, processing
a transaction from Us requires bank Bs to send its PVORM update
to Br prior to posting the transaction to the ledger, but Br may
never reply. With no abort operation, Bs has two options: wait for
a reply—causing a DoS attack if none arrives—or proceed as if the
transaction were never initiated. In the second case, Br can learn
with high probability whether Us participates in future transactions involving Bs
; if a different Circuit ORAM path is accessed,
Us
is not involved, but if the same path is accessed, Us
likely is.
In order to prevent this information leakage, Bs must post some
PVORM update to the ledger after sending the update to Br before initiating any other transaction. If the original transaction
settles that includes exactly such an update. Otherwise Bs can invoke “abortTxn” with a dummy update on the same tree path, thus
invalidating any information Br may have gained.
With these ideal functionalities defined, we can now present
the main Solidus protocol, ProtSol, in Figure 6. We note that the
environment Z is a standard UC framework entity that represents
all behavior external to the protocol execution. (Z feeds input to
and collects outputs from protocol parties and the adversary.)
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 708
ProtSol (
Bi
)k
i=1
,
(
Ui
)n
i=1

User Ui
:
On input (“beginTxn”, Uj
, $v) from environment Z:
Let Bi = bank(Ui
) and Bj = bank(Uj
)
Generate random unique txid
Encrypt cr = Enc(ePKj
, pkj
) and cv = Enc(ePKi
, $v)
σ = hSign(ski
, ePKj
, (txid, cr , cv ))
send (“requestTxn”, txid, ePKj
, cr , cv, σ ) to Bi
Bank Bi
:
On receive (“initBank”, ePKj
, sPKj
, Cj
) from FInit:
assert B[Bj] is not set
B[Bj] ← (ePKj
, sPKj
, Cj
)
On receive (“postTxn”, txid, txn) from FLedger:
Retrieve (Bs , C
′
s
) and (Br, C
′
r
) from txn
if (Bi = Bs or Bi = Br ), then Pend ← ⊥
Update B[Bs ] ← (ePKs , sPKs , C
′
s
)
B[Br ] ← (ePKr, sPKr, C
′
r
)
On input (“abortPend”) from environment Z:
assert Pend , ⊥
Retrieve Ui at Bi
from Pend
Update (C
′
i
, e, proof ) ← Update(eSKi
, (Ui
, 0), Ci
)
Generate a ZK-proof pf ⋆ that e encrypts a 0-value change.
send (“abortTxn”, (txid, Bi
, (C
′
i
, e, proof ), pf ⋆) to FLedger
On receive (“abortTxn”, abort) from FLedger:
Parse (txid, Bj
, (C
′
j
, e, proof ), pf ⋆) ← abort
if Bj = Bi
assert Pend = (txid, _)
Pend ← ⊥
B[Bj] ← (ePKj
, sPKj
, C
′
j
)
if Pend , ⊥ and Bj
is the other bank in Pend
Execute “abortPend” as described above
On receive (“requestTxn”, txid, ePKs , cv, cr , σ ) from Us :
assert (Pend = ⊥) ∧ (txid is unique)
∧ hVer(ePKi
, (txid, cv, cr ), σ )
∧

((α, β ), _) ← σ : Dec(eSKi
, (α, β )) = pks

Decrypt $v = Dec(eSKi
, cv )
assert 0 ≤ $v ≤ Mi[Us ]
Update (C
′
i
, es , proof s
) ← Update(eSKi
, (Us , −$v), Ci
)
Let c
′
v = Enc(ePKj
, $v)
Generate txdatas containing:
• (txid, (cv, cr ), σ, c
′
v )
• (C
′
i
, es , proof s
)
• RangePf(ev, t)
• Proof that es updates Us by amount in cv
• Proof that cv and c
′
v encrypt the same value
Pend ← txdatas
σs = Sign(sSKi
, txdatas )
send (“approveSendTxn”, txid, txdatas , σs ) to Bj
On receive (“approveSendTxn”, txid, txdatas , σs ) from Bj
:
assert (Pend = ⊥) ∧ (txid is unique)
∧ sVer(sPKj
, txdatas , σs )
∧ all proofs in txdatas are valid
Retrieve (txid, (cv, cr ), σ, c
′
v ) from txdatas
Decrypt $v ← Dec(eSKi
, c
′
v )
assert txid is unique and $v ≥ 0
Decrypt pkr = Dec(eSKi
, cr )
Update (C
′
i
, er , proof r
) ← Update(eSKi
, (Ur, $v), Ci
)
Generate txdatar containing:
• (txid, (cv, cr ), σ, c
′
v )
• (C
′
i
, er , proof r
)
• Proof that er updates account cr by value c
′
v
Pend ← (txid, txdatar )
σr ← Sign(sSKi
, txdatar )
Let txn = (Bj
, Bi
, txdatas , σs , txdatar, σr )
send (“approveRecvTxn”, txid, txn) to FLedger
Figure 6: FLedger-hybrid protocol for Solidus with banks {Bi} and users {Ui}. For simplicity we omit operations to open and close accounts.
To execute a transaction in ProtSol, a user executes “beginTxn”,
which sends a “requestTxn” request to the user’s bank. The bank
verifies the request, updates its PVORM, signs the update, and
forwards it to the recipient’s bank. That bank similarly verifies,
updates, and signs before posting the completed transaction to
FLedger. For simplicity the sending bank performs all updates and
sends them to the receiving bank. In practice both banks can update
their respective PVORMs in parallel as implied by Figure 3.
The protocol also contains operations for two other purposes:
handling transaction aborts described above and updating other
banks’ states when they post updates to FLedger.
5.2 Security Definition
To demonstrate the security of ProtSol, we need a notion of how a
secure Solidus protocol operates. We define this as an ideal functionality FSol presented in Figure 7. For an adversary A and environment Z, we let HybridA, Z (λ) denote the transcript of A
when interacting with ProtSol. We let IdealS, Z (λ) be the transcript
produced by a simulator S when run in the ideal world with FSol.
This allows us to define security as follows.
Definition 5.1. We say that Solidus securely emulates FSol if for
all real-world PPT adversaries A and all environments Z, there
exists a simulator S such that for all PPT distinguishers D,



Pr f
D

HybridA, Z (λ)

= 1
g
− Pr f
D

IdealS, Z (λ)

= 1
g



≤ negl(λ).
This definition leads to the following theorem, which we prove in
the extended version of the paper [21].
Theorem 5.2. The Solidus protocol ProtSol satisfies Definition 5.1
assuming a DDH-hard group in the ROM.
In order to prove Theorem 5.2 in the Universal Composability
(UC) framework [19], we assume Solidus employs only universally
composable (UC) NIZKs. Prior work [6] demonstrates that GSPs
can be transformed into UC-NIZKs by using the Fiat-Shamir heuristic and including a ciphertext of the witness under a public key
provided by a common initializer. As Solidus already employs this
trusted initialization and includes ciphertexts of most operations
anyway, the performance impact of ensuring UC-NIZKs is minimal.
6 OPTIMIZATIONS
In addition parallelizing operation, there are several optimizations
which make Solidus more practical. Some of these optimizations
are only appropriate for certain use cases, but they may result
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 709
FSol (
Bi
)k
i=1
,
(
Ui
)n
i=1
,
(
U$
i
)ℓ
i=1

Init
Initialize T to empty
Initialize V [Ui] ← 0 for i ∈ [1, n]
On receive (“requestTxn”, Ur, $v) from Us :
assert $v ≥ 0
Generate unique txid
T [txid] ← (Us , Ur, $v, “req”)
send txid to Us
send (“req”, txid, Us , bank(Ur ), $v) to bank(Us )
On receive (“approveSendTxn”, txid) from Bs :
Retrieve (Us , Ur, $v, f ) ← T [txid]
assert f = “req” and Bs = bank(Us )
T [txid] ← (Us , Ur, $v, “aprv”)
send (“aprv”, txid, Bs , Ur, $v) to bank(Ur )
On receive (“approveRecvTxn”, txid) from Br :
Retrieve (Us , Ur, $v, f ) ← T [txid]
assert f = “aprv” and Br = bank(Ur )
Remove T [txid] mapping
Retrieve $bs ← V [Us ], $br ← V [Ur ]
assert $bs ≥ $v or Us = U$
i
for some i
V [Us ] ← $bs − $v
V [Ur ] ← $br + $v
// Reveal identities of asset notaries and banks
Let Ps = Us if Us = U$
i
, bank(Us ) otherwise
Let Pr = Ur if Ur = U$
j
, bank(Ur ) otherwise
broadcast (“postTxn”, txid, Ps → Pr ) to all banks
On receive (“abortTxn”, txid) from B:
if txid has been seen before // Can “abort” nonexistent transactions
Retrieve (Us , Ur, _, _) ← T [txid]
assert B = bank(Us ) or B = bank(Ur )
Remove T [txid] mapping
broadcast (“abortTxn”, txid, B) to all banks
Figure 7: Ideal functionality for the Solidus system with banks
{Bi}, users {Ui}, and asset notaries {U$
i
}. For simplicity we assume
a fixed set of accounts for each bank.
in significant speedups when applicable. We include the simpler
optimizations in our evaluation in Section 7.
6.1 Precomputing Randomization Factors
A large computational expense in Solidus is re-randomizing ciphertexts while updating a PVORM. Fortunately, El Gamal allows us to
re-randomize ciphertexts by combining them with fresh encryptions of the group identity. That is, in a group G = ⟨д⟩ with key pair
(pk = д
sk
,sk) and a ciphertext c = (α, β), we can re-randomize c
by picking a random r ← Z|G | and computing c
′ = (α · pkr
, β · д
r
).
Computing (pkr
,д
r
) only requires knowledge of the groupG, the
generator д, and a bank’s public key pk, none of which change. This
means we can precompute these unit ciphertexts and re-randomize
by multiplying in a precomputed value.
Since the system can continue indefinitely, it must continue
generating these randomization factors. Many financial systems
have predictable high and low load times (e.g., very light traffic at
night), so they can utilize otherwise-idle hardware for this purpose
during low-traffic times. If the precomputation generates more
randomization pairs than the application consumes over a modest
time frame (e.g. a day), we can drastically improve performance.
6.2 Reducing Verification Overhead
As we see in Section 7, proof verification is quite expensive. In
the basic protocol, the ledger consensus nodes must each verify
every transaction. As more banks join the system this increases
the load on the consensus nodes—which may be the banks. By
strengthening trust assumptions slightly, we can omit much of
this online verification and increase performance. We present two
strategies that rely on different assumptions.
Threshold Verification. In the financial industry, there is often a
group of entities (e.g., large banks and regulators) who are generally
trusted. If a threshold number of these entities verify a transaction, this could give all other consensus nodes—often other banks—
confidence that the transaction is valid, allowing them to accept it
without further verification. Once the threshold is reached, each
other node need only verify the signatures of the trusted entities
that verified the transaction, which is far faster than performing
a full verification. If the group of trusted entities is significantly
larger than the threshold or those entities have much more capacity
than others, this strategy will improve system scaling.
Full Offline Verification. In some cases banks can be treated
as covert adversaries. That is, they will attempt to learn extra information, but they will subvert the protocol only if attribution is
impossible. This situation could arise if each Solidus bank is controlled by a large commercial bank. While a bank may wish to learn
as much information as possible, the cost of being caught misbehaving is high enough to deter attributable protocol deviations.
Under these assumptions we can omit online verification entirely.
The verifiability of a ledger-based system remains in place, so if a
bank submits an invalid transaction or proof, post hoc identification
of the faulty transaction and offending bank is trivial. Thus, in this
covert adversary model, banks will only submit valid transactions
and proofs, meaning that the ledger can accept transactions without
first verifying the associated proofs first.
6.3 Transaction Pipelining
Solidus requires sequential processing of transactions at a single
bank because PVORM updates must be sequential to generate valid
proofs. Given transactions T1 followed by T2, in order for B to
process T2 it needs the PVORM state following T1. It does not,
however, need the associated proofs. Therefore, if B assumes T1
will settle—because faults are rare—it can start processing T2 early
while generating proofs forT1. While this technique will not reduce
transaction latency, it can drastically increase throughput. Moreover, determining the updated PVORM state requires primarily
re-randomizing ciphertexts, making this optimization particularly
effective when combined with precomputation (Section 6.1).
When failures do occur, it impacts performance but not correctness. IfT1 aborts for any reason,T2 will not yet have settled sinceT1
would have to settle first. This means B can immediately identify
the problem and reprocess T2—and any following transactions—
without T1. This reprocessing may lead to significant, but temporary, performance degradation, meaning this optimization is only
appropriate when failure are rare if each transaction is posted individually to the ledger.
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 710
15 20 25 30 35
0.3
0.4
0.5
0.6
0.7
Stash Size
Time (sec)
B = 3 Ver
B = 2 Update
Figure 8: PVORM performance with capacity 2
15 for buckets of
size B = 2 and B = 3 as stash size varies.
We can alleviate some of this performance penalty by bundling
transactions into blocks, as is done in systems like Bitcoin. If T1
aborts, instead of reprocessing T2, B can include a rollback operation later in the same block. This rollback must provably revert any
changes executed by T1’s update, thus allowing verifiers to check
that T1 was never processed at all. There is, however, no need to
recompute T2 as long as the rollback can be placed after it while
remaining in the same block as T1.
7 EXPERIMENTS
We now present performance results for our PVORM and Solidus
prototypes. Our Solidus implementation is 4300 lines of Java code,
2000 of which constitute the PVORM. We use BouncyCastle [14] for
crypto primitives and Apache ZooKeeper [5] for distributed consensus. We ran all experiments on c4.8xlarge Amazon EC2 instances
and employed the precomputation optimization (Section 6.1). These
benchmarks do not include the precomputation time.
We emphasize that our performance results employ an unoptimized implementation and only one server per bank, highly limiting
our parallelism. Solidus is designed to be highly parallelized, allowing it to scale up using multiple servers per bank to achieve vastly
superior performance in practice.
7.1 PVORM Performance
We measured the concrete performance of PVORM Update and Ver
operations under different configurations and levels of parallelism.
Bucket and Stash Size. Figure 8 shows the single-threaded performance of our PVORM as we vary bucket and stash sizes. As
expected, larger buckets are slower and runtime grows linearly
with the stash size. As bucket and stash sizes determine the chance
of stash overflow, this measures the performance-privacy trade-off.
Tree Depth. Figure 9 shows the single-threaded performance of
our PVORM as the capacity scales. As expected, the binary tree
structure results in clearly logarithmic scaling.
Parallelism. Our PVORM construction supports highly parallel
operation. A single update contains many NIZKs that can be created
or verified independently. Figure 10 shows performance for a single
2
10 2
12 2
14 2
16 2
18 2
20 2
22
0.3
0.4
0.5
0.6
0.7
0.8
PVORM Capacity
Time (sec)
Generate Verify
Figure 9: PVORM capacity scaling with buckets of size 3 and stash
of size 25.
2 4 6 8 10
2
6
10
14
18
22
Number of Worker Threads
Throughput (ops/sec)
Perfect Scaling
Update
Ver
Figure 10: Parallel PVORM performance using size 3 buckets, a
size 25 stash, and capacity of 2
15. Dashed lines show perfect scaling
where all computation is parallelized with no overhead.
PVORM with varying numbers of worker threads. In each test there
is exactly one coordination thread, which does very little work.
Because the proof of each pairwise swap can be computed or verified independently, we expect performance to scale well beyond
10 threads—possibly as high as 100. We stop at 10 for a combination of two reasons. First, PVORM operations are CPU-bound,
so adding threads beyond the number of CPU cores produces no
meaningful speedup. Second, our prototype implementation does
not distribute to multiple hosts and scales poorly to multi-CPU
architectures. Since c4.8xlarge EC2 instances have two 10-core
CPUs, we present scaling to only 10 worker threads. Note that with
10 worker threads there are 11 total threads, so some work may not
be effectively parallelized on the same CPU. This likely explains
some of the reduced scaling in that case.
Proof Size and Memory Usage. For a PVORM with size 3 buckets, a size 25 stash, and capacity 2
15, a single PVORM update with
proofs is 190 KB (or 114 KB if compressed7
). To generate an update,
our prototype requires a complete copy of the PVORM in memory.
Despite this, memory consumption peaks at only 880 MB.
7.2 Solidus System Performance
We present performance tests of a fully distributed Solidus system
with 2 to 12 banks. Each bank runs on its own c4.8xlarge EC2 instance and maintains a PVORM with size 3 buckets, as size 25 stash,
and capacity 2
15. These parameters allow realistic testing, with a
stash overflow probability of around 2
−64. To maintain the ledger,
7An elliptic curve point is an ordered pair of elements of Fp . Points can be compressed
to a single bit and a field element, but decompression imposes nontrivial overhead.
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 711
2 4 6 8 10 12
3
5
7
9
Number of Banks
Throughput (tx/sec)
Offline Verification
Online Verification
Figure 11: Solidus performance distributed using ZooKeeper. Each
bank is a ZooKeeper node and maintains a PVORM with size 3
buckets, a size 25 stash, and capacity 2
15
.
each bank’s host also runs a ZooKeeper [5] node. We make no
attempt to tune ZooKeeper or optimize off-ledger communication.
To test this configuration we fully load each bank with both
incoming and outgoing transactions. As explained in Section 6.2,
in some settings transaction verification can occur offline, so we
also test performance with online verification turned off.
Figure 11 contains the results of these tests. With regular online
verification, performance improves until all CPUs are saturated
verifying third-party transactions, after which point scaling slows.
Using offline verification, transactions settle faster and additional
banks impose lower overhead on existing banks, improving scaling.
These results could be further improved by having each bank
distribute verification cross multiple machines, improving capacity
and throughput. Pipelining transactions (as described in Section 6.3)
could improve throughput substantially if banks also distributed
proof generation across multiple hosts. (Such distribution is unlikely to provide any benefit without pipelining.) Implementing this
distribution introduces complex systems engineering challenges
that are orthogonal to the technical innovations introduced by
Solidus, so we neither implement nor benchmark these options.
7.3 zk-SNARK Comparison
We finally compare our prototype’s performance to that of a PVORM
implemented with zk-SNARKs. This approach has succinct proofs
and short verification times, but costly proof generation.
Simply taking our Circuit ORAM PVORM construction and converting all proofs to zk-SNARKs would be needlessly expensive. As
zk-SNARKs can prove correct application of an arbitrary circuit [8],
we use a compact Merkle tree structure. Each account is stored at
the leave of a standard Merkle hash tree, the root of which is posted
to the ledger. To update the PVORM, a bank updates one account
to a valid value and modifies the Merkle tree accordingly. It then
produces a zk-SNARK that it properly performed the update and
verified the requester’s signature. The root of the new Merkle tree
is the new PVORM state and the zk-SNARK is the proof.
We implemented this construction using a security level equivalent to our GSP-based PVORM.
8 Table 1 shows its performance
8Both hash with SHA-256. The GSP-based PVORM uses El Gamal with the secp256k1
curve and the SNARK-based PVORM uses RSA-3072. Both provide 128 bits of security.
Number of Threads
1 4 36
Proof Time (sec) 65.45 24.53 13.76
Verification Time 0.0065 sec
Proof Size 288 bytes
Peak Memory Use 7.2 GB
Table 1: Performance of PVORM using zk-SNARKs.
running on a c4.8xlarge EC2 instance. While verification is extremely fast, even highly parallel proof generation is more than
200 times slower than the GSP PVORM. For this to improve overall
system throughput, the system would need to verify every proof
around 200 times. In our expected use-case, at most tens of banks
would maintain the ledger, so this is significantly slower. Moreover, additional hardware can allow banks to verify numerous GSP
transactions in parallel but provides little benefit to zk-SNARKs.
8 RELATED WORK
We compare Solidus here with related work on cryptocurrencies
and transaction confidentiality. We omit related work on ORAM,
which was covered in Sections 2.3 and 4.
Anonymous cryptocurrencies. Anonymous e-cash was proposed
by Chaum [22, 23] and refined in a long series of works, e.g., [15, 17,
31]. In these schemes, trust is centralized. A single authority issues
and redeems coins that are anonymized using blind signatures or
credentials. Due to its centralization and technical limitations, such
as poor handling of fractional coins and double-spending, e-cash
has been largely displaced by decentralized cryptocurrencies.
Zcash, a recently deployed decentralized cryptocurrency, and its
academic antecedents [7, 25, 46] and offshoots e.g., Hawk [37], provide strong transaction-graph confidentiality like Solidus. Zcash
relies on zk-SNARKs to ensure conservation of money, prevent
double spending, and hide both transaction values and the system’s
transaction graph. Consequently, unlike Solidus, it requires trusted
setup, which in practice must be centralized (as multiparty computation for this purpose [9] is impractical). Moreover, as we showed
in our exploration of a zk-SNARK variant of Solidus in Section 7.3,
zk-SNARKs are far more expensive to generate (by two orders of
magnitude) than the GSPs used in Solidus. Additionally, Zcash and
Hawk do not provide auditability as Solidus does; as designed, they
do not record assets on-chain, only commitments.
Alternative schemes such as Monero [3], a relatively popular
cryptocurrency, and MimbleWimble [35], a pseudonymous proposal, provide partial transaction-graph concealment. Serious weaknesses in Monero’s anonymity have recently been identified, however [47], while MimbleWimble has yet to be deployed or have its
confidentiality properties formally analyzed.
Mixes. Mixes partially obscure the transaction graph in an existing cryptocurrency. A number have been proposed and deployed,
e.g., [30, 41, 54, 61]. Mixes have a fundamental limitation: they only
protect participating users, and thus provide only partial anonymity,
resulting in demonstrated weaknesses [48, 57]. As mixes’ costs are
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 712
linear in the number of participants, they do not scale well. In contrast, Solidus achieves strong and rigorously provable transactiongraph confidentiality for all users.
Confidential Transactions. A class of schemes called Confidential Transactions [39, 42, 43] hide transaction amounts, but do not
aim at transaction graph privacy. Solidus employs a Confidential
Transaction scheme similar to that in [42], but makes more direct
use of and inherits the provable security properties of GSPs.
Financial sector blockchain technologies. The financial industry’s intense interest in blockchains has led to a number of proposed
and deployed systems. These systems support current banking
system transaction flows like Solidus. They achieve elements of
Solidus, but lack its full set of features. For example, Ripple [2] is
a widely deployed scheme for value transfer, but does not aim at
the confidentiality properties of Solidus. RSCoin [26], a scheme for
central bank cryptocurrency issuance that supports auditability
like Solidus, but similarly does not inherently support transaction
confidentiality. Other examples are SETLcoin [62], which aims at
on-chain trade settlement, like Solidus, but lacks strong transactiongraph confidentiality, and the Digital Asset Platform [1], which
provides confidentiality by keeping transaction details off-chain
and completely foregoing on-chain settlement and auditability.
9 CONCLUSION
We have introduced Solidus, a system that addresses a major impediment to broad use of blockchain transaction systems, their
critical lack of transaction-graph confidentiality. Unlike previous
approaches (e.g. Zcash), Solidus is specifically geared towards the
structural and performance requirements of modern financial transaction and settlement systems. The key innovation in Solidus is the
Publicly-Verifiable Oblivious RAM Machine (PVORM), a generalization of ORAM. A PVORM supports publicly verifiable outsourcing
of computation over memory, enabling a completely new approach
to blockchain transaction system design. Solidus employs a PVORM
with data structure size linear in the number of accounts—rather
than the number of transactions in the system, as in Zcash—and
proof computation times two orders of magnitude faster than zkSNARKs. We define the security of Solidus as an ideal functionality
and prove its security in the UC framework. Finally, we present
a series of optimizations and experiments running the complete
Solidus protocol on a distributed ledger (ZooKeeper), which demonstrate the ability of Solidus to scale to the throughputs required
for real-world workloads. We believe that Solidus is the first viable approach to building strongly verifiable and fully auditable
bank-intermediated ledger transaction systems.