We propose Tesseract, a secure real-time cryptocurrency exchange
service. Existing centralized exchange designs are vulnerable to
theft of funds, while decentralized exchanges cannot offer real-time
cross-chain trades. All currently deployed exchanges are also vulnerable to frontrunning attacks. Tesseract overcomes these flaws
and achieves a best-of-both-worlds design by using a trusted execution environment. The task of committing the recent trade data
to independent cryptocurrency systems presents an all-or-nothing
fairness problem, to which we present ideal theoretical solutions,
as well as practical solutions. Tesseract supports not only real-time
cross-chain cryptocurrency trades, but also secure tokenization of
assets pegged to cryptocurrencies. For instance, Tesseract-tokenized
bitcoins can circulate on the Ethereum blockchain for use in smart
contracts. We provide a demo implementation of Tesseract that
supports Bitcoin, Ethereum, and similar cryptocurrencies.
KEYWORDS
Cryptocurrency Exchanges; Frontrunning; Trusted Hardware
ACM Reference Format:
Iddo Bentov, Yan Ji, Fan Zhang, Lorenz Breidenbach, Philip Daian, and Ari
Juels. 2019. Tesseract: Real-Time Cryptocurrency Exchange Using Trusted
Hardware. In 2019 ACM SIGSAC Conference on Computer and Communications Security (CCS ’19), November 11–15, 2019, London, United Kingdom.
ACM, New York, NY, USA, 19 pages. https://doi.org/10.1145/3319535.3363221
1 INTRODUCTION
The rise of Bitcoin [81] has spawned many hundreds of other cryptocurrencies as well as application-specific units of value known as
crypto “tokens.” This diverse ecosystem of assets has in turn led to
a large and dynamic array of cryptocurrency exchanges, platforms
that allow users to trade different cryptocurrencies against one
another and/or for fiat currencies. At the time of writing, the aggregate daily trading volume of cryptocurrency exchanges exceeds
$10 billion.
Unfortunately, cryptocurrency exchanges suffer from a variety
of security problems. Currently, the most popular exchanges are
centralized, meaning that they hold traders’ assets while trades
are executed. Such exchanges support real-time trading of various
cryptocurrencies and fiat currencies. They are vulnerable, however,
to theft of traders’ funds (cf. Appendix A.1). In a number of highprofile incidents, funds have been stolen when exchanges were
breached or other forms of malfeasance took place [21, 46, 67, 76].
Permissionless blockchains, however, are designed specifically to
eliminate trust assumptions between transacting parties by avoiding centralization. A trust-free cryptocurrency exchange can be
realized for transactions across such blockchains in the form of
atomic intra-chain or cross-chain swaps (ACCSs) [31, 59], transactions that exchange cryptocurrencies between pairs of users in a
fair, all-or-nothing manner. ACCSs, though, require users to wait
many minutes (in fact, often hours) for a trade to execute. Additionally, atomic swaps in general aren’t sufficient to realize an exchange:
a mechanism for matching orders or otherwise performing price
discovery is also necessary. Since ACCSs serve as a useful reference
point, we elaborate on the concept and its limitations in Appendix B.
The systemic risk of theft in centralized exchanges has led to the
rising popularity of decentralized exchanges such as EtherDelta [92],
0x [107], and Kyber Network [70]. These systems hold traders’ funds
and settle transactions in smart contracts, eliminating the risk of
theft in centralized exchanges. Unfortunately, they have other drawbacks. Their on-chain settlement means that they cannot support
real-time trading. Moreover, while their use of smart contracts
conveys an appearance of trustworthiness, they are vulnerable to
various frontrunning attacks by miners and other users [40].
Achieving the best of both worlds has been a standing challenge,
but a seemingly elusive one. An ideal cryptocurrency exchange
would be real-time like a centralized exchange, meaning that participants can respond to price fluctuations and alter their positions
with low latency. It would support even traders that utilize automated programs for high frequency trading and arbitrage (cf. [22]),
who may wish to modify their positions in fractions of a second.
At the same time, such an exchange would be trust-free, protecting
against theft in the way that decentralized exchanges do, but also
eliminating frontrunning attacks that exploit blockchain latencies.
In this work, we present Tesseract, a cryptocurrency exchange
that achieves this ideal set of properties. Tesseract is real time.
Traders can rapidly observe the alterations in the buy (a.k.a. “bid”)
and sell (a.k.a. “ask”) orders on the exchange, as well as external
events (e.g., [112]), then modify their trading positions in milliseconds. By performing fast price discovery, they can drive price convergence so that the gap (a.k.a. “spread”) between bids and asks
is small, leading to efficient markets like those in major financial
systems. Tesseract also prevents theft of users’ funds by exchange
operators and hackers as well as a variety of frontrunning attacks
present in centralized and decentralized exchanges.
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1521
Tesseract supports cross-chain trading in which assets are exchanged across distinct blockchains. Trades within a single blockchain, e.g., exchange of tokens and Ether within Ethereum, can also
be important (cf. [36, 37, 88, 93]). While this use case can be achieved
at least in part using smart contracts, a significantly simplified variant of Tesseract can offer the added benefit of real-time trading,
which smart contracts cannot support. Tesseract also supports a
tokenization scheme that allows pegged tokens to circulate across
blockchains, without relying on a human element for security (see
Appendix E).
Tesseract relies on a trusted execution environment (TEE, cf. [87,
115]). This technology allows applications to execute within a protected environment called an enclave, that ensures confidentiality
and software integrity. It enables Tesseract to behave like a trusted
third party, controlling funds without exposing them to theft while
preventing frontrunning by the exchange operator. Our security
and trust assumptions are quite conservative, cf. Section 2.1.
Our reference implementation is built using SGX, which provides
a TEE via an instruction-set architecture extension in recent-model
Intel CPUs [14, 60, 61, 75]. While side-channel attackss [110] on SGX
have been demonstrated, prominently Foreshadow [106] (that was
later patched [39]), TEE technologies evolve as well. In particular,
the Keystone project [62] is developing an open-source TEE.
The main challenge in the design of Tesseract is dealing with
powerful network adversaries. Such adversaries can perform an
eclipse attack in which an exchange is presented with fake blockchain data. We show how to address this problem by checkpointing
trustworthy blocks within the Tesseract application and having
it monitor the cumulative difficulty of newly furnished blocks. A
network adversary can also suppress messages / transactions issued
by the exchange in an attempt to interfere in on-chain settlement
of trades, e.g., permitting partial settlement in which cryptocurrency flows to the adversary from a counterparty but not from the
adversary, resulting in the adversary stealing funds. We express a
theoretical solution to these network attacks in terms of an ideal
functionality called a refundable multi-input transaction (RMIT).
RMIT provides a conceptual springboard for securely architecting
a secure cross-chain exchange. We present a highly efficient realization of RMIT in Tesseract, via a protocol that involves a network
of TEE-backed nodes (Section 3.3, with an extended Paxos-based
protocol in [27]). While only one node handles assets directly, others can execute or cancel transactions should the main node fail.
This protocol enforces a key fairness property we define called
all-or-nothing settlement.
In summary, our contributions in this paper are as follows:
• We introduce Tesseract, an TEE-backed cryptocurrency exchange
that can support a wide variety of transaction types, with realtime cross-chain trading as its primary application.
• We consider powerful network adversaries that may seek to
mount eclipse attacks or suppress transactions to achieve unfair
settlement and thus theft of funds. We define a key fairness
property called all-or-nothing settlement and show how to realize
an exchange that achieves this property using as a conceptual
building block an ideal functionality called RMIT.
• We present theoretical and practical techniques to achieve all-ornothing settlement in Tesseract. The practical techniques include
within-enclave blockchain monitoring to prevent eclipse attacks
and use of a consensus group of TEE-backed nodes that can
enforce and/or cancel transactions in the case that the main
(asset-holding) exchange node becomes unavailable.
• We implement proof-of-concept of Tesseract, describing our parameter and design choices.
2 THE TESSERACT DESIGN
In this section we first specify our assumptions and then present an
overview of the operation of Tesseract, describing how it achieves
its security and performance goals. Specifically, Section 2.3 presents
defense against powerful network adversaries that can eclipse the
host; Section 2.4 gives the mechanism that prevents malicious administrators from mounting frontrunning attacks; Section 2.5 gives
a defense-in-depth mitigation to TEE attestation failures.
2.1 Threat Model
The Tesseract exchange achieves its security and performance goals
by relying on a trusted execution environment (TEE), i.e., a hardware
architecture that enables code execution in an isolated, tamper-free
environment. The TEE can also attest [61] that an output represents
the result of such an execution, and allows remote users to make
sure that the attestation is correct. The remote attestation feature is
essential for Tesseract, for reasons that will soon become clear.
We assume a strong network adversary (potentially the exchange
operator) that can gain complete physical access to the host in
which the funds are stored, giving her complete control of the
operating system and network connections. We do assume that the
code that runs inside the TEE enclave can neither be observed nor
tampered with. Our reference implementation minimizes the risk of
side-channel attacks by using constant-time and constant-memory
code [109] for the critical part of Tesseract. In our threat model, the
adversary’s goal is to maximize her profit: she may directly attack
the exchange (e.g., to attempt to extract secret keys that control
the funds), but may also attack the network between users and the
exchange to mount frontrunning attacks.
In a sense, the Tesseract exchange still relies on a trusted party
in the form of the hardware manufacturer, because the attestation
key inside CPU (and generates signatures for remote attestation) is
provisioned by the manufacturer. It can be argued that a weaker
yet similar form of trust is required in a practical instantiation of
any cryptographic protocol, since the manufacturer may be able to
attack the protocol by embedding malicious logic into the hardware.
We critique this argument in Section 2.5, where we also give a
double attestation scheme that makes Tesseract strictly more secure
than exchange platforms that rely on centralized servers with no
TEE. Thus, Tesseract still requires trust, but to a significantly lesser
degree than centralized exchanges and other real-time exchange
schemes (cf. Appendix A).
2.2 Overview of Tesseract
Let us describe the operation of Tesseract, illustrated in Figure 1.
For ease of notation, we use Bitcoin and Litecoin as the exemplary
cryptocurrencies. We discuss more technical details in Appendix D.
Essentially, the Tesseract enclave is running light (a.k.a. SPV)
blockchain clients. The enclave code is hardcoded with the hash
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1522
Alice
 if block# > T0+2000
 sigverify PKA
 else
 sigverify PKTEEBTC
----------------------
 amount: 5
 sigverify PKA
--------------------
 amount: 5
TXA
 if block# > T1+8000
 sigverify PKB
 else
 sigverify PKTEELTC
----------------------
 amount: 600
 sigverify PKB
--------------------
 amount: 600
TXB
Bitcoin:
T0
Litecoin:
Bob
TEE real-time exchange
Deposit(TXA)
Bid(3 BTC, price=310:1)
Bid(1 BTC, price=305:1)
Deposit(TXB)
Ask(500 LTC, price=299:1)
Genesis Genesis T1
1 2 3 2 1
Figure 1: Illustrating deposits followed by bids/asks.
of the Bitcoin genesis block, or a more recent “checkpoint” block
of the Bitcoin blockchain. When the execution starts, the enclave
receives the latest block headers from an untrusted Bitcoin client
that runs on the same server machine. Each header is validated
according to the protocol rule of the underlying cryptocurrency,
specifically for Bitcoin the proof-of-work (PoW) in the header is
validated against the current difficulty level. Each valid block is
then added to a FIFO queue that is stored inside the enclave, where
the size of the queue is set according to a parameter that specifies
the maximum time window that the enclave maintains. The enclave
maintains the same kind of queue for every other cryptocurrency
that is supported by the Tesseract exchange service.
After initialization, the enclave invokes a key generation procedure to create a keypair (sk, pk) for each supported cryptocurrency.
The randomness that we feed to the key generator is obtained by
concatenating several sources: an hardware-based randomness instruction (RDRAND with SGX), the hashes of the latest blockchain
blocks, OS provided randomness (via /dev/random), and the semitrusted hardware clock (cf. Section 2.3). Each of these sources increases the entropy of the random data, and by combining them
securely (via concatenation or hashing [84]) inside the enclave we
reduce the likelihood that an adversary will have knowledge of the
secret key sk.
The enclave will then attest that a public key pk is its deposit address, for each cryptocurrency. The attestation to these public keys
should be published through multiple services (such as websites,
IPFS [25], and even Bitcoin and other blockchains). Our multi-server
design (cf. Section 3.3 and [27]) also helps to make the attested deposit addresses publicly known. Figure 1 shows the two deposit
addresses PKTEEBTC, PKTEELTC, for Bitcoin and Litecoin.
When a new user wishes to open a Tesseract account, she first
needs to deposit a significant enough amount into a deposit address of the exchange. After the deposit transaction is confirmed
on the blockchain, the (GUI client of the) user will transform the
confirmed deposit into evidence that will be sent to the enclave.
This evidence consists of the transaction that spends the coins into
a deposit address of Tesseract, as well as an authentication path
that consists of the sibling nodes in the Merkle tree whose root
is stored in a block header, and the index of that block. Tesseract will credit the user’s account (in the enclave) after verifying
that the deposit transaction is valid, that the block B that contains
the deposit belongs to the enclave’s headers queue, and that B is
buried under enough additional confirmations (see Section 2.3 for
security analysis). Tesseract also protects against replay attacks, by
requiring strictly increasing block indices for the user’s deposits.
In Figure 1, the evidence that Alice provides is Deposit(TXA).
As shown in Figure 1, the output of a valid deposit transaction
needs to specify a time limit (e.g., two weeks). Before the limit
is reached, only the enclave can spend the deposit amount (for
a Bitcoin deposit, this public key PKTEEBTC is hardcoded in the
output and the spending is done by creating a signature with the
corresponding secret key SKTEEBTC). After the time limit, the user
can gain back control of her money by signing with a secret key
that only she knows (see Appendix D for extra details). This deposit
format ensures that the funds will safely be restored to the user if
the Tesseract server becomes unavailable.
We note that the enclave is hardcoded with the current difficulty
parameter of each PoW-based blockchain. At the beginning of the
execution, the enclave will fetch blocks from genesis (or a more
recent checkpoint), and verify that the chain reaches a block of
the hardcoded difficulty level. This prevents an adversary (who
has physical control of the Tesseract server) from feeding a lowdifficulty fake chain to the enclave. The enclave updates the PoW
difficulty level by inspecting the timestamps of block headers in the
FIFO queue and applying the consensus rules of the cryptocurrency
system (the queue size must be at least as the adjustment interval,
which is 2016 for Bitcoin). This implies that an adversary cannot
feed low-difficulty blocks to the enclave at a later time. The users
of the Tesseract exchange can gain extra security by inspecting the
latest block of each traded cryptocurrency and verifying (via remote
attestation) that the enclave has the latest blocks, see Section 2.3
for details.
Malicious users may try to carry out a DoS attack on the Tesseract
server by attempting to open many new accounts while providing
fake deposits as evidence. Currently, Bitcoin blocks contain less
than 4000 transactions, which implies that the authentication path
requires 12 or fewer sibling nodes of the Merkle tree, and hence
12 invocations of a hash function. Thus, the time complexity of
verifying the validity of a deposit is quite low. To further mitigate
the prospects of a DoS attack, the enclave may require a moderate
PoW done on the entire evidence data of the deposit (that the
user will compute on her own), or simply limit the number of new
account requests per timeframe.
One reason that the enclave maintains a queue of headers and
fetches the additional block confirmations from the queue — as
opposed to asking the user to concatenate the extra confirmations
as part of the evidence of the deposit — is that the queue provides
an undisputed point of reference in the form of the genesis (or
checkpoint) block. That is to say, if there are two blockchains that
use the same hash function for PoW and have a similar difficulty
level, then a malicious user could deceive the enclave into accepting
a deposit transaction that was confirmed on an incorrect blockchain.
This approach also reduces the communication complexity between
the Tesseract server and remote users.
After the user registers with Tesseract, her deposited amount
is credited into her account entry in the array of users that is
stored inside the enclave. Next, the user will be able to trade in realtime with other users who opened a Tesseract account, by sending
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1523
Table 1: Deposit confidence vs false positives
p δ n Pr[Erlang(n, p) ≤ δn] Pr[Erlang(n, 1) > δn]
1
10 2 60 2−75 2
−31
1
10 2 120 2−145 2
−58
1
5
1.5 120 2−92 2
−21
1
4
1.3 120 2−82 2
−10
bid/ask orders to the Tesseract server via a secure channel (see
Section 2.4). If the user wishes to deposit other currencies into her
account, she can then send similar authentication paths as evidence.
In Figure 1, Bob opens an account with Deposit(TXB), and then
asks to sell 500 LTC for the price of 299 LTC per BTC. Since Alice’s
bids are with a price of 305 LTC per BTC and higher, there is no
match yet, and the requests of Alice and Bob are recorded in the
order book kept inside the enclave. Each user can request her recent
trading history via the secure channel, and cancel her pending orders. The Tesseract server publishes an anonymized version of the
order book (i.e., price and volume of each order, without usernames)
with remote attestation; hence anyone can observe the price spread
of the exchange. Since order book updates can occur at a very rapid
rate, we reduce the amount of TEE attestations via delayed randomized checkpoints: the enclave always outputs the anonymized
order book without a signature, and outputs a delayed attestation
(that include an incremental counter) only for randomly selected
data points. The administrator of the Tesseract server provides her
part of the double attestation for all the data points (using HTTPS,
see Section 2.5). Thus, an administrator that publishes fake order
book data repeatedly will (w.h.p.) be detected. The administrator
still has a potential advantage over all other traders because she is
the first to see each order book, but the advantage is quite small.
E.g., if Alice sends a buy order (via TLS, cf. Section 2.4) with a typo,
the sell orders (in the enclave’s order book) that match her order
will execute before the enclave outputs the next order book (the
administrator stands to gain if the order book is shallow or empty).
Real-time trading among the users will cause frequent updates to
the balances of their accounts inside the enclave, but these updates
are not reflected on the actual cryptocurrency systems yet. If nothing else were to happen, the entire process would just be a sandbox
or playground, as the users will simply claim their original money
after the time limit of their deposits is reached. Therefore, from time
to time (e.g., once a day) Tesseract will broadcast to the cryptocurrency networks “settlement” transactions that commit the current
account balances of the users. See Figure 3 for an illustration, and
Section 3 regarding a secure settlement protocol.
The enclave extends the time limit of each user’s output in the
settlement transactions that it constructs (e.g., if the user could
control the output in 5 days before the settlement, then she could
control the output in 19 days after the settlement). This allows
uninterrupted trading by active traders. To minimize the size of the
settlement transactions, users who did not trade are not included in
the inputs and outputs. When some of a user’s funds are in an output
whose time limit is about to expire, the user will be prohibited from
trading. The user is permitted to send a renewal request before the
expiration, in case she was unlucky and none of her trade orders
were matched (renewal after the expiration can be exploited by
malicious users who would create conflicting transactions near the
time limit). The user can also request an early withdrawal of some
of her funds. This is done by directing the enclave to prepare an
output that is controlled only by the user, in the next settlement.
The Tesseract exchange collects a proportional fee for each successful trade (e.g., 0.1% from both ends of a trade), and a flat fee for
early withdrawal and renewal requests. The enclave requires each
user to have a minimal amount of funds at all times, and limits the
total number of pending orders that a user may have in the order
book – users who flood the exchange with an excessive number of
orders may be penalized (by confiscating some of their funds) and
blacklisted for a period of time. The fees that Tesseract collects are
needed in order to pay miner fees for the settlement transactions.
2.3 Eclipse Attacks
We assume an adversary A that controls p <
1
2
fraction of the
computational power of a blockchain that the enclave interacts
with, and also has physical access to the Tesseract server. Thus, A
can cut the communication between the enclave and the network,
and feed the enclave fake blocks.
Assuming a naive enclave implementation, A can mount an
Eclipse attack [58] as the following example illustrates: A cuts the
enclave off from the Bitcoin network and presents it with a fake
blockchain containing a deposit transaction TXfake. As a result, the
enclave credits A with a higher Bitcoin balance, which A trades
for Litecoin inside the enclave. When the enclave publishes the next
settlement transactions on the two blockchains, A will have traded
her fake Bitcoin for real Litecoin: The Bitcoin settlement transaction
will not be valid because it spends an output from TXfake which was
never included in the real Bitcoin blockchain. However, the Litecoin
settlement transaction will be valid, resulting in A profiting.
To defend against this attack, we rely on the fact that the rate
at which A can feed fake blocks to the enclave is at least twice
slower than in the absence of an attack. (Since p <
1
2
.) Assuming
that the TEE has a trusted clock1
, the enclave can impose a rule that
requires waiting for additional confirmations if the blocks arrive too
slowly. We note that the Tesseract enclave is assumed to be running
continuously, since our enclave code disallows rollbacks [72, 101] by
design (cf. Section 3.3 and [27] regarding our approach to resiliency).
The time between every two consecutive Bitcoin blocks is an
exponentially distributed random variable. Hence, for a rule that
dictates whether blocks arrive too slowly we should consider the
sum of exponential random variables, known as the Erlang distribution. Let n be the number of blocks that a deposit needs to be buried
under before it is credited by the enclave. Let δ be the multiplicative
slowness factor by which blocks are allowed to arrive. E.g., δ = 3
means that blocks that arrive 3 times slower than the expected time
(or more slowly than that) will trigger the enclave to wait for n
extra block confirmations before accepting any deposits.
Setting δ to a high value reduces the probability of a false positive
(i.e., a rejected deposit when no attack is taking place and the honest
chain growth was unluckily slow during some timeframe). However,
a high δ also increases the prospects of an attack. For any δ > 1, it is
possible to set a large enough n so that the probability of a successful
attack becomes negligible. However, a large n implies that honest
1The trusted relative timer that SGX can provide is adequate, see [1].
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1524
Price Volume
 $850 2
 $840 5
 $820 5
Buying
 Order Book (BTC/USD)
Arrival of new orders:
1. Alice: buy($870, 10)
2. Bob: sell($820, 10)
Frontrunning:
1. Adversary: buy($851, 10)
2. Bob: sell($820, 10)
3. Alice: buy($870, 10)
4. Adversary: sell($870, 10)
Selling
Price Volume
 $890 3
 $906 5
 $945 4
Figure 2: Example of frontrunning.
users need to wait for a long time before their deposit is confirmed,
which makes the Tesseract exchange service unattractive.
In Table 1 we provide exemplary concrete parameters for n and
δ. E.g., the third row of Table 1 shows that with n = 120 (20 hours
on average in Bitcoin) and δ = 1.5:
• An adversary with computational power p ≤
1
5
can mount a
successful eclipse attack on the enclave with probability 2
−92 or
smaller.
• In expectation, an honest user will need to wait for extra confirmations once in every ≈ 2 million deposits that she makes.
While the concrete parameters that can be obtained are already
quite reasonable, let us stress that prudent users of the Tesseract
exchange will not be exposed to eclipse attacks at all. Any user
can simply compare the latest blocks in the actual cryptocurrency
networks with the latest blocks that Tesseract enclave publishes
(with remote attestation), and cancel her bids/asks in case of a
discrepancy. In the example above, the honest Pj will avoid Pi
’s
attack by observing that the latest Bitcoin blocks that Tesseract
published are inconsistent with the real Bitcoin network, and refuse
to trade her LTC for BTC. Our practical instantiation of Tesseract
has another layer of security that further protects (incautious) users
from eclipse attacks, see Section 3.3.
2.4 Secure Communication
For each user who has already opened an account with Tesseract,
we establish a secure channel (e.g., TLS) when the user wishes to
communicate with the enclave. The reasons for a channel with
authenticated encryption are:
• Fast identification: The authenticated messages in the TLS Record
Protocol are computed via symmetric-key operations, after the
initial key exchange (done via public-key operations in the Handshake Protocol) to establish the channel. Since symmetric-key
operations are an order of magnitude faster than public-key operations, a persistent TLS connection delivers performance suitable
for real-time trades.
• Frontrunning prevention: An adversary can try to inspect the
entire communication flow that arrives at the Tesseract server,
learn information regarding real-time actions of other users, and
perform trades that exploit this information. Encrypted communication avoids such attacks.
An example of a frontrunning attack is shown in Figure 2. There,
Alice believes that the BTC price is going to rise. Therefore, she
places an order to buy 10 BTC at $870 each, so that any of the
current sellers will match her order first. On the other hand, Bob
believes that the price of BTC is going to drop, and he therefore
places an order to sell his 10 BTC for a price that is as low as $820.
Given the public order book, Bob’s intention is thus to sell 2 BTC for
$850, 5 BTC for $840, and 3 BTC for $820. If the trades are executed
in this order, it will be to the benefit of Bob, because he will actually
sell 10 BTC to Alice for $870 each. However, an adversary with
this knowledge can permute the orders and insert her own new
orders. In this scenario, the adversary would be guaranteed to gain
$10 · (870 − 851) = $190, by buying Bob’s 10 BTC cheaply and then
selling it to Alice.
Since all users send encrypted messages through their secure
channels, an adversary with a physical control of the Tesseract
server cannot frontrun other users. To the best of our knowledge,
all other designs of real-time cryptocurrency exchanges are exposed
to these kinds of frontrunning attacks. Non-real-time exchanges
such as TEX [63] prevent frontrunning attacks, by employing timelock puzzles and progressing in delayed batches.
We note that an adversary may still observe patterns of communication at the IP-level and try to learn information about the
traders. An IP-level anonymizer (e.g., Tor [45]) is inapplicable as
a mitigation technique against such adversaries, since the extra
latency [80] that Tor users incur will put them at a disadvantage
relative to non-Tor users that engage in real-time trading. As an
alternative, the user’s client can randomly inject dummy data into
the TLS channel (which would be ignored on arrival), thereby making it more difficult to track communication patterns. Furthermore,
in future versions of Tesseract we plan to allow users to upload
an algorithmic trading program to their enclave account (for a
fee), that will enable them to issue multiple trading orders without
communication with the server. The use of automated trading programs is quite popular in centralized exchanges (cf. [22]), although
these automated traders do communicate each of their orders to
the server.
2.5 Double Attestation
Several reputable providers may wish to offer different variants
of the Tesseract service (perhaps with their own tokenized coins
and other digital assets, cf. Appendix E). This raises the following
question: does a single entity (i.e., the hardware manufacturer) have
the power to compromise the security of all the Tesseract-based
platforms, simultaneously?
No such single entity exists with regard to centralized exchanges
(cf. Appendix A.1), because these exchanges are independent of
one another. That is to say, a security breach of one centralized
exchange will not have a direct impact on the users of the other
centralized exchanges.
For trusted hardware with remote attestation support, the plain
way that the manufacturer can break security is by attesting to
fraudulent data. In our context, suppose for example that there
are two Tesseract-based exchanges X1,X2 that invite users to deposit their funds to PKTEEBTC1 and PKTEEBTC2, respectively. If Intel
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1525
has knowledge of the secret signing keys sk1,sk2 that are embedded into the CPUs of X1 and X2, then it can forge signatures that
attest to fresh ephemeral public keys PK′
TEEBTC1, PK′
TEEBTC2 that
Intel would generate together with the corresponding secret keys
SK′
TEEBTC1, SK′
TEEBTC2. Thus, Intel will be able deceive users into
sending their deposits to PK′
TEEBTC1, PK′
TEEBTC2, and then steal
funds that users wished to deposit to X1,X2.
The manufacturer may also break security by embedding malicious logic into the hardware. For instance, whenever an application
executes code that generates a (supposedly) random secret key, the
key will actually be generated in a way that can be predicted by the
manufacturer. While this attack would be easy enough if there were
one assembly opcode that generates a random key (the malicious opcode can use a randomness source with low entropy), it is far more
difficult to achieve predictable behavior for any application-level
code that is executed by a general-purpose CPU.
Another attack vector that the hardware manufacturer may attempt is simply to send the data that a CPU generates over the
network (to the manufacturer’s address), without consent or knowledge of the administrator of the server computer. This is indeed a
concern with Intel’s Management Engine (see [91]), but it is not
an inherent defect of the trusted hardware model (hopefully the
Management Engine will allow opt-out).
Similarly to [97], the Tesseract platform protects against false
remote attestation by attaching a secondary signature – created by
the administrator of the platform – to the attested data. Following
the above example, the users of X1 (resp. X2) will take into consideration the reputation of the administrator of X1 (resp. X2), and reject
the attested data unless it was signed both by the TEE-enabled CPU
and by the reputable administrator. Hence, the hardware manufacturer alone cannot attack all Tesseract-based exchanges, since
the manufacturer has to collude with the administrator of an exchange in order to create a fraudulent attestation. This implies that
Tesseract is strictly more secure than centralized exchanges.
The double attestation mechanism is also efficient, since the
secondary signature is rarely needed. Specifically, the secondary
signature is required only once for the hardware-associated public
key identity (cf. [27, Section 6.1]) of the enclave, and this identity
can then establish the TLS channel with each user. All further communication in a TLS channel (e.g., bid/ask orders) is done without
attestation. For non-user-specific data such as real-time updates to
the public order book, the secondary signature is already implicit if
HTTPS is used to view this data.
3 ATOMIC CROSS-CHAIN SETTLEMENTS
Assume first that Tesseract only supports the trading of digital
assets that circulate within a single cryptocurrency. In this case,
the publication of each settlement transaction — that reflects the
account balances of the users after trading in a time period — does
not entail the risk of an adversary stealing funds from honest users.
The reason is that an invalid deposit (see Section 2.3) or blockage of
the settlement will amount just to a DoS attack, since all the users
will claim their prior funds after the time limit in the output of their
original deposit (or the last settlement transaction) expires.
On the other hand, trading among multiple cryptocurrency systems (that are independent of one another) may allow an adversary
Bob
300000 LTC
Bob
1000 BTC
Carol
2 BTC
Dave
1 BTC
Dave
300 LTC
Alice
300000 LTC
Carol
300 LTC
TX1 TX2
Bitcoin transaction Litecoin transaction
Alice
1000 BTC
Carol
3 BTC
Figure 3: The cross-chain settlement problem.
to steal funds from honest users. We provide an illustration of the
risk in Figure 3. Suppose for instance that 1 BTC is worth $2000, and
also that the market price of 1 BTC is 300 LTC. In the illustration,
Alice and Bob traded 1000 BTC (i.e., $2 million worth of BTC) for
300000 LTC (i.e., $2 million worth of LTC), while Carol and Dave
traded 1 BTC for 300 LTC. Thus, the enclave will construct and sign
the Bitcoin and Litecoin settlement transactions, and attempt to
broadcast the settlements to the Bitcoin and Litecoin networks. An
adversary with physical access to the Tesseract server can collude
with Alice and intercept the Bitcoin settlement transaction when it
leaves the CPU but before it is broadcast to the Bitcoin network,
and let the Litecoin settlement transaction go through and reach
the Litecoin network. The result is that the transfer of ownership
of $2 million worth of LTC from Bob to Alice will be committed on
the Litecoin system, while the transfer of ownership of $2 million
worth of BTC will never occur. In effect, Bob lost $2 million worth
of funds to Alice.
Let us provide security definitions that capture the above fairness
problem.
Definition 3.1 (All-or-nothing settlement). Given the transaction
tx1 for system CA and the transaction tx2 for system CB, an allor-nothing cross-chain settlement is a protocol that guarantees
that
(1) Both tx1 will become confirmed on system CA and tx2 will
become confirmed on system CB, or
(2) Neither tx1 will become confirmed on system CA nor will tx2
become confirmed on system CB.
In our context, CA and CB are cryptocurrencies. We stress that
parties that execute the consensus protocol for CA may be unaware
of the existence of CB, and vice versa.
Notice that Definition 3.1 does not imply that honest users are
fully protected against financial loss. Specifically, an adversary A
that prevents both tx1 and tx2 from being confirmed may benefit
at the expense of honest users: A may wish to renege on a trade
after observing some external events and/or price fluctuations that
worked to her disadvantage. Still, Definition 3.1 implies better security than that of the commonplace centralized exchanges (cf.
Appendix A.1), because the users of such centralized exchanges
run not only the risk that their trades will be reversed but also the
risk that their initial funds will be stolen.
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1526
Bob
300000 LTC
TX1 TX2
Bitcoin transaction Litecoin transaction
Alice
1000 BTC
 if block# > T1 + 2000 + 200
 sigverify PKA
 else if block# > T1 + 2000
 (sigverify PKB) AND (x: hash(x)=Y)
 else
 sigverify PKTEEBTC
---------------------------------------
 amount: 1000 BTC
 if block# > T2 + 4·(2000 + 100)
 sigverify PKB
 else if block# > T2 + 4·2000
 (sigverify PKA) AND (x: hash(x)=Y)
 else
 sigverify PKTEELTC
---------------------------------------
 amount: 300000 LTC
Figure 4: Settlement with two parties.
Definition 3.2 (Unprivileged settlement). Let U
in
1
,U
in
2
denote the
sets of users in the inputs of the transactions tx1,tx2, and let
U
out
1
,U
out
2
denote the sets of users in the outputs of tx1,tx2. Let
U = U
in
1
∪U
in
2
∪U
out
1
∪U
out
2
. An unprivileged cross-chain settlement is a protocol that satisfies Definition 3.1 in the presence of
an adversary A who can obtain any information that every user
P ∈ U accesses, at the moment that the information was accessed.
In essence, Definition 3.2 implies that honest traders cannot utilize secret data during the settlement protocol (such as picking a
secret x ∈ {0, 1}
λ
in the first step of the ACCS protocol in Appendix B), because A could break the security by gaining access to
any sensitive data that honest traders attempt to use. Thus, Definition 3.2 captures a rushing adversary who has physical control
over the TEE server and can intercept all the data that leaves the
CPU, before honest users have an opportunity to make use of this
data in a secure fashion. Note that Definition 3.2 does not permit A
to observe the secret keys that enable honest users to spend their
funds, as long as they do not access their secret keys during the
settlement protocol.
In fact, Definition 3.2 gives A more power than a real-world
adversary with physical control over the TEE server. Consider for
instance a protocol where in the first step the enclave encrypts data
using Carol’s public key, and attempts to send the encrypted data
to Carol over the network. In that case, A will not be able to obtain
the data that Carol accesses; the only action available to A is to
mount a DoS attack and not let the protocol make progress. The
motivation for the more conservative definition is that we wish to
support settlement transactions among a large number of users (e.g.,
thousands) and multiple cryptocurrency systems, where the users
can be anonymous and can create Sybil accounts. In this setting,
it is difficult to design a secure protocol that sends sensitive data
to rational users (with the expectation that they will act in their
own self-interest), due to the possibility of malicious coalitions with
Sybils who would be willing to sacrifice some of their funds. For this
reason, Definition 3.2 denies the enclave the power to communicate
privately with individual users.
Thus, intricate solutions to the all-or-nothing settlement problem
are needed mainly because our goal is to support many anonymous
traders. Let us in fact demonstrate that with a few users, the allor-nothing settlement problem can become easy. In Figure 4, Alice
Protocol Πsimp
(1) The enclave picks a symmetric key K ∈ {0, 1}
λ
.
(2) The enclave embeds K into TX1, TX2.
(3) The enclave sends ct = encryptK (TX1, TX2) to S1, S2, . . . , SN .
(4) The enclave waits for acknowledgements from S1, S2, . . . , SN .
(5) The enclave broadcasts TX1 to C1 and TX2 to C2.
(6) Each Sj that sees TXi but not TX3−i will fetch K from TXi
, decrypt
ct, and broadcast TX3−i to C3−i
.
Figure 5: Naive protocol for fair settlement.
and Bob again wish to trade $2 million worth of BTC for LTC, but
they are the only users of the Tesseract exchange. Here, the enclave
prepares the settlement transactions TX1, TX2 that keep the enclave
in control in the next two weeks (2000 blocks where T1 is the head
of the Bitcoin blockchain, and 8000 blocks where T2 is the head of
the Litecoin blockchain). This enables Alice and Bob to continue to
trade, if they wish to. The secret data x ∈ {0, 1}
λ
is generated inside
the enclave. After the enclave receives evidence that TX1 and TX2
are both confirmed, it sends x in encrypted form only to Alice, over
a secure channel. After the two weeks, the outputs can be redeemed
using x, otherwise the timeouts allow the funds to be returned to
each user. As with the ACCS protocol (cf. Appendix B), the timeout
in TX1 is longer, so Bob will have enough time to redeem the 1000
BTC after Alice reveals x, spending 300000 LTC.
Let us note that Definition 3.2 does not give A the power to
observe secret information inside the enclave. In the Tesseract
implementation, this is justified because we use a constant-time
constant-memory library for cryptographic operations [109], reducing the potential for side-channels greatly.
We now present solutions to the all-or-nothing settlement problem, in a setting that involves many anonymous traders.
3.1 Naive Protocols
To clarify why an intricate protocol is needed, we first describe a
simple protocol Πsimp that relies on N extra servers S1, S2, . . . , SN
that are supposedly reputable. See Figure 5.
The cryptocurrency systems C1 and C2 can be for example Bitcoin and Litecoin as in Figure 3. The embedding of K into TX1 and
TX2 can be done with the OP_RETURN script instruction [23], which
allows storing arbitrary data on the blockchain as an unspendable
output (for a small fee). It is not possible to mount a malleability
attack that removes K from TX1 or TX2, because the signatures
for TX1 and TX2 are over the entire transaction data (i.e., data that
includes the OP_RETURN output).
Since information that is published on a blockchain becomes
publicly available, the idea behind Πsimp is that any non-corrupt
server Si will be able to impose fairness by fetching K from a public
blockchain and decrypting the ciphertext ct, because ct is already
in Si
’s possession.
Unfortunately, Πsimp is insecure, due to a race condition. The
adversary A can intercept both TX1 and TX2, but broadcast neither
of them initially. Since the users’ outputs must have a time limit
(see Section 2), A will wait until an input (that belongs to a corrupt
user Pj
) in TXi
is about to expire, and then broadcast TX3−i
. Then,
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1527
Functionality RMIT (refundable multi-input transaction)
Notation: let C be a cryptocurrency system.
Upon receiving t x = ({in1, . . . , ink }, {out1, . . . , outn }, ϕ1, ϕ2)
(1) Verify ∀j ∈ [k] : inj
is unspent in C.
• If the verification failed then abort.
(2) Verify Ík
j=1
amount(inj) ≥ Ín
j=1
amount(outj).
• If the verification failed then abort.
(3) Make {in1, . . . , ink } unspendable in C.
(4) Wait to receive a witness w
(a) If ϕ1(w) = 1 then commit {out1, . . . , outn } to C, and terminate.
(b) If ϕ2(w) = 1 then make {in1, . . . , ink } spendable in C, and
terminate.
(c) Otherwise, return to Step 4.
Figure 6: The ideal functionality RMIT.
A will instruct Pj to spend that input, thereby invalidating TXi
.
Hence, even if all of the servers S1, S2, . . . , SN are honest, they may
not have enough time to fetch K from TX3−i and broadcast the
decrypted TXi
.
If the cryptocurrency systems C1,C2 allowed transactions to
embed large arbitrary data, then it would have also been possible
to eliminate the reliance on S1, S2, . . . , SN . Briefly, each TXi will
embed the TX3−i data in a designated output, the enclave will
broadcast both TX1 and TX2, and any user would then have the
opportunity to enforce fairness. This would bloat Ci with the entire
TX3−i data, which is undesirable — there are risks associated with
a popular decentralized cryptocurrency that allows embedding
of large data (e.g., illegal content). In any event, this approach is
insecure due to the same race condition that Πsimp exhibits.
In the following section, we give a theoretical protocol Πtheo that
avoids the race condition, using scripts with PoW-based logic that
ensures the occurrence of certain conditions on another blockchain.
3.2 Theoretical Protocol
Let us present a theoretical protocol for the all-or-nothing settlement problem, which solves the race condition that Section 3.1
elaborates upon. Following Section 3 and Figure 3, we condition
the second settlement transaction TX2 on the result of the first
settlement transaction TX1, by constraining TX2 with PoW-based
predicates that verify certain events’ occurences on another blockchain.
As we will see, this approach is problematic with the current Bitcoin protocol. Thus, we first describe the settlement protocol in an
hybrid world that has an ideal “refundable multi-input transaction”
(RMIT) functionality, defined in Figure 6.
The description of TX1, TX2 is outlined in Figure 7. We use the
notation TXi,j to denote that TXi was updated by supplying w that
satisfied ϕj
. The secrets x1 ∈ {0, 1}
λ
, x2 ∈ {0, 1}
λ
are generated
inside the enclave. The predicates ϕ
′
1
, ϕ
′
2
are specified in Figure 8.
To elaborate, the hardcoded parameter D0 specifies a difficulty
level for PoW mining, ℓ1 is an upper bound on the length of an
authentication path of a Merkle tree, and ℓ2 is a PoW confidence
parameter. The input witness w for ϕ
′
1
consists of up to ℓ1 sibling
Bob
300000 LTC
Bob
1000 BTC
Carol
2 BTC
Dave
1 BTC
Dave
300 LTC
Alice
300000 LTC
Carol
300 LTC
TX1 TX2
Bitcoin transaction Litecoin transaction
Alice
1000 BTC
Carol
3 BTC
φ1 ={x1: hash(x1)=Y1}
φ2 ={block# > T0}
φ'
1={TX1,1 is confirmed}
 OR
 {x2: hash(x2)=Y2}
φ'
2={TX1,2 is confirmed}
RMIT: RMIT:
Figure 7: Theoretical fair settlement transactions.
Predicate ϕ
′
1
Hardcoded parameters: TX1, D0, ℓ1, ℓ2
Input: w = ((v1, d1), (v2, d2), . . . , (vk , dk ), y, H1, H2, . . . , Hℓ2
)
(1) Embed hash(TX1,1) into y
(2) For j = 1 to min(k, ℓ1)
• If dj =’L’ then y := hash(y, vj) else y := hash(vj
, y)
(3) For j = 1 to ℓ2
• Embed y into Hj and compute y := hash(Hj)
• If y > D0 then return false
(4) return true
Predicate ϕ
′
2
Hardcoded parameters: TX1, D0, ℓ1, ℓ2, ℓ3, b1
Input: w = (G1, . . . , Gn, (v1, d1), . . . , (vk , dk ), y, H1, . . . , Hℓ2
)
(1) z := b1
(2) For j = 1 to max(n, ℓ3)
• Embed z into Gj and compute z := hash(Gj)
• If z > D0 then return false
(3) Embed hash(TX1,2) into y
(4) For j = 1 to min(k, ℓ1)
• If dj =’L’ then y := hash(y, vj) else y := hash(vj
, y)
(5) Embed y into H1 and compute y := hash(H1)
(6) If y , z then return false
(7) For j = 2 to ℓ2
• Embed y into Hj and compute y := hash(Hj)
• If y > D0 then return false
(8) return true
Figure 8: The cryptocurrency scripts ϕ
′
1
, ϕ
′
2
.
hash values vj
in the authentication path (with direction dj ∈
{’L’,’R’}) for the leaf transaction y, together with exactly ℓ2 block
headers H1,H2, . . . ,Hℓ2
. The predicate ϕ
′
1 will verify that TX1,1 is
in a leaf that reaches some root value r, and that r is extended by
valid proofs of work H1,H2, . . . ,Hℓ2
that meet the difficulty level
D0. The input witness w for ϕ
′
2
does the same, but also verifies
that there is a valid PoW chain of at least ℓ3 blocks between the
hardcoded b1 and TX1,2.
We describe the theoretical protocol Πtheo for all-or-nothing
settlement in Figure 9. Note that the enclave constructs TX2 only
after it receives the evidence that TX1 was confirmed in the end
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1528
Protocol Πtheo
(1) The enclave releases TX1 and waits for evidence that it was confirmed on the cryptocurrency system C1.
(2) The enclave releases TX2 and waits for evidence that it was confirmed on the cryptocurrency system C2.
(3) The enclave releases x1 and waits for evidence that TX1,1 was
confirmed on the cryptocurrency system C1.
(4) The enclave releases x2.
Figure 9: Theoretical protocol for fair settlement.
of Step 1, by hardcoding b1 as the hash of the block in which TX1
resides.
Essentially, Πtheo avoids the race condition by first making sure
that TX1 was resolved on the cryptocurrency system C1 either
by committing the output or by committing the inputs, and then
allowing TX2 to commit accordingly in the cryptocurrency system
C2. If A carries out a DoS attack before x1 is released in Step 3,
then the users will gain possession of their inputs in the C1 after
block T0 is reached (see Figure 7), which would be followed by the
miners of C1 starting to create a witness w that satisfies ϕ
′
2
(w) = 1
and thus allowing users to gain possession of their inputs in C2. If
the enclave exposes x1 in Step 3, it is still the case that the miners
of C1 will be harnessed to resolve TX1 in one of the two possible
ways.
In the case that no attack is taking place, the enclave will release
x2 in Step 4, thereby allowing the settlement to complete quickly
and without asking the miners of C2 to evaluate a complex condition
that relates to another blockchain.
However, the assumption regarding the computational power of
A has to be slightly less conservative in comparison to the power
that is needed to mount a classical double-spending attack [94],
because Πtheo enables A to gain a minor head start that depends on
the parameter T0. Specifically, A can intercept x1 in Step 3 and use
her own computational power (and x1) to create a hidden chain w1
that spends TX1 into TX1,1. The miners of C1 will create the witness
w2 in which TX1 is spent into TX1,2, but they will only begin to
work on w2 after block T0 is reached.
The success probability of an attack with a duration of T1 blocks
for the head start is
Õ∞
k=0

Pr[NegBin(T1, p) = k] · Pr[NegBin(ℓ2, p) ≥ ℓ2 − k]

.
The first negative binomial variable counts the number of blocks
that A creates during the time that the honest miners are creatingT1
blocks. This corresponds to the head start, because these T1 blocks
will not contribute to the witness that the predicate ϕ
′
2
requires.
The second negative binomial variable counts the number of blocks
that A creates while the honest miners are creating ℓ2 blocks. If
A can extend her head start to reach ℓ2 or more blocks before the
honest miners, then the attack succeeds.
In Table 2, we give exemplary figures for the attack on Πtheo. For
easy comparison, we also include the success probability without a head start (i.e., T1 = 0), which is simply the probability
Pr[NegBin(ℓ2, p) ≥ ℓ2].
Table 2: Breaking the security of Πtheo
p T1 ℓ2 with head start with T1 = 0
1
3
6 50 0.0016 0.0003
1
5
10 50 2−30 2
−37
1
5
6 50 2−33 2
−37
1
5
6 100 2−65 2
−69
1
10 20 50 2−64 2
−79
1
10 10 50 2−71 2
−79
1
10 10 100 2−145 2
−153
For the opposite attack, A may intercept x1 in Step 3 and then
create a hidden chain w2 that excludes x1. With this attack strategy,
A will broadcast x1 to C1 right before the timeout T0 is reached,
in hope that her hidden chain w2 will outcompete the chain that
the miners of C1 begin to create. This attack vector is mitigated
by disallowing a precomputation of w2. Specifically, the enclave
hardcodes b1 into TX2, and the predicate ϕ
′
2
verifies that b1 is buried
under at least ℓ3 blocks.
The parameter ℓ3 should be set to 2ℓ2 +T1. This gives a time span
of T1 blocks to update TX1 into TX1,1, after the enclave received the
evidence that TX1, TX2 were confirmed and thus revealed x1. The
parameter T1 should not be too low, to avoid the cancellation of
the settlements in case of a short network outage or a slow chain
growth in C2 relative to C1.
In the current Bitcoin network, ℓ1 = 12 suffices, hence the predicates ϕ
′
1
, ϕ
′
2
require ≤ 12 + ℓ2 + ℓ3 hash invocations for confidence
level ℓ2. Given that the complexity of ECDSA signature verification
is an order of magnitude higher than that of invoking a hash function, moderate values such as ℓ2 = 50, T1 = 10, ℓ3 = 2ℓ2 +T1 = 110
imply that Bitcoin miners can validate the scripts ϕ
′
1
, ϕ
′
2
for a mild
fee. These parameters for PoW-based SPV proofs can be even better
if the cryptocurrency system supports NIPoPoW [35, 65].
It is unlikely that Πtheo will be vulnerable to an attack that embeds a transaction that spends TX1 into TX1,1 or TX1,2 in another
cryptocurrency system C3, where C3 has the same PoW hash function and the same difficulty level. The reason is that the txid hash
of TX1 in the leaf of the Merkle tree is determined according to the
prior history that goes back to the genesis block of C1. Unless C3
allows the input of a transaction to consist of arbitrary data, A will
need to mount a preimage attack that creates valid transaction in
C3 with a particular value (i.e., the txid of TX1) as its hash.
The main obstacle to an implementation of Πtheo in Bitcoin is the
RMIT functionality. It is possible to implement the specific RMIT
that Πtheo requires by creating a transaction txinit that spends the
inputs into a single output that is controlled by the secret signing
key of Tesseract, and creating a refund transaction txrefund that has
locktime [6] of T0 and spends the output of txinit back into the
inputs. After the enclave receives evidence that txrefund is publicly
available, it will broadcast txinit to the Bitcoin network. When
the execution of Πtheo reaches Step 3 and the enclave needs to
release x1, it will broadcast a transaction txcommit that spends the
output of txinit into the desired outputs. The only problem with this
procedure is that there is no good way to make txrefund publicly
available while relying on the security of Bitcoin alone. In a purely
theoretical sense, it is possible to make txrefund available by storing
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1529
TEE real-time exchange
S1
TEE
S2
TEE
S3
TEE
SN
TEE
Figure 10: Practical fair settlement.
it as arbitrary data on the Bitcoin blockchain using OP_RETURN, but
this will be very costly because the size of txrefund can be dozens of
kilobytes and the capacity of an OP_RETURN output is only 80 bytes.
An efficient version of RMIT can be done via a Bitcoin protocol fork:
an initial transaction will mark both the inputs and the new outputs
as unspendable in the UTXO set, and a subsequent transaction will
supply a witness to ϕ1 or ϕ2 and thereby ask the miners to make
either the inputs or the outputs spendable (for a fee). An Ethereum
implementation of a RMIT contract is possible, but it should be
noted that Πtheo (and its generalization to more than two systems)
requires RMIT support by all the cryptocurrency systems that are
involved in the settlement.
Our analysis of Πtheo gives the essential security arguments
for a protocol that enables an all-or-nothing settlement. A formal
security proof of Πtheo (as well as Πprac of Section 3.3) requires a
rigorous model for the cryptocurrency consensus system — such
as GKL [51] or PSS [86] — together with a rigorous model that
is rich enough to express the scripting language that controls the
users’ coins (see, e.g., [78]). In Appendix C we provide a formal
security proof (under certain assumptions) for the ACCSs protocol
of Appendix B, that also serves to show several of the ingredients
that a proof for Πtheo needs to incorporate.
3.3 Practical Protocol
The theoretical protocol Πtheo of Section 3.2 is resilient against an
adversary who has total access to the server machine, except for
the data that is inside the TEE-enabled CPU. Here, we present a
practical protocol Πprac for the all-or-nothing settlement problem
that relaxes this resiliency aspect, but in fact offers better security
in other respects.
Our strategy is to distribute the trust among N additional servers
that are all running TEE enclaves (see Figure 10), and ensure that
Πprac satisfies Definition 3.2 if there exists at least one server Sj ∈
{S1, S2, . . . , SN } that is beyond the reach of the adversary A. That
is to say, we assume that Sj can communicate with cryptocurrencies
C1,C2 without interference.
The main idea of Πprac is to emulate the essential characteristic
of the theoretical protocol Πtheo, which is to wait for a proof that the
settlement transaction TX1 was either committed to C1 or cancelled,
and then do the same for the settlement transaction TX2.
The settlement protocol Πprac that Tesseract and the servers
S1, S2, . . . , SN execute is specified in Figure 11. As a prerequisite,
the Tesseract server and S1, S2, . . . , SN need to share a symmetric
secret key K that is known only to their enclaves. The transactions
TXc
1
, TXc
2
are “cancellation” transactions that invalidate the settlement transactions TX1, TX2, respectively. In Bitcoin, TXc
i
can be
implemented simply by spending one of the inputs of TXi
into a
Protocol Πprac
(1) Tesseract sends ct = encryptK (TX1, TX2, TXc
1
, TXc
2
) to
S1, S2, . . . , SN .
(2) For every i ∈ [N ], Tesseract waits for acknowledgement from Si
that it received ct.
(3) Tesseract broadcasts TX1 to C1.
(4) Starting from the time at which it received ct in Step 1, each server
Si ∈ {S1, S2, . . . , SN } inspects the next blocks of C1
• If Si does not see TX1 on C1 within T1 blocks, then it broadcasts
TXc
1
to C1.
• If Si sees that TX1 has ℓ2 extra confirmations on C1, then it
broadcasts TX2 to C2.
• If Si sees that TXc
1
has ℓ2 extra confirmations on C1, then it
broadcasts TXc
2
to C2.
Figure 11: Practical protocol for fair settlement.
new output that is identical to that input (this will cause TXi
, TXc
i
to conflict with each other).
Thus, the protocol Πprac seeks to preserve the property that
TX2 remains confidential inside the enclaves for as long as TX1 is
not yet confirmed. This property avoids the risk that TXi
, TXc
3−i
will compete for confirmations at the same time, as that can easily
violate the all-or-nothing requirement.
In the case that at least one server Si
is not under physical attack,
we have that either TX1 or TXc
1 will be broadcast to C1 within T1
blocks. As a consequence, either TX1 or TXc
1 will be confirmed after
T1 + ℓ2 blocks. This allows Si or one of the other non-adversarial
servers to broadcast the appropriate transaction (i.e., TX2 or TXc
2
)
to the cryptocurrency system C2, causing it to be confirmed too.
The adversary A may attempt to mount a race attack with a
head start ofT1 blocks, by eclipsing one of the servers Sj
. The attack
can proceed as follows:
(1) A intercepts the data TX1 that Tesseract reveals in Step 3 of Πprac, and
deactivates the Tesseract server.
(2) A eclipses the server Sj
, and feeds it with a fake blockchain (generated
by A herself) that contains TX1.
(3) When the enclave of Sj becomes convinced that TX1 was confirmed, it
releases TX2.
(4) A waits until TXc
1
is confirmed on C1, and then broadcasts TX2 to C2.
As with Πtheo, the reason that A obtains a head start is that the
honest participants wait for a duration of T1 blocks before they
attempt to invalidate TX1, whereas A begins to create her fake
chain immediately — see Section 3.2 and Table 2 for analysis. Note
that the purpose of the cancellation transaction TXc
2
is to defeat this
race attack, in the case that A fails to generate ℓ2 blocks while the
honest network generates T1 + ℓ2 blocks.
In fact, it is more difficult for A to exploit the head start and
attack Πprac, than it is to attack Πtheo. This is because Πprac can
specify the precise duration T1, and Πtheo has to estimate T1 by
setting T0 in the predicate ϕ2. This estimation should use a lenient
bound (that will likely give A a larger head start), as otherwise
the variance of the block generation process can cause ϕ2 to be
triggered and thus abort the settlement.
Notice that A cannot mount an eclipse attack before Step 3 of
Πprac is reached. Only the Tesseract enclave can produce the data
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1530
Table 3: Settlement transaction size and fee. In the columns
of total cost and cost per user, the first value represents the
cost on Bitcoin and the second one on Litecoin.
Number of
active users
Size of settlement
transaction (KB)
Total settlement
cost (USD)
Settlement cost
per user (USD)
10 2.538 10.004/0.192 1.000/0.019
100 23.674 93.312/1.788 0.933/0.018
1000 235.026 926.374/17.753 0.926/0.018
2000 469.887 1852.093/35.494 0.926/0.018
3000 704.766 2777.886/53.236 0.926/0.018
4000 939.640 3703.659/70.978 0.926/0.018
TX1, and it will do so only after receiving all the acknowledgements
from S1, S2, . . . , SN in Step 2. Therefore, an eclipse attack will be
thwarted if at least one non-adversarial server Si ∈ {S1, S2, . . . , SN }
is present, because Si will broadcast the invalidation transactions
TXc
1
, TXc
2
to ensure the all-or-nothing guarantee of Definition 3.1.
In practice, it is preferable that the Tesseract enclave will wait
for acknowledgements from only a constant fraction of the servers
Si ∈ {S1, S2, . . . , SN }, so that A will not be able to deny service
by preventing a single acknowledgement from reaching Tesseract
in Step 2 of the settlement procedure. Our practical approach can
in fact make Tesseract resistant to DoS in a broader sense, via a
consensus protocol among identical servers. Due to lack of space,
we defer the full protocol to [27].
Another advantage of Πprac is that it can support other cryptocurrency systems besides a PoW blockchain. This is because
the servers S1, S2, . . . , SN can run a full node inside their enclave,
whereas the predicates ϕ
′
1
, ϕ
′
2
lack the power to express the irreversibility condition of a more complex cryptocurrency system (see
Appendix D).
Irrespective of the settlement procedure, the Tesseract exchange
server can fetch from S1, S2, . . . , SN the heights of their longest
chains (e.g., once every 30 minutes), and refuse to confirm users’
deposits if less than N/2 of the servers respond. This would avert
fake deposits from being confirmed due to an eclipse attack, without
relying on the prudence of the users.
4 IMPLEMENTATION AND EVALUATION
We implemented a prototype of Tesseract that executes the clients’
trade orders, and performs all-or-nothing settlements. In this section, we present implementation details and evaluation results.
4.1 Real-time trading
We implemented a continuous limit-orderbook that runs fully protected inside the enclave. Figure 12 contains end-to-end measurements of the real-time trading performance of our prototype: For
each level of concurrency, users concurrently send encrypted and
signed orders to the enclave over the local network and we measure the throughput and latency over the course of processing 3
million orders. Each user repeatedly sends a randomly generated
order, and then (synchronously) awaits a reply from the exchange
(i.e. whether the order was (partially) filled and/or placed in the
orderbook). The latency is the time between sending the order and
receiving a response. The exchange is running on a recent model
Intel CPU (i7-8700) using six threads, one per physical core.
1
2
4
8
16
32
50
100
200
500
1000
2000
5000
0
0.5
1
1.5
2
·104
Number of concurrent trading users
Orders/sec
0 1,000 2,000 3,000 4,000 5,000
0
100
200
300
Number of concurrent trading users
Latency (ms)
Median Mean 99th pctile
Figure 12: Trading performance
0 1,000 2,000 3,000 4,000
0
25
50
75
100
Number of users participate in settlement
Time (s)
Figure 13: Time to generate a pair of settlement transactions.
As suggested by Figure 12, our prototype supports thousands
of concurrent users, processing over 18k orders per second, with
latency scaling linearly with the number of users; for 2k concurrent
users we achieve 99th percentile latency of 106ms, for 5k concurrent
users we achieve 99th percentile latency of 268ms. For low numbers
of concurrent users, full throughput is not achieved due to idle
exchange threads that are not being utilized by our synchronous
benchmark.
4.2 All-or-nothing settlement
We implemented the atomic settlment protocol Πprac between Bitcoin and Litecoin. To minimize the Trusted Computing Base (TCB),
we ported only the necessary part of Bitcoin Core v0.14.0 to SGX,
resulting in only using ∼13.3% of it. We use NaCl [32] for lightweight secure channels, rather than TLS. The entire TCB of our
implementation consists of approximately 850 source lines of code
(SLoC) for the functionalities that run inside the SGX enclave. This
figure excludes Bitcoin Core and NaCl code, which contribute about
10,284 SLoC and 1,057 SLoC, respectively.
The source code of our implementation demo is available at
https://github.com/iddo333/exchSGX. We tested the correctness
of our implementation by running it on the public testnets. The
confirmed settlement transactions can be viewed at [10, 11].
Transaction size and fees. First, we evaluate the settlement transaction size and cost with respect to different number of active
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1531
traders. Note that only users with trade activity (since the last settlement) take part in the settlement transactions. As shown in Table 3, the size of the settlement transactions grows linearly with the
number of active user, while the transaction fee per user roughly
remains constant. On average, it costs a single user approximately
92.6 cents to settle on Bitcoin and 1.8 cents on Litecoin. This results
in a total daily cost of 94.4 cents for an active user trading between
Bitcoin and Litecoin.
We estimate the transactions fees by calculating the average
transaction fee per kilobyte from historic blockchain data. Specifically, we analyzed 10081580 transactions in blocks 587351 to 592040
(July 28, 2019 - Aug 27, 2019) using the Google BigQuery [42] Bitcoin dataset, and found the average unit cost of transaction fee on
the Bitcoin network to be 0.00039 Bitcoins per kilobyte of transaction data (BTC/KB). Similarly, the average transaction fee on
Litecoin is 0.00105 LTC/KB. The Bitcoin and Litecoin prices (on
August 27th, 2019) were 10106.6 USD/BTC and 71.94 USD/LTC,
respectively.
Transaction generation time. Figure 13 shows the total generation
time of two settlement transactions (one for Bitcoin and one for Litecoin). The bottleneck in the generation of a settlement transaction
is hashing a large amount of data, and signature computation. Our
current implementation generates legacy transactions (i.e., before
the recent SegWit [33] upgrade), hence the signing time is quadratic [2] in the number of inputs – each input requires re-hashing
slightly different versions of the entire data, instead of only the
signature computation. The structure of transactions on Bitcoin
and Litecoin are the same, so the generation time of one settlement
transaction inside the SGX enclave for either blockchain is approximately 6.6 seconds for 1000 users. Up to 5.7 seconds, 86.3% of the
generation time, is spent on hashing.
Since all the trading is done off-chain and settlements occur periodically, the time for generating settlement transactions is minor,
even when the number of active traders is large. E.g., for daily settlements with 1000 users that trade between 2 blockchains, transaction
generation takes about 13.2 seconds once every 24 hours. Note that
the size of a settlement transaction among 1000 active traders is
235 KB, i.e., about 23% of the Bitcoin block capacity (pre-SegWit),
leaving 77% of the capacity for other commerce during the settlement timeframe. To compare, decentralized exchanges typically
have only dozens of active traders per day on average [5, 8], since
each trade is performed on-chain. Centralized exchanges can have
100k active traders per day [100].
With SegWit, the Bitcoin block capacity is doubled, and the
transaction fees a typically 35% smaller [3, 111] as the quadratic
hashing overhead is avoided. Thus, while our reference implementation may already be appealing to traders, it can be improved by
migrating to SegWit (legacy code still predominates the Bitcoin
ecosystem [9]). Transaction signing is also highly parallelizable, so
with more engineering effort the generation time can be reduced
by signing each input concurrently.
5 RELATED WORK
Trusted hardware has been proposed as an effective tool for different kinds of cryptocurrency use-cases, such as off-chain payment
channels [69], reputable data feed services [114], and a mixing service [105]. These schemes offer better efficiency and features by
placing more trust in the hardware manufacturer: in particular, offchain channels and mixers can also be accomplished without secure
processors (see, e.g., [28, 57, 74, 95]). By contrast, Tesseract reduces
the amount of trust that needs to be placed in the exchange service relative to all other real-time exchange schemes (to the best of
our knowledge). In Appendix A we provide a comparison between
Tesseract and various other cryptocurrency exchange schemes.
Trusted hardware can also be used to achieve significant efficiency gains for well-known cryptographic primitives such as
functional encryption [50], secure MPC [90], and NIZK in the presence of side-channels [104]. Pass, Shi, and Tramèr give a formal
model of trusted hardware and remote attestation [87].
Several works achieve fair exchange and secure cash distribution
via interaction with a cryptocurrency system, cf. [16, 17, 28, 66].
However, these works enable fair exchange (with penalties) by using
a single cryptocurrency system, while Tesseract has to provide allor-nothing fairness among multiple cryptocurrency systems.
Outside of academic work, a wide range of industry and community efforts have attempted to realize various aspects of cross-chain
distributed exchange. Notable strategies include the use of payment
channels to achieve a hub-and-spoke exchange, cf. Appendix A.
Several exchanges aim at using raw atomic swaps, as in Figures 15 and 16. Per Appendix B, such use of on-chain mediation is
unsuitable for real-time trades. Further alternatives to an atomic
swap model for decentralized exchanges are explored in Appendix A – e.g., the use of IOUs as the basis of an exchange platform.
A wide range of decentralized exchanges run inside a single
blockchain and let users to swap assets on that chain, using custody
in smart contracts to trustlessly hold user assets. Due to their onchain settlement, these exchanges are not real-time, and suffer from
several manipulation vectors across a design space explored in [40]