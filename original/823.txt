Internet of Things (IoT) deployments are becoming increasingly
automated and vastly more complex. Facilitated by programming
abstractions such as trigger-action rules, end-users can now easily
create new functionalities by interconnecting their devices and
other online services. However, when multiple rules are simultaneously enabled, complex system behaviors arise that are diicult
to understand or diagnose. While history tells us that such conditions are ripe for exploitation, at present the security states of
trigger-action IoT deployments are largely unknown.
In this work, we conduct a comprehensive analysis of the interactions between trigger-action rules in order to identify their security
risks. Using IFTTT as an exemplar platform, we irst enumerate the
space of inter-rule vulnerabilities that exist within trigger-action
platforms. To aid users in the identiication of these dangers, we go
on to present iRuler, a system that performs Satisiability Modulo
Theories (SMT) solving and model checking to discover inter-rule
vulnerabilities within IoT deployments. iRuler operates over an abstracted information low model that represents the attack surface
of an IoT deployment, but we discover in practice that such models
are diicult to obtain given the closed nature of IoT platforms. To
address this, we develop methods that assist in inferring triggeraction information lows based on Natural Language Processing.
We develop a novel evaluative methodology for approximating plausible real-world IoT deployments based on the installation counts
of 315,393 IFTTT applets, determining that 66% of the synthetic
deployments in the IFTTT ecosystem exhibit the potential for interrule vulnerabilities. Combined, these eforts provide the insight
into the real-world dangers of IoT deployment misconigurations.
CCS CONCEPTS
· Security and privacy → Formal methods and theory of security;
Vulnerability scanners; Software security engineering; · Computing methodologies → Natural language processing; · Computer
systems organization → Embedded and cyber-physical systems.
KEYWORDS
Trigger-Action IoT Platform; Inter-rule Vulnerability; Formal Methods; NLP; Information Flow

1 INTRODUCTION
The Internet of Things (IoT) is growing rapidly. With predictions of
20 billion deployed IoT devices by 2020 [1], the IoT has evolved from
isolated single devices to integrated platforms that facilitate interoperability between diferent devices and online services (e.g., Gmail).
Samsung’s SmartThings[11], Apple’s HomeKit [4], IFTTT [5] and
Zapier [17] are just a few examples. IoT platforms support end-user
customizations, with many going so far as to provide programming
frameworks for the design of simple automation logic that enable
customized functionality. Currently, trigger-action programming
(TAP) is the most commonly-used model to create automations in
IoT. Studies have shown that about 80% of the automation requirements of typical users can be represented by TAP and that even
non-programmers can easily learn this paradigm [85].
Unfortunately, as IoT deployments grow in complexity, so do
their attack surface ś as users further automate their homes, unexpected interactions between the automation rules may give rise
to alarming new classes of security issues [81]. Consider the possibility that a user has installed the rule If temperature exceeds 30
◦C, then open my windows; while this may be innocuous in isolation, it could be leveraged by an attacker to gain physical entry to
the house if the user has also installed the rule (If you say) łAlexa,
trigger heaterž, then turn the heater on. While IoT presents a variety of novel security challenges, the threats created by the ease of
trigger-action automation are worthy of careful consideration.
Reasoning about the security of trigger-action IoT platforms
requires a precise understanding of the interplay between triggeraction rules. The circumstances under which the interactions between two rules should be designated as a bug or vulnerability, as
opposed to a feature, are not presently clear. Even among small
rulesets, such as the real-world example shown in Figure 1, it is
not immediately obvious whether this composition of 5 rules could
lead to a breach in the user’s home security system; in fact, because
the three rules (r2, r4, r5) all modify the security mode of the user’s
Somfy Home Security System, there is a legitimate risk that the system could reach an unsafe state. What further frustrates analysis is
the fact that trigger-action IoT ecosystems are closed-sourced and
developed by a variety of third parties, rendering existing program
analysis techniques unusable.
In this work, we describe three distinct and inter-related efforts to enable precise reasoning about IoT security postures. To
* Joint irst authors.
Session 7A: Internet of Things CCS ’19, November 11–15, 2019, London, United Kingdom 1439
Button
Widget
Location
Service
Manything
Camera
Somfy
Security
System
r1 r2 r3 r4 r5
New
Command
Exit
Region
Enter
Region
Start
Recording
Change
Security Mode
Figure 1: Interaction of rules between popular home security
services from real-world examples [6]. Rules are represented as
hexagon vertices, triggers using oval vertices, actions using rectangle vertices, and services using cloud vertices.
better understand trigger-action rule bugs, we irst exhaustively explore the space of inter-rule vulnerabilities within trigger-action IoT
platforms. This taxonomy of inter-rule vulnerabilities attempts to
systematize problems identiied by other recent work in this space
[30, 32, 52, 70] and uncovers new subclasses of this vulnerability.
Second, we leverage formal methods to enable the detection of these
bugs; we present the design and implementation of iRuler, an IoT
analysis framework that leverages Satisiability Modulo Theories
(SMT) solving and model checking to discover inter-rule vulnerabilities. However, iRuler requires an information low graph of the
IoT deployment to operate, which at present is unavailable due to
the opacity of commodity IoT platforms. To overcome this obstacle
in the absence of viable program analysis techniques, the third
and inal element of our design is an approach to infer inter-rule
information lows by using Natural Language Processing (NLP)
to inspect the text descriptions of triggers and actions on the IoT
platform website.
We evaluate iRuler against a real-world dataset of 315,393 applets found on the IFTTT website. Testing against a manually-coded
ground truth of inter-rule lows, we ind that our NLP tool is able
to eliminate 72% of false dependencies in the IFTTT ecosystem
with minimal Type I error, the sources of which we characterize
in discussion. iRuler detects vulnerabilities in speciic conigurations of IoT deployments, but at present robust data on realistic
conigurations is not publicly available. To address this, we develop
a method for synthesizing plausible rulesets based on publiclyvisible install counts of IFTTT applets. By testing iRuler on these
synthetic conigurations, we discover the widespread potential for
inter-rule vulnerabilities in the IFTTT platform, with 66% of the
rulesets being associated with at least one such vulnerability.
2 BACKGROUND
2.1 Trigger-action IoT Platforms
Home automation IoT platforms commonly use the trigger-action
programming paradigm, which provides an intuitive abstraction
for non-technical users wishing to automate their devices. Broadly,
Table 1: A comparison of several popular trigger-action platforms,
which vary in their support for conditions, rules with multiple actions, parameter passing from triggers to actions, and a rule store.
Platform Support Multiple Trigger Values Rule
Conditions Actions used in Actions Store
SmartThings [11] ✓ ✓ ✓ ✓
IFTTT [5] ✓ ✓ ✓ ✓
openHAB [10] ✓ ✓ ✓ ✓
Microsoft Flow [8] ✓ ✓ ✓ ✓
Zapier [17] ✗ ✓ ✓ ✓
HomeKit [4] ✗ ✗ ✗ ✗
Iris [7] ✗ ✗ ✗ ✓
Wink [15] ✗ ✗ ✗ ✗
a trigger-action (TA) program speciies that when a certain trigger event occurs (e.g., motion is detected), one or more actions
(e.g., turn on the light) should be subsequently executed. Emerging
trigger-action models are also becoming more expressive through
the introduction of advanced features. In Table 1, we compare the
trigger-action models in 5 popular smart home platforms and 3
popular task automation platforms. While we note the diferences
between these platforms, our study considers a generalized triggeraction model in which each rule can have one trigger, one or more
actions, and a condition associated with each action.
Trigger-action Rule Chaining. The power of the trigger-action
programming paradigm is that rules can be chained together [81];
the execution of an action can invoke another trigger event, causing
another rule to execute. There are two ways rules can be chained,
examples of which are given in Figure 2 in the form of triggeraction graphs: rules A and B are Explicitly Chained if (1) A’s action
and B’s trigger belong to the same service and (2) executing A’s
action directly satisies B’s trigger event; rulesA and B are Implicitly
Chained if (1) A’s action and B’s trigger connect to a global shared
medium or state and (2) executing A’s action manipulates the shared
medium such that B’s trigger is satisied.
The IFTTT Platform. If-this-then-that (IFTTT) [5] is a web-based
task-automation platform which allows users to connect diferent
services to create automations using the trigger-action paradigm.
Services are typically published by third parties, facilitating interoperability with smart devices (e.g., Nest thermostat) or online
services (e.g., Gmail and Facebook). Each supported service publishes a set of triggers and actions that are akin to a service API. A
trigger is a source of events in a service. For example, a trigger in
the Nest thermostat service is łTemperature drops belowž, which
ires every time the temperature drops below a threshold. An action
is a task that a service can perform, e.g., sending an email. An applet
(i.e., a rule) is an automation program that consists of one trigger
and one or more actions. For example, a user can create an applet
to send an email if the temperature drops below a threshold. Most
triggers, like the one above, have trigger ields that determine under
what circumstances the trigger event should occur. Similarly, most
actions have action ields which are the parameters of the action.
Each trigger also has ingredients (i.e., parameters) which are basic
data available from the corresponding trigger event. For example,
the subject and the sender’s email address are two ingredients of an
email trigger. In an applet, trigger ingredients can be used as part of
a parameter by an action. An applet developer can also set further
conditions on the invocation of an action by using the ilter code
feature, which adds extra lexibility in the form of a TypeScript [14]
Session 7A: Internet of Things CCS ’19, November 11–15, 2019, London, United Kingdom 1440
Motion
Detected
Unlock 
Door
Door
Unlocked
Send
SMS
Service 2
Rule 1 Rule 2
Service 1 Service 3
(a) Rule 1 and Rule 2 are explicitly linked through Service 2.
Temperature
User is
Home
Turn On
Heater
Temperature
High
Open
Window
Service 2
Rule 1 Rule 2
Service 1 Service 3 Service 4
(b) Rule 1 and Rule 2 are implicitly linked through the temperature.
Figure 2: Trigger-action graphs depicting (a) explicit chaining and
(b) implicit chaining. Solid and dotted-line edges represent explicit
and implicit chains, respectively.
code snippet. The ilter code has access to the data returned by the
trigger and metadata like the current time. It can use the information to override action ield values or skip an action. An example
ilter code snippet is provided in Appendix A.
2.2 Model Checking and Rewriting Logic
Model checking [48] is a technique that checks if a system meets a
given speciication by systematically exploring the system’s state.
In an ideal case, a model checker exhaustively examines all possible
system states to verify if there is any violation of speciications.
Rewriting logic [61], a logic of concurrent change that can naturally deal with state and with concurrent computations, ofers
a clean-yet highly expressive-mathematical foundation to assign
formal meaning to open system computation. In rewriting logic,
concurrent computations are axiomatized by (possibly conditional)
rewrite rules of the form l → r, meaning that any system state
satisfying the pattern l will be transited to a system state satisfying
the pattern r. For any given state, many rewrite rules can be active,
thus allowing for non-determinism. Rewriting logic has been used
to model and analyze diferent distributed systems [54ś57].
3 THREAT MODEL & ASSUMPTIONS
We consider an adversary that seeks to covertly compromise an IoT
deployment via rule-level attacks that target the logic layer of an IoT
platform. Rule-level attacks seek to subvert the intent of the end
user by exploiting the interactions of the IoT automation rules. Such
interactions may enable the attacker to execute privileged actions,
cause denial of service on devices or access sensitive information
belonging to the user. These attacks are enabled solely through
the invocation of automation rules that were legitimately installed
by the user. There are many scenarios through which an attacker
could create or detect the opportunity for rule-level attacks.
• Exploitation: An adversary discovers an exploitable interaction
between two or more benign apps or invokes a trigger event
through manipulation of a 3rd party service [41].
• Targeted Rules: An adversary tricks a user into installing rules that
enable an attack, e.g., through phishing or social engineering.
• Malicious Apps: An adversary develops and distributes a malicious
app that contains hidden functionality [23, 38, 49, 84].
T R1 C1 A
R2 C2
tb cb ab
c · · · i
tb
cb ab
ci
Figure 3: The condition bypass vulnerability. Two paths exist from
tb to ab and ci , cb . The red line shows a rule chain to bypass cb .
Recent work has considered powerful adversaries that obtain
root access to devices [3] or compromise communication protocols
[2], which are out of scope in this work. While important, these
strong adversarial models run the risk of downplaying the potential
dangers posed by everyday attackers without advanced technical
knowledge. Prior work has demonstrated that IoT end users often
make errors in writing trigger-action rules [46, 68, 86]. Since they
are often unaware of the implications of rules interactions, it stands
to reason that users’ creation, deletion, or misconiguration of rules
leads to security vulnerabilities in their homes. Our threat model
also accounts for the safety risks of benign misconigurations, which
pose a real-world threat. We thus argue that rule-level attacks are an
important consideration for IoT security, and note also that similar
threat models have appeared in related work [23, 30, 49, 70, 87].
4 INTER-RULE VULNERABILITIES
In this section, we consider and deine the interference conditions
for trigger-action rules, which we call inter-rule vulnerabilities. For
generality, we deine each inter-rule vulnerability as a property
of an abstracted information low graph for an IoT deployment;
we concretize these deinitions in later sections once the state for
various devices and automation rules are known.
Consider the graphG =< V, E > that encodes the active automation logic for an IoT deployment. Vertices V can be of type T , C, or
A, respectively representing triggers, conditions, and actions. All
edges carry state from one vertex to another, but this state is device
and coniguration-speciic; for now, we only deine an abstract state
for condition vertices as a boolean lag, i.e., STATE(c) ∈ {0, 1}. Edges
that low into conditions may update this state, i.e., ON(c) or OFF(c).
Null conditions can also exist in the graph where STATE(c) = 1
always. An individual rule Rj
is given by {tj
,cj
, aj}; rule vertices
are otherwise elided. Using the above system, events in the IoT
deployment can be represented as path traversals in graph G. An
event trigger t being ired is represented by ACTIVATE(t), which
causes branching traversal of the outbound directed edges of vertex
t. Traversal automatically proceeds from all trigger and action vertices, leading to additional ACTIVATE(t) and ACTIVATE(a) events.
Traversal only proceeds from condition vertices if STATE(c) = 1.
Traversal concludes when all paths have reached either a childless
action vertex or a condition vertex where STATE(c) = 0. A path
p ∈ P describes the series of valid transitions that occurred in the
graph traversal, with the set P deining all valid paths.
We now enumerate the space of inter-rule vulnerabilities in
terms of properties of IoT information low graphs. We will do so
with respect to a benign rule Rb = {tb
,cb
, ab
} and (when necessary)
an interference rule Ri = {ti
,ci
, ai}.
Condition Bypass. Security-sensitive actions (e.g., open the window) are often guarded by some security conditions (e.g., I am at
Session 7A: Internet of Things CCS ’19, November 11–15, 2019, London, United Kingdom 1441
tb
cb ab
t
i ai
ON
ci
(a) Not enough rules
tb
cb ab
t
i ai
ON
tb
ai
ab
· · · OFF
ci
ci
cb
(b) Active blocking
Figure 4: Condition blocking scenarios. In 4a, removing ai will
make cb unsatisiable. In 4b, ai
’s activation makes cb unsatisiable.
A1
T2
A3
Rule2
T1
A2
Rule3
T1 R1 A1
A2 R2 T2
A2
tb
t ab i
'
ab
· · ·
ci
cb
(a) Action reverting
tb
ab
'
ab
ci
cb
(b) Action conlict
Figure 5: (a) Action reverting: a
′
b
has the opposite efect as action ab .
(b) Action conlict: tb activates ab and a
′
b
in an unknown order.
home). However, when a trigger is ired, all associated rules are
activated; if there are multiple paths to the security-sensitive action, the burden is on the user to apply the condition for all active
rules. The security guarantee of an action thus follows the weakest
precondition, creating the potential for condition bypass:
∃ p ∈ P s.t. {tb
, ab
} ∈ p ∧ {cb
} < p
Condition bypass is visualized in Figure 3. As an example of the condition bypass threat, consider the rule łIf temperature is higher than
30 ◦C,when I am at home and time is between 8am to 6pm, then open
the windowž. If another rule exists with a null condition, i.e., łIf
temperature is higher than 30 ◦C, then open the windowž then the
prior condition is trivially bypassed.
Condition Block. An alternate vulnerability related to conditions
is that a given condition is simply unsatisiable. Broadly, the deinition for condition blocking can be given as follows:
∀ p ∈ P, ACTIVATE(ai
) =⇒ OFF(cb
)
We identify two scenarios in which condition blocking is a potential
issue, Not Enough Rules and Active Blocking, visualizations for which
are shown in Figure 4. For the former scenario, a condition may depend on other devices’ states but there is no rule to manipulate the
state in such a way to satisfy the condition. For example, if a user has
a rule łIf motion is detected at the door when home is in armed state,
then send me a notiicationž. If no action in the deployment sets the
home’s security system to the armed state, this condition cannot
be satisied. Conversely, when Active Blocking occurs there is a
buggy or malicious rule that actively disables the condition before
the action can be activated. For example, another rule using the
łIf motion is detected at the doorž trigger could specify an action
that sets the home’s security system to the disarmed state. In either
case, the user’s intended action is unreachable.
Action Revert. An alternate mechanism for preventing an action
from having its intended efect is to immediately reverse it. For a
given action ab
, let there be an opposite action a
′
b
that negates the
ab
’s efect. With this in mind, action reverting can be deined as:
∃ p ∈ P s.t. ACTIVATE(ab
) =⇒ ACTIVATE(a
′
b
)
Action reverting is shown in Figure 5a. The reverting action pair
shown here could be lock and unlock commands on a door. It is
also possible that ab = a
′
b
, e.g., an action that toggles a switch.
Action Conlict. In contrast to action reverting, which deterministically negates ab
, action conlicts activate ab and a
′
b
in a nondeterministic ordering, potentially putting the deployment in an
unstable or unknown state. Action conlicts are deined as:
∃ p1,p2 ∈ P s.t. {tb
, ab
} ∈ p1 ∧ {tb
, a
′
b
} ∈ p2 ∧ p1 1 p2
That is, there exist paths from tb
to both ab and a
′
b
, but the former
path is not a subset of the latter path. In an action conlict, a door
could be left in either a locked or unlocked state depending on
non-deterministic state in the IoT platform. For ease of intuition,
in the above deinition we consider an action conlict that arises
based on the same trigger, but in fact an even more general deinition would accommodate diferent triggers. For example, the rules
łWhen motion is detected, unlock the doorž and łEveryday at 11pm,
lock the doorž will conlict if motion is detected at 11pm.
Action Loop. Intuitively, this vulnerability describes when an action’s activation cyclically leads to its own re-activation. We can
deine action looping as follows:
∃ p ∈ P s.t. ACTIVATE(ab
) =⇒ ACTIVATE(ab
)
An example of action loop are the rules łIf the bedroom light is
turned on, then turn of the living-room light" and łIf the living-room
light is turned of when the home state is away, then turn on bedroom
lightž. Further, attacks that exploit the action loop condition have
previously been presented in the literature. For example, an attacker
can use an action loop on a smart bulb to create strobe light that
could potentially induce seizures [76]. An attacker can also use
action looping as a side channel to leak information [49].
Action Duplicate. Unexpected duplicate activation of an action
can lead to user harm. For example, the duplication of an action to
inject some medicine could cause health problem to a patient, or
a duplicate transaction can cause inancial loss. Action looping is
an instance of the action duplication vulnerability; a more general
deinition is as follows:
∃ p1,p2 ∈ P s.t. {ab
} ∈ p1 ∧ {ab
} ∈ p2 ∧ p1 , p2
In addition to action looping, this deinition accommodates the
duplicate actions being invoked by the same or diferent triggers.
Another circumstance in which action duplication arises is the
event where one action in the deployment coniguration subsumes
another action, which we do not deine here but account for when
concretizing rules in the subsequent sections.
5 IRULER
In this section, we describe iRuler, our tool to detect inter-rule
vulnerabilities in TA rulesets. The architecture and worklow of
iRuler is shown in Figure 6. Given a set of IoT apps from a TA
platform, the Rule Parser extracts trigger-action rules from the apps
Session 7A: Internet of Things CCS ’19, November 11–15, 2019, London, United Kingdom 1442
iRuler
Rule
Parser
Checking
Engine
Model
Builder
Device/Service
Metadata
Deployment 
Config
Inter-rule
Vulnerabilities
RRs IR
Apps
Figure 6: The architecture and worklow of iRuler. RR: Rule Representations; IR: Intermediate Representation.
Listing 1: The iRuler rule representation format.
rule ::= ( trigger ) ( action ) +
trigger ::= ( event ) ( constraint )
action ::= ( condition ) ( subject ) .( command ) ( arguments )
event ::= ( subject ) .( attribute )
condition ::= logical expression | null
constraint ::= logical expression | null
and transforms the rules into Rule Representations (RR). The Model
Builder takes the rule representations, device metadata and the
user’s deployment coniguration as input and generates an Intermediate Representation (IR) of the IoT deployment. The Checking
Engine performs checking over the IR and outputs potential interrule vulnerabilities as introduced in Section 4. It is then up to the
user to determine the severity of the warning and whether or not
to correct the rules. In Figure 6, the components in yellow are provided by the user, the components in green are platform-speciic
and the components in blue are platform-agnostic. Our tool can be
easily extended to another platform by implementing a rule parser
and building device metadata for the platform. Below we discuss
each component in more detail.
5.1 Rule Parser
An IoT app could contain multiple TA rules. The rule parser irst
extracts all the rules in the app, then transforms the rules into
uniform rule representations which are used by the model builder.
Listing 1 shows the format of our rule representation. A rule is
composed of a trigger and one or more actions. A trigger is deined as an event with a constraint and an event is deined in
terms of subject (e.g., a certain device) and attribute. For example, the trigger łif temperature drops below 30ž is represented as
temperature_sensor.temperature < 30. The event here is the value
change in the measurement of the temperature sensor. An action
comprises a condition, the subject, the command to execute and
the arguments to the command. A condition or a constraint could
be null (i.e., no condition) or a logical expression. The diference
between them is that a constraint is a predicate over the event data
while a condition could be a predicate over other subjects.
5.2 Formal Modeling with Model Builder
The model builder generates a model of the IoT deployment using rule representations, deployment coniguration describing the
user’s IoT deployment (e.g., the types of devices and where they are
located), and device metadata. It then generates an intermediate
representation for the checking engine. As an IoT deployment is
essentially a distributed system interacting with a nondeterministic
environment, we model the deployment as an event-based (e.g.,
device events and time events) transition system and we model the
transitions with rewriting logic. Below we describe how we model
diferent aspects of an IoT system.
Device/Service Modeling. Each device has a set of attributes, representing the states of the device, and supported commands (i.e.,
actuator capability). For example, a heater device may have a switch
attribute and two commands turn_on and turn_off. A device command can change the values of one or more attributes, e.g., the
turn_on command sets the value of the switch attribute to łonž.
Further, the execution of a command can afect one or more environmental variables, e.g., the turn_on command can afect the
temperature environmental variable. Devices can also observe multiple environmental variables (i.e., sensor capability). For example,
a temperature sensor monitors the environment temperature. Each
device instance is modeled as a device object, i.e., an instance of a
particular device type. For example, a heater instance is modeled
as < oid : Heater | switch : _ >, where oid is the id of the device.
Device State Transitions. To model the interaction of rules, it is
important to model the state transitions of devices (or services) as
the action of a rule could cause a state transition which invokes the
trigger of another rule. For a device command that can change the
device’s attributes, we model the command execution as a transition
from one device state to another. The value change of a device
attribute is modeled as a device event. For example, the turn_off
command of the heater is modeled as a transition from state <
switch : on > to state < switch : of > with a switch change event
Event(oid,switch : of) where oid is the id of the device.
Environment Modeling. Implicit chaining is achieved through
environmental variables such as temperature. We model each environmental variable as an environment object, for example, <
env.temperature | value : _ >. As a device usually only observes
or afects environmental variables in the same place the device is
deployed, we consider the same type of environmental variable in
diferent zones (locations) as diferent variables. For example, the
temperature of the bedroom and the temperature of the living room
are treated as two diferent variables. Further, when the value of
an environmental variable is updated, the corresponding attribute
of a device that observe the variable will also be updated. For example, when the value of env.temperature_bedroom is changed, the
temperature attribute of a temperature sensor in the bedroom will
be updated to the same value. This is achieved with parallel state
transitions which change both the environment object and the device object. If no location coniguration is provided for a device,
we consider it as deployed in the common zone. Note that, our
main purpose for environment modeling is to model the implicit
chaining of a device’s command to another device’s event (e.g., temperature is higher than 30). Thus, we model each environmental
variable with discrete values. A full modeling of environmental
variables, such as dealing with real-time continuous environments
with dynamic laws and time delays, and modeling correlations of
environmental variables are out of our scope.
Time Modeling. We support temporal behavior modeling by modeling time as a monotonically increasing variable. Time advances
when there is no other transition available. Time-based triggers (e.g.,
Session 7A: Internet of Things CCS ’19, November 11–15, 2019, London, United Kingdom 1443
a timer at 8 am) are modeled as time events when the time variable
advances to the speciic values. For device actuation that can afect
environmental variables, we make state transitions of the environment objects to update their values as time advances. The updates
are made based on the efects caused by the actuation. Currently, we
support increase (i.e., increasing by a rate), decrease (i.e., decreasing
by a rate) and change to efects (i.e., directly changing to a value).
For example, if a heater increases the temperature with a rate r.
For each time unit that the switch attribute of the heater is łonž,
we make a state transition from < env.temperature | value : T > to
< env.temperature | value : T + r >. If no rate r is provided, we use
1 as default. One optimization we use to reduce system states is to
update the values of time and environmental variables only with
the values used in the ruleset. For example, if there are two timers,
one at 8 am and the other at 9 am , in the rules, we will advance
time from 0 to 8 am then to 9 am instead of advancing the time by
one time unit in the transitions.
Device/Service Metadata. The device metadata contains the necessary information for device modeling and environment modeling.
For example, it deines the attributes and commands of a device
type, the efects on environmental variables (e.g., increasing temperature) of a command, and state transitions of a device command
(i.e., what events will be generated by the execution of a command). Device/Service metadata can be constructed by analyzing
the documentation of an IoT platform or provided by the platform
developers or experts [28, 51]. For the IFTTT platform, we construct
the service metadata by crawling the web page of each service to
get what triggers and actions the service supports. We describe how
we extract state transitions of service actions using NLP techniques
in Section 6. We show examples of a device metadata and a service
metadata in Appendix C.1. The service metadata is generated with
the help of the NLP techniques in Section 6.
Intermediate Representation. The model builder could generate
intermediate representation for diferent model checkers. Due to
its maturity and expressiveness, we use Maude [13], which is a language and tool that supports the formal speciication and analysis of
concurrent systems in rewriting logic [62], as our checking engine.
With rewriting logic, an IoT system, which is a concurrent system,
can be naturally speciied as a rewrite theory R = (Σ, E, R) with
(Σ, E) an equational theory describing system states, and R rewrite
rules describing the system’s concurrent transitions. Rewrite rules
of the form crl [l] : t(
−→x ) → t
′
(
−→x ,
−→y ) if ϕ(
−→x ,
−→y ) describe an llabeled transition in an open system from an instance of t to the
corresponding instance of t
′
; the extra variables −→y on the righthand side of the rule are fresh new variables that can represent
external nondeterminism (e.g., sensor probing); ϕ is a constraint
solvable by an SMT solver. In the generated intermediate representation, devices, environmental variables and time are modeled
as objects; events and commands are modeled as messages; state
transitions and trigger-action rules are modeled as rewrite rules
(rl for rules and crl for conditional rules). Consider an example
of an IoT deployment consisting of a temperature sensor sensor
sensing the temperature from the environment and an air conditioner ac, which collaborate to maintain the in-house temperature
at a desired setpoint. In this case, the state of the system can be
modeled as < ac | setpoint : _, switch : _ >, < sensor | temp : _ >,
< env.temp | temp : _ > and < Time | time : _ >, where the
attributes time, temp, and setpoint are integers representing the
wall-clock, the temperature in the house, and the desired temperature setpoint, respectively, and the attribute switch is a Boolean
referring to whether the air conditioner is turned on or of. Note that
time and temp are under control of the environment, while setpoint
and switch are under control of the system. The state transitions
can then be modeled by the following three rewrite rules:
crl [ turn - on ] :
( < ac | setpoint :S , switch : false >
< sensor | temp : T > ; ϕ)
→ ( < ac | setpoint :S , switch : true >
< sensor | temp : T > ; ϕ ∧ T > S ) if sat (ϕ ∧ T > S ) .
crl [ turn - off ] :
( < ac | setpoint :S , switch : true >
< sensor | temp : T > ; ϕ)
→ ( < ac | setpoint :S , switch : false >
< sensor | temp : T > ; ϕ ∧ T ≤ S ) if sat (ϕ ∧ T ≤ S ) .
rl [ time - advance ] :
< Time | time : R > < Temp | temp : T > < sensor | temp : T >
→ < Time | time : R +1 > < Temp | temp :T ' > < sensor | temp :T ' > .
Rules [turn-on] and [turn-of] model the situations in which the
temperature sensed by the sensor exceeds the setpoint or not, and
thus the air conditioner is turned on or of. Rule [time-advance]
models the advance of wall-clock time (advancing the timer by one
time unit in this case) and the state transition of temperature and
the sensor. Note that the extra variable T
′
indicates the external
nondeterminism resulting from temperature changes in the house.
Also note that we embed in the system state the constraints (e.g.,
ϕ ∧ T > S) along the way during the system transitions, which will
be solved by the SMT solver in the symbolic reachability analysis.
5.3 Formal Analysis by Checking Engine
The checking engine takes the IR as input and uses rewriting modulo
SMT [75] to discover inter-rule vulnerabilities. Rewriting modulo
SMT is a symbolic technique combining the power of rewriting
modulo theories, SMT solving, and model checking. For each combination of device states, we use it as an initial state to check the
vulnerable properties as deined in Section 5.2. Since our goal is to
ind existence of violations, we use the search command to search
a reachable state that reveals the vulnerabilities. As an example,
the following search command looks up to 1 solution and a search
depth 15 for a reachable state in which the air conditioner is turned
on, while the temperature sensed by the sensor from the house
does not exceed the current setpoint:
search [1 ,15] ( < sensor | temp : T : Integer > < ac | setpoint : S :
Integer , switch : false > ; true )
= >* ( < sensor | temp : T ': Integer > < ac | setpoint : S : Integer ,
switch : true > ; B ': Boolean )
such that sat (T ': Integer <= S : Integer and B ': Boolean ) .
Note that the true on the left-hand side of the arrow indicates no
initial constraints. Similar with [70], we perform bounded model
checking [25, 26] with the argument like ł[1,15]ž to bound the
search task to a certain depth to reduce the search space. The searchbased model checker returns either a vulnerable state reachable
from the initial state or no solution, indicating no such vulnerability.
Besides the inter-rule vulnerabilities, our tool can also check
other properties using the built-in LTL (Linear Temporal Logic) [19]
Session 7A: Internet of Things CCS ’19, November 11–15, 2019, London, United Kingdom 1444
Smartthings
Close
Device
Lock Switch on
Open
Device
Unlock
Switched
on
Unlocked
Temperature
rises above
Humidity Locked
rises above
Brightness
rises above
New
motion
detected
Activate
Device
ecobee
Indoor
humidity
change
Presence
Detected
Thermostat
Mode
Change Indoor temp
change
Light Switch
Turned off
Light Switch
Turned on
Set
Thermostat
Mode
Resume
Thermostat
Turn
Switch off
Turn
Switch on
Rule R1 Rule R2
Figure 7: Initial attempts at building trigger-action information
low graphs sufered from state explosion and false dependencies.
model checker. For example, the air conditioner will be turned on if
the in-house temperature exceeds the desired setpoint. The following command analyzes, from the initial state, if the air conditioner
will be eventually turned on in all reachable states once the temperature is above the setpoint:
reduce modelCheck ( init , above ( C1 : Config ) -> [] < > on ( C2 : Config ) ) .
Note that above and on are two user-deined predicates on the
system states. The temporal operator → represents the notion of
łimplicationž, and □ ♢ the LTL notion of łalways eventuallyž.
6 IOT INFORMATION FLOW MODELING
As discussed in the prior section, iRuler requires an understanding
of how triggers and actions interact to detect inter-rule vulnerabilities. In this section, we describe our approach to the automatic
extraction of such lows from proprietary trigger-action platforms.
At irst glance, identifying such lows seems trivial. However, in
practice, identifying these links proves surprisingly diicult.
Preliminary Experiment: Following the methodology of [86] and
[63], we scraped the descriptions of 674 services and 315,393 applets
from the IFTTT website. Recall that each trigger and action in an
applet represent an API deined by a third-party service (channel).
For example, the SmartThings service provides an action łLock a
SmartThings devicež and a trigger łIf a SmartThings device is turned
onž. The simplest way to model action-to-trigger lows within a
service is to conservatively assume that all outbound triggers depend on all inbound actions. However, applying this naïve strategy
generates 6637 intra-service lows, many of which are spurious and
represent false dependencies. For example, in Figure 7, the łLockž
action of the SmartThings would not afect the łHumidity rises
abovež trigger; these are two independent attributes that can be manipulated through this service. Thus, while information low within
a rule (trigger-to-action) is deinitionally apparent, understanding
inter-rule dependencies (action-to-trigger) requires decomposition of
services into their underlying components so that true lows can be
identiied.
6.1 NLP-based Information Flow Analysis
Given the proprietary nature of trigger-action IoT platforms, our
options for analyzing the internal state of services are extremely
limited. As observed in prior work [81, 84, 86], analyzing text descriptions of IoT components that appear on the platform websites
1. POS tagging
2. Depedency tree
generation
3. Grammar heuristics
Textual Descriptions
A: This action will turn off the air
conditioner.
T: This trigger fires every time
the air conditioner is turned off.
1. Main Task [turn off]
2. Object [conditioner]
3. Object properties [air]
1. Semantic similarity
score (word-vector
embedding)
2. Semantic Relation
Mining (Babelnet)
Syntactic Analyzer
Semantic
Analyzer
<A,T> Pairwise Numeric
Feature Extraction
1. Classification
2. Cross validation
Training Set
Test Set
Unseen
Dataset
Trained Model
Accuracy Analysis
Real world information
flow graph
Classifier
Syntactic Elements
Figure 8: An overview of our NLP-based information low analysis
of trigger-action IoT platforms.
 This Action will turn off the air conditioner .
 DET NOUN MODAL VERB PRT DET NOUN NOUN PUNCT

det
nsubj
aux
ROOT
compound:prt
det
compound
dobj
punct
Part of Speech
Relation
Dependency
Figure 9: An example dependency tree that encodes the grammatical structure of an action description.
provides one means of overcoming this obstacle. We now present
an approach that leverages Natural Language Processing (NLP) in
the design of an information low analysis framework, an overview
of which is given in Figure 8. To eliminate the spurious lows and
to detect the true information lows, we pose this problem as a
supervised classiication problem. Our framework learns a function
to map an Action (A) and Trigger (T ) pair from a Service (S) to a
binary output specifying whether an information low exists from
A to T . As a irst step toward our goal, we need to encode each
⟨A,T ⟩ pair as a set of numeric features.
6.1.1 Syntactic Element Extraction. To simplify the analysis of unstructured text, we irst perform Part-of-Speech (POS) tagging and
Dependency Parsing using the Stanford CoreNLP [12] library to produce a dependency tree for the description of each rule component.
An example dependency tree for an action description is shown
in Figure 9. The parser performs Dependency Parsing to identify
the root verb representing the main task of the rule component.
All other syntactic units are either directly or indirectly connected
to the root by dependency edges, which encode a grammatical relation between a source node (governor) and a destination node
(dependent). While there are many dependency relationships, those
we use in our analysis are:
• Direct Object: The dependent of this relation with respect to the
root is the object that the main task is acted upon.
• Compounds: These relations are part of the root verb or direct
object of the task (e.g., łair conditionerž, łturn ofž).
• Modiiers: These relations encode words that modify the meaning
of a noun by specifying some additional quality, association, or
attribute (e.g., łnew subscriberž - adjective modiier to subscriber).
Session 7A: Internet of Things CCS ’19, November 11–15, 2019, London, United Kingdom 1445
Table 2: A summary of our feature vector, calculated as a comparison between the text descriptions of an action and trigger.
Feature Type Description
Verb Similarity Continuous Semantic similarity scores of ⟨A, T ⟩ verb-pairs.
Object Similarity Continuous Semantic similarity scores of ⟨A, T ⟩ object-pairs.
Verb Synonym Binary Is the trigger verb a synonym of the action verb?
Verb Hypernym Binary Is trigger verb (move) a hypernym1
of action verb (walk)?
Verb Causation Binary Can the trigger verb (eat) be caused by the action verb (feed)?
Verb Entailment Binary Does the trigger verb (wake) entail2
the action verb(sleep)?
Object Synonym Binary Is the trigger object a synonym of the action object?
Object Hypernym Binary Is trigger object (publication) a hypernym of action object (book)?
Object Meronym Binary Is the trigger object (lock) a meronym3
of action object (door)?
Object Holonym Binary Is the trigger object (door) a holonym4
of the action object (lock)?
Object-Property
Match Binary Does action object property match the trigger object property?
Verb-Particle
Match Binary Do the verb-particles5 match between action verb and trigger verb,
if the verbs are multi-word expression (turn of )?
Usually, root deines the main task while Direct Object and Compound together deine the object, in addition to Modiiers that deine the properties of the object (Figure 9). However, sometimes
the clausal complement to the root verb describes the main task
instead. For example, in the trigger description łThis Trigger ires
every time an audio event is detectedž, the root verb łirež is not
the main task, but łdetectž is, which is a clausal complement to
łirež. Moreover, łaudio eventž is a passive nominal subject to łdetectž
instead of the Direct Object relationship. So, there are a few other
dependency relations, e.g., Nominal and Passive Nominal subjects
and Clausal Complements [21], that we track to detect syntactic elements in order to accommodate the variability in unstructured text.
These grammatical dependencies comprise the syntactic elements
of interest for the remainder of our analysis.
After performing POS tagging, parsing and extracting the relevant syntactic elements, we also attempt to detect and exclude
the Named Entities [9] from each text description. In preliminary
experimentation, we found that this was necessary because named
entities appearing in extracted object descriptions often seemed to
encode similarity between dissimilar objects. For example, WeMo
Humidiier and WeMo Lighting are likely to be unrelated in spite
of a shared Named Entity WeMo. We therefore decide to exclude
named entities to avoid bias when calculating object similarity.
6.1.2 Semantic Feature Extraction. After extracting the relevant
text elements, we then encode the semantic relationship between
the syntactic elements of the action and trigger as a vector of (continuous and binary) numerical features. These features are calculated
by processing the syntactic elements of A and T in a pairwise fashion (i.e., verb-verb, object-object). Intuitively, if the elements of the
trigger and action description have related semantics, it is likely
that there exists a dependency between them. A summary of the
feature vector is given in Table 2.
Continuous Feature Computation: We leverage the Word Vector
Embedding technique to calculate Verb Similarity and Object Similarity features, which maps words from a vocabulary into vectors of
real numbers. These vector representations are able to encode inegrained semantic regularities using vector arithmetic [64]. Based
1Hypernym: generic term used to designate a class of speciic instances.
2Entailment: the trigger verb cannot happen unless the action verb happens.
3Meronym: a constituent part, the substance of, or member of some object.
4Holonym: The name of the object of which the meronym names a part.
5The verb-particles, i.e., Of or On are tagged diferently by the POS-Tagger than On
as a preposition.
on vector arithmetic, we then use the word embedding tools (e.g.,
word2vec [16], GloVe [18]) to calculate a real number score representing the semantic similarity between the two syntactic elements.
We calculate pairwise semantic similarity scores for each pair of
verbs and objects extracted from A and T . To calculate the similarity score for multi-word elements, we calculate a phrase vector
as the average of the vectors of the component words [47]. Let
phrase P be composed of words (w1,w2, . . . ,wn ) with vector embeddings (uw1
,uw2
, . . . ,uwn
). The vector for P is then deined as:
uP :=
1
n
Pn
i=1
uwi
. Finally, the semantic similarity score for the
action and trigger phrases is calculated as the cosine similarity
between the two vectors.
Binary Semantic Feature Computation: We are ultimately interested in speciic causal relationships between actions and triggers,
but our continuous features relect any relationship between the
syntactic elements. As a result of this broader focus, the similarity
scores may underweight the relationship between two elements
within the context of IoT; for example, word2vec(lock, door) with the
Wikipedia-trained model we used yields a middling similarity score
of 0.53, but in the IoT domain it is highly likely that a change in lock
state suggests a change in door state. To correct for this, we also calculate a series of binary features for each action trigger pair, which
we deine to capture generic semantic relationships that we found
were commonly relevant to action-trigger lows during manual
coding of our IFTTT dataset. For example, multi-word expressions
(e.g., łturn onž) are commonly found in descriptions, but the verb
particle on is often tagged as a preposition by the POS tagger, so
we introduce a feature that tests if the verb particles match. These
features are calculated using the lexical database Babelnet [69],
annotated and interlinked with semantic relations.
6.2 Classiication Problem
We cast information low detection as a supervised binary classiication problem between an action and trigger pair ⟨A,T ⟩, where both
T and A belong to the same service S. Each ⟨A,T ⟩ pair is labeled
such that 1 signiies the existence of a low from A to T while 0
signiies the contrary. We divide the dataset into training and test
sets by service so that the classiier is unable to leverage servicespeciic semantics when classifying test samples. We use 4 diferent
classiication algorithms - Support Vector Machine, Random Forest,
Multilayer Perceptron and Logistic Regression. We use Grid Search
with Cross Validation to search the hyperparameter space to optimize the classiier performance for a high recall (i.e., maximize
proportion of actual positives identiied correctly) value. The decision of recall optimization comes from the intuition that it is safer
to admit false lows than exclude true lows.
One issue with our dataset is that it is highly imbalanced because
there are more spurious non-lows than true lows, i.e., the number
of positive examples is far less than the number of negative examples. We use two diferent techniques to combat this problem. First,
we use class-weights inversely proportional to the percentage of
class examples in the training set. This assigns a higher misclassiication penalty to training instances of the minority class. Second,
we use Random Oversampling to balance the data by randomly
oversampling the minority class. We do not use undersampling of
majority class since we have a limited sized dataset.
Session 7A: Internet of Things CCS ’19, November 11–15, 2019, London, United Kingdom 1446
Table 3: A summary of the classiication performance (percentages).
Classiier Accuracy AUC Recall FP
Rate
FN
Rate
False Flow
Reduction
SVM (RBF Kernel) 80.2 79.8 90.7 22.3 9.2 72
Random Forest 85.7 80.5 88.2 15.2 11.8 78.7
Multilayer Perceptron 86.8 82.7 88.6 16.4 11.4 77.6
Logistic Regression 83.1 79.5 84.4 20.4 15.6 74.3
6.3 Classiication Performance
Based on the methodology described above, we now evaluate the
overall accuracy of our NLP-aided information low analysis tool.
6.3.1 Experimental Setup. Our feature extraction tool was implemented using the Stanford CoreNLP [12] library for POS tagging
during syntactic element extraction, the FastText [27] project’s
Wikipedia dataset word vectors to calculate similarity scores, and
Babelnet [69] to extract binary semantic features.
The classiier’s training and test sets were derived by randomly
selecting 512 services from our IFTTT dataset, which is described
in greater detail in Section 7.1. We divided this into 374 services
for training and 138 services for testing. Because we were unable
to purchase, conigure, and run all of the devices and services on
IFTTT, our labeled ground truth is based not on applet invocations,
but on manual coding by two of the authors; we consider the potential limitations of this approach in Section 8. Each coding decision
entailed examining the text descriptions of the service to determine
whether it was possible for a given action to lead to the invocation
of a given trigger. The existence or absence of a low was usually
obvious; occasionally the coders needed to look up the functionality
of a service if they were not familiar with it. Manual coding entailed an author spending approximately 40 hours manually coding
the intra-service lows, followed by a second author spending 5
hours on reliability coding [82]. for a total of 45 hours of human
efort. There were a small number (less than 10 in total out of 512
services) of discrepancies identiied by the reliability coder, which
were easily resolved between the two coders through a brief discussion. While this strategy for deriving intra-service lows is already
tedious, we argue that it will shortly become entirely untenable
as IoT platforms continue to grow in popularity. There is already
evidence that this expansion of IFTTT is underway ś during a 5
month window in 2017, the platforms services, triggers and actions
grew by 11%, 31%, and 27% respectively [63].
6.3.2 Results. We used the training set to train the classiier and
the test set to compute the accuracy and AUC score. Then we fed
the entire training set and test set together to our tool and computed
recall, error rates and the amount of false low reduction. These
results are summarized in Table 3. We compare the performance
of our NLP-aided tool using diferent classiication models against
the baseline naïve strategy used in our preliminary experiments,
which conservatively assumes a low exists between all actions and
triggers of a service. Compared to this baseline which generates 6637
lows, our NLP-based tool with SVM classiier minimizes the FN rate
to 9.2% while causing an overall reduction in graph complexity of
72%. This inding demonstrates that an NLP-based approach is a
irst step towards overcoming the opacity of IoT platforms.
6.3.3 Discussion. In light of the large number of false dependencies
that exist using the naïve information low strategy, we feel that
our error rates are promising. Here, a false positive signiies that
our attack surface model is overly conservative, encoding a low
between two rules that does not actually exist, while a false negative
fails to identify a legitimate low.
We identify two error sources that can be directly attributed to
our methodology. First, our approach depends on an accurate text
description of the rule behavior; in cases where the trigger/action
do not contain verbs that explain the behavior, we are unable to
identify the low (True Error). In a few cases, the classiier’s decision
boundary detected ⟨A,T ⟩ pairs with high verb or object similarity
as a non-low, or pairs with lower similarity scores as a low (Classiication Error). However, we did not want to overit our model
to the dataset, so we restrained from ine-tuning the classiier to
address this.
The larger sources of error in our system can be attributed to
limitations in the underlying NLP tools we employed. (1) Text descriptions that generated complex syntax trees (with uncommon
grammatical relations) led to false positives because we were unable
to track the language elements indicating a non-low (Syntax Tree
Complexity). (2) The POS-tagger sometimes labeled words incorrectly, leading to errors; for example, the łonž in łTurn onž might
be detected as preposition instead of a verb-particle, third-person
verbs sometimes detected as plural nouns, or the word everytime
is detected as a verb (POS Tagger Error). (3) Parsing errors by the
CoreNLP parser module produced incorrect dependency trees, leading to incorrect feature vectors (Dependency Parsing Error). (4) Descriptions that contained complex object modiiers led to some false
positives, e.g., łThis Action will create a regular post on your Blogger
blogž and łThis Trigger ires every time you publish a new post on
your Blogger blog with a speciic labelž (Complex Object Modiier). (5)
Word embeddings often assign high similarity score to contextually
similar verb pairs, for example łopen-closež, łactivate-deactivatež,
thus confusing the classiier to record a false positive. (6) A signiicant source of error was that the word embedding models we used
were not trained for the IoT domain, but a more general vocabulary
(i.e., Wikipedia). This was especially problematic when novel words
(e.g., łcool-modež) were encountered.
These error sources could potentially be addressed in future work
through advancements in these techniques or by training NLP tools
speciically for the IoT domain. Alternately, our method could be
augmented with prediction uncertainty analysis and quantiication
techniques [43] to request human intervention when the classiier
is not conident enough in its prediction.
7 EVALUATION
Having generated an information low graph of IoT deployments
using our NLP-aided analysis tool, we are now able to leverage
iRuler to identify inter-rule vulnerabilities within real-world IoT
platforms. In this section, we examine the potential for inter-rule
vulnerabilities within the IFTTT ecosystem.
7.1 Dataset
We conduct our evaluation on a dataset crawled from the IFTTT
website in October 2018 using the methodology introduced by Ur
et al. in [86]. The data we collect is entirely public and includes
only metadata about the published applets and services ś all user
Session 7A: Internet of Things CCS ’19, November 11–15, 2019, London, United Kingdom 1447
 0.01
 0.1
 1
 10
 100
 0 10 20 30 40 50 60
Average # of violations
# of rules
Looping
Conflict
Conflict_2
Reverting
Duplication
Duplication_2
(a) Random Strategy
 0.01
 0.1
 1
 10
 100
 0 10 20 30 40 50 60
Average # of violations
# of rules
Looping
Conflict
Conflict_2
Reverting
Duplication
Duplication_2
(b) Install Count Strategy
 0.01
 0.1
 1
 10
 100
 1000
 0 10 20 30 40 50 60
Average # of violations
# of rules
Looping
Conflict
Conflict_2
Reverting
Duplication
Duplication_2
(c) Service-based Strategy
Figure 10: Average number of vulnerabilities discovered for diferent coniguration synthesis strategies (averaged over 50 trials per number
of rules). Diferent inter-rule vulnerability classes are separated by color; Conflict_2 stands for action conlict with diferent triggers and
Duplication_2 stands for group action duplication (i.e., one action subsumes another action). Duplication violations can exceed # of rules
because a single action can be involved in multiple duplications.
data in IFTTT is private, and thus not contained in our dataset,
with the exception of aggregate applet install counts which are
made public.6 Our crawl identiies 315,393 applets and 674 services.
The applets make use of 1,718 distinct triggers and 1,327 distinct
actions. The applets were written by either service providers or
131,768 third-party authors (i.e., users). Some components of IFTTT
applets are not publicly visible, making us unable to discover certain
classes of inter-rule vulnerabilities; for example, because applet
ilter code is not public, we cannot analyze IFTTT for the condition
bypassing vulnerability. Instead, we limit our evaluation to action
loop, conlict, revert, and action duplicate vulnerabilities.
The security of a given IoT deployment ultimately depends on its
coniguration, i.e., the currently active set of rules. However, we are
not aware of a publicly available dataset that describes how actual
users conigure their IoT deployments; for example, on IFTTT each
user’s installed rules are private. This knowledge gap is not speciic
to our study but belies a broader limitation in state-of-the-art IoT
security research. Unfortunately, without an accurate picture of IoT
conigurations, we are limited in our ability to identify real-world
vulnerabilities in smart homes.
In order to evaluate iRuler, we make the observation that IFTTT
actually exposes a limited amount of usage information that will
allow us to approximate realistic IoT conigurations. We leverage
this usage information in the form of 3 competing heuristics for
synthesizing plausible trigger-action rule sets:
• Install Count Strategy. IFTTT reports the total number of installations of each applet. We normalize these install counts to assign
each applet a weight and construct an IoT coniguration of r rules
by performing a weighted random walk starting at a random point
in the IFTTT information low graph. This strategy relects the
intuition that popular applets are more likely to be simultaneously
installed.
• Service-Based Strategy. We construct an IoT coniguration by randomly selecting a small number of services, then randomly selecting r rules from within those services. This strategy relects the
intuition that a user is likely to make use of only a small number
of services.
6We argue that this is analogous to security surveys of mobile app markets (e.g., [37])
and therefore consistent with community norms governing ethical data collection.
 0
 20
 40
 60
 80
 100
 0 10 20 30 40 50 60
percentage (%)
# of rules
(a) Including duplication
 0
 20
 40
 60
 80
 100
 0 10 20 30 40 50 60
percentage (%)
# of rules
(b) Excluding duplication
Figure 11: The percentage of applet authors whose applets have at
least one vulnerability.
• Author-Based Strategy. In IFTTT, authors have the option of sharing their applets publicly. We construct an IoT coniguration by
assuming that an author has all of their public applets simultaneously installed. This strategy relects the intuition that authors
are likely to use their own applets.
We compare each of these heuristics to a baseline Random Strategy that uniformly selects at random r rules from the IFTTT dataset.
Thus, our indings will not only serve to validate iRuler but also
characterize the potential for real-world inter-rule vulnerabilities.
7.2 Results
We apply each IoT coniguration synthesis strategy for variable
numbers of rules between 2 and 60, reporting the average number
of discovered violations across 50 trials. Figure 10 shows the average number of vulnerabilities identiied as the number of active
rules increases using the Random Strategy, Install Count Strategy,
and Service-Based Strategy, respectively. In Figure 10, action duplication is the most prevalent concern in the IFTTT ecosystem.
Looping behaviors are also quite frequent, occurring at least once
per coniguration when more than 15 rules are simultaneously active. While less prevalent, we also identify the potential for conlicts
and reverting behaviors in many of the synthesized conigurations.
The group action duplication vulnerability, while rare, was also observed in our tests. Using the Install Count Strategy, in total, 66% of
the rulesets are associated with at least one inter-rule vulnerability.
We consider the Author-Based Strategy in a separate analysis
because, unlike the other strategies, we are unable to control the
Session 7A: Internet of Things CCS ’19, November 11–15, 2019, London, United Kingdom 1448
Table 4: Rule chaining in IFTTT. Actions/Triggers is the number of
chainable mechanisms in IFTTT, while Observed signiies the number of linkable mechanisms observed in at least one IFTTT rule.
Type Actions (Observed) Triggers (Observed)
Explicit chaining 204,510 (200,030) 62,013 (61,967)
Implicit chaining 10,128 (9931) 6262 (5228)
number of trials and the number of active rules. Figure 11a shows
the percentage of authors of applets with at least one vulnerability.
Almost all authors’ applets show evidence of at least one interrule vulnerability. Again, similar to prior test, duplication is the
most common concern; Figure 11b shows the frequency of vulnerabilities excluding duplication. Concerningly, about 1 in 5 authors
will experience a non-duplication vulnerability in their rule set if
they activate at least 10 rules. However, some authors might not
simultaneously activate all their applets, meaning that this test
may overestimate the frequency of vulnerabilities. However, taken
as a whole, this test provides compelling evidence that inter-rule
vulnerabilities currently exist in the wild.
Our study also presents an opportunity to characterize the potential for rule chaining within TA platforms. Because rule chaining
increases the complexity of an IoT coniguration, we theorize that
it also increases the potential for security violations within the deployment. Across the 674 IFTTT services we analyzed, there exist
509 actions that can explicitly link to other rules and 518 triggers
can be explicitly triggered by some action. In addition, we identify
460 actions that can afect an environment variable in order to indirectly invoke 392 triggers that monitor environmental variables.
Table 4 summarizes our rule chaining results. We identify a total
of 204,510 (64.8%) rules that can explicitly link to other rules, and
62,013 (19.5%) rules that can be explicitly linked by other rules.
There exist 10,128 (3.2%) rules can implicitly link to other rules, and
6262 (2.0%) rules that can be implicitly linked by other rules.
7.3 Vulnerability Analysis
Condition Bypassing & Condition Blocking. While we introduce
the notion of condition-based vulnerabilities in ğ4, we are unable
to detect them on IFTTT because applets’ ilter code is not public.
We veriied the presence of condition vulnerabilities using our own
applets but leave large-scale validation of this issue to future work.
Action Reverting. Our dataset contains 1127 applets with multiple
actions, 50 of which contain contrary action pairs that revert each
other. A rule susceptible to action-reverting by another rule/applet,
usually occur within distance 1 or 2 of one another in the IFTTT
information low graph, but the longest distance observed was 5
in a coniguration of 26 applets; such violations would likely to be
diicult to identify manually. One example of such violation in our
dataset consists of an applet that turns the lights on when motion
is detected, but another applet turns of the lights whenever a light
is turned on. A more concerning violation we observed was a rule
that would disconnect a HomeSeer device from Wi-Fi the moment
it was turned on, creating a DoS attack because the device cannot
function or receive commands without a network connection.
Action Looping. Most of the loops we observed consist of 2 or 3
rules, while the longest loop contains 9 rules in a coniguration of
30 applets. We observed one rule chain that triggered IFTTT to call
the user whenever their calendar received an appointment, while a
second rule triggered IFTTT to make an appointment to the user’s
calendar whenever they missed a call. Hence, if a user sent IFTTT’s
autodial to voicemail, IFTTT would continue to call back while
simultaneously illing her calendar with pointless appointments.
Action Conlicts. Most of the conlicting action pairs are direct
actions of the same trigger (i.e., distance 1). There are also rules that
conlict with other rules in another branch, including rule chain of
length 4, longest in a coniguration of 23 rules. We observed a rule
chain where two rules conlict: łArm the Scout Alarm when the user
enters an areaž, and łTurn of the user’s phone Wi-Fi when the user
enters an areaž. The second rule disconnects the phone from the
network, so IFTTT is unable to trigger the irst rule, i.e., arm Scout
Alarm. We observe that the sequence of the iring triggers usually
determines the inal states of the conlicting actions. We found one
example where scoutalarm enters armed mode everyday from 10
AM until the user’s phone connects to home Wi-Fi, but a second
rule disables the home Wi-Fi every day at 9:55 AM. Combined,
these will cause scoutalarm to irst disarm at 9:55 AM and then
re-enter armed mode at 10 AM, even when the user is at home.
Action Duplication. As seen from Section 7.2, action duplication
is very common. It is perhaps not surprising to observe redundant
rules in the community-based IFTTT ecosystem as developers may
publish applets with the same function. A chain length of 8 in a coniguration of 38 rules is the longest we observed to contain an action
duplicate violation. The number of group duplication violations we
detected is very small as there are only 113 applets that use group
actions. We further investigated that IoT services in IFTTT provides
more group actions, such as Turn of device vs. Turn of all devices
(Linn) or Disarm all cameras vs. Disarm a camera (Eagle Eye NuboCam). We envision that as more functionalities are introduced in
IoT devices, these superseding relationships will become more common, creating the potential for action-duplication vulnerabilities to
signiicantly frustrate the debugging of IoT deployments.
8 DISCUSSION & LIMITATIONS
Usability. The motivation of this work is to help users better
diagnose potential security problems in their IoT deployments. In
future work, we plan to evaluate the usability of iRuler through
real world IoT user studies, and further characterize actual security
threats. An important component of the future work is to extend
iRuler to provide further assistance to non-expert users when an
inter-rule vulnerability is found.
The IFTTT Applets Dataset. Similar to Ur’s IFTTT recipe dataset in
[86], our dataset is missing relevant information that is not publicly
available, including values for the trigger ields in each applet and
the applet’s ilter code (i.e., conditions). An interesting direction
for further study is leveraging applet descriptions to attempt to
recover these ields; for example, the applet łGet a phone call alert
when a door is opened during sleeping hours,ž suggests the condition
łduring sleeping hoursž is applied to the call_my_phone action. Note
the model checker of iRuler already supports conditions.
Synthetic IoT conigurations. Because we lack real-world examples of IoT deployment conigurations, in our evaluation, we use
heuristic strategies to synthesize IoT deployments from our IFTTT
Session 7A: Internet of Things CCS ’19, November 11–15, 2019, London, United Kingdom 1449
dataset. Because ilter code is not publically visible, we conservatively assume in our analysis that any action that may low to a
trigger will low to it. We also assume that environmental factors
are always afected such that the low from action to trigger occurs.
Thus, the vulnerabilities we detect may be absent from real-world
conigurations. However, this method demonstrated the validity of
iRuler for cases in which coniguration data is available. In our
future work, we plan to conduct user studies to evaluate our tool
with real-world IoT conigurations.
Manual Coding of Action-Trigger Flows. Due to the diiculty and
cost of registering for hundreds of IFTTT services, many of which
would require the purchase of one to dozens of devices in order to
exercise, we had to rely on manual coding (not physical invocation)
as our ground truth for information low on IFTTT. It is diicult
to judge the correctness of our manual labeling without physical
ground truth; however, because services are incentivized to write
informative text descriptions of their functionalities, we believe
that our coding was accurate enough to demonstrate the validity
of our NLP approach. Regardless, this coding is a potential source
of error in our analysis.
Applicability. We ensure the generality of our approach through
presenting a realistic trigger-action rule model. While we have
implemented iRuler for IFTTT, this model holds for other systems (e.g., Zapier and Microsoft Flow), as does the observation that
NLP-based analysis is required due to the closed nature of these
platforms.
9 RELATED WORK
IoT Security. Numerous vulnerabilities have been identiied in
IoT devices [3, 45, 78], protocols [2, 42], apps and platforms [38].
Alrawi et al. [22] proposed a modeling methodology for IoT devices,
associated apps and communication protocols to analyze devicespeciic security postures. Diferent from the network-based [79, 89],
platform-based [39] and app-based [49, 87] IoT-security solutions
which detect vulnerabilities at runtime, iRuler leverages NLP and
model checking to statically check vulnerabilities before an app
is installed and executed. Celik et al. [29] use static analysis to
identify sensitive data lows in IoT apps, while our work studies
vulnerabilities caused by the interaction of multiple trigger-action
rules. Several other studies consider challenges related to access
control in IoT [44, 50, 74, 77].
Trigger-Action Programming (TAP) in IoT. Researchers have studied how smart homes [33, 85, 88] and commercial buildings [66] can
be customized using TAP, and the usability of existing TAP frameworks to propose guidelines for developing more user-friendly
interfaces [46, 83]. Ur et al. [86] create a dataset of IFTTT recipes
and analyze diferent aspects of the recipes. Bastys et al. [23, 24]
discuss user privacy issues in IFTTT and developed a framework to
detect private data leakage to attacker controlled URLs. However,
they concentrate only on the privacy violations in the ilter code
of individual applets, not the interaction between applets. Fernandes et al. [40] consider the efect of OAuth-related overprivilege
issues on the IFTTT platform and proposed a way to decouple the
untrusted cloud from trusted clients on the user’s personal devices.
NLP-aided Flow Analysis. FlowCog [71] extracts app-semantics
and contextual information that deines an android app behavior,
and uses NLP to correlate the app behavior with the information
lows in the app. Other work has used NLP to locate sensitive information in mobile apps and track information leakage to third-party
libraries [35, 67]; evaluate the semantic gap between mobile app
descriptions and app permissions [72], and match IoT app description with actual app behavior [84]. Ding et al. [36] use keyword
identiication in the app description of SmartThings apps to detect
app interaction-chains through physical channels. Surbatovich et
al. [81] deine an information-low lattice to analyze potential secrecy or integrity violations in IFTTT recipes. While their work
manually rewrites and labels triggers and actions to identify ruleinteractions chains, our approach uses NLP to automate this process.
There are also eforts to build semantic parsers that creates executable code from IFTTT-style natural language recipes [53, 73] ,
which are orthogonal to our contributions.
IoT Automation Errors. IoT automation errors have been studied
from various aspects, including analyzing logic inconsistencies and
supporting end-user debugging to resolve them [20, 34, 51, 52, 90] as
well as assisting IoT app developers with GDPR [58]. Chandrakana
et al. [68] identify that too few triggers in automation rules is a
source of errors and security issues. They propose a tool to determine a necessary and suicient set of triggers based on the actions
written by end users. However, their tool analyzes each rule in isolation while we consider vulnerabilities from rule interactions. Some
work has also been done on detecting and resolving automation
conlicts in smart home and oice environments [59, 60, 65, 66, 80];
in this work, we consider a broader class of vulnerabilities.
IoT Properties Checking. Several recent studies have proposed to
check security or safety properties of IoT when multiple rules/apps
are enabled. We compare our approach with other existing approaches in diferent aspects in Table 5; iRuler is among the works
that support the more advanced features of TA platforms (Multiple
Actions), incorporates a broad set of characteristics into its model
(Environment Modeling, Device Location, Time Modeling, Support
Checking Other Properties), and identiies new classes of inter-rule
vulnerabilities.7 Conversely, these works also provide several useful properties that we did not consider in iRuler. AutoTap [90]
presents a method for verifying coniguration properties as expressed by novice users, and joins MenShen [28], Salus [51], and
SIFT [52] in supporting automated creation and repair of rules
(Rule Writing). Systems like Soteria [30], IoTSan [70], and HomeGuard (arXiv preprint only: [32]) are based on source code analysis
of IoT apps and can therefore consider additional factors such as
iner-grained reduction of state explosion and speciic malicious
input sequences. IoTGuard [31] instruments apps to check security
and safety properties at runtime. Conversely, rather than leverage
source code analysis, instrumentation, or a priori knowledge of
app behaviors, our technique uses an NLP-based approach to infer
information low. As a result, iRuler is necessarily less precise
and ine-grained in its analysis but has the advantage of working
out-of-the-box on commodity IoT platforms where source code is
typically unavailable.
7We show the vulnerabilities considered by other work in Table 6 in Appendix B.
Session 7A: Internet of Things CCS ’19, November 11–15, 2019, London, United Kingdom 1450
Table 5: Approaches for checking security and safety properties of IoT rules/apps. [31] checks properties at runtime while all others perform
static checking. These systems all have diferent aims and advantages; this table focuses speciically on the similarity of their design to iRuler.
Multiple
Actions
Environment
Modeling
Device
Location
Time
Modeling
Support Checking
Other Properties
# Inter-rule Vuln
Types Considered
Rule
Writing Access Required
iRuler ✓ ✓ ✓ ✓ ✓ 8 ✗ Applet Descriptions, Conig Data
Soteria [30] ✓ ✗ ✗ ✗ ✓ 3 ✗ App Source Code1
, Device Handler Code
IoTSan [70] ✓ ✗ ✗ ✓ ✓ 2 ✗ App Source Code, Conig Data
AutoTap [90] ✗ ✗ ✗ ✓ ✓ N/A ✓ App Behaviors,2 Device Speciications
MenShen [28] ✗ ✓ ✗ ✓ ✓ N/A ✓ App Behaviors,2 Device Schema
Salus [51] ✗ ✓ ✓ ✓ ✓ N/A ✓ App Behaviors,2 Conig Data, Device Schema
SIFT [52] ✗ ✓ ✗ ✓ ✓ 1 ✓ App Behaviors,2 Device Metadata
HomeGuard [32] ✓ ✗ ✗ ✗ ✗ 5 ✗ App Source Code, Conig Data
IoTGuard [31] ✓ N/A ✗ N/A ✓ 3 ✗ App Source Code, Instrumentation
Surbatovich et al. [81] ✗ ✗ ✗ ✗ ✗ N/A ✗ Applet Descriptions1
1. Coniguration factors are not considered.
2. Assumes knowledge of app behaviors is available a priori.
10 CONCLUSION
While the trigger-action programming paradigm promotes the creation of rich and collaborative IoT applications, it also introduces
potential security and safety threats if users do not take precautions
in combining these apps. In this work, we generalize and examine
inter-rule vulnerabilities in trigger-action IoT platforms, presenting
a tool for their automatic detection. iRuler combines the power
of SMT solving and model checking to model the IoT systems and
check vulnerable properties. As a related contribution, we have also
demonstrated an NLP-aided technique for inferring information
low between rules in proprietary trigger-action platforms.