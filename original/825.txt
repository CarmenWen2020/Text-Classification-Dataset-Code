Bitcoin owes its success to the fact that transactions are transparently recorded in the blockchain, a global public ledger that removes
the need for trusted parties. Unfortunately, recording every transaction in the blockchain causes privacy, latency, and scalability issues.
Building on recent proposals for “micropayment channels” — two
party associations that use the ledger only for dispute resolution
— we introduce techniques for constructing anonymous payment
channels. Our proposals allow for secure, instantaneous and private
payments that substantially reduce the storage burden on the payment network. Specifically, we introduce three channel proposals,
including a technique that allows payments via untrusted intermediaries. We build a concrete implementation of our scheme and
show that it can be deployed via a soft fork to existing anonymous
currencies such as ZCash.
1 INTRODUCTION
Bitcoin has become increasingly popular as a decentralized electronic currency. In Bitcoin, each transaction is recorded in the
blockchain, a public transaction ledger maintained by a set of decentralized peers. While this design has proven successful at low
transaction volumes, the reliance on a globally-shared ledger has
caused serious scaling issues. Since in Bitcoin 1MB blocks are added
to the blockchain every ten minutes on average, the Bitcoin transaction rate is limited to fewer than ten new transactions per second
across the entire Bitcoin user base [1].1 Several proposals to increase
blockchain bandwidth are being debated in the Bitcoin community
today, but none are likely to produce a transaction rate that competes with centralized services such as payment card networks.
A promising approach to addressing the scaling problem is to
move the bulk of Bitcoin transactions off chain, while preserving
the system’s decentralized structure and strong integrity guarantees. The leading proposal for off-chain payments is to use payment
channels, exemplified by the Lightning Network [45] and Duplex Micropayment Channels [30]. Rather than posting individual payment
transactions to the blockchain, channels employ the blockchain to
first establish a shared deposit between two parties. The parties
interact directly to make payments — adjusting the respective ownership shares of the deposit — and communicate with the blockchain
only to agree on the final split of escrowed funds. In cases where no
direct payment channel exists between two parties, these proposals also allow participants to route transactions via intermediate
peers [45]. The main benefit of the payment channel paradigm is
that it dramatically reduces the transaction volume arriving at the
blockchain, without adding new trusted and centralized parties.
While payment channels offer a solution to the scaling problem,
they inherit many of the well-known privacy weaknesses of Bitcoin [40, 46]. Although payments are conducted off chain, any party
may learn the pseudonymous identities and initial (resp. final) channel balances of the participants. More critically, payment channels
provide few privacy protections against transaction counterparties.
By establishing a channel to pay for e.g., Tor bandwidth or web
content, a user implicitly links each payment on a given channel
to all of her other payments on this channel. This is particularly
problematic in the likely event that payments are routed via a common intermediate peer — such as a currency exchange — since the
intermediary must now be trusted to keep private your full payment history. Some proposals, such as the Lightning Network, have
proposed to work around this problem by routing the payment via
multiple intermediary nodes; however (as we discuss in §6) this
approach substantially increases the complexity of establishing
payment channels, and reveals payment information in the event
that even a subset of the intermediaries collude.
Several academic works have recently proposed solutions that
address the privacy problems of Bitcoin-type currencies [29, 41, 42,
47]. Some of the resulting systems been publicly deployed, notably
ZCash [3] (an implementation of the Zerocash protocol [47]) and
Monero [2]. Unfortunately, the privacy mechanisms contained in
these systems apply to the privacy of transactions on the blockchain,
and do not address the setting of payment channels. Indeed privacy
for payment channels seems fundamentally challenging due to
channels’ pairwise structure. Even when a channel is funded with
anonymous currency, repeated payments within the same channel
are inherently linkable. This is concerning, given that one of the
main proposed applications of channels is for web micropayments —
which are often described as a more private alternative to tracking
and online behavioral advertising.
We stress that concerns about privacy are not theoretical. Several
commercial ventures [11, 23, 32] have been founded around the task
of analyzing and tracing blockchain transactions. It is reasonable to
expect that surveillance will be applied to payment channel systems
if they become widely deployed.
Our Contribution. In this paper we propose Blind Off-chain Lightweight Transactions, or Bolt. Bolt consists of a set of techniques for
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 473
constructing privacy-preserving payment channels for a decentralized currency. These techniques ensure that multiple payments on
a single channel are unlinkable to each other and — if channels are
funded with anonymized capital 2 — anonymous.
Our constructions enhance earlier work in privacy-preserving
decentralized payments [29, 41, 47] while addressing the problem
of providing fast and private off-chain transactions. Unlike earlier
proposals [37], which simply obfuscate participant identities from
intermediaries, our proposals create anonymous direct channels
even when a merchant does not know the identity of the paying
party. Of more practical interest, we prototype one of our constructions and show that we can deploy Bolt as a soft fork of a Bitcoin
like cryptocurrency. We provide constructions for three types of
channels:
Unidirectional payment channels allow a customer to
pay a merchant fixed value coins repeatedly without linking the payments together. While our approach builds on
the compact e-cash paradigm introduced by Camenisch et
al. [17], it requires a novel mechanism to achieve succinct
channel closure, ensuring blockchain space usage is constant,
regardless of the transaction volume.
Bidirectional Channels allow two parties to exchange
arbitrary valued payments in either direction, without linking the payments. The challenge here is preventing a malicious counterparty from using obsolete information to claim
an earlier balance, while maintaining the scheme’s unlinkability. While multiple payments on the same channel are unlinkable, to avoid linking an aborted payment to the payer’s
identity, our construction requires that the underlying payment channel be funded anonymously.
Indirect channels Finally, we extend our bidirectional
payment channel construction to enable third party payments, where an untrusted intermediary acts as a “bridge”
allowing two otherwise unconnected parties to exchange
value. Critically, the intermediary learns neither the identity
of the parties nor the amount transacted.
1.1 Background on Payment Channels
A payment channel is a relationship established between two participants in a privacy-preserving decentralized ledger-based currency
network. While payments may flow in either direction on an established channel, the parties themselves are not symmetric: for
a payment channel to work, at least one party must initiate the
connection. For simplicity of exposition, we will refer to the initiating party as a customer, and the responding party as a merchant.
We assume that the payment network includes a means to validate
published transactions and to resolve disputes according to public rules. In principle these requirements can be satisfied by the
scripting systems of consensus networks such as Monero or ZCash,
using only minimal script extensions (which we discuss in §5.) We
stress that our proposals in this work focus on the privacy of payment channels, and thus we assume the privacy of the underlying
funding network.
2 This requires either that the underlying cryptocurrency, is itself anonymous, e.g.
as in ZCash [3], or that there exists some way of anonymizing or mixing that adds
sufficient anonymity to non-anonymous cryptocurrency.
When two parties wish to open a channel, the parties first agree
on the respective balance shares of the channel, which we represent
by non-negative integers B
merch
0
and B
cust
0
. The parties establish
the channel by posting a payment to the network. Provided that
these transactions are correctly structured, the network places the
submitted funds in “escrow” until a subsequent closure transaction
is received. The customer now conducts payments by interacting
off-chain with the merchant. For some positive or negative integer
payment amount ϵi
, the i
th payment can be viewed as a request
to update B
cust
i
:= B
cust
i−1
− ϵi and B
merch
i
:= B
merch
i−1
+ ϵi
, with the
sole restriction that B
merch
i
≥ 0 and B
cust
i
≥ 0. At any point, one or
both parties may request to close the channel by posting a channel
closure message to the ledger. If the closure messages indicate
that the parties disagree about the current state of the channel,
the ledger executes a dispute resolution algorithm to determine
the final channel balances. After a delay sufficient to ensure each
party has had an opportunity to contribute its closure message, the
parties may recover their final shares of the channel balance using
an on-chain payment transaction.
Any payment channel must meet two specific requirements,
which we refer to as universal arbitration and succinctness:
(1) Universal arbitration. In the event that two parties disagree about the state of a shared channel, the payment network can reliably arbitrate the dispute without requiring any
private information.
(2) Succinctness. To make payments scalable, all information
posted to the ledger must be compact — i.e., the size of this
data should not grow linearly with the balance of the channel,
the number of transactions or the amounts exchanged.
The latter property is an essential requirement for the setting of
payment channels, since it rules out degenerate solutions that result
in a posted transaction for every offline payment, or that post the
full off-chain payment interaction to the ledger.
1.2 Customers, Merchants, and the Limits of
Anonymity for Payment Channels
Informally our constructions for payment channels provide the
following privacy guarantee:
Upon receiving a payment from some customer,
the merchant learns no information beyond the
fact that a valid payment (of some known positive
or negative value) has occurred on a channel that
is open with them. The network learns only that
a channel of some balance has been opened or
closed.
Note, however, that the privacy protections against a channel participant are slightly weaker than those against third parties. This is
an inherent limitation of the payment channel setting. Moreover,
these limitations change depending on if a payment is made over a
single direct channel or an indirect channel consisting of a series
channels between the customer, one or more intermediaries, and a
merchant. We explain these limitations further here.
Direct channels. The direct channel setting has three limitations.
First, the privacy provided for direct channels is asymmetric: only
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 474
the party initiating the payment is anonymous and unlinkable between payments, while the target of the payment is pseudonymous.
This holds because at least one party must know which payment
channel is being used.
Second, when receiving a payment on a channel, the recipient
knows the payment came from someone with whom they have an
open channel. This is also fundamental to the nature of channels,
since they must be established with a counter-party before being
used.
This final requirement suggests that recipients should use wellknown channel parameters to group all channels, and thus maximize the anonymity set of its customers. If a recipient provides
unique channel parameters to each potential payer (i.e., behaves
as though it was a different party to each payer), than the payer
receives no privacy — as the set of channels open under that set of
parameters has an anonymity set of a single person.
This setting maps well to a situations where the payment target
is known, e.g., where a single merchant or website accepts payments
from many anonymous customers. Thus for the remainder of the
paper we term this well-known target party the merchant, and refer
to the paying party as the customer. We keep this terminology even
when in settings where payment amounts are negative (resulting
in a reverse payment), since one party must still be well known
and this terminology maps to the case where, e.g., a merchant is
refunding a customer for a previous purchase. We stress that to
anyone not a party to the payment channel, privacy is absolute.
Indirect channels For indirect channels which involve one or
more intermediate channels, the privacy guarantees may, surprisingly, be stronger than the direct case. First, this configuration facilitates a larger anonymity set, since it encompasses any party who
has a channel open with the entry intermediary (for the initiator) as
well as anyone who has a channel open with the exit intermediary
(for the target). Additionally, when channels contain a single intermediary, they can be configured such that the merchant remains
anonymous to the customer. Specifically, although the underlying
pair-wise channels still offer asymmetric privacy (i.e., one party
is well-known), we can arrange the indirect channels so that the
customer and merchant are both holding the private end of their
channel and instead the intermediary is the only well-known party.
We discuss this arrangement in §4.3.
The advantages of intermediaries do not fully generalize to
chains containing more than a single intermediary. Specifically,
we show that channels with a single intermediary can be configured to hide the payment amount from the intermediary. However,
channels which involve more than one intermediary cannot hide
the value of a payment from all intermediaries. Regardless of cryptographic underpinnings, at least one endpoint3 of each channel
must know the channel balance or else the channel cannot be closed.
As a result, in any chain of channels with multiple intermediaries,
at least one channel will have an intermediary party on both endpoints, and one of these parties will inevitably learn the value of
the payments. This is not a limitation of our techniques but simply
a consequence of the nature of payment channels.
3
It is possible that neither endpoint knows the balance in full and instead must cooperate to learn it. This does not alter the problem.
1.3 Overview of our constructions
In this work we investigate two separate paradigms for constructing
anonymous payment channels. Our first construction builds on the
electronic cash, or e-cash, paradigm first introduced by Chaum [25]
and extended in many subsequent works, e.g., [13, 17, 26]. This
unidirectional construction allows for succinct payments of fixedvalue tokens from a customer to a merchant, while preserving the
anonymity and functionality of a traditional payment channel. Our
second construction extends these ideas to allow for variable-valued
payments that traverse the channel in either direction (i.e., each
payment may have positive or negative value), at the cost of a
more complex abort condition. Finally, we show how to extend our
second construction to support path payments where users pay
anonymously via a single untrusted intermediate party or a chain
of intermediaries.
We now present the intuition behind our constructions.
Unidirectional payment channels from e-cash.An e-cash scheme
is a specialized protocol in which a trusted party known as a bank
issues one-time tokens (called coins) that customers can redeem
exactly one time. “Offline” e-cash protocols seem like a natural candidate for implementing a one-way payment channel. For purposes
of exposition, let us first consider a “strawman” proposal based on
some ideal offline e-cash scheme that allows for the detection of
doubly-spent coins. In this proposal, the merchant plays the role of
the bank. After confirming that the customer has funded a channel,
it issues a “wallet” of anonymous coins to the customer, who then
spends them back to the merchant. To close the channel, the customer spends the remaining coins to herself and posts the evidence
to the payment network. The merchant can dispute the customer’s
statement by providing evidence of a doubly-spent coin.
This strawman protocol suffers from several weaknesses. Most
obviously, it is not succinct, since closure requires the customer to
post all of her unspent coins. Secondly, there is an issue of timing:
the merchant cannot issue a wallet to the customer until the customer’s funds have been escrowed by the network, a process that
can take from minutes to hours. At the same time, the customer
must be assured that she can recover her funds in the event that
the merchant fails to issue her a wallet, or aborts during wallet
activation. Finally, to avoid customer “framing” attacks (in which
a merchant issues coins to itself and then accuses the customer of
double-spending) we require an e-cash scheme with a specific property called exculpability: namely, it is possible for any third party (in
our case the payment network) to distinguish “true” double spends
— made by a cheating customer — from false double-spends created
by the merchant.
Intuition behind our unidirectional construction. To address the first
concern, we begin with a compact e-cash scheme [17]. Introduced
by Camenisch et al, this is a form of e-cash in which B separate
coins can be generated from a constant-sized wallet stored at the
customer (here B is polynomial in the wallet size). While compact
e-cash reduces the wallet storage cost, it does not immediately give
rise to a succinct closure mechanism for our channels. The key
innovation in our construction is a new mechanism that reduces
channel closure to a single fixed-size message — at the cost of
some increased (off-chain) interaction between the merchant and
customer.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 475
redeem
for -5
-5
+5
Customer
escrows
funds on
blockchain
C
u
s
t
o
m
e
r
m
e
r
c
h
a
n
t
 Merchant
signs new
wallet. Used in
next payment
-5
+5
New
IOU
BLOCK
CHAIN

100
0
channel establishment
 Merchant
provides token
for closing
channel on new
balance
REVOKED
Customer
revokes previous
wallet +refund
token
redeem
for
Payment for $5.00 (does not touch blockchain) channel closure
redeem
for 95


 Merchant
issues signed
wallet for
escrowed
funds
Customer
proves new
unsigned wallet
pays merchant
$5 more than
existing signed
IOU
Customer
posts
refund
token
 Blockchain
splits escrowed
funds
Figure 1: High level description of bidirectional channel protocol. The customer is the anonymous party. The merchant is a
known identity. Only channel establishment and closure touch the blockchain.
To create a payment channel in our construction, the customer
first commits to a set of secrets used to formulate the wallet. These
are embedded within a succinct wallet commitment that the customer transmits to the payment network along with the customer’s
escrow funds (and an ephemeral public signature verification key
pkc
). The customer and merchant now engage in an interactive
channel establishment protocol that operates as follows. The customer first generates B coin spend transactions, and attaches to
each a non-interactive zero knowledge proof that each coin is tied
to the wallet commitment. She then individually encrypts each of
the resulting transactions using a symmetric encryption scheme
such that each ciphertext Ci embeds a single spend transaction,
along with the decryption key for ciphertext Ci+1. After individually signing each of the resulting ciphertexts using her secret key,
the customer transmits the signed results to the merchant for safekeeping. A critical aspect of this scheme is that from the merchant’s
perspective these ciphertexts are opaque: the customer does not
need to prove to the merchant that any ciphertext is well-formed.
When the customer wishes to close an active channel with remaining balance N (for 0 < N ≤ B), she computes j = (B − N) + 1
and posts a signed message (channel ID, j, kj
) to the network, with
kj being the decryption key for the j
th ciphertext. The merchant
can use this tuple to decrypt each of the ciphertexts Cj
, . . . ,CN
and thus detect further spending on the channel. If the customer
cheats by revealing an invalid decryption key, or if any ciphertext
decrypts to an invalid coin, or if the resulting transactions indicate
that she has double-spent any coin, the merchant can post indisputable evidence of this cheating to the network — which, to punish
the customer, will grant the full channel balance to the merchant.
Bidirectional payment channels. A restriction on the previous
construction is that it is unidirectional: all payments must flow from
the customer to the merchant. While this is sufficient for many useful applications — such as micropayments for web browsing — some
applications of payment channels require payments to flow from
the merchant to the customer. As we further discuss below, a notable example of such an application is third party payments, where
two parties send funds via an intermediary, who must increase the
value of one channel while decreasing the other.
For these applications, we propose a second construction that
combines techniques from existing (non-anonymous) payment
channels with blind signatures and efficient zero-knowledge proofs.
As in the existing payment channel systems [30, 45], the customer
and merchant first on agree on an initial channel state, with the
customer holding B
cust
0
escrowed funds, and the merchant provides
a signature on this balance. When the customer wishes to pay the
merchant an arbitrary positive or negative amount ϵ, she conducts
an interactive protocol to (1) prove knowledge of the previous
signature on the current balance B
cust
i−1
, and (2) demonstrate that
she possesses sufficient balance to complete the payment. She then
(3) blindly extracts a new signed refund token from the merchant
containing the updated balance B
cust
i
= B
cust
i−1
− ϵ. At any point, the
customer may post her most recent refund token to the blockchain
to redeem her available funds. See figure 1.
The main challenge in this approach is to prevent a dishonest
customer from retaining and using earlier versions of her refund
token on channel closure. To prevent this, during each payment, the
customer interacts with the merchant to present a revocation token
for the previous state. As long as the customer behaves honestly,
this revocation token can never be linked to the channel or to any
previous transactions. However, if the customer misbehaves by
posting an obsolete refund token, the merchant can instantly detect
this condition and present the revocation token to the network as
proof of the customer’s malfeasance – in which case, the network
awards the balance of the channel to the merchant. Unlike the ecash approach, this proposal suffers from the possibility that one of
the parties will abort the protocol early; we address this by using
the network to enforce fairness.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 476  
From direct to third-party payments. As the concluding element of our work, we show how a bidirectional payment channel
can be used to construct third-party payments, in which a first party
A pays a second party B via a common, untrusted intermediary
I to which both parties have previously established a channel. In
practice, this capability eliminates the need for parties to maintain
channels with all of their peers. The key advantage of our proposal
is that the intermediary I cannot link transactions to individual
users, nor — surprisingly — can they learn the amount being paid
in a given transaction. Similarly, even if I is compromised, it cannot
claim any transactions passing through it. This technique makes
anonymous payment channels usable in practice, provided there
exists a highly-available (untrusted) intermediary to route the connections. We provide the full details of our construction and how
to extend it to support multiple intermediaries in §4.3.
Aborts. Our unidirectional protocol provides privacy guarantees
that are similar to the underlying e-cash protocol, with the obvious
(and necessary) limitation that final channel balances are revealed
on closure. Payments between a customer and merchant are noninteractive and completely anonymous. The bidirectional payment
construction, on the other hand, provides a slightly weaker guarantee: by aborting during protocol execution, the merchant can
place the customer in a state where she is unable to conduct future
transactions. This does not prevent the customer from resorting
to the network to close the channel, but it does raise concerns for
anonymity in two ways:
(1) The merchant can arbitrarily reduce the anonymity set by
(even temporarily) evicting other users through induced
aborts.
(2) The merchant may link a user to a repeating sequence of
transactions by aborting the user in the middle of the sequence.
For many traditional commerce settings, the consequences of such
aborts may be minimal: no matter the payment mechanism, the
merchant can fail to deliver the promised goods and the customer
will almost certainly abort. For other settings, such as micropayments, these possibilities should be considered. In such settings
customers should scan the network for premature closures and
abort the channel if the number of open channels with a merchant
falls below their minimal anonymity set.
1.4 Comparison to related work
In concurrent work, Heilman et al. proposed an elegant mixing
system called Tumblebit [36]. Tumblebit is compatible with classical Bitcoin and operates in two modes. The first allows users to
anonymize (aka mix or “launder”) their own coins. The second
mode allows for payment channels between distinct users. Overcoming the limited choice of cryptographic primitives to get Bitcoin
compatibility is a serious achievement, but for Tumblebit it comes
at the cost of far more limited features, performance, and privacy
in comparison to Bolt’s payment channels.
Most significantly, in a payment from Alice to Bob, “Bob and the
Tumbler can collude to learn the true identity of Alice” [36] since
Alice identifies herself to the Tumbler when making a payment
because she must pay the Tumbler with traceable Bitcoins.4
In
contrast both our schemes provide provable privacy for Alice even
in the face of corrupted and colluding parties. Second, Tumblebit
does not hide payment values.
On the functionality side: Tumblebit payments are of a single
fixed value and payment channels are unidirectional. In contrast
we provide for bidirectional payment channels with variable valued
payments. Tumblebit payments are also not succinct: a channel
allowing n payment needs either O(n) state on the blockchain or
O(n
2
) invocations of their protocol.
On the performance side: at 387ms per channel payment, Tumblebit is 5 times slower than our prototype implementation of Bolt’s
bidirectional channels. We stress that this is not due to a design flaw
in Tumblebit: working within the confines of Bitcoin compatibility
is extremely challenging and comes at a high cost.
Finally, like Tumblebit, our unidirectional protocol provides full
protections from aborts. Our bidirectional protocol does not and
requires an underlying anonymous currency for safety (see §1.3).
Variable payments seem to require multiple rounds of interaction,
thus risking aborts terminating in invalid intermediate states.
1.5 Outline of this paper
The remainder of this paper proceeds as follows. In §2 we present
definitions for anonymous payment channels. In §3 we present the
building blocks of our scheme. In §4 we describe the protocols for
our payment channel constructions, and in §5 we present concrete
instantiations of these protocols. Finally, in §6 we discuss the related
work.
2 DEFINITIONS
Notation: Let λ be a security parameter. We write P (A(a), B(b))
→ (c,d) to indicate a protocol P run between parties A and B,
where a is A’s input, c is A’s output, b is B’s input and d is B’s
output. We will define ν (·) as a negligible function. We will use
valmax to denote the maximum balance of a payment channel, and
denote by the set of integers {ϵmin, . . . , ϵmax} the range of valid
payment amounts.
2.1 Anonymous Payment Channels
An Anonymous Payment Channel (APC) is a construct established
between two parties that interact via a payment network. In this section we first describe the properties of an anonymous payment channel scheme, which is a collection of algorithms and protocols used
to establish these channels. We then explain how these schemes
can be used to construct channels in a payment network. We now
provide a formal definition of an APC scheme.
Definition 2.1 (APC scheme). An anonymous payment channel
scheme consists of a tuple of possibly probabilistic algorithms (KeyGen,
InitC, InitM, Refund, Refute, Resolve) and two interactive protocols
(Establish, Pay). These are defined in Figure 2. For completeness we
also define an optional function Setup(1
λ
) to be run by a trusted
party for generating the parameters pp, e.g., a Common Reference
4This is likely fundamental. See Section 7.c of [36] for further discussion. Although
Heilman et al. provide some mitigations for these attacks, as they acknowledge the
Tumbler and Bob can still correlate Alice’s interactions. Thus they cannot offer Alice
provable privacy from Bob.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 477
String. In some instantiations the CRS is not required. In this case, we
set pp := 1
λ
.
5
Using Anonymous Payment Channels. An anonymous payment channel scheme must be used in combination with a payment
network capable of conditionally escrowing funds and binding these
escrow transactions funds to some data. Such payment networks
can be constructed using blockchain-based systems, although they
can be built from other technology as well. In this work we assume
only the existence of a payment network with these capabilities,
and leave the details of the payment network’s implementation (e.g.,
modeling a blockchain) as a separate problem. We now describe
how these algorithms and protocols are used to establish a channel
on a payment network.
To instantiate an anonymous payment channel, the merchant M
first generates a long-lived keypair (pkM,skM) ← KeyGen(pp)
that will identify it to all customers. The merchant initializes its state
S ← ∅. A customer C generates an ephemeral keypair (pkC,skC)
for use on a single channel. The customer and merchant agree on
their respective initial channel balances B
cust
0
, B
merch
0
. They now
perform the following steps:
(1) Each party executes the InitC algorithm on the agreed initial channel balances, in order to derive the channel tokens
TC, TM.
(2) The two parties transmit these tokens to the payment network along with a transaction to escrow the appropriate
funds.
(3) Once the funds have been verifiably escrowed, the two parties run the Establish protocol to activate the payment channel. If the parties disagree about the initial channel balances,
this protocol returns ⊥ and the parties may close the channel.
(4) If channel establishment succeeds, the customer initiates the
Pay protocol as many times as desired, until one or both
parties close the channel.
(5) If the customer wishes to close the channel, she runs Refund
and transmits rcC along with the channel identifier to the
payment network.6
(6) The merchant runs Refute on the customer’s closure token
to obtain the merchant closure token rcM.
At the conclusion of this process, the network runs the Resolve
algorithm to determine the final channel balance and allows each
party to collect the determined share of the escrowed funds.
2.2 Correctness and Security
We now described the correctness and security of an anonymous
payment channel scheme. Here we provide intuition, and present
formal definitions in Appendix B.
Correctness. Informally, an APC scheme is correct if for all correctlygenerated parameters pp and opening balances B
cust
0
, B
merch
0
∈
{0, . . . , valmax}, every correct (and honest) interaction following
the paradigm described above always produces a correct outcome.
Namely, each valid execution of the Pay protocol produces success,
5Looking forward to our recommended instantiations in §5, we propose to use a CRS
based on public randomness.
6Here we assume that channel closure is initiated by the customer. In cases where the
merchant wishes to initiate channel closure, it may transmit a special message to the
network requesting that the customer close the channel.
and the final outcome of Refute correctly reflects the final channel
balance.
Security. The security of an Anonymous Payment Channel scheme
is defined in terms of two games, which we refer to as payment
anonymity and balance. We now provide an informal description
of each property, and refer the reader to Appendix B for the formal
definitions.
Payment anonymity. Intuitively, we require that the merchant, even
in collaboration with a set of malicious customers, learns nothing
about a customer’s spending pattern beyond the information that
is available outside of the protocol. In our anonymity definition,
which extends a definition of Camenisch et al. [17], the merchant
interacts with either (1) a series of oracles implementing the real
world protocols for customers C1, . . . , CN , or (2) with a simulator
S that performs the customer’s part of the Pay protocol. In the
latter experiment, we assume a simulator that has access to side
information not normally available to participants in the real protocol, e.g., a simulation trapdoor or control of a random oracle. We
require that the simulator has the ability to simulate any customer
without access to the customer’s wallet, and without knowing the
identity of the customer being simulated. Our definition holds if
no adversary can determine whether she is in world (1) or (2). We
stress that this definition implies anonymity because the simulator
has no information about which party it is simulating.
Balance. The balance property consists of two separate games, one
for the merchant and one for the customer. In both cases, assuming
honest execution of the Resolve protocol, this property ensures
that no colluding set of adversarial counterparties can extract more
value from a channel than justified by (1) the party’s initial channel
funding, combined with (2) the set of legitimate payments made
to (or by) the adversary. Because the merchant and customer have
different interfaces, we define this property in terms of two slightly
different games. In each game, the adversarial customer (resp. merchant) is given access to oracles that play the role of the merchant
(resp. customer), and allows the parties to establish an arbitrary
number of channels with chosen initial balances. The adversary
may then initiate (resp. cause the other party to initiate) the Pay
protocol repeatedly on adversarially-chosen payment amounts ϵ.
Finally, the adversary can initiate channel closure with the counterparty to obtain channel closure messages rcC, rcM. The adversary
wins if the output of the Resolve protocol is inconsistent with the
total value funded and paid.
3 TECHNICAL PRELIMINARIES
In this section we recall some basic building blocks that we will use
in our constructions.
Commitment schemes. Let Πcommit = (CSetup,Commit, Decommit)
be a commitment scheme where CSetup generates public parameters; on input parameters, a message M, and random coins r,
Commit outputs a commitment C; and Decommit on input parameters and a tuple (C,m,r) outputs 1 if C is a valid commitment
to the message, or 0 otherwise. In our instantiations, we recommend
using the Pedersen commitment scheme [44] based on the discrete
logarithm assumption in a cyclic group.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 478
Key generation and channel initialization algorithms:
KeyGen(pp). This algorithm generates a keypair (pk, sk) for use by each customer or merchant.
InitP (pp, B
cust
0
, B
merch
0
, pk, sk). For P ∈ {C, M } this algorithm is run by each party prior to opening a channel. On input the initial channel balances, public parameters
and the party’s keypair, the InitC algorithm outputs the party’s channel token TP and a corresponding secret cskP .
Two-party protocols run between a customer C and a merchant M:
Establish({C(pp, TM, cskC )}, {M((pp, TC, cskM )}. On input public parameters and each of the initial channel tokens, the Establish protocol activates a channel
between two parties who have previously escrowed funds. If successful, the merchant receives established and the customer receives a wallet w. Either party may receive
the distinguished failure symbol ⊥.
Pay({C(pp, ϵ, wold)}, {M(pp, ϵ, Sold)}). On input parameters, a payment amount ϵ, and a wallet wold from a customer, and the merchant’s current state Sold (initially
∅) from the merchant: the customer receives a payment success bit RC and new wallet wnew if the interaction succeeded. The merchant receives a payment success bit RM
and an updated state Snew if the interaction succeeded.
Channel closure and dispute algorithms, run by the customer and merchant respectively:
Refund(pp, TM, cskC, w). On input a wallet w, outputs a customer channel closure message rcC.
Refute(pp, TC, S, rcC ). On input the merchant’s current state Sold and a customer channel closure message, outputs a merchant channel closure message rcM and an
updated merchant state Snew.
Dispute resolution algorithm, run by the network:
Resolve(pp, TC, TM, rcC, rcM ). On input the customer and merchant’s channel tokens TC, TM, along with closure messages rcC, rcM (where either message may be
null), this algorithm outputs the final channel balance B
merch
final , B
cust
final.
Figure 2: Definition of an Anonymous Payment Channel scheme.
Symmetric encryption schemes. Our constructions require an
efficient symmetric encryption scheme as well as a one-time symmetric encryption scheme. We define a symmetric encryption scheme
Πsymenc = (SymKeyGen, SymEnc, SymDec) where SymKeyGen
outputs an ℓ-bit key. We also make use of a one-time encryption
scheme Πotenc = (OTKeyGen, OTEnc, OTDec). In practice, the encryption scheme can be implemented by encoding the plaintext as
an element in a cyclic group G and multiplying by a random group
element. In either case, our constructions require that the schemes
provide IND-CPA security.
Pseudorandom Functions. Our unidirectional construction requires a pseudorandom function (PRF) F that supports efficient
proofs of knowledge. For our purposes it is sufficient that the PRF be
secure for a poly-size input space. In addition to the standard pseudorandomness property, ourprotocols require that the PRF should
also possess a property we refer to as strong pre-image resistance.
This property holds that, given access to an oracle implementing
the function Fs (·) for a random seed s, no adversary can find an
input point x and a pair (s
′
, x
′
) in the domain of the function such
that Fs (x) = Fs
′ (x
′
) except with negligible probability. We propose
to instantiate F using the Dodis-Yampolskiy PRF [31], the public
parameters are a group G of prime order q with generator д. The
seed is a random value s ∈ Zq and the function is computed as
fs (x) = д
1/(s+x )
for x in a polynomially-sized set. We show in
the full version of this paper [33] that the Dodis-Yampolskiy PRF
satisfies the strong pre-image resistance property.
Signatures with Efficient Protocols. Our schemes make use of
a signature scheme Πsig = (SigKeygen, Sign, Verify) with efficient
protocols, as proposed by Camenisch and Lysyanskaya [18]. These
schemes feature: (1) a protocol for a user to obtain a signature on
the value(s) in a commitment without the signer learning anything
about the message(s), and (2) a protocol for (non-interactively)
proving knowledge of a signature. Several instantiations of these
signatures have been proposed in the literature, including constructions based on the Strong RSA assumption [18] and various
assumptions in bilinear groups [8, 19]. For security, we assume that
all signatures satisfy the property of existential unforgeability under
chosen message attack (EU-CMA).
Non-Interactive Zero-Knowledge Proofs. We use several standard results for non-interactively proving statements about committed values, such as (1) a proof of knowledge of a committed value,
and (2) a proof that a committed value is in a range. When referring
to the proofs above, we will use the notation of Camenisch and
Stadler [22]. For instance, PoK{(x,r) : y = д
xh
r ∧ (1 ≤ x ≤ n)} denotes a zero-knowledge proof of knowledge of integers x and r such
that y = д
xh
r holds and 1 ≤ x ≤ n. All values not in enclosed in
()’s are assumed to be known to the verifier. Our protocols require a
proof system that provides simulation extractability, which implies
that there exists an efficient proof extractor that (under specific
circumstances, such as the use of a simulation CRS) can extract the
witness used by an adversary to construct a proof, even when the
adversary is also supplied with simulated proofs. In practice we can
conduct these proofs non-interactively using a variety of efficient
proof techniques [8, 12, 14, 16, 20, 27, 34, 35, 48].
4 PROTOCOLS
In this section we present our main contribution, which consists
of three protocols for implementing anonymous payment channels. Our first protocol in §4.1 is a unidirectional payment channel
based on e-cash techniques. Our second construction in §4.2 allows for bidirectional payments, with a more complex protocol
for handling aborts. Finally, in §4.3 we propose an approach for
third-party payments, in which two parties transmit payment via
an intermediary.
4.1 Unidirectional payment channels
Our first construction modifies the compact e-cash construction
of Camenisch et al. [17] to achieve efficient and succinct unidirectional payment channels. We now provide a brief overview of this
construction.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 479
Compact e-cash. In a compact e-cash scheme, a customer withdraws a fixed-size wallet capable of generating B coins. The customer’s wallet is based on a tuple (k,sk, B): k is an (interactively
generated) seed for a pseudorandom function F , sk is the customer’s
private key, and B is the number of coins in the wallet. Once signed
by the merchant, this wallet can be used to generate up to B coins
as follows: the i
th coin consists of a tuple (s,T, π ) where s is a
“serial number” computed as s = Fk
(i); T is a “double spend tag”
computed such that, if the same coin is spent twice, the double
spend tags can be combined to reveal the customer’s key pk (or sk);
and π is a non-interactive zero-knowledge proof of the following
statements:
(1) 0 < i ≤ B
(2) The prover knows sk.
(3) The prover has a signature on the wallet (k,sk, B).
(4) The pair (s,T ) is correctly structured with respect to the
signed wallet.
This construction ensures that double spending is immediately
detected by a verifier, since both transactions will share the serial
numbers.
7 The verifier can then recover the spender’s public key by
combining the double-spend tags. At the same time, the individual
coin spends cannot be linked to each other or to the user. Camenisch
et al. [17] show how to construct the proof π efficiently using
signatures and proof techniques secure under the Strong RSA or
bilinear assumptions in the random oracle model. Subsequent work
presents efficient proofs in the standard model [8, 9].
Achieving succinct closure. Let us recall our intuition for using
compact e-cash in a unidirectional payment channel (see §1.3). In
this proposal, the merchant plays the role of the bank and issues the
customer a wallet of B coins, which she can then (anonymously)
spend back to the merchant. To close a channel, the customer simply
spends any unused coins “to herself”, thus proving to the merchant
that she retains no spending capability on the channel (since any
subsequent attempt to spend those coins would be recognized by
the merchant as a double spend). Unfortunately while compact
e-cash provides a succinct wallet, this does not immediately lead
to a succinct protocol for closing the channel — as the customer
cannot simply reveal the wallet secrets without compromising the
anonymity of previous coins spent on the channel. We require a
mechanism to succinctly reveal only a fraction of the coins in a
wallet, without revealing them all. At the same time, we wish to
avoid complex proofs (e.g., a proving cost that scales with O(B)).8
Our approach is to use the merchant to store the necessary information to verify channel closure. This requires a number of changes
to the compact e-cash scheme of Camenisch et al. [17] (requiring
a fresh analysis of the scheme, which we provide in §4.1.1). First,
7
In the original compact e-cash construction [17], the key k was generated using an
interactive protocol between the customer and bank, such that honest behavior by
one party ensured that k was uniformly random. In our revised protocol below, k will
be chosen only by the customer. This does not enable double-spending, provided that
the PRF is deterministic and the proof system is sound.
8
Indeed, an alternative proposal is to construct the coin serial numbers using a chained
construction, where each si
is computed as a one-way hash of the key used in the
previous transaction. This would allow the customer to revoke the channel by posting
a secret from one transaction. Unfortunately, proving the correctness of si using
standard zero-knowledge techniques would then require O (B) proving cost, and
moreover, does not seem easy to accomplish using the efficient zero knowledge proof
techniques we recommend in this work.
we design the customer’s InitC algorithm so that the PRF seed k
is generated solely by the customer, rather than interactively by
the customer and the bank (merchant) as in [17]. The customer
now commits to the wallet secrets, producing wCom, and embeds
this into the customer’s channel token TC := (wCom, pkc
) where
pkc
is a signature verification key. During the Establish protocol
to obtaining the merchant’s signature on wCom, the customer provides the merchant with a series of signed ciphertexts (C1, . . . ,CB ),
each of which contains a coin spend tuple of the form (s,T, π
′
)
where π
′
is identical to the normal compact e-cash proof, but simply proves that s,T are correct with respect to wCom (which is
not yet signed by the merchant). These ciphertexts are structured
so that a key revealed for the j
th ciphertext will also open each
subsequent ciphertext.
The key feature of this approach is that the merchant does not
need to know if these ciphertexts truly contain valid proofs at the time
the channel is opened. To reveal the remaining j coins in a channel,
the customer reveals a key for the j
th ciphertext, which allows
the merchant to “unlock” all of the remaining coin spends and verify them with respect to the commitment wCom embedded in the
customer’s channel token. If any ciphertext fails to open, or if the
enclosed proof is not valid, the merchant can easily prove malfeasance by the customer and obtain the balance of the channel. This
requires only symmetric encryption and a means to “chain” symmetric encryption keys – both of which can easily be constructed
from standard building blocks.9 Our schemes additionally require
a one-time encryption algorithm OTEnc where the keyspace of the
algorithm is also the range of the pseudorandom function F .
We now present the full scheme:
Setup(1
λ
). On input λ, optionally generate CRS parameters
for (1) a secure commitment scheme and (2) a non-interactive
zero knowledge proof system. Output these as pp.
KeyGen(pp). Compute (pk,sk) ← Πsig.SigKeygen(1
λ
).
10
InitC (pp, B
cust
0
, B
merch
0
,pkc ,skc ). On input a keypair (pkc ,skc ),
uniformly sample two distinct PRF seeds k1, k2 and random coins
r for the commitment scheme. Compute wCom = Commit(skc ,
k1, k2, B
cust
0
;r). For i = 1 to B, sample cki ← SymKeyGen(1
λ
)
to form the vector ⃗ck. Output TC = (wCom,pkc ) and cskC =
(skc , k1, k2,r, B
cust
0
,
⃗ck).
InitM (pp, B
cust
0
, B
merch
0
,pkm,skm ). Output TM = pkm,cskM =
(skm, B
cust
0
).
Refund(pp, TM,cskC,w). Parsew (generated by the Establish
and Pay protocols) to obtain ⃗ck and the current coin index i.
Compute σ ← Sign(skc ,refund∥cID∥i ∥cki
) (where cID uniquely
identifies the channel being closed) and outputrcC := (cID,i,cki
, σ ).
Refute(pp, TC, S,rcC). Parse the customer’s channel closure
message rcC as (cID,i,cki
, σ ) and verify cID and the signature σ.
If the signature verifies, then obtain the ciphertexts Ci
, . . . ,CB
stored after the Establish protocol. For j = i to B, compute
(j ∥sj ∥uj ∥π
r
j
∥ckj ∥σˆj
) ← SymDec(ckj
,Cj
) and verify the signature σˆj and the proof π
r
j
. If (1) the signature σˆj or the proof π
r
j
fail
9
For example, the necessary properties can be achieved using a secure commitment
scheme and any secure symmetric encryption mechanism.
10For simplicity of exposition, we assume that pk can be derived from sk
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 480
to verify, (2) any ciphertext fails to decrypt correctly, or (3) any
of the decrypted values (sj
,uj
) match a valid spend containing
(sj
,tj
) in S where OTDec(uj
,tj
) = pkc : record the invalid result
into rcM along with cID and sign the result using skm so that it
can be verified by the network. Otherwise set rcM = (accept)
and sign with skm. Finally for each validCj
, set S ← S∪(sj
,tb
, π )
and output S as the new merchant state.
Resolve(pp, TC, TM,rcC,rcM). Parse the customer and merchant closure messages and verify all signatures. If any fail to
verify, grant the balance of the channel to the opposing party. If
rcC = (N,skN , σ ) and rcM = accept then set B
cust
final to (B
cust
0
−
N) + 1. Otherwise, evaluate the merchant closure message to
determine whether the customer misbehaved. If so, assign the
merchant the full balance of the channel.
We present the Establish and Pay protocols in Figure 3.
4.1.1 Security Analysis.
Theorem 4.1. The unidirectional channel scheme satisfies the
properties of anonymity and balance under the assumption that (1)
F is pseudorandom and provides strong pre-image resistance, (2)
the commitment scheme is secure, (3) the zero-knowledge system is
sound and zero-knowledge, (4) the signature scheme is existentially
unforgeable under chosen message attack and signature extraction
is blind, and (5) the symmetric encryption and one-time encryption
scheme are each IND-CPA secure.
A proof of Theorem 4.1 can be found in the full version of this
paper [33].
4.2 Bidirectional payment channels
The key limitation of the above construction is that it is unidirectional, and only supports payments from a customer to a merchant.
Additionally, it supports only fixed-value coins. In this section we
describe a construction that enables bidirectional payment channels
which feature compact closure, compact wallets, and allow a single
run of the Pay protocol to transfer arbitrary values (constrained by
a maximum payment amount).
In this construction the customer’s wallet is structured similarly
to the previous construction: it consists of B
cust
0
, and a random wallet public signature key wpk. The customer first commits to these
values and sends the resulting commitment to the payment network.
The wallet is activated when the customer and merchant interact
to provide the customer with a blind signature on its contents.
The key difference from the first protocol is that, instead of
conducting the payment ϵ using a series of individual coins, each
payment has the customer (1) prove that it has a valid signed wallet
with balance B
cust ≥ ϵ of currency in it, and (2) request a blind
signature on a new wallet for the amount B
cust −ϵ (and embedding
a fresh wallet public key wpknew). Notice that in this construction
the value ϵ can be positive or negative. The customer uses a zero
knowledge proof and signatures with efficient protocols to prove
that the contents of the new requested wallet are constructed properly, that the balances of the new wallet differs from the original
balance by ϵ, and that (B
cust − ϵ ) ≥ 0. At the conclusion of the
transaction, the customer reveals wpkold to assure the merchant
that this wallet cannot be spent a second time, and the old wallet
is invalidated by the customer signing a “revoked” message with
wsk the corresponding private key. Closing the channel consists
of the customer posting a valid wallet signed by the merchant to
the blockchain.11 The challenge in this construction is to simultaneously invalidate the existing wallet and sign the new one. If the
merchant signs the new wallet before the old wallet is invalidated,
then the customer can retain funds in the old wallet while continuing to use the new one. On the other hand, if the merchant can
invalidate the old wallet before signing the new one, the customer
has no way to close the channel if the merchant refuses to sign the
new wallet.
To solve this, we separate the wallet — used in interactive payments — from the value that is posted to perform channel closure
and use a two phase protocol to obtain each of these values. Instead
of revealing the most recent wallet w, C closes the channel using a
refund token rt which specifies B
cust, the current wallet’s public key,
and a signature by the merchant. In phase one of Pay, the customer
first obtains a signature on the refund token blindly from M. In the
second phase, the customer invalidates the old wallet, and then the
merchant signs the new wallet. If the merchant refuses to sign the
new wallet, the customer can safely close the channel using rt.
We now describe the revised scheme. The protocols Establish
and Pay are presented in Figure 4. The Setup and InitM algorithms
are identical to the previous construction.
• KeyGen(pp). Compute (pk,sk) ← Πsig.SigKeygen(1
λ
).
• InitC (pp, cID, B
cust
0
, B
merch
0
,pkc ,skc ). The customer generates the wallet commitment by sampling random coins r,
computing an ephemeral keypair (wpk,wsk) ← KeyGen(pp)
and producing a commitment wCom = Commit(cID,wpk, B
cust
0
;r).
It outputs the token TC = (pkc , wCom) and retains the secrets cskC = (wCom,skc , cID,wpk,wsk,r, B
cust
0
).
• InitM (pp, B
cust
0
, B
merch
0
,pkm,skm ). Output TM = pkm,cskM =
(skm, B
cust
0
).
• Refund(pp, TM,cskC,w). If the customer has not yet invoked the Pay protocol, it setsm := (refundUnsigned, (cID,wpk,
B),r). Otherwise set m := (refundToken, (cID,wpk, B),rtw ).
Compute σ = Sign(skc ,m). Output rcC = (m, σ ).
• Refute(pp, TC, S,rcC). If a merchant sees a channel closure
message, it first parses TC to obtain pkc . It parses rcC as
(m, σ ) and verifies the signature σ using pkc . If this signature verifies, it parses m to obtain (cID,wpk, B) and verifies that cID matches the channel. Finally, if it has previously stored (wpk, σr ev ) in its state S then it outputs rcM =
((revoked, σr ev ), σ ) where σ is a valid signature on the message (revoked, σr ev ) under skm. Otherwise it adds the new
key wpk to its state S.
• Resolve(pp, TC, TM,rcC,rcM).
Verify that both rcC,rcM are correctly signed by the customer and merchant keys pkc and pkm respectively. Verify
that both tokens contain the same cID and this matches the
channel identifier from TC, TM. If either of the tokens fails
this test, replace it with ⊥. Let Btotal = B
cust
0
+B
merch
0
. If rcC
is ⊥, simply output all funds to the merchant.
11In the special case where the customer has not obtained a signature on the wallet
from the merchant (e.g., because the merchant never accepted the channel opening), it
can simply post an opening of the wallet commitment.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 481
Customer(pp, TM, cskC ) Establish Merchant(pp, TC, cskM)
(1) Parse cskC as (pkc, skc, k1, k2, r, B). Sample sk0 ∈ {0, 1}
ℓ
.
(2) Generate a proof π1 that
PK {(skc, k1, k2, r) : wCom = Commit(skc, k1, k2;r)
∧ (pkc, skc ) ∈ KeyGen(1
λ
)}
(3) For j = 1 to B:
(a) Compute sj ← Fk1
(j), uj ← Fk2
(j), π
r
j where
π
r
j = PK {(skc, k1, k2, r) : s = Fk1
(j) ∧ u = Fk2
(j)
∧ wCom = Commit(skc, k1, k2;r)
∧ (pkc, skc ) ∈ KeyGen(1
λ
)}
(b) Compute an internal signature σˆj = Sign(skc, spend∥j ∥sj ∥uj ∥π
r
j
∥ckj+1 ).
(c) Compute Cj = SymEnc(ckj
, j ∥sj ∥uj ∥π
r
j
∥σˆj ∥ckj+1 ) and an external signature σj = Sign(skc, coin∥j ∥Cj
).
wCom, π
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→ (C1
,σ1
, . . .,CB,σB )
σw ←−−−−−−−−−−−−−−−−−−−−−→
Verify the signature on TC, and check that B
cust
0
= B. Verify π1 and for i = 1 to B, verify the signature σj on Cj
. If any
check fails, abort and output ⊥. Otherwise, interact with the customer to provide a blind signature σw on the contents of
wCom.
Return w = (sk0, skc, k1, k2, r, B, σw, 1). Return established.
Customer(pp, ϵ, wold) Pay Merchant(pp, ϵ, Sold)
(1) Parse wold as (sk0, skc, k1, k2, r, B, σw, i). Abort if i ≥ B.
(2) Compute s ← Fk1
(i), t ← OTEnc(Fk2
(i), pkc ), and a proof:
π = PK {(pkc, skc, k1, k2, r, i, σw ) : s = Fk1
(i) ∧ 0 < i ≤ B
∧ t = OTEnc(Fk2
(i), pkc )
∧ Verify(pkm, (k1, k2, skc ), σw )
∧ (pkc, skc ) ∈ KeyGen(pp) }
(s, t, π )
−−−−−−−−−−−−−−−→
Verify π and that (s, ·, ·) < S. If so, set S ← S ∪ (s, t, π ) and set RM ← 1 , else set RM ← ⊥.
Return wnew := (sk0, skc, k1, k2, r, B, σw, i + 1). Return RM.
Figure 3: Establishment and Payment protocols for the Unidirectional Payment Channel scheme.
(1) Parse TC to obtain (pkc , wCom).
(2) Parse m as (type, (cID,wpk, B), Token).
(3) Parse m as (revoked,wpk, σr ev ). Check that Verify(wpk,
(revoke∥cID∥wpk)σ ) = 1. If any check fails, terminate
and output B
cust
final = Btotal and B
merch
final = 0.
(4) Perform the following checks:
(a) Check the refund’s validity: If type is refundUnsigned,
check that wCom = Commit(cID,wpk, B, Token). If the
merchant’s token contains σr ev
Otherwise type is refundToken, so check that Token is a
valid refund token on (cID,wpk, B). If either check fails,
terminate and output B
cust
final = 0 and B
merch
final = Btotal.
(b) Check the refutation’s validity: and check Verify(wpk,
revoke∥wpk, σr ev ) = 1. If so, terminate and output
B
cust
final = 0 and B
merch
final = Btotal. Otherwise return B
cust
final =
B and B
merch
final = Btotal − B (i.e. pay the claimed B to C
and the remainder to M).
4.2.1 Security Analysis. In §1.3 we noted a main limitation of
the bidirectional protocol, namely the possibility that a malicious
merchant may abort the protocol. As discussed in that section, this
provides only limited advantage to an adversary. Within the context
of our security proof we address this in a simpler way, by simply
preventing the adversarial merchant from aborting during the Pay
protocol.
Theorem 4.2. The bidirectional channel scheme satisfies the properties of anonymity and balance under the restriction that the adversary does not abort during the Pay protocol, and the assumption that
(1) the commitment scheme is secure, (2) the zero-knowledge system
is simulation extractable and zero-knowledge, (3) the blind signature
scheme is existentially unforgeable under chosen message attack, and
(4) the one time signature scheme is existentially unforgeable under
one time chosen message attack.
We sketch a proof of Theorem 4.2 in the full version of this paper [33].
4.3 Bidirectional Third Party Payments
One of the main applications of the bidirectional construction above
is to enable third party payments. In these payments, a first party A
makes a payment of some positive value to a second party B via
some intermediary I with whom both A and B have open channels.
In this case, we assume that both A and B act as the customer for
channel establishment, and I plays the role of the merchant. Our
goal is that I does not learn the identities of the participants, or the
amount being transferred (outside of side information she can learn
from her channel state), nor should she trusted to safeguard the
participants’ funds. This construction stands in contrast to existing
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 482
Customer(pp, TM, cskC ) Establish Merchant(pp, TC, cskM )
(1) Parse cskC to obtain (cID, wCom, wpk, wsk, r, B
cust
0
).
(2) Generate a proof π1 of the following statement:
π1 = PK {(wpk, wsk, r) : wCom = Commit(cID, wpk, B
cust
0
;r)
∧ (wpk, wsk) ∈ KeyGen(pp)}
π1
−−−−−−−−−−−−−−−−−−−−→
σw ←−−−−−−−−−−−−−−−−−−−−−→
Parse TC to obtain B
cust
0
, wCom. Verify that the proof π1 is valid. If not, output ⊥, If the proof is valid: interact with the
customer to provide a blind signature σw under skm on the contents of wCom.
Return w := (B
cust
0
, wpk, wsk, r, σw ). Return established.
Customer(pp, ϵ, wold) Pay Merchant(pp, ϵ, Sold)
(1) Parse wold as (cID, B, wpk, wsk, r, σw ).
(2) Sample (wpk′
, wsk′
) ← KeyGen(pp) and sample random coins r
′
.
(3) Generate wCom′ ← Commit(cID, wpk′
, B − ϵ;r
′
) and formulate the proof:
π2 = PK {(wpk′
, B, r
′
, σw ) : wCom′ = Commit(cID, wpk′
, B − ϵ;r
′
)
∧ Verify(pkm, (wpk, B), σw ) = 1
∧ 0 ≤ (B − ϵ ) ≤ valmax }
ϵ, wCom′
, wpk, π2
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
r tw′
←−−−−−−−−−−−−−−−−−−−−−→
Verify π2, ensure that (wpk, ·) < S and ϵmin ≤ ϵ ≤ ϵmax. If these conditions do not hold, abort and output ⊥. Otherwise set
Snew := Sold ∪ {(wpk, ⊥)}. If ϵ < 0, RM ← 1 otherwise RM ← ⊥. Interact with the customer to provide a partially blind
signature r tw′ under skm on the message (refund∥wpk′
∥B − ϵ ), where wpk′
and B − ϵ are the contents of wCom′
.
Compute Verify(pkm, r tw′, refund∥wpk′
∥B − ϵ ). If verification fails, or if this message does not arrive, abort and output
r tw′. Else compute σr ev = Sign(wsk, revoke∥cID∥wpk).
σr ev
−−−−−−−−−−−−−−−−−−−−−−−−→
σw′
←−−−−−−−−−−−−−−−−−−−−−→
Ensure Verify(wpk, revoke∥wpk, σr ev ) = 1. If so, set Snew := Sold ∪ {(wpk, σr ev )} and RM ← 1. Generate a blind
signature σw′ on the contents of wCom′ using skm. If this completes, set RM ← 2
return wnew := (B − ϵ, wpk′
, wsk′
, r
′
, σw′ ) return Snew, RM
Figure 4: Establishment and Payment protocols for the Bidirectional Payment Channel scheme
non-anonymous payment channel schemes [30, 45] where given
the chain A → I → B, the intermediary always learns both the
amount and the participants.
The challenge in chaining payment channels is to make the
payments atomic. That is, the payer A only wants to pay the intermediary I once I has paid the recipient B. But of course this places
the intermediary at risk if A fails to complete the payment. Similarly, the payer risks losing her funds to a dishonest intermediary.
There is no purely cryptographic solution to this problem, since
it’s in essence fair exchange — a problem that has been studied
extensively in multi-party protocols. However, there are known
techniques for using blockchains to mediate aborts [5, 10]. This is
our approach as well.
Recall from §4.2 that the Pay protocol occurs in two phases. The
first portion is an exchange of refund tokens that can be used to
reclaim escrowed funds. The second phase generates an anonymous
wallet for subsequent payments. For a chained transaction from
A → I → B to be secure, we need only ensure that the first phase
of both legs completes or fails atomically.
We accomplish this by adding conditions to the refund tokens.
These conditions are simple statements for the network to evaluate
on examining a token during the Resolve protocol. Specifically, to
prevent the recipient B from claiming funds from I if the payer A
has not delivered a corresponding payment to I, we introduce the
following conditions into B’s refund token:
(1) B must produce a revocation message (i.e. a signature using
A’s wsk) on A’s previous wallet.
(2) A has not posted a revocation token containing wsk to the
ledger.
By condition (1), once B forces a payment on I → B, A → I cannot
be reversed since I has the revocation token. By condition (2) if
A → I has been already been reversed, B cannot force the payment
I → B since wpk is already on the ledger.
Hiding the payment amount. Our third-party payment construction also provides an additional useful feature. Since I acts only a
passive participant in the transaction and does not maintain state
for either channel, there is no need for for I to learn the amount
being paid. Provided that both A and B agree on an amount ϵ (i.e.,
both parties have sufficient funds in each of their channels), neither
party need reveal ϵ to I: I need merely be assured that the balance
of funds is conserved.
To hide the payment amount, we must modify the proof statement used to construct π2 from the Pay protocol of Figure 4. Rather
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 483
A I B
commitment to a new wallet and a proof πB that the updated balance is greater by ϵ
Step 1
commitment to ϵ, A & B’s new wallet commitments, proofs πA, πB
Step 2
refund token for A, conditional refund token for B
Step 3
revocation token for A, conditional refund token for B
Step 4
revocation tokens for A & B’s old wallets Step 5
signature for A’s new wallet signature for B’s new wallet
Step 6
Figure 5: Outline of our third-party payments protocol. In practice, A can route all messages from B to I.
than revealing ϵ to the merchant, the customer A now commits to
ϵ and uses this value as a secret input in computing the payment.
Simultaneously, in the payment protocol conducted to adjust B’s
wallet, B now proves that his wallet has been adjusted by −ϵ.
To do this, we change the proof in the pay protocol to one that
binds ϵ to a commitment but does not reveal it:
π2 = PK{(wpk′
,B,r
′
, σw , ϵ,rϵ ) :
wCom′ = Commit(wpk′
, B − ϵ;r
′
)
∧ Verify(pkm, (wpk, B), σw ) = 1
∧ vCom = Commit(ϵ,rϵ )
∧ 0 ≤ (B − ϵ ) ≤ valmax }
A can then prove to I that the two payments cancel or (if f ee is
non-zero), leave B with f ee extra funds via a proof:
πϵ = PK{(ϵA, ϵB,rϵA
,rϵB
) :vComϵA = Commit(ϵA;rϵA
)
∧vComϵB = Commit(ϵB;rϵB
)
∧ϵA < ϵmax ∧ −ϵB < ϵmax
∧ϵA + ϵB = f ee
The protocol. We now combine the process of updating both A
and B’s wallet into a single protocol flow, which we outline in
Figure 5. In detail, the steps are as follows:
(1) B commits to ϵ and conducts the first move of the variable
payment Pay protocol (Figure 4) (with the modified balancehiding proof described above) and sends a commitment to its
new wallet state wCom′
b
, proof of correctness for the wallet,
πB, and commitment randomness to A.
(2) A completes it’s own first move, generating wCom′
a
, πA and
additionally computes πA attesting to the correct state of its
original wallet and new wallet commitment. It sends these
and B’s new wallet commitment and πA to I.
(3) I, after validating the proofs, issues A a refund token for its
new wallet rtw′
a
and B a conditional refund token crtσ
wa
r ev
w′
b
as its new wallet. This token embeds the condition that B
must produce a revocation token for A’s old wallet and that
A must not have closed the channel already.
(4) A completes its second move in the variable payment Pay
protocol to generate σ
wa
r ev the revocation token for its old
wallet. It sends that and the crtσ
wa
r ev
w′
b
to B.
(5) B completes its second move to generate σ
wb
r ev the revocation
token for its old wallet. After validating that it now has a
valid refund token by verifying σ
wa
r ev , it sends σ
wa
r ev , σ
wb
r ev to
I.
(6) I completes the remaining moves of the variable payment
Pay protocol with A and B individually, giving each a blind
signature on their new wallets.
Security and abort conditions. We provide a proof sketch for
balance preservation in the full version of the paper [33].
In terms of anonymity, the execution of this protocol is no different in terms of the information revealed than two in parallel
payments from A → I and I → B. Our payment anonymity definition already allows this type of attack even for the two party
case.
The main challenge in realizing this construction is the possibility that a malicious I can selectively abort the protocol during a
transaction. This does not allow I to steal funds, but it does force
A and B to transmit messages to the network in order to recover
their funds. This potentially links the payment attempt to A and
B’s channels. Unfortunately, this seems fundamentally difficult to
avoid in an interactive protocol.
We note that the anonymity threat is limited in practice by the
fact that the channels themselves can be funded with an anonymous
currency (e.g., [29, 41, 47]), so linking two separate channels does
not reveal the participant identifiers. More importantly, since the
intermediary can use this abort technique only one time during the
lifetime of a channel, there is no possibility for the merchant to link
separate payments on the same channel. Finally, an intermediary
who performs this abort technique will produce public evidence
on the network, which allows participants to avoid the malicious
intermediary.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 484
4.4 From Third Party Payments to Payment
Networks
It should be possible to extend the above protocol to allow payments
of the form A → I1 → . . . → In → B via techniques similar to
those used in non-anonymous payment channel networks [45]. As
discussed in §1.2, it is not possible to hide channel balances in such
a setting. The general approach is as follows: we use “hash locks”
to enforce that either all refund and revocation tokens are valid or
none are. Specifically, we attach to both the fund and revocation
tokens a condition that they can only be used if one party reveals
x such that y = H (x), where x is picked by A. Because if one
party releases x, all parties may close their channels, this forces the
entire sequence of payments to either go through or not. As with
Lightning, the timeouts for each channel must be carefully chosen.
We leave the exact details of this approach to future work.
4.5 Hiding Channel Balances
Each of the constructions presented above has a privacy limitation:
the balance of each payment channel is revealed when a channel
is closed. While individuals can protect their identities and initial
channel balances by using an anonymous currency mechanism
to fund channels, the information about channel balances leaks
useful information to the network. We note, however, that in the
case of non-disputed channel closure, even this information can be
hidden from the public as follows. On channel closure, the customer
posts a commitment to the final channel balance, along with a
zero-knowledge proof that she possesses a valid channel closure
token (ı.e., a signature on the channel balance in our bidirectional
construction). In systems such as Zerocash [47], the final payment
redeeming coins to the merchant and customer can be modified to
include an additional statement: the amounts paid in this transaction
are consistent with the commitment, and do not exceed the initial
funding transaction that created the channel. We leave the precise
details of such a construction to future work.
5 IMPLEMENTATION OF THE
BIDIRECTIONAL SCHEME
We now detail the integration of Bolt into a cryptocurrency and
performance and cryptographic details of a concrete instantiation.
5.1 Integration with a Currency
In this section we consider the problem of integrating the bidirectional Bolt protocol into a Bitcoin like cryptocurrency in a soft fork: a
protocol change which does not break backward compatibility with
existing nodes. Recall that the bidirectional scheme requires that the
channels be funded anonymously in order to protect against aborts
linking the aborted payment to the channel opening (this does not
hold if one wishes merely to prevent multiple payments on the
same channel from being linked together). In these conditions, the
anonymity of the payment channel is no better than the anonymity
of the underlying cryptocurrency. Of the Bitcoin derived currencies,
Zerocash and ZCash [3, 47] provide a strong underlying anonymity
layer. Anonymity tools for Bitcoin, such as Coinjoin [39], may also
be sufficient in some circumstances and future improvements to
Bitcoin may increase the achievable anonymity. The mechanism
for deployment is compatible with either currency.
In Bitcoin and ZCash each transaction12 consists of a set of
inputs and a set of outputs. Inputs reference a previous transaction output and contain a ScriptSig authorizing use of the funds.
Outputs specify the amount of the output and a ScriptPubKey
specifying when the output can be spent. To evaluate a transaction
the ScriptPubKey from the previous transaction and ScriptSig
from the current transaction are combined and evaluated using a
stack-based scripting language. In the simplest case, ScriptPubKey
requires a signature under a specified public key to spend the funds
and ScriptSig contains such a signature. However, more complex
scripts are allowed including control flow such as if statements,
time locks that enforce that a given number of blocks has elapsed
since the transaction was created, and threshold signatures. As long
as the combined script evaluates to True, spending is authorized.
Our soft fork approach involves adding a single opcode, OP_BOLT
to the scripting language. This opcode has the power to (1) validate
the commitment opening and blind signature on the commitment
in a refund token, and (2) inspect the output of the transaction and
enforce restrictions on it.
Most opcodes do not inspect transaction outputs. The notable
exception to this rule are signature opcodes that may hash the
entire transaction, including both inputs and outputs, in order to
verify the signature. However, it is entirely possible to modify the
ZCash and Bitcoin codebase to enable opcodes that do have access
to transaction outputs in general.13 Specifically, our new opcode
will enforce two constraints on the outputs of a transaction closing
the channel:
(1) Verifying that there are two outputs: one paying the merchant his balance and the other paying the customer hers.
(2) Verifying that the customer’s payout is time locked such that
it can be claimed by the merchant if the refund token has
been invalidated (i.e. the customer tried to close on an old
channel state).
To accomplish this, we implement the Pay protocol so that the
revocation token is the private key corresponding to a Bitcoin
(resp. transparent ZCash) address. When a channel is closed, the
merchant’s fraction of the channel balance is paid in a transaction
that is spendable immediately. However, the customer’s funds are
not immediately spendable by the customer since we need to allow
the merchant to dispute the closure. The merchant does this by
signing a transaction with both his key and the revocation token
key. If the merchant does not do so, the customer can claim the
funds after some elapsed time. The script is given below:
OP_IF # I f me rchan t
OP_2 < rev −pubkey ><merchan t −pubkey > OP_2
OP_CHECKMULTISIG #2 o f 2 m ul ti −s i g c he c k
OP_ELSE # I f c u s t om e r w ai t
< d el a y > # d e l a y t o w ai t
12We refer here to the “unshielded” transactions in ZCash. Shielded transactions
function differently.
13In systems derived from Bitcoin core’s source code, this requires some modification
as the current architecture abstraction in script evaluation provides a callback to get
the transaction hash, not direct access to the transaction itself. However this is not a
protocol limitation and indeed past versions of the codebase did expose direct access.
Exposing direct access does not affect consensus rules in and of itself.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 485
Customer Merchant
primitive Establish(ms) Pay(ms) Setup(ms) Establish(ms) Pay(ms)
Bilinear CL-Sigs[19] 8.07 ± 0.13 100.13 ± 1.60 1433.51 ± 23.69 15.87 ± 0.27 82.32 ± 1.37
Algebraic MACs[24] 6.90 ± 0.17 37.61 ± 0.93 826.78 ± 19.26 11.97 ± 0.31 34.39 ± 0.88
Figure 6: Performance comparison of different implementations of BOLT bidirectional payment protocol. 1000 iterations on
a single core of a Intel(R) Xeon(R) CPU E5-2695 v4 @ 2.10GHz. Customer setup is included in Establish.
OP_CSV # Timel o c k e n f o r c e s d e l a y
OP_DROP
< cu s t ome r −pubkey > # key f o r c u s t om e r s f u n d s
OP_CHECKSIG
OP_ENDIF
This approach greatly simplifies the implementation. Channel opening consists of posting a transaction with (previously anonymized)
inputs containing the needed funds for escrow and a single output.
This outputs ScriptPubKey contains the new opcode OP_BOLT and
the channel parameters as one argument. To close the channel, the
customer posts the appropriate transaction spending that output
with a ScriptSig that contains what is required to satisfy OP_BOLT:
the refund token and two outputs. One output for the merchant’s
share of the channel which is spendable immediately and one with
the customer’s spendable under the above time locked script. Finally, each party can post the appropriate transaction claiming their
output. The merchant can dispute the channel closure and claim
the funds immediately with OP_FALSE <sig revocation-pubkey>
<sig merchant-pubkey>. On the other hand, the customer must
wait and then claim with OP_TRUE <sig customer-pubkey>.
Simplified resolution. At the cost of an extra round trip in the Pay
protocol, we can eliminate the need to validate “blind” signatures in
the resolution phase, instead opting to verify a simple commitment
opening and a standard (e.g. ECDSA) signature on that commitment.
We do this by having the refund token consist of a standard signature on the wallet commitment. Because it is a standard signature,
refund token issuance can be linked to usage. This is not a problem
if the token is used to handle an abort in the same protocol run as
its issuance—our security model assumes the attacker can link a
single transaction to channel open/closure. However, it cannot be
safely used after that, i.e. in the first step of the next pay protocol,
because the unblinded signature will link the current execution of
the protocol to the previous one. To solve this, at the start of every
run of the pay protocol, we request a fresh refund token on the
current wallet before revealing anything. Because the contents of
the refund token commitment are deterministically and provably
generated from the existing wallet, issuing multiple of them has
no other effect. However, it eliminates the need to ever use the old
refund token. The only consequence is an additional round trip as
we must wait for the refreshed refund token before we can publish.
5.2 Implementation
We provide two constructions of Bolt, one using signatures with efficient protocols [19] and the other using using Algebraic MACs [24].
We defer further discussion of primitive selection and usage to
Appendix A and move directly to presenting performance numbers
in Figure 6.
6 RELATED WORK
Anonymity and scaling for Bitcoin. A number of works have
proposed additional privacy protections for Bitcoin. Zerocoin, Zerocash and similar works [41, 47] provide strong anonymity through
the use of complex zero knowledge proofs. A separate line of works
seek to increase anonymity by Bitcoin by mixing transactions
(e.g. CoinJoin [39], CoinShuffle, CoinSwap). Like Bitcoin, each of
these constructions require that all transactions are stored on the
blockchain. Finally, recent work has proposed probabilistic payments as an alternative payment mechanism [43].
Privacy in payment channels As discussed in detail in the introduction, Heilman et al. [37] construct off-chain payments with 3rd
party privacy.
Lightning anonymity limitations. The Lightning Network [45]
does not provide payment anonymity between pairs of channel
participants – i.e., a merchant can see the channel identity of every
customer that initiates a payment. However, the protocol includes
some limited anonymity protections for path payments. These operate on a principle similar to an onion routing network, by using
multiple non-colluding intermediaries to obscure the origin and
destination of a path. Unfortunately this proposal suffers from collusion problems: given the chain A → I1 → I2 → I3 → B, only I1
and I3 must collude to recover the identities of A and B, since all
transactions on the path share the same Hash Timelock Contract ID.
Moreover, this security mechanism assumes there exist a network
with sufficient path diversity for these protections to be viable.