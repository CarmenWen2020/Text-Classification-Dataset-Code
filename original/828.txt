Permissionless blockchains protocols such as Bitcoin are inherently
limited in transaction throughput and latency. Current efforts to
address this key issue focus on off-chain payment channels that
can be combined in a Payment-Channel Network (PCN) to enable
an unlimited number of payments without requiring to access the
blockchain other than to register the initial and final capacity of
each channel. While this approach paves the way for low latency
and high throughput of payments, its deployment in practice raises
several privacy concerns as well as technical challenges related to
the inherently concurrent nature of payments that have not been
sufficiently studied so far.
In this work, we lay the foundations for privacy and concurrency in PCNs, presenting a formal definition in the Universal
Composability framework as well as practical and provably secure solutions. In particular, we present Fulgor and Rayo. Fulgor
is the first payment protocol for PCNs that provides provable privacy guarantees for PCNs and is fully compatible with the Bitcoin
scripting system. However, Fulgor is a blocking protocol and therefore prone to deadlocks of concurrent payments as in currently
available PCNs. Instead, Rayo is the first protocol for PCNs that
enforces non-blocking progress (i.e., at least one of the concurrent
payments terminates). We show through a new impossibility result that non-blocking progress necessarily comes at the cost of
weaker privacy. At the core of Fulgor and Rayo is Multi-Hop HTLC,
a new smart contract, compatible with the Bitcoin scripting system,
that provides conditional payments while reducing running time
and communication overhead with respect to previous approaches.
Our performance evaluation of Fulgor and Rayo shows that a payment with 10 intermediate users takes as few as 5 seconds, thereby
demonstrating their feasibility to be deployed in practice.
CCS CONCEPTS
• Security and privacy → Security requirements; Distributed systems security; Privacy protections;
KEYWORDS
Payment-Channel Network; Bitcoin; Scalability; Privacy; Concurrency
1 INTRODUCTION
Bitcoin [57] is a fully decentralized digital cryptocurrency network
that is widely adopted today as an alternative monetary payment
system. Instead of accounting payments in a ledger locally maintained by a trusted financial institute, these are logged in the Bitcoin
blockchain, a database replicated among mutually distrusted users
around the world who update it by means of a global consensus
algorithm based on proof-of-work. Nevertheless, the permissionless
nature of this consensus algorithm limits the transaction rate to tens
of transactions per second whereas other payment networks such
as Visa support peaks of up to 47,000 transactions per second [18].
In the forethought of a growing number of Bitcoin users and most
importantly payments about them, scalability is considered today
an important concern among the Bitcoin community [3, 67]. Several
research and industry efforts are dedicated today to overcome this
important burden [2–4, 32, 60, 62].
The use of Bitcoin payment channels [6, 32] to realize off-chain
payments has flourished as a promising approach to overcome
the Bitcoin scalability issue. In a nutshell, a pair of users open a
payment channel by adding a single transaction to the blockchain
where they lock their bitcoins in a deposit secured by a Bitcoin
smart contract. Several off-chain payments can be then performed
by locally agreeing on the new distribution of the deposit balance.
Finally, the users sharing the payment channel perform another
Bitcoin transaction to add the final balances in the blockchain,
effectively closing the payment channel.
In this manner, the blockchain is required to open and close a
payment channel but not for any of the (possibly many) payments
between users, thereby reducing the load on the blockchain and
improving the transaction throughput. However, this simple approach is limited to direct payments between two users sharing an
open channel. Interestingly, it is in principle possible to leverage a
path of opened payment channels from the sender to the receiver
with enough capacity to settle their payments, effectively creating
a payment-channel network (PCN) [60].
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 455
Many challenges must be overcome so that such a PCN caters a
wide deployment with a growing number of users and payments.
In particular, today we know from similar payment systems such
as credit networks [15, 17, 36, 37] that a fully-fledged PCN must
offer a solution to several issues, such as liquidity [29, 55], network
formation [30], routing scalability [61, 71], concurrency [49], and
privacy [49, 54, 56] among others.
The Bitcoin community has started to identify these challenges [3,
22, 40, 41, 43, 47, 48, 67]. Nevertheless, current PCNs are still immature and these challenges require to be thoroughly studied. In this
work, we lay the foundations for privacy and concurrency in PCNs.
Interestingly, we show that these two properties are connected
to each other and that there exists an inherent trade-off between
them.
The Privacy Challenge. It seems that payment channels necessarily improve the privacy of Bitcoin payments as they are no longer
logged in the blockchain. However, such pervading idea has started
to be questioned by the community and it is not clear at this point
whether a PCN can offer sufficient privacy guarantees [22, 43, 68].
Recent research works [40, 41, 47] propose privacy preserving protocols for payment hub networks, where all users perform off-chain
payments through a unique intermediary. Unfortunately, it is not
clear how to extend these solutions to multi-hop PCNs.
Currently, there exist some efforts in order to define a fullyfledged PCN [10, 13, 19, 60]. Among them, the Lightning Network [60] has emerged as the most prominent PCN among the
Bitcoin community [1]. However, its current operations do not provide all the privacy guarantees of interest in a PCN. For instance, the
computation of the maximum possible value to be routed through
a payment path requires that intermediate users reveal the current
capacity of their payment channels to the sender [62, Section 3.6],
thereby leaking sensitive information. Additionally, the Bitcoin
smart-contract used in the Lightning Network to enforce atomicity
of updates for payment channels included in the payment path,
requires to reveal a common hash value among each user in the
path that can be used by intermediate users to derive who is paying
to whom [60]. As a matter of fact, while a plethora of academic papers have studied the privacy guarantees offered by current Bitcoin
payments on the Bitcoin blockchain [21, 25, 45, 51, 52, 64, 66], there
exists at present no rigorous analysis of the privacy guarantees
offered by or desirable in PCNs. The lack of rigorous definitions for
their protocols, threat model and privacy notions, hinders a formal
security and privacy analysis of ongoing attempts, let alone the
development of provably secure and privacy-preserving solutions.
The Concurrency Challenge. The consensus algorithm, e.g.,
proof-of work in Bitcoin, eases the serialization of concurrent onchain payments. A miner with access to all concurrent payments at
a given time can easily serialize them following a set of predefined
rules (e.g., sort them by payment fee) before they are added to the
blockchain. However, this is no longer the case in a PCN: The bulk
of off-chain payments are not added to the blockchain and they
cannot be serialized during consensus. Moreover, individual users
cannot avoid concurrency issues easily either as a payment might
involve several other users apart from payer and payee.
In current PCNs such as the Lightning Network, a payment is
aborted as soon as a payment channel in the path does not have
enough capacity (possibly allocated for another in-flight payment
concurrently). This, however, leads to deadlock (and starvation)
situations where none of the in-flight payments terminates. In summary, although concurrent payments are likely to happen when
current PCNs scale to a large number of users and off-chain payments, the inherent concurrency issues have not been thoroughly
investigated yet.
Our Contribution. This work makes the following contributions:
First, we formalize for the first time the security and privacy
notions of interest for a PCN, namely balance security, value privacy
and sender/receiver anonymity, following the universal composability (UC) framework [27].
Second, we study for the first time the concurrency issues in
PCNs and present two protocols Fulgor and Rayo that tackle this
issue with different strategies. Fulgor is a blocking protocol in line
with concurrency solutions proposed in somewhat similar payment
networks such as credit networks [15, 49] that can lead to deadlocks
where none of the concurrent payments go through. Overcoming
this challenge, Rayo is the first protocol for PCNs guaranteeing
non-blocking progress [20, 42]. In doing so, Rayo ensures that at
least one of the concurrent payments terminates.
Third, we characterize an arguably surprising tradeoff between
privacy and concurrency in PCNs. In particular, we demonstrate
that any PCN that enforces non-blocking progress inevitably reduces the anonymity set for sender and receiver of a payment,
thereby weakening the privacy guarantees.
Fourth, we formally describe the Multi-Hop Hash Time-Lock
Contract (Multi-Hop HTLC), a smart contract that lies at the core of
Fulgor and Rayo and which, in contrast to the Lightning Network,
ensures privacy properties even against users in the payment path
from payer to payee. We formally define the Multi-Hop HTLC
contract and provide an efficient instantiation based on the recently
proposed zero-knowledge proof system ZK-Boo [38], that improves
on previous proposals [69] by reducing the data required from 650
MB to 17 MB, the running time for the prover from 600 ms to 309 ms
and the running time for verifying from 500 ms to 130 ms. Moreover,
Multi-Hop HTLC does not require changes to the current Bitcoin
scripting system, can thereby be seamlessly deployed in current
PCNs, and is thus of independent interest.
Finally, we have implemented a prototype of Fulgor and Rayo in
Python and evaluated the running time and communication cost
to perform a payment. Our results show that a privacy-preserving
payment in a path with 10 intermediate users can be carried out in as
few as 5 seconds and incurs on 17 MB of communication overhead.
This shows that our protocols for PCN are in line with with other
privacy-preserving payment systems [49, 54]. Additionally, our
evaluation shows that Fulgor and Rayo can scale to cater a growing
number of users with a reasonably small overhead that can be
further reduced with an optimized implementation.
Organization. Section 2 overviews the required background. Section 3 defines the problem we tackle in this work and overviews
Fulgor and Rayo, our privacy preserving solution for PCNs. Section 4 details the Fulgor protocol. Section 5 describes our study
of concurrency in PCNs and details the Rayo protocol. Section 6
describes our implementation and the evaluation results. Section 7
discusses the related work and Section 8 concludes this paper.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 456
Figure 1: Illustrative example of payment channel. White solid
boxes denote Bitcoin addresses and their current balance, dashed
boxes represent Bitcoin transactions, the clock denotes a time lock
contract [7], a user name along a tick denotes her signature to validate the transaction and colored boxes denote the state of the payment channel. Dashed arrows denote temporal sequence. Alice first
deposits 5 bitcoins opening a payment channel with Bob, then uses
it to pay Bob off-chain. Finally, the payment channel is closed with
the most recent balance.
2 BACKGROUND
In this section, we first overview the notion of payment channels
and we then describe payment-channel networks.
2.1 Payment Channels
A payment channel enables several Bitcoin payments between two
users without committing every single payment to the Bitcoin
blockchain. The cornerstone of payment channels is depositing
bitcoins into a multi-signature address controlled by both users and
having the guarantee that all bitcoins are refunded at a mutually
agreed time if the channel expires. In the following, we overview the
basics of payment channels and we refer the reader to [32, 50, 60]
for further details.
In the illustrative example depicted in Figure 1, Alice opens a
payment channel with Bob with an initial capacity of 5 bitcoins. This
opening transaction makes sure that Alice gets the money back after
a certain timeout if the payment channel is not used. Now, Alice
can pay off-chain to Bob by adjusting the balance of the deposit
in favor of Bob. Each off-chain payment augments the balance for
Bob and reduces it for Alice. When no more off-chain payments are
needed (or the capacity of the payment channel is exhausted), the
payment channel is closed with a closing transaction included in the
blockchain. This transaction sends the deposited bitcoins to each
user according the most recent balance in the payment channel.
The payment channel depicted in Figure 1 is an example of unidirectional channel: it can be used only for payments from Alice to
Bob. Bidirectional channels are defined to overcome this limitation
as off-chain payments in both directions are possible. Bidirectional
payment channels operate in essence as the unidirectional version.1
The major technical challenge consists in changing the direction
of the channel. In the running example, assume that the current
payment channel balance bal is {Alice: 4, Bob: 1} and further assume
1Technically, a bidirectional channel might require that both users contribute funds
to the deposit in the opening transaction. However, current proposals [39] allow
bidirectional channels with single deposit funder.
Figure 2: Illustrative example of a payment in a PCN. Non-bold
(bold) numbers represent the capacity of the channels before (after)
the payment from Alice to Bob. Alice wants to pay 2 bitcoins to Bob
via Carol, Edward and Fabi. Therefore, she starts the payment with
3 bitcoins (i.e., payment amount plus fees).
that Bob pays off-chain one bitcoin back to Alice. The new payment
channel balance bal′
is {Alice: 5, Bob: 0}. At this point, Alice benefits
from bal′
balance while Bob benefits from bal. The solution to this
discrepancy consists on that Bob and Alice make sure that any
previous balance has been invalidated in favor of the most recent
one. Different “invalidation” techniques have been proposed and
we refer the reader to [32, 60, 65] for details.
The Bitcoin protocol has been updated recently to fully support
payment channels. In particular, transaction malleability [8], along
with a set of other interesting new features, have been added to
the Bitcoin protocol with the recent adoption of Segregated Witness [16]. This event paves the way to the implementation and
testing of PCNs on the main Bitcoin blockchain as of today [70].
2.2 A Payment Channel Network (PCN)
A PCN can be represented as a directed graph G = (V, E), where
the set V of vertices represents the Bitcoin accounts and the set E
of weighted edges represents the payment channels. Every vertex
u ∈ V has associated a non-negative number that denotes the
fee it charges for forwarding payments. The weight on a directed
edge (u1,u2) ∈ E denotes the amount of remaining bitcoins that u1
can pay to u2. For ease of explanation, in the rest of the paper we
represent a bidirectional channel between u1 and u2 as two directed
edges, one in each direction.2 Such a network can be used then to
perform off-chain payments between two users that do not have an
open channel between them but are connected by a path of open
payment channels.
The success of a payment between two users depends on the
capacity available along a path connecting the two users and the
fees charged by the users in such path. Assume that s wants to
pay α bitcoins to r and that they are connected through a path
s → u1 → . . . → un → r. For their payment to be successful, every
link must have a capacity γi ≥ α
′
i
, where α
′
i
= α −
Pi−1
j=1
fee(uj
) (i.e.,
the initial payment value minus the fees charged by intermediate
users in the path). At the end of a successful payment, every edge
2
In practice, there is a subtle difference: In a bidirectional channel between Alice and
Bob, Bob can always return to Alice the bitcoins that she has already paid to him.
However, if two unidirectional channels are used, Bob is limited to pay to Alice the
capacity of the edge Bob → Alice, independently of the bitcoins that he has received
from Alice. Nevertheless, our simplification greatly ease the understanding of the rest
of the paper and proposed algorithms can be easily extended to support bidirectional
channels.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 457
in the path from s to r is decreased by α
′
i
. To ensure that r receives
exactly α bitcoins, s must start the payment with a value α
∗ =
α +
Pn
j=1
fee(uj
).
In the illustrative example of payment shown in Figure 2, assume
that Alice wants to pay Bob 2 bitcoins. For that she needs to start
a payment for a value of 3 bitcoins (2 bitcoins plus 1 bitcoin for
the fees charged by users in the path). Then the payment is settled
as follows: capacity in the link Alice → Carol is reduced by 3.
Additionally, Carol charges a fee if 0.25 bitcoins by reducing the
capacity of the link Carol → Edward by 2.75 instead of 3 bitcoins.
Following the same reasoning, the link Edward → Fabi is set to
capacity 3.75 and the link Fabi → Bob is set to 5.
2.3 State-of-the-Art PCNs
The concepts of payment channels [32, 41, 47] and PCNs [50] have
already attracted attention from the research community. In practice, there exist several ongoing implementations for a PCN in Bitcoin [10–12, 19]. Among them, the Lightning Network has emerged
as the most prominent example in the Bitcoin community and an
alpha implementation has been released recently [1]. The idea of a
PCN has been proposed to improve scalability issues not only in
Bitcoin, but also in other blockchain-based payment systems such
as Ethereum [13].
2.3.1 Routing in PCNs. An important task in PCNs is to find
paths with enough capacity between sender and receiver. In our
setting, the network topology is known to every user. This is the
case since the opening of each payment channel is logged in the
publicly available blockchain. Additionally, a gossip protocol between users can be carried out to broadcast the existence of any
payment channel [62]. Furthermore, the fees charged by every user
can be made public by similar means. Under these conditions, the
sender can locally calculate the paths between the sender and the
receiver. In the rest of the paper, we assume that the sender chooses
the path according to her own criteria. Nevertheless, we consider
path selection as an interesting but orthogonal problem.
2.3.2 Payments in PCNs. A payment along a path of payment
channels is carried out by updating the capacity of each payment
channel in the path according to the payment amount and the associated fees (see Section 2.2). Such an operation rises the important
challenge of atomicity: either the capacity of all channels in the path
Figure 3: Illustrative example of a payment from Alice to Fabi for
value 1 using HTLC contract. First, the condition is sent from Fabi
to Alice. The condition is then forwarded among users in the path to
hold 1 bitcoin at each payment channel. Finally, the receiver shows
R, releasing the held bitcoin at each payment channel. For simplicity, we assume that there are no payment fees in this example.
is updated or none of the channels is changed. Allowing changes
in only some of the channels in the path can lead to the loss of
bitcoins for a user (e.g., a user could pay certain bitcoins to the next
user in the path but never receive the corresponding bitcoins from
the previous neighbor).
The current proposal in the Lightning Network consists of a
smart contract called Hash Time-Lock Contract (HTLC) [60]. This
contract locks x bitcoins that can be released only if the contract is
fulfilled. The contract is defined, in terms of a hash value y := H(R)
where R is chosen uniformly at random, the amount of bitcoins x
and a timeout t, as follows:
HTLC (Alice, Bob, y, x, t):
(1) If Bob produces the condition R
∗
such that H(R
∗
) = y
before t days,3Alice pays Bob x bitcoins.
(2) If t days elapse, Alice gets back x bitcoins.
An illustrative example of the use of HTLC in a payment is
depicted in Figure 3. For simplicity, we assume that there are not
payment fees in this example. First, the payment amount (i.e., 1
bitcoin) is set on hold from the sender to the receiver and then
released from the receiver to the sender. In a bit more detail, after
the receiver (Fabi) sends the condition to the sender (Alice), Alice
sets an HTLC with her neighbor, effectively setting the payment
value (i.e., 1 bitcoin) on hold. Such HTLC is then set at each payment
channel in the path to the receiver. At this point, the receiver knows
that the payment value is on hold at each payment channel and
thus she reveals the value R, that allows her to fulfill the contract
and to settle the new capacity at each payment channel in the path.
It is important to note that every user in the path sets the HTLC
in the outgoing payment channel with a timeout smaller than the
HTLC in the incoming payment channel. In this manner, the user
makes sure that she can pull bitcoins from her predecessor after
her bitcoins have been pulled from her successor. An offline user
can outsource the monitoring of fulfillments corresponding to open
HTLC contracts associated to her payment channels [33].
Although HTLC is fully compatible with Bitcoin, its use in practice leads to important privacy leaks: It is easy to see that the value
of the hash H(R) uniquely identifies the users that took part in a
specific transaction. This fact has two main implications. First, any
two colluding users in a path can trivially derive the fact that they
took part in the same payment and this can be leveraged to reconstruct the identity of sender and receiver.4 Second, if the HTLC
statements are uploaded to the blockchain (e.g., due to uncollaborative intermediate users in the payment path), an observer can
easily track the complete path used to route the payment, even if
she is not part of the payment. In this work, we propose a novel
Multi-Hop HTLC smart contract that avoids this privacy problem
while ensuring that no intermediate user loses her bitcoins.
An important issue largely understudied in current PCNs is the
handling of concurrent payments that require a shared payment
channel in their paths. Current proposals simply abort a payment
if the balance at the shared payment channel in the path is not
enough. However, as we show in Section 3.3, this approach can lead
3We use days here as in the original description [60]. Instead, recent proposals use the
sequence numbers of blocks as they appear in the Bitcoin blockchain [35].
4 As noted in [40], in a path A → I1 → I2 → I3 → B, only I1 and I3 must collude to
recover the identities of A and B as all the contracts in the path share the same H (R).
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 458
to a deadlock situation where none of simultaneous payments terminates. We propose a payment protocol that ensure non-blocking
progress, that is, at least one of the concurrent payments terminates.
Moreover, we show an inherent tradeoff between concurrency and
privacy for any fully distributed payment network.
3 PROBLEM DEFINITION
In this section, we first formalize a PCN and underlying operations,
and discuss the attacker model and our security and privacy goals.
We then describe an ideal world functionality for our proposal,
and present a system overview. Throughout the following description we implicitly assume that every algorithm takes as input the
blockchain, which is publicly known to all users.
Definition 3.1 (Payment Channel Network (PCN)). A PCN is defined as graph G := (V, E), where V is the set of Bitcoin accounts
and E is the set of currently open payment channels. A PCN is defined with respect to a blockchain B and is equipped with the three
operations (openChannel, closeChannel, pay) described below:
• openChannel(u1,u2, β,t, f ) → {1, 0}. On input two Bitcoin
addresses u1,u2 ∈ V, an initial channel capacity β, a timeout t, and
a fee value f , if the operation is authorized by u1, and u1 owns
at least β bitcoins, openChannel creates a new payment channel
(c⟨u1,u2⟩
, β, f ,t) ∈ E, where c⟨u1,u2⟩
is a fresh channel identifier.
Then it uploads it to B and returns 1. Otherwise, it returns 0.
• closeChannel(c⟨u1,u2⟩
, v) → {1, 0}. On input a channel identifier c⟨u1,u2⟩ and a balance v (i.e., the distribution of bitcoins locked
in the channel between u1 and u2), if the operation is authorized by
both u1 and u2, closeChannel removes the corresponding channel
from G, includes the balance v in B and returns 1. Otherwise, it
returns 0.
• pay((c⟨s,u1⟩
, . . . ,c⟨un,r⟩
), v) → {1, 0}. On input a list of channel identifiers (c⟨s,u1⟩
, . . . ,c⟨un,r⟩
) and a payment value v, if the
payment channels form a path from the sender (s) to the receiver
(r) and each payment channel c⟨ui
,ui+1⟩
in the path has at least a
current balance γi ≥ v
′
i
, where v
′
i
= v −
Pi−1
j=1
fee(uj
), the pay
operation decreases the current balance for each payment channel
c⟨ui
,ui+1⟩ by v
′
i
and returns 1. Otherwise, none of the balances at
the payment channels is modified and the pay operation returns 0.
3.1 Attacker Model, and Security and Privacy
Goals
We consider a computationally efficient attacker that can shape the
network at her will by spawning users and corrupting an arbitrary
subset of them in an adaptive fashion. Once a user is corrupted,
its internal state is given to the attacker and all of the following
messages for that user are handed over to the attacker. On the
other hand, we assume that the communication between two noncompromised users sharing a payment channel is confidential (e.g.,
through TLS). Finally, the attacker can send arbitrary messages on
behalf of corrupted users.
Against the above adversary, we identify the following security
and privacy notions of interest:
• Balance security. Intuitively, balance security guarantees
that any honest intermediate user taking part in a pay operation
(as specified in Definition 3.1) does not lose coins even when all
other users involved in the pay operation are corrupted.
• Serializability. We require that the executions of PCN are serializable [58], i.e., for every concurrent execution of pay operations,
there exists an equivalent sequential execution.
• (Off-path) Value Privacy. Intuitively, value privacy guarantees that for a pay operation involving only honest users, corrupted
users outside the payment path learn no information about the
payment value.
• (On-path) Relationship Anonymity [24, 59]. Relationship anonymity requires that, given two simultaneous successful
pay operations of the form (
payi
((c⟨si
,u1⟩
, . . . ,c⟨un,ri⟩
), v)
)
i ∈[0,1]
with at least one honest intermediate user uj ∈[1,n]
, corrupted intermediate users cannot determine the pair (si
,ri
) for a given payi
with probability better than 1/2.
3.2 Ideal World Functionality
Our Model. The users of the network are modeled as interactive
Turing machines that communicate with a trusted functionality F
via secure and authenticated channels. We model the attacker A
as a probabilistic polynomial-time machine that is given additional
interfaces to add users to the system and corrupt them. A can query
those interfaces adaptively and at any time. Upon corruption of a
user u, the attacker is provided with the internal state of u and the
incoming and outgoing communication of u is routed thorough A.
Assumptions. We model anonymous communication between
any two users of the network as an ideal functionality Fanon, as proposed in [26]. Furthermore, we assume the existence of a blockchain
B that we model as a trusted append-only bulletin board (such
as [72]): The corresponding ideal functionality FB maintains B locally and updates it according to the transactions between users. At
any point in the execution, any user u of the PCN can send a distinguished message read to FB, who sends the whole transcript of B to
u. We denote the number of entries of B by |B|. In our model, time
corresponds to the number of entries of the blockchain B, i.e., time t
is whenever |B| = t. Our idealized process F uses Fanon and FB as
subroutines, i.e., our protocol is specified in the (Fanon, FB)-hybrid
model. Note that our model for a blockchain is a coarse grained
abstraction of the reality and that more accurate formalizations
are known in the literature, see [44]. For ease of exposition we
stick to this simplistic view, but one can easily extend our model to
incorporate more sophisticated abstractions.
Notation. Payment channels in the Blockchain B are of the form
(c⟨u,u
′
⟩
, v,t, f ), where c⟨u,u
′
⟩
is a unique channel identifier, v is the
capacity of the channel, t is the expiration time of the channel, and
f is the associated fee. For ease of notation we assume that the
identifiers of the users (u,u
′
) are also encoded in c⟨u,u
′
⟩
. We stress
that any two users may have multiple channels open simultaneously.
The functionality maintains two additional internal lists C and L.
The former is used to keep track of the closed channels, while the
latter records the off-chain payments. Entries in L are of the form
(c⟨u,u
′
⟩
, v,t,h), where c⟨u,u
′
⟩
is the corresponding channel, v is the
amount of credit used, t is the expiration time of the payment, and
h is the identifier for this entry.
Operations. In Figure 4 we describe the interactions between F
and the users of the PCN. For simplicity, we only model unidirectional channels, although our functionality can be easily extended
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 459
Open channel: On input (open,c⟨u,u
′
⟩
, v,u
′
,t, f ) from a user u, the F checks whetherc⟨u,u
′
⟩
is well-formed (contains valid identifiers
and it is not a duplicate) and eventually sends (c⟨u,u
′
⟩
, v,t, f ) to u
′
, who can either abort or authorize the operation. In the latter case,
F appends the tuple (c⟨u,u
′
⟩
, v,t, f ) to B and the tuple (c⟨u,u
′
⟩
, v,t,h) to L, for some random h. F returns h to u and u
′
.
Close channel: On input (close,c⟨u,u
′
⟩
,h) from a user ∈ {u
′
,u} the ideal functionality F parses B for an entry (c⟨u,u
′
⟩
, v,t, f ) and
L for an entry (c⟨u,u
′
⟩
, v
′
,t
′
,h), for h , ⊥. If c⟨u,u
′
⟩ ∈ C or t > |B| or t
′ > |B| the functionality aborts. Otherwise, F adds the entry
(c⟨u,u
′
⟩
,u
′
, v
′
,t
′
) to B and adds c⟨u,u
′
⟩
to C. F then notifies both users involved with a message (c⟨u,u
′
⟩
, ⊥,h).
Payment: On input (pay, v, (c⟨u0,u1⟩
, . . . ,c⟨un,un+1⟩
), (t0, . . . ,tn )) from a user u0, F executes the following interactive protocol:
(1) For all i ∈ {1, . . . , (n+1)} F samples a random hi and parses B for an entry of the form (c⟨ui−1,u
′
i
⟩
, vi
,t
′
i
, fi
). If such an entry does
exist F sends the tuple (hi
,hi+1,c⟨ui−1,ui⟩
,c⟨ui
,ui+1⟩
, v−
Pn
j=i
fj
,ti−1,ti
) to the user ui via an anonymous channel (for the specific
case of the receiver the tuple is only (hn+1,c⟨un,un+1⟩
, v,tn )). Then F checks whether for all entries of the form (c⟨ui−1,ui⟩
, v
′
i
, ·, ·) ∈
L it holds that v
′
i
≥

v −
Pn
j=i
fj

and that ti−1 ≥ ti
. If this is the case F adds di = (c⟨ui−1,ui⟩
, (v
′
i
− (v −
Pn
j=i
fj
)),ti
, ⊥) to L,
where (c⟨ui−1,ui⟩
, v
′
i
, ·, ·) ∈ L is the entry with the lowest v
′
i
. If any of the conditions above is not met, F removes from L all
the entries di added in this phase and aborts.
(2) For all i ∈ {(n + 1), . . . , 1} F queries all ui with (hi
,hi+1), through an anonymous channel. Each user can reply with either ⊤ or
⊥. Let j be the index of the user that returns ⊥ such that for all i > j : ui returned ⊤. If no user returned ⊥ we set j = 0.
(3) For all i ∈ {j + 1, . . . ,n} the ideal functionality F updates di ∈ L (defined as above) to (−, −, −,hi
) and notifies the user of the
success of the operation with with some distinguished message (success,hi
,hi+1). For all i ∈ {0, . . . , j} (if j , 0) F removes di
from L and notifies the user with the message (⊥,hi
,hi+1).
Figure 4: Ideal world functionality for PCNs.
to support also bidirectional channels. The execution of our simulation starts with F initializing a pair of local empty lists (L, C).
Users of a PCN can query F to open channels and close them to any
valid state in L. On input a value v and a set of payment channels
(c⟨u0,u1⟩
, . . . ,c⟨un,un+1⟩
) from some user u0, F checks whether the
path has enough capacity (step 1) and initiates the payment. Each
intermediate user can either allow the payment or deny it. Once
the payment has reached the receiver, each user can again decide
to interrupt the flow of the payment (step 2), i.e., pay instead of
the sender. Finally F informs the involved nodes of the success
of the operation (step 3) and adds the updated state to L for the
corresponding channels.
Discussion. Here, we show that our ideal functionality captures
the security and privacy properties of interest for a PCN.
• Balance security. Let ui be any intermediate hop in a payment
pay((c⟨s,u1⟩
, . . . ,c⟨un,r⟩
), v). F locally updates in L the channels
corresponding to the incoming and outgoing edges of ui such that
the total balance of ui
is increased by the coins she sets as a fee,
unless the user actively prevents it (step 2). Since F is trusted,
balance security follows.
• Serializability. Consider for the moment only single-hop payments. It is easy to see that the ideal functionality executes them
serially, i.e., any two concurrent payments can only happen on
different links. Therefore one can trivially find a scheduler that
performs the same operation in a serial order (i.e., in any order). By
balance security, any payment can be represented as a set of atomic
single-hop payments and thus serializability holds.
• Value Privacy. In the ideal world, users that do not lie in the
payment path are not contacted by F and therefore they learn
nothing about the transacted value (for the off-chain payments).
• Relationship Anonymity. Let ui be an intermediate hop in a
payment. In the interaction with the ideal functionality, ui
is only
provided with a unique identifier for each payment. In particular,
such an identifier is completely independent from the identifiers
of other users involved in the same payment. It follows that, as
long as at least one honest user ui
lies in a payment path, any
two simultaneous payments over the same path for the same value
v are indistinguishable to the eyes of the user ui+1. This implies
that any proper subset of corrupted intermediate hops, for any two
successful concurrent payments traversing all of the corrupted
nodes, cannot distinguish in which order an honest ui forwarded
the payments. Therefore such a set of corrupted nodes cannot
determine the correct sender-receiver pair with probability better
than 1/2.
UC-Security. Let EXECτ, A, E be the ensemble of the outputs of
the environment E when interacting with the adversary A and
parties running the protocol τ (over the random coins of all the
involved machines).
Definition 3.2 (UC-Security). A protocol τ UC-realizes an ideal
functionality F if for any adversary A there exists a simulator S
such that for any environment E the ensembles EXECτ, A, E and
EXECF ,S, E are computationally indistinguishable.
Lower bound on byzantine users in PCN. We observe that in
PCNs that contain channels in which both the users are byzantine
(à la malicious) [46], there is an inherent cost to concurrency. Specifically, in such a PCN, if we are providing non-blocking progress,
i.e., at least one of the concurrent payments terminates, then it
is impossible to provide serializability in PCNs (cf. Figure 11 in
Appendix D). Thus, henceforth, all results and claims in this paper
assume that in any PCN execution, there does not exist a channel
in which both its users are byzantine.
Lemma 3.3. There does not exist any serializable protocol for the
PCN problem that provides non-blocking progress if there exists a
payment channel in which both users are byzantine.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 460
3.3 Key Ideas and System Overview
In the following, we give a high-level overview on how we achieve
private and concurrent payments in PCNs.
3.3.1 Payment Privacy. The payment operation must ensure
the security and privacy properties of interest in a PCN, namely
balance security, value privacy and relationship anonymity. A naïve
approach towards achieving balance security would be to use HTLCbased payments (see Section 2.3.2). This solution is however in
inherent conflict with anonymity: It is easy to see that contracts
belonging to the same transactions are linkable among each other,
since they encode the same condition (h) to release the payment.
Our proposal, called Multi-Hop HTLC, aims to remove this link
among hops while maintaining the full compatibility with the Bitcoin network.
The idea underlying Multi-Hop HTLC is the following: At the
beginning of an n-hop transaction the sender samples n-many independent strings (x1, . . . , xn ). Then, for all i ∈ 1, . . . ,n, she sets
yi = H
Ln
j=i
xj

, where H is an arbitrary hash function. That is,
eachyi
is the result of applying the function H to all of the input values xj for j ≥ i in an XOR combiner. The sender then provides the
receiver with (yn, xn ) and the i-th node with the tuple (yi+1,yi
, xi
).
In order to preserve anonymity, the sender communicates those
values to the intermediate nodes over an anonymous channel. Starting from the sender, each pair of neighboring nodes (ui+1,ui
) defines a standard HTLC on inputs (ui
,ui+1,yi
,b,t), where b and t
are the amount of bitcoin and the timeout parameter, respectively.
Note that the release conditions of the contracts are uniformly distributed in the range of the function H and therefore the HTLCs
of a single transaction are independent from each other. Clearly,
the mechanism described above works fine as long as the sender
chooses each value yi according to the specification of the protocol.
We can enforce an honest behavior by including non-interactive
zero-knowledge proofs [38].
3.3.2 Concurrent Payments. It is possible that two (or more)
simultaneous payments share a payment channel in their payment
paths in such a manner that none of the payments goes through.
In the example depicted in Figure 5, the payment from Alice to
Gabriel cannot be carried out as the capacity in the payment channel
between Fabi and Gabriel is already locked for the payment from
Bob to Edward. Moreover, this second payment cannot be carried
out either as the capacity on the payment channel between Carol
and Edward is already locked. This deadlock situation is a generic
problem of PCNs, where a payment is aborted as soon as there
exists a payment channel in the path without enough capacity.
Blocking Payments (Fulgor). A best-effort solution for avoiding this deadlock consists on letting both payments fail. Aborted
payments do not affect the balance of the involved users as the
receiver would not disclose the release condition for the locked
payment channels. Therefore, involved payment channels would
get unlocked only after the corresponding timeout and bitcoins are
sent back to the original owner.
The sender of an aborted payment can then randomly choose
a waiting period to reissue the payment. Although the blocking
Figure 5: Illustrative example of two blocking payments: Alice to
Gabriel (red) and Bob to Edward (blue). For simplicity, assume each
payment pays 1 bitcoin and each payment channel has capacity 1
bitcoin. Each payment channel is colored with the payment that has
reached it first. In this deadlock situation, none of the payments can
continue further in the path and cannot be trivially completed.
mechanism closely resembles the practice of users in others payment networks such as Ripple [14] or SilentWhispers [49], it might
degrade transaction throughput in a fully decentralized PCN.
Non-blocking Payments (Rayo). An alternative solution consists on a non-blocking solution where at least one out of a set of
concurrent payments completes. Our approach to achieve it assumes that there exists a global ordering of payments (e.g., by a
global payment identifier). In a nutshell, users can queue payments
with higher identifier than the current one “in-flight”, and abort
payments with lower identifiers. This ensures that either the current in-flight payment completes or one of the queued payments
would do, as their identifiers are higher.
4 FULGOR: OUR CONSTRUCTION
In this section, we introduce the cryptographic building blocks
required for our construction (Section 4.1), we describe the details
for the Multi-Hop HTLC contract (Section 4.2), we detail the constructions for PCN operations (Section 4.3), analyze its security and
privacy (Section 4.4) and conclude with a few remarks (Section 4.5).
Notation. We denote by λ the security parameter of our system
and we use the standard definition for a negligible function. We
denote by decision the possible events in a payment channel due
to a payment. The decision forward signals to lock the balance in
the payment channel corresponding to the payment value. The
decision abort signals the release of locked funds in the payment
channel due to the abortion of a payment. Correspondingly, the
decision accept signals the confirmation of a payment accepted by
the receiver.
For ease of notation, we assume that users identifiers (ui
,ui+1)
can be extracted from the channel identifier c⟨ui
,ui+1⟩
.
System Assumptions. We assume that every user in the PCN
is aware of the complete network topology, that is, the set of all
users and the existence of a payment channel between every pair
of users. We further assume that the sender of a payment chooses
a payment path to the receiver according to her own criteria. The
current value on each payment channel is not published but instead
kept locally by the users sharing a payment channel as otherwise
privacy is trivially broken. We further assume that every user is
aware of the payment fees charged by each other user in the PCN.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 461
This can be accomplished in practice. The opening of a payment
channel between two users requires to add a transaction in the
blockchain that includes both user identifiers. Therefore, the topology of the PCN is trivially leaked. Moreover, the transaction used to
open a payment channel can contain user-defined data [5] so that
each user can embed her own payment fee. In this manner, each
user can proactively gather updated information about the network
topology and fees from the blockchain itself or be disseminated by
a gossip protocol [48, 62].
We further assume that pairs of users sharing a payment channel
communicate through secure and authenticated channels (such as
TLS), which is easy to implement given that every user is uniquely
identified by a public key. Also we assume that the sender and
the receiver of a (possibly indirect) transaction can communicate
through a secure and direct channel. Finally, we assume that the
sender of a payment can create an anonymous payment channel
with each intermediate user. The IP address where to reach each
user could be encoded in the channel creation transaction and
therefore logged in the blockchain. We note that our protocol is
completely parametric with respect to the routing, therefore any
onion routing-like techniques would work in this context.
We consider the bounded synchronous communication setting [23].
In such communication model, time is divided into fixed communication rounds and it is assumed that all messages sent by a user in
a round are available to the intended recipient within a bounded
number of steps in an execution. Consequently, absence of a message indicates absence of communication from a user during the
round. In practice, this can be achieved with loosely synchronized
clocks among the users in the PCN [28].
Finally, we assume that there is a total order among the users
(e.g., lexicographically sorted by their public verification keys).
4.1 Building Blocks
Non-Interactive Zero-Knowledge. Let R : {0, 1}
∗ × {0, 1}
∗ →
{0, 1} be an NP relation, and let L be the set of positive instances
for R, i.e., L = {x | ∃w s.t. R(x,w) = 1}. A non-interactive zeroknowledge proof for R consists of a single message from a prover
P to a verifier V. The prover P wants to compute a proof π that
convinces the verifier V that a certain statement x ∈ L. We allow
the prover to run on an extra private input w such that R(x,w) = 1.
The verifier can either accept or reject, depending on π. A NIZK
is complete if the V always accepts honestly computed π for a
statement x ∈ L and it is sound if V always rejects any π for
all x < L, except with negligible probability. Loosely speaking, a
NIZK proof is zero knowledge if the verifier learns nothing from π
beyond the fact that x ∈ L. Efficient NIZK protocols are known to
exist in the random oracle model [38].
Two Users Agreement. Two users ui and uj sharing a payment
channel, locally maintain the state of the payment channel defined
as a scalarchannel-state := cap(c⟨ui
,uj⟩
) that denotes the current capacity of their payment channel. We require a two party agreement
protocol that ensures that both users agree on the current value of
cap(c⟨ui
,uj⟩
) at each point in time. We describe the details of such
protocol in Appendix B. For readability, in the rest we implicitly
assume that two users sharing a payment channel satisfactorily
agree on its current state.
4.2 Multi-Hop HTLC
We consider the standard scenario of an indirect payment from a
sender Sdr to a receiver Rvr for a certain value v through a path
of users (u1, . . . ,un ), where un = Rvr. All users belonging to the
same network share the description of a hash function H : {0, 1}
∗ →
{0, 1}
λ
that we model as a random oracle.
Let L be the following language: L = {(H,y
′
,y, x) | ∃(w) s.t. y
′
= H(w) ∧y = H(w ⊕ x)} where w ⊕ x denotes the bitwise XOR of
the two bitstrings. Before the payment starts, the sender Sdr locally
executes the following SetupHTLC algorithm described in Figure 6.
Intuitively, the sender samples n-many random strings xi and
defines yi as H
Ln
j=i
xj

which is the XOR combination of all xj
such that j ≥ i. Then, Sdr computes the proofs π to guarantee that
each yi
is well-formed, without revealing all of the xi
. The receiver
is provided with (xn,yn ) and she simply checks that yn = H(xn ).
Sdr then sends (xi
,yi
, πi
) to each intermediate user ui
, through a
direct communication channel. Eachui runs V((H,yi+1,yi
, xi
), πi
)
and aborts the payment if the verification algorithm rejects the
proof.
Starting from the user u0 = Sdr, each pair of users (ui
,ui+1)
check whether both users received the same values of (yi+1, v).
This can be done by simply exchanging and comparing the two
values. If this is the case, they establish HTLC (ui
, ui+1, yi+1, v,
ti
) as described in Section 2.3, where ti defines some timespan
such that for all i ∈ [n] : ti−1 = ti + ∆, for some positive value
∆. Once the contract between (un−1,un ) is settled, the user un
(the receiver) can then pull v bitcoins by releasing the xn, which
by definition satisfies the constraint H(xn ) = yn. Once the value
of xn is published, un−1 can also release a valid condition for the
contract between (un−2,un−1) by simply outputting xn−1 ⊕ xn. In
fact, this mechanism propagates for every intermediate user of the
payment path, until Sdr: For each node ui
it holds that, whenever
the condition for the contract between (ui
,ui+1) is released, i.e.,
somebody publishes a string r such that H(r) = yi+1, then ui
immediately learns xi ⊕r such that H(xi ⊕r) = yi
, which is a valid
condition for the contract between (ui−1,ui
). It follows that each
intermediate user whose outgoing contract has been pulled is able
to release a valid condition for the incoming contract.
4.3 Construction Details
In the following, we describe the details of the three operations
(openChannel, closeChannel, pay) that compose Fulgor.
SetupHTLC(n) :
∀i ∈ [n] :
xi ∈ {0, 1}
λ
;yi ← H
*
.
,
Mn
j=i
xj
+
/
-
∀i ∈ [n − 1] :
πi ← P *
.
,
(H, yi+1, yi
, xi
),
*
.
,
Mn
j=i+1
xj
+
/
-
+
/
-
return ((x1, y1, π1), . . . , (xn, yn ))
Figure 6: Setup operation for the Multi-Hop HTLC contract.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 462
payu0
(m) :
(Txid,
(
c⟨u0,u1⟩
)
∪
(
c⟨ui
,ui+1⟩
)
i∈[n]
, v) ← m
v1 := v +
Xn
i
fee(ui
)
if v1 ≤ cap(c⟨u0,u1⟩
) then
cap(c⟨u0,u1⟩
) := cap(c⟨u0,u1⟩
) − v1
t0 := tnow + ∆ · n
∀i ∈ [n] :
vi
:= v1 −
Xi−1
j=1
fee(uj
)
ti
:= ti−1 − ∆

(xi
, yi
, πi
)
	
i∈[n+1] ← SetupHTLC(n + 1)
Send(ui
, ((Txid, xi
, yi
, yi+1,
πi
, c⟨ui−1,ui
⟩
, c⟨ui
,ui+1⟩
, vi+1, ti
, ti+1), forward))
HTLC(u0, u1, y1, v1, t1)
Send(un+1, (Txid, xn+1, yn+1, c⟨un,un+1⟩
,
vn+1, tn+1))
else
abort
Figure 7: The pay routine in Fulgor for the sender. The light blue
pseudocode shows additional steps required in Rayo.
• openChannel(u1,u2, β,t, f ): The purpose of this operation is
to open a payment channel between users u1 and u2. For that, they
create an initial Bitcoin deposit that includes the following information: their Bitcoin addresses, the initial capacity of the channel
(β), the channel timeout (t), the fee charged to use the channel (f )
and a channel identifier (c⟨u1,u2⟩
) agreed beforehand between both
users. After the Bitcoin deposit has been successfully added to the
blockchain, the operation returns 1. If any of the previous steps is
not carried out as defined, the operation returns 0.
• closeChannel(c⟨u1,u2⟩
, v): This operation is used by two users
(u1,u2) sharing an open payment channel (c⟨u1,u2⟩
) to close it at the
state defined by v and accordingly update their bitcoin balances in
the Bitcoin blockchain. This operation in Fulgor is performed as defined in the original proposal of payment channels (see Section 2.1),
additionally returning 1 if and only if the corresponding Bitcoin
transaction is added to the Bitcoin blockchain.
• pay((c⟨u0,u1⟩
, . . . ,c⟨un,un+1⟩
), v): A payment operation transfers a value v from a sender (u0) to a receiver (un+1) through a path
of open payment channels between them (c⟨u0,u1⟩
, . . . , c⟨un,un+1⟩
).
Here, we describe a blocking version of the payment operation
(see Section 3.3). We discuss the non-blocking version of the payment operation in Section 5.
As shown in Figure 7 (black pseudocode), the sender first calculates
the cost of sending v bitcoins to Rvr as v1 := v +
P
i
fee(ui
), and
the corresponding cost at each of the intermediate hops in the payment path. If the sender does not have enough bitcoins, she aborts
the payment. Otherwise, the sender sets up the contract for each
intermediate payment channel following the mechanism described
in Section 4.2 and sends the information to the corresponding users.
payun+1
(m) :
(Txid, xn+1, yn+1, c⟨n,n+1⟩
, vn+1, tn+1) ← m
if H (xn+1) = yn+1 and tn+1 > tnow + ∆ then
store (xn+1, yn+1, c⟨n,n+1⟩
, tn+1)
Send(un, ((Txid, xn+1, yn+1, c⟨n,n+1⟩
), accept))
else
Send(un, ((Txid, yn+1, c⟨n,n+1⟩
, vn+1), abort))
payui
(m) :
(m∗
, decision) ← m
if decision = forward then
(Txid, xi
, yi
, yi+1, πi
, c⟨i−1,i⟩
, c⟨i,i+1⟩
,
vi+1, ti
, ti+1) ← m∗
if vi+1 ≤ cap(c⟨ui
,ui+1⟩
) and V((H, yi+1, yi
, xi
), πi
)
and ti+1 = ti − ∆ then
cap(c⟨ui
,ui+1⟩
) := cap(c⟨ui
,ui+1⟩
) − vi+1
HTLC(ui
, ui+1, yi+1, vi+1, ti+1)
cur(c⟨ui
,ui+1⟩
).append(m∗
)
else if ∃k | Txid > cur(c⟨ui
,ui+1⟩
)[k].Txid then
Q(c⟨ui
,ui+1⟩
).append(m∗
)
else
Send(ui−1, ((Txid, yi
, c⟨i−1,i⟩
, vi
), abort))
else if decision = abort then
(Txid, yi+1, c⟨i,i+1⟩
, vi+1) ← m∗
cap(c⟨ui
,ui+1⟩
) := cap(c⟨ui
,ui+1⟩
) + vi+1
Send(ui−1, ((Txid, yi
, c⟨i−1,i⟩
, vi
), abort))
cur(c⟨ui
,ui+1⟩
).delete(m∗
.Txid)
m′
:= max(Q(c⟨ui
,ui+1⟩
))
payui
((m′
, forward))
else if decision = accept then
(Txid, xi+1, yi+1, c⟨i,i+1⟩
, vi+1) ← m∗
store (xi+1 ⊕ xi
, yi
, c⟨i−1,i⟩
, ti
)
Send(ui−1, ((Txid, xi+1 ⊕ xi
, yi
, c⟨i−1,i⟩
, vi
), accept))
cur(c⟨ui
,ui+1⟩
).delete(m∗
.Txid)
Figure 8: The pay routine in Fulgor for the receiver and each intermediate user. The light blue pseudocode shows additional steps in
Rayo. max(Q) returns the information for the payment with highest
identifier among those in Q.
Every intermediate user verifies that the incoming HTLC has an
associated value smaller or equal than the capacity of the payment
channel with her sucessor in the path. Additionally, every intermediate user verifies that the zero-knowledge proof associated to
the HTLC for incoming and outgoing payment channels correctly
verifies and that the timeout for the incoming HTLC is bigger than
the timeout for the outgoing HTLC by a difference of ∆. If so, she
generates the corresponding HTLC for the same associate value
(possibly minus the fees) with the successor user in the path; otherwise, she aborts by triggering the abort event to the predecessor
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 463
user in the path. These operations have been shown in Figure 8
(black pseudocode).
If every user in the path accepts the payment, it eventually reaches
the receiver who in turn releases the information required to fulfill
the HTLC contracts in the path (see Figure 8 (black pseudocode)).
Interestingly, if any intermediate user aborts the payment, the receiver does not release the condition as she does not receive any
payment. Moreover, payment channels already set in the previous
hops of the path are voided after the timeout set in the corresponding HTLC.
4.4 Security and Privacy Analysis
In the following, we state the security and privacy results for Fulgor.
We prove our results in the (Fanon, FB)-hybrid model. In other
words, Theorem 4.1 holds for any UC-secure realization of Fanon
and FB. We show the proof of Theorem 4.1 in Appendix A.
Theorem 4.1 (UC-Security). Let H : {0, 1}
∗ → {0, 1}
λ
be a
hash function modelled as a random oracle, and let (P, V) a zeroknowledge proof system, then Fulgor UC-realizes the ideal functionality F defined in Figure 5 in the (Fanon, FB)-hybrid model.
4.5 System Discussion
Compatibility with Bitcoin. We note that all of the non-standard
cryptographic operations (such as NIZK proofs) happen off-chain,
while the only algorithm required to be executed in the verification
of the blockchain is the hash function H, which can be instantiated
with SHA-256. Therefore our Multi-Hop HTLC scheme and Fulgor
as a whole is fully compatible with the current Bitcoin script. Moreover, as mentioned in Section 2.1, the addition of SegWit or similar
solution for the malleability issue in Bitcoin fully enables payment
channels in the Bitcoin system [70].
Generality. Fulgor is general to PCNs (and not only tied to Bitcoin). Fulgor requires that: (i) openChannel allows to embed custom
data (e.g., fee); (ii) conditional updates of the balance in the payment channel. As arbitrary data can be included in cryptocurrency
transactions [5] and most PCNs support, among others, the HTLC
contract, Fulgor can be used in many other PCNs such as Raiden, a
PCN for Ethereum [13].
Support for Bidirectional Channels. Fulgor can be easily extended to support bidirectional payment channels and only two
minor changes are required. First, the payment information must
include the direction requested at each payment channel. Second,
the capacity of a channelc⟨uL,uR ⟩
is a tuple of values (L, R,T ) where
L denotes the current balance for uL, R is the current balance of uR
and T is the total capacity of the channel. A payment from left to
right for value v is possible if L ≥ v and R + v ≤ T . In such case,
the tuple is updated to (L − v, R + v,T ). A payment from right to
left is handled correspondingly.
5 NON-BLOCKING PAYMENTS IN PCNS
In this section, we discuss how to handle concurrent payments in
a non-blocking manner. In other words, how to guarantee that at
least one payment out of a set of concurrent payments terminates.
In the following, we start with an impossibility result that dictates the design of Rayo, our protocol for non-blocking payments.
Then, we describe the modifications required in the ideal world
functionality and Fulgor to achieve them. Finally, we discuss the
implications of these modifications in terms of privacy properties.
5.1 Concurrency vs Privacy
We show that achieving non-blocking progress requires a global
state associated to each of the payments. Specifically, we show
that we cannot provide disjoint-access parallelism and non-blocking
progress for PCNs. Formally, a PCN implementation is disjointaccess parallel if for any two payments channels ei
, ej
, channel-state
(ei
) ∩ channel-state (ej
) =∅.
Lemma 5.1. There does not exist any strictly serializable disjointaccess parallel implementation for the payment channels problem
that provides non-blocking progress.
We defer to Appendix D for a proof sketch. Having established
this inherent cost to concurrency and privacy, we model global
state by a Txid field attached to each of the payments. We remark
that this Txid, however, allows an adversary to reduce the set of
possible senders and receivers for the payment, therefore inevitably
reducing the privacy guarantees, as we discuss in Section 5.2.
5.2 Ideal World Functionality
Here, we show how to modify the ideal functionality F , as described
in Section 3.2, to account for the changes to achieve non-blocking
progress in any PCN. First, a single identifier Txid (as opposed to
independently sampled hi
) is used for all the payment channels
in the path (c⟨u0,u1⟩
, . . . ,c⟨un,un+1⟩
). Second, F no longer aborts
a payment simply when no capacity is left in a payment channel.
Instead, F queues the payment if its Txid is higher than the current in-flight payment, or aborts it the Txid is lower. We detail the
modified ideal functionality in Appendix C.
Discussion. Here, we discuss how the modified ideal world definition captures the security and privacy notions of interest as
described in Section 3.1. In particular, it is easy to see that the notions of balance security and value privacy are enforced along the
same lines. However, the leakage of the same payment identifier
among all intermediate users in the payment path, reduces the
possible set of sender and receivers to the actual sender and receiver for such payment, thereby breaking relationship anonymity.
Therefore, there is an inherent tradeoff between how to handle concurrent payments (blocking or non-blocking) and the anonymity
guarantees.
An illustrative example of this tradeoff is shown in Figure 9.
It shows how two simultaneous payments pay1
((c⟨S1,U1⟩
,c⟨U1,U2⟩
,
c⟨U2,U3⟩
,c⟨U3,R1⟩
), v) and pay2
((c⟨S2,U1⟩
,c⟨U1,U2⟩
,c⟨U2,,U3⟩
,c⟨U3,R2⟩
),
v) are handled depending on whether concurrent payments are
handled in a blocking or non-blocking fashion. We assume that
both payments can successfully finish in the current PCN and that
both payments transfer the same payment amount v, as otherwise
relationship anonymity is trivially broken.
For the case of blocking payments, each intermediate user uj
observes an independently chosen identifier Txidij for each payment payi
. Therefore, the attacker is not able to correlate the pair
(Txid11, Txid21) (i.e., view of U1) with the pair (Txid13, Txid23) (i.e.,
view of U3). It follows that for a pay operation issued by any node,
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 464
Figure 9: Illustrative example of tradeoff between concurrency and
privacy. Each node represents a user: black nodes are honest and red
are byzantine. In both cases, we assume two concurrent payments:
S1 pays R1 and S2 pays R2 through the path U1, U2, U3. The color of
the arrow denotes the payment identifier. Dashed ellipses denote
the anonymity set for each case.
say S1, the set of possible receivers that the adversary observes is
{R1, R2 }.
However, when the concurrent payments are handled in a nonblocking manner, the adversary observes for pay1
that Txid11 =
Txid13. Therefore, the adversary can trivially derive that the only
possible receiver for a pay initiated by S1 is R1.
5.3 Rayo: Our Construction
Building Blocks. We require the same building blocks as described in Section 4.1 and Section 4.2. The only difference is that the
channel’s state between two users is now defined aschannel-state :=
(cur(ui
,uj
)
[ ], Q(ui
,uj
)
[ ], cap(ui
,uj
)
), where cur denotes an array of
payments currently using (part of) the capacity available at the
payment channel; Q denotes the array of payments waiting for
enough capacity at the payment channel, and cap denotes the current capacity value of the payment channel.
Operations. The openChannel and closeChannel operations remain as described in Section 4.3. However, the pay operation has to
be augmented to ensure non-blocking payments. We have described
the additional actions in light blue pseudocode in Figures 7 and 8.
In the following, we informally describe these additional actions
required for the pay operation. In a nutshell, when a payment
reaches an intermediate user in the path, several events can be
triggered. The simplest case is when the corresponding payment
channel is not saturated yet (i.e., enough capacity is left for the
payment to succeed). The user accepts the payment and simply
stores its information in cur as an in-flight payment.
The somewhat more interesting case occurs when the payment
channel is saturated. This means that (possibly several) payments
have been already gone through the payment channel. In this case,
the simplest solution is to abort the new payment, but this leads
to deadlock situations. Instead, we ensure that deadlocks do not
occur by leveraging the total order of payment identifiers: If the
new payment identifier (Txid) is higher than any of the payment
identifiers currently active in the payment channel (i.e., included
in cur [ ]), the payment identified by Txid is stored in Q. In this
manner, if any of the currently active payments are aborted, a
queued payment (Txid∗
) can be recovered from Q and reissued
towards the receiver. On the other hand, if Txid is lower than every
identifier for currently active payments, the payment identified
by Txid is directly aborted as it would not get to complete in the
presence of a concurrent payment with higher identifier in the
PCN.
5.4 Analysis and System Discussion
Security and Privacy Analysis. In the following, we state the
security and privacy results for Rayo when handling payments in
a non-blocking manner. We prove our results in the (Fanon, FB)-
hybrid model. In other words, Theorem 5.2 holds for any UC-secure
realization of Fanon and FB (analysis in Appendix A).
Theorem 5.2 (UC-Security). Let H : {0, 1}
∗ → {0, 1}
λ
be a
hash function modelled as a random oracle, and let (P, V) a zeroknowledge proof system, then Rayo UC-realizes the ideal functionality
F described in Figure 10 in the (Fanon, FB)-hybrid model.
System Discussion. Rayo is compatible with Bitcoin, can be
generally applicable to PCN and supports bidirectional payment
channels similar to Fulgor. Moreover, the Rayo protocol provides
non-blocking progress. Specifically, Rayo ensures that some payment successfully terminates in every execution. Intuitively, this is
because any two conflicting payments can necessarily be ordered
by their respective unique identifier: the highest payment identifier
is deterministically identified and terminates successfully while the
lower priority payment aborts.
5.5 Fulgor vs Rayo
In this work, we characterize the tradeoff between the two protocols
presented in this work. As shown in Table 1, both protocols guarantee crucial security and correctness properties such as balance
security and serializability. By design, Rayo is the only protocol that
ensures non-blocking progress. Finally, regarding privacy, we aimed
at achieving the strongest privacy possible. However, although both
protocols guarantee value privacy, we have shown that it is impossible to simultaneously achieve non-blocking progress and strong
anonymity. Therefore, Fulgor achieves strong anonymity while
Rayo achieves non-blocking progress at the cost of weakening the
anonymity guarantees. We note nevertheless that Rayo provides
relationship anonymity only if none of the intermediate nodes
is compromised. Intuitively, Rayo provides this (weaker) privacy
guarantee because it still uses Multi-Hop HTLC as Fulgor.
Table 1: Comparison between Fulgor and Rayo.
Fulgor Rayo
Balance security
Serializability
Non-blocking progress #
Value Privacy
Anonymity G#
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 465
6 PERFORMANCE ANALYSIS
In this section, we first evaluate the performance of Fulgor. Finally,
we describe the overhead required for Rayo.
We have developed a proof-of-concept implementation in Python
to evaluate the performance of Fulgor. We interact with the API of
lnd [1], the recently released Lightning Network implementation,
We use listchannels to extract the current capacity of an open payment channel, listpeers to extract the list of public keys from other
users in the network, and getinfo to extract the user’s own public
key. We have instantiated the hash function with SHA-256. We
have implemented the Multi-Hop HTLC using a python-based implementation of ZK-Boo [63] to create the zero-knowledge proofs.
We set ZK-Boo to use SHA-256, 136 rounds to achieve a soundness
error of the proofs of 2
−80, and a witness of 32 bytes as in [69].
Implementation-level Optimizations. During the protocol description, we have assumed that the sender creates a different anonymous communication channel with each intermediate user. In our
implementation, however, we use Sphinx [31] to create a single
anonymous communication channel between sender and receiver,
where intermediate nodes are the intermediate users in the path.
Sphinx allows to send the required payment information to each
intermediate user while obfuscating the information intended for
other users in the path and the actual length of the path by padding
the forwarded data. This optimization has been discussed in the bitcoin community and implemented in the current release of lnd [9].
Testbed. We have simulated five users and created a linear structure of payment channels: user i has payment channels open only
with user i − 1 and user i + 1, user 0 is the sender, and user 4 is
the receiver of the pay operation. We run each of the users in a
separated virtual machine with an Intel Core i7 3.1 GHz processor
and 2 GB RAM. The machines are connected in a local network
with a mean latency of 111.5 milliseconds. For our experiments,
we assume that each user has already opened the corresponding
payment channels and got the public verification key of each other
user in the PCN. As this is a one time setup operation, we do not
account for it in our experiments.
Performance. We have first executed the payment operation available in the lnd software, which uses the HTLC-based payment as
the contract for conditional updates in a payment channel. We observe that a (non-private) pay operation over a path with 5 users
takes 609 ms and so needs Fulgor. Additionally, the Sdr must run
the SetupHTLC(n +1) protocol, increasing thereby her computation
time. Moreover, the Sdr must send the additional information corresponding to the Multi-Hop HTLC contract (i.e., (xi
,yi
,yi+1, πi
))
to each intermediate user, which adds communication complexity.
The sender requires 309 ms to compute the proof πi for each of
the intermediate users. Each proof is of size 1.65 MB. Finally, each
intermediate user requires 130 ms to verify πi
. We focus on the
zero-knowledge proofs as they are the most expensive operation.
Therefore, the total computation overhead is 1.32 seconds (lnd
pay and Multi-Hop HTLC) and the total communication overhead
is less than 5 MB (3 zero-knowledge proofs plus the tuple of smallsize values (xi
,yi
,yi+1) per intermediate user). We observe that
previous proposal [69] required around 10 seconds to compute only
a single zero-knowledge proof. In contrast, the pay operation in
Fulgor requires less than 2 seconds of computation and to communicate less than 5 MB among the users in the path for the complete
payment operation, which demonstrates the practicality of Fulgor.
Scalability. In order to test the scalability of the pay operation
in Fulgor, we have studied the running time and communication
overhead required by each of the roles in a payment (i.e., sender,
receiver, and intermediate user). Here, we take into account that
Sphinx requires to pad the forwarded messages to the maximum
path length. In the absence of widespread PCN in practice, we set
the maximum path length to 10 in our test, as suggested for similar
payment networks such as the Ripple credit network [49].
Regarding the computation time, the sender requires 3.09 seconds to create πi for each intermediate user. However, this computation time can be improved if different πi are calculated in parallel
taking advantage of current multi-core systems. Each intermediate
user requires 130 ms as only has to check the contract for payment
channels with successor and predecessor user in the path. Finally,
the receiver incurs in few ms as she only has to check whether a
given value is the correct pre-image of a given hash value.
Regarding communication overhead, the sender must create a
message with 10 proofs of knowledge and other few bytes associated to the contract for each intermediate payment channel. So
in total, the sender must forward 17MB approximately. As Sphinx
requires padded messages at each node to ensure anonymity, every
intermediate user must forward a message of the same size.
In summary, these results show that even with an unoptimized
implementation, a payment with 10 intermediate users takes less
than 5 seconds and require a communication overhead of approximately 17MB at each intermediate user. Therefore, Fulgor induces
a relatively small overhead while enabling payments between any
two users in the PCN and has the potential to be deployed as a PCN
with a growing base of users performing payments with even 10
intermediate users in a matter of few seconds, a result in line with
other privacy preserving payment systems [49, 54].
Non-blocking payments (Rayo). Given the similarities in their
definitions, the performance evaluation for Fulgor carries over to
Rayo. Additionally, the management of non-blocking payments
requires that intermediate users maintain a list (cur) of current
in-flight payments and a queue (Q) of payments waiting to be forwarded when capacity is available. The management of these data
structures requires a fairly small computation overhead. Moreover,
the number of messages to be stored in these data structures according to the specification of Rayo is clearly linear in the length of
the path. Specifically, a payment involving a path of length k ∈ N
incurs O(c·k) message complexity, where c is bounded by the total
of concurrent conflicting payments.
7 RELATED WORK
Payment channels were first introduced by the Bitcoin community [2] and since then, several extensions have been proposed.
Decker and Wattenhofer [32] describe bidirectional payment channels [32]. Lind et al. [47] leverage trusted platform modules to use
a payment channel without hindering compatibility with Bitcoin.
However, these works focus on a single payment channel and their
extension to support PCNs remain an open challenge.
Session B5: Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 466
TumbleBit [41] and Bolt [40] propose off-chain path-based payments while achieving sender/receiver anonymity in Tumblebit
and payment anonymity in Bolt. However, these approaches are
restricted to single hop payments, and it is not clear how to extend them to account for generic multi-hop PCNs and provide the
privacy notions of interest, as achieved by Fulgor and Rayo.
The Lightning Network [60] has emerged as the most prominent
proposal for a PCN in Bitcoin. Other PCNs such as Thunder [19]
and Eclair [10] for Bitcoin and Raiden [13] for Ethereum are being
proposed as slight modifications of the Lightning Network. Nevertheless, their use of HTLC leaks a common identifier per payment,
thereby reducing the anonymity guarantees as we described in this
work. Moreover, current proposals lack a non-blocking solution for
concurrent payments. Fulgor and Rayo, instead, rely on Multi-Hop
HTLC to overcome the linkability issue with HTLC. They provide
a tradeoff between non-blocking progress and anonymity.
Recent works [49, 54] propose privacy definitions for credit networks, a payment system that supports multi-hop payments similar
to PCNs. Moreover, privacy preserving protocols are described for
both centralized [54] and decentralized credit networks [49]. However, credit networks differ from PCNs in that they do not require
to ensure accountability against an underlying blockchain. This
requirement reduces the set of cryptographic operations available
to design a PCN. Nevertheless, Fulgor and Rayo provide similar
privacy guarantees as credit networks even under those restrictions.
Miller et al [53] propose a construction for payment channels
to reduce the time that funds are locked at intermediate payment
channels (i.e., collateral cost), an interesting problem but orthogonal to our work. Moreover, they formalize their construction for
multi-hop payments as an ideal functionality. However, they focus
on collateral cost and do not discuss privacy guarantees, concurrent payments are handled in a blocking manner only, and their
construction relies on smart contracts available on Ethereum that
are incompatible with the current Bitcoin scripting system.
Towns proposed [69] a variation of the HTLC contract, based on
zk-SNARKs, to avoid its linkability problem among payment channels in a path. However, the Bitcoin community has not adopted
this approach due to its inefficiency. In this work, we revisit this
solution with a formal protocol with provable security and give an
efficient instantiation based on ZK-Boo [38].
8 CONCLUSION
Permisionless blockchains governed on global consensus protocols face, among others, scalability issues in catering a growing
base of users and payments. A burgeoning approach to overcome
this challenge consists of PCNs and recent efforts have derived
in the first yet alpha implementations such as the Lightning Network [60] in Bitcoin or Raiden [13] in Ethereum. We are, however,
only scratching the surface as many challenges such as liquidity,
network formation, routing scalability, concurrency or privacy are
yet to be thoroughly studied.
In this work, we lay the foundations for privacy and concurrency
in PCNs. In particular, we formally define in the Universal Composability framework two modes of operation for PCNs attending
to how concurrent payments are handled (blocking versus nonblocking). We provide formally proven instantiations (Fulgor and
Rayo) for each, offering a tradeoff between non-blocking progress
and anonymity. Our evaluation results demonstrate that is feasible to deploy Fulgor and Rayo in practice and can scale to cater a
growing number of users.