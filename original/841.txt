Volume leakage has recently been identified as a major threat to the
security of cryptographic cloud-based data structures by Kellaris
et al. [CCS’16] (see also the attacks in Grubbs et al. [CCS’18] and
Lacharité et al. [S&P’18]). In this work, we focus on volume-hiding
implementations of encrypted multi-maps as first considered by Kamara and Moataz [Eurocrypt’19]. Encrypted multi-maps consist of
outsourcing the storage of a multi-map to an untrusted server, such
as a cloud storage system, while maintaining the ability to perform
private queries. Volume-hiding encrypted multi-maps ensure that
the number of responses (volume) for any query remains hidden
from the adversarial server. As a result, volume-hiding schemes can
prevent leakage attacks that leverage the adversary’s knowledge of
the number of query responses to compromise privacy.
We present both conceptual and algorithmic contributions towards volume-hiding encrypted multi-maps. We introduce the first
formal definition of volume-hiding leakage functions. In terms of
design, we present the first volume-hiding encrypted multi-map
dprfMM whose storage and query complexity are both asymptotically optimal. Furthermore, we experimentally show that our construction is practically efficient. Our server storage is smaller than
the best previous construction while we improve query complexity
by a factor of 10-16x.
In addition, we introduce the notion of differentially private
volume-hiding leakage functions which strikes a better, tunable balance between privacy and efficiency. To accompany our new notion,
we present a differentially private volume-hiding encrypted multimap dpMM whose query complexity is the volume of the queried
key plus an additional logarithmic factor. This is a significant improvement compared to all previous volume-hiding schemes whose
query overhead was the maximum volume of any key. In natural
settings, our construction improves the average query overhead by
a factor of 150-240x over the previous best volume-hiding construction even when considering small privacy budget of ϵ = 0.2.
CCS CONCEPTS
• Security and privacy → Management and querying of encrypted data;
KEYWORDS
cloud storage, privacy, encrypted search, volume-hiding
1 INTRODUCTION
In this paper, we study structured encryption (STE), first introduced
by Chase and Kamara [16], which is a cryptographic primitive used
to study the security of cloud-hosted data structures. Structured
encryption schemes enable the owner of a data structure to encrypt
the data structure and outsource the storage of encrypted data
structure to a potentially untrusted third-party such as a cloud
storage system. Additionally, STE schemes allow the data owner to
perform data structure operations on the outsourced encrypted data
structure without revealing any information to the server beyond
some well-defined and “sensible” leakage function.
An important example of a STE scheme is the encrypted multimap (EMM) [17, 32] primitive which enables the storage of keys
associated to a sequence of (possibly) multiple values. Furthermore,
multi-maps allows its owner to query for a key and receive all values
associated with the key. EMM’s form the basis of many important
applications. Two such applications are searching over a corpus
of encrypted documents and performing queries over encrypted
relational databases. As a result, the construction of both efficient
and private encrypted multi-maps is a very important problem. We
now explain these applications in more detail.
Searchable encryption is a primitive first introduced by Song et
al. [51] and has continued to be well-studied in the past decade. One
can see some of the following as examples of works in searchable
encryption [2, 4–6, 9–11, 13–15, 17–19, 21, 30, 34, 42, 44, 47, 52].
Searchable encryption enables a data owner with a corpus of documents to encrypt and store the corpus to an untrusted third-party
while maintaining the ability to privately search for documents
1
Session 1C: Cloud Security I CCS ’19, November 11–15, 2019, London, United Kingdom 79
containing specified keywords. In many cases, searchable encryption uses EMMs as the main underlying primitive to map keywords
to documents that contain keywords. Although, EMMs have also
been used in many other ways.
Encrypted databases are another important application of EMMs.
The goal is to encrypt databases whose storage will be outsourced to
an untrusted third party while enabling the data owner to privately
perform database operations. We note that earlier attempts [49] at
encrypted databases used property-preserving encryption schemes
such as deterministic [6] and order-preserving [7, 8] encryption
schemes. Work by Naveed et al. [43] show that encrypted databases
built from property-preserving encryption have security vulnerabilities. Recently, Kamara and Moataz [31] present an encrypted
SQL database scheme that foregoes the use of property-preserving
encryption. Instead, they rely on EMMs to perform SQL operations
privately.
As a result of the above important applications, it is clear that
constructing EMMs that are both efficient and private is important.
While efficiency is clear to evaluate, assessing the privacy of an
EMM (and STE schemes in general) is a challenging problem. So
far, our only measure of privacy is a “sensible” or “reasonable” leakage function, which is both a vague and subjective qualifier. There
has been a lot of work that attempt to understand various leakage profiles and determine whether certain leakage profiles may
be abused to compromise privacy. The first leakage-abuse attacks
was presented by Islam et al. [29]. Many follow up works [12, 26–
28, 35, 40, 43, 50, 54] consider either different leakage profiles and/or
weaker assumptions. These attacks significantly further our understanding of the dangers of various types of leakage profiles.
Furthermore, these attacks present guidance on the necessary requirements of private STE schemes. Therefore, an important line
of research is to construct STE schemes with smaller leakage that
protect against these attacks.
In an attempt to mitigate the risk of leakage profiles, the seminal
work of Kamara and Moataz [32] introduce the notion of volumehiding EMM schemes. These schemes ensure that the number of
values (volume) associated with a single key is never leaked to the
adversary. Several of the above leakage-abuse attacks rely on the
knowledge of volume to compromise privacy. As a result, volumehiding schemes can foil such attacks. In this work, we continue the
study of volume-hiding constructions by presenting schemes with
better query and storage efficiency.
1.1 Our Contributions
In this work, we make both conceptual and algorithmic contributions in the area of volume-hiding EMMs. In particular, we present
formal definitions for volume-hiding EMMs and introduce the notion of differentially private volume-hiding EMMs. Furthermore,
we present efficient constructions for both types of EMMs.
Throughout this section, we will phrase the efficiency improvements of our constructions using multipliers. As an example, a 2x
improvement in communications means that our new construction
uses half the communication of the previous best construction.
Volume-Hiding EMMs. We start by describing our contributions
to volume-hiding encryption schemes for multi-maps. To our knowledge, we present the first formal security definition for volumehiding leakage functions. Our security definition is built on top of
the typical simulation-based security definitions for STE schemes
allowing the proof techniques from STE schemes to also be used for
volume-hiding STE schemes. Accompanying our conceptual definitional contributions, we present the following efficient, volumehiding STE scheme for general multi-maps:
Theorem 1 (Informal). Consider any multi-map MM with n
total values and let ℓ be the maximum number of values associated
with a key of MM. Then there exists a volume-hiding encrypted multimap with communication complexity of O(ℓ), server storage of O(n)
and client storage of size f (λ), for every function f (λ) = ω(1). The
leakage of the encrypted multi-map consists of only the query equality
pattern and the values ℓ and n.
Our construction is lossless (that is, it always returns all the values associated with a key) and is asymptotically optimal in terms of
storage and communication complexity. Indeed, in a losseless construction each of the n values must be stored at least once and our
construction results in server storage of about 2n. More precisely,
it can be instantiated to use (2 + α)n storage, for every constant
α > 0. Moreover, due to volume-hiding, it must be that each query
returns at least ℓ records and our construction will always return
exactly 2ℓ records. Finally, the client storage typically must include
at least a private key. Our construction requires storing a private
key in addition to just ω(1) values. We show experimentally that
our volume-hiding scheme is concretely efficient and improves on
previous best volume-hiding scheme. In particular, our scheme uses
less server storage and improves query overhead by a factor of
10-16x over [32] when encrypting multi-maps of size 1-67 MB in
the plaintext and consisting of 2
16
-2
22 total values.
Differentially Private, Volume-Hiding EMMs. As another contribution, we directly address a statement appearing in [32]: “it is
hard to imagine any non-lossy construction being able to hide response length of a query and have query complexity o(t), where t is
the maximum response length.” We introduce the notion of a differentially private volume-hiding leakage function as a weakening
of volume-hiding. Kellaris et al. [36] studied the related notion of
differentially private volume-hiding for ORAM.
We present the following differentially private, volume-hiding
encryption scheme whose query complexity for many keys are
much smaller than the maximum volume:
Theorem 2 (Informal). Consider any multi-map MM with n
total values and let, for every key, ℓ(key) denote the number of values, the volume, associated with key. Then there exists an encrypted
multi-map with communication complexityO(ℓ(key)+ f (λ)), for any
function f (λ) = ω(log λ), with server storage of O(n), and client storage of size д(λ), for any function д(λ) = ω(1). The scheme is lossless
except with probability negligible in λ. The leakage of the encrypted
multi-map consists of only query equality pattern, the number of total
values n as well as differentially private leakage of volumes of the
queried keys.
We note that, unlike volume-hiding schemes, our differentially
private scheme is able to achieve query complexity that is only
2
Session 1C: Cloud Security I CCS ’19, November 11–15, 2019, London, United Kingdom 80
dependent on the volume of the queried key. In particular, the query
complexity will be at most the volume of the query key plus an
additional logarithmic factor. In typical scenarios, most keys have
smaller volume than the maximum volume. Using experiments, we
show that our schemes can reduce query overhead by a factor of
150-240x over the previous best volume-hiding scheme [32] when
encrypting multi-maps consisting of 2
16
-2
22 values and occupy 1-67
MB in the plaintext.
By defining our new security notion of differential privacy volumehiding, we attempt to strike a tunable balance between efficiency
and privacy. The previous notion of volume-hiding considered
strong privacy that resulted in large query complexity. When defending future, feasible attacks, volume-hiding might be too strong
resulting in unnecessary query overhead. We thus look at the differential privacy framework to obtain a more efficient protocol at
the cost of weakening the security notion in a meaningful way. We
observe that all previous volume attacks on STE schemes [25, 29, 35,
40, 43] are generic and do not exploit weaknesses of specific constructions. Rather, they are attacks to the ideal world functionality.
Therefore, our generic framework will provide protection against
all of these, as well as future, attacks to ideal world functionalities.
1.2 Comparison to Previous Works
In this section, we compare our new constructions with those that
were presented in the work on volume-hiding EMMs by Kamara
and Moataz [32] as well as some naive approaches. To do this,
we briefly review their EMM constructions and compare them to
our work. For a more detailed exposition on these constructions,
we refer the reader to [32]. We summarize our comparisons in
Table 1. All shown efficiencies are taken from the suggested concrete
parameters sections of [32]. We denote the number of keys by m,
the total number of values by n, and the maximum number of values
associated with a key by ℓ.
Naive Padding. The simplest approach to volume-hiding encryption schemes is naive padding. Given any multi-map, a new multimap can be constructed where each key has ℓ values. For keys
with less than ℓ values, additional dummy values are padded until
there are ℓ values. We note that the resulting storage is m · ℓ. In
many cases, (m · ℓ) ≫ n where n is the number of total values. For
example, when m = n/2 and ℓ = n/2, the storage of naive padding
is m · ℓ = Θ(n
2
) which is quadratically larger than the number of
total values. Additionally, naive padding results in larger overhead
if the multi-map follows naturally appearing distributions such as
Zipf’s distribution. In practice, plaintext multi-maps typically use
storage on the order of the number total values n. Therefore, naive
padding uses too much storage in almost all cases and our storage
goal for volume-hiding EMMs should be close to n.
ORAMs.Another naive approach is to use oblivious RAMs (ORAMs),
which were introduced by Goldreich and Ostrovsky [23]. ORAMs
are a powerful primitive that enable access to storage hosted by a
potentially untrusted server such as a cloud storage provider without leaking any information beyond the number of accesses. As a
result, there has been a lot of work in ORAM [3, 24, 39, 46, 53] leading to logarithmic overhead constructions. Furthermore, ORAM
lower bounds [41, 48] have shown that these are the best possible constructions. A simple approach is to take any STE scheme
and replace each access using an ORAM access to suppress leakage. Furthermore, one can make an STE scheme volume-hiding by
making fake ORAM accesses until ℓ records have been retrieved.
The resulting scheme would have Θ(ℓ · logn) overhead using the
best theoretical constructions and Θ(ℓ · log2 n) using the more concretely efficient ORAM constructions. In either case, the overhead
of ORAM is too large for practical use cases.
Pseudorandom Transform. From a high level, the pseudorandom
transform [32] takes an input multi-map and generates a new multimap such that the number of values associated with each key is
generated using a pseudorandom function. As a result, there may
exist keys whose volume in the new multi-map is smaller compared
to the input multi-map. Therefore, the construction is lossy as
truncation occurs and several values are removed from the new
multi-map. The authors show that the number of truncated keys is
small when the input multi-map is Zipf’s distributed. Furthermore,
the authors of [32] show that the storage overhead is (m · ℓ)/2
which is better than naive padding. Unfortunately, this transform
is not practical as there are no guarantees for data loss (truncation)
on general multi-maps and the storage overhead is closer to naive
padding of m · ℓ than our goal of n.
Densest Subgraph Transform for General Multi-Maps. This
transform considers a bipartite graph where each of the m keys are
in one part and there are b empty bins in the other part. Each of
the m keys are assigned ℓ bins chosen uniformly at random. Each
of the, at most ℓ, values associated with a key is placed into one of
the key’s assigned bin such that at most one value appears in each
bin. After this is done for all keys, the bins are padded with dummy
values to the size of the maximum bin. By balls-and-bins analysis,
the size of the bins must be Ω(logn) size. As a result, the query
overhead becomes at least Θ(ℓ·logn). On the other hand, the storage
overhead becomes Θ(n). We note that this construction is strictly
worse in query overhead than our construction as it requires an
extra logn overhead while achieving the same asymptotic storage
overhead of Θ(n). Furthermore, we experimentally show that our
constructions achieve 10-16x query overhead improvements.
Densest Subgraph Transform for Concentrated Multi-Maps.
The last construction of [32] considered concentrated multi-maps.
That is, multi-maps where a large number of keys share many
same values. In this case, they modify the previous construction
such that this concentrated set of values will appear only once
in a single set of bins. As a result, the storage overhead becomes
Θ(n −
√
m · polylog(m)). Unfortunately, this construction requires
assuming that the planted densest subgraph problem is hard, which
has been not heavily studied. Due to the lack of cryptanalysis, it
is very difficult to find concrete parameters that can be used in
practice where security can be trusted. Furthermore, the resulting
query complexity is very large. As a result, this construction does
not seem to be usable in practice at the moment.
Final Comparison. To make a final comparison, it is clear that
our volume-hiding construction is more concretely efficient and
practical compared to all previous works. In particular, it achieves
the best storage overhead of just (2 + α) times the number of total
values. Additionally, the query overhead is only 2ℓ. In contrast, the
schemes from [32] either might lose a lot of information for general
3
Session 1C: Cloud Security I CCS ’19, November 11–15, 2019, London, United Kingdom 81
Query
Complexity
Server Storage for
General MMs
Lossy with
Non-Negligible Probability
Server Storage for
Concentrated MMs
Computational
Assumption
Naive Padding Θ(ℓ) Θ(m · ℓ) Θ(m · ℓ)
One-Way
Functions
Pseudorandom
Transform [32] Θ(ℓ) Θ(m · ℓ) ✓ Θ(m · ℓ)
One-Way
Functions
Dense Subgraph
Transform [32] Θ(ℓ · log n) Θ(n) Θ(n)
One-Way
Functions
Dense Subgraph
and Planting
Transform [32]
Θ

ℓ ·
n
polylog(m)

Θ(n) Θ(n −
√
m · polylog(m)) Planted Densest
Subgraph Problem
Ours (dprfMM) 2ℓ (2 + α)n (2 + α)n
One-Way
Functions
Ours (dpMM) 2ℓ(k) + ω(log λ) (2 + α)(m + n) (2 + α)(m + n)
One-Way
Functions
Table 1: This table compares previous volume-hiding encryption schemes for multi-maps from [32] with the constructions of
this paper. For notation, ℓ represent the volume of the largest key of the input multi-map, m denotes the number of unique
keys and n denotes the total number of values over all keys. For any queried key k, we denote by ℓ(k) as the number of values
associated with the queried key k. The value α may be any positive constant. Finally, we refer to 2
−λ as the probability of losing
data in our differentially private solution.
multi-maps and have large storage overhead (pseudorandom transform), require computational assumptions that have not been well
studied (densest subgraph for concentrated multi-maps) or require
a much larger query overhead of Θ(ℓ · logn) (densest subgraph for
general multi-maps) than our construction. Furthermore, our differentially private volume-hiding construction uses slightly more
server storage while enabling significantly smaller query overhead.
1.3 Our Techniques
In this section, we outline our techniques that enable us to construct
better volume-hiding, encryption schemes for multi-maps. We start
by considering a simple construction. Consider any key k and its
associated values v1, . . . ,vℓ(k) where ℓ(k) is the number of values
associated with key k. The server stores a dictionary in the following
manner. The value vi will appear at location FK (k || i) in the
dictionary where F is a pseudorandom function (PRF), K is the key
of the PRF and k || i is the concatenation of the key k to the index i.
Assuming the output range of the PRF F is large (like Ω(n
2
) where
n is the total number of values), there would be no collisions in the
dictionary. To query for a key k, the client would simply send the
values FK (k || 1), . . . , FK (k || ℓ(k)) and the server would return the
associated encrypted values from the dictionary.
Going towards the problem of volume-hiding, it is not clear how
to modify this EMM construction to hide the volumes of all the
keys. The first naive approach would be to send ℓ PRF values for
any key where ℓ is the maximum value of any key. Unfortunately,
this does not work. Consider a key k where ℓ(k) < ℓ. If the client
sends the values FK (k || 1), . . . , FK (k || ℓ), the server will see that
the values FK (k || ℓ(k)+1), . . . , FK (k || ℓ) do not exist in the serverheld dictionary. As a result, the server can quickly determine the
volume of key k is exactly ℓ(k). One way to mitigate this leakage
is to simply populate the dictionary with the missing values for
all keys k. However, this is similar to the naive padding approach
which would result in m · ℓ storage which is much larger than our
goal of n (the number of total values) in most cases.
Therefore, we seem to have contrasting problems now. We wish
to make sure that all PRF values for those with no value, FK (k ||
ℓ(k) + 1), . . . , FK (k || ℓ), point to some non-empty entry in the
dictionary. On the other hand, we do not want to simply insert
dummy values in for each of the PRF values and increase server
storage. The main idea to overcome these problems is to reduce the
output space of the PRF F . For example, we could attempt to reduce
the output range of the PRF F to be Θ(n). Now, the problem is to
place each of the n values into a location that is determined by F .
The remaining empty locations can be simply padded with dummy
values without, hopefully, incurring a huge storage overhead like
before. This is the exact problem that is considered in hashing
where the goal is to place n items into a space of Θ(n) locations
such that each item can be easily retrieved by looking into only
a small number of locations specified by a PRF F . One approach
to this problem would be to simply place a value into its location
specified by the PRF F . Each location will be padded to the size of
the largest bin. The classical balls-and-bins analysis shows the size
of the largest will contain Ω(logn) items. To query, a key will be
download its ℓ associated bins which would incur an Ω(ℓ · logn)
query complexity. We note an approach similar to this idea is used
by the densest subgraph transform in [32].
To avoid the additional logarithmic overhead, we will use cuckoo
hashing introduced by Pagh and Rodler [45] for our constructions.
In particular, we will use a variant presented by Kirsch et al. [38]
where an additional stash exists to exponentially decrease the probability of failure. From a high level, cuckoo hashing consists of two
tables of size (1 + α)n for a small constant 0 < α < 1. For value
vi associated with key k, the value vi will be placed into one of
the three locations: FK (k || i || 0) in table one or FK (k || i || 1) in
table two or in the stash. The stash will be stored by the client. The
remaining empty locations in each table will be filled by dummy
values and all values in both tables will be encrypted. Let us now
reconsider a query for a key k where ℓ(k) < k. The client can send
the values {FK (k || i || 0), FK (k || i || 1)}i ∈[ℓ] and the server will
4
Session 1C: Cloud Security I CCS ’19, November 11–15, 2019, London, United Kingdom 82
return all 2ℓ encrypted values in the tables. We prove that this construction is volume-hiding as the server will be unaware whether a
location is filled with a real or dummy value.
Additionally, we present a concrete optimization that further improves the communication costs of our volume-hiding encryption
scheme for multi-maps. In the above scheme, the client must send
the output of 2ℓ PRF evaluations. However, the PRF evaluations
may be easily arranged to correspond to a consecutive set of inputs.
As a result, we are able to use delegatable PRFs [22, 37] where the
2ℓ PRF evaluations can be sent using smaller communication. In our
specific application, the client will always be sending the prefix of
exactly 2ℓ evaluations. We are able to convey these 2ℓ PRF evaluations using exactly one PRF evaluation in such a way that the server
can securely expand the single PRF evaluation to the required 2ℓ
PRF evaluations. This optimization reduces the bandwidth from
the client to the server from 2ℓ PRF outputs to just one PRF output.
Finally, we describe our modifications to construct a differentially private volume-hiding EMM. A first attempt at differentially
private volume-hiding would be to send ℓ(k) + X PRF evaluations
for any key k with ℓ(k) values and X is drawn from the Laplacian distribution. The problem is that Lap(1/ϵ) may be negative
resulting in a lossy construction. Instead, we will pick some public
parameter f (λ) such that the probability that X drawn from the
Laplacian is smaller than f (λ) occurs with probability at most 2
−λ
.
By picking large enough λ and f (λ) = ω(log λ), we can guarantee
that our construction is non-lossy except with small probability
that is not observable in practice. Note, the query complexity of our
differentially private volume-hiding EMM is ℓ(k) + ω(log λ) which
is, on average, significantly smaller than the largest volume ℓ. The
only caveat is that we now need to know the volume of any queried
key. To do this, we will store a count table which, for each key k
with positive volume, stores the volume of the key ℓ(k). The count
table will be stored on the server using cuckoo hashing.
2 DEFINITIONS
Structured encryption schemes considers the problem of encrypting
a data structure. Additionally, the encrypted data structure should
enable the original data owner to be able to perform queries in
a private manner when the encrypted data structure is held by
a potentially untrusted third party server. The first definitions of
structured encryption were presented by Chase and Kamara [16].
While we can consider generic definitions for encrypting any data
structure, we focus our definitions on encrypting multi-maps exclusively.
2.1 Encrypted Multi-Maps
We start by considering the multi-map (MM) primitive, which maintains a set of m key to value vector pairs MM = {(keyi
, v®i)}i ∈[m]
where each keyi
is from the key universe K and v®i
is a tuples (or
vector) of values from the value universe V. For convenience, we
suppose that all keys are unique. That is, keyi , keyj when i , j.
Note, this assumption is without loss of generality as if there are
two equal keys keyi = keyj
, then the two tuples of values can be
combined into a single tuple of values. For any keyi
, we denote
by the number of values associated with keyi by ℓ(keyi
) (that is,
ℓ(keyi
) := |v®i
|). Note, the number of values associated with different keys can be different. We denote the maximum number of values associated by ℓ (that is, ℓ := maxi ∈[m]
ℓ(keyi
) = maxi ∈[m]
|v®i
|).
Note, we will refer to ℓ as the width of the multi-map. We denote
the total number of values by n :=
Í
i ∈[m]
ℓ(keyi
) =
Í
i ∈[m]
|v®i
|.
In terms of functionality, a multi-map provides a query operation
which takes as input key from the key universe K. The output of
the query operation with input key for a multi-map MM will be the
tuple of values associated with the key stored in MM. For example,
if key = keyi
for some i ∈ [m], then the query operation will return
the tuples v®i
. On the other hand, if key , keyi
for all i ∈ [m], then
the output of the query operation will be ⊥.
Moving towards encrypted multi-maps, we now present a formal
definition of structured encryption for multi-maps. Our STE definition will consider query algorithms with r rounds of interaction
where the data structure must correctly answer to queries using r
rounds of communication between the client and the server. However, we will only consider non-interactive (r = 1) or two-rounds
of interaction (r = 2) in this paper. We focus on schemes with few
rounds of interaction due to their practicality and efficiency as they
only use a small number of roundtrips of communication between
the client and server per query.
Definition 3 (r-Interactive, Structured Encryption for MMs). A rinteractive structured encryption scheme for multi-maps ΣMM =
(Setup,Query, Reply, Result) where r ≥ 1 consists of the r + 2
following polynomial time algorithms:
(1) (K, EMM) ← Setup(1
λ
, MM) is an algorithm executed by
the client C that takes as input the security parameter λ as
well as the input multi-map MM . The output of Setup is
a private key K as well as the encrypted multi-map EMM.
The private key K will be held by the client C while the
encrypted multi-map EMM is sent to the server S.
(2) For i ∈ {0, . . . ,r − 1}, we define the query algorithm as
Requesti ← Queryi
(K, key, Responsei−1
) that is executed
by the client C that takes as input the private key K, the key
from the key universe K as well as the server’s response,
Responsei−1
from the previous query. For the first query
(i = 0), Response−1 will be ⊥. The output is a search request
Requesti which will be sent to the server S.
(3) For i ∈ {0, . . . ,r − 1}, we define the reply algorithm as
Responsei ← Replyi
(Requesti
, EMM) that is executed by
the server S that takes as input Requesti
and the encrypted
multi-map EMM. The output of Reply will be Responsei
which is the server’s response for the i-th query.
(4) v® ← Result(K, Responser−1
) is an algorithm executed by the
client C that takes as input Responser−1
as well as the private
key K. The output will be the tuple of values v® associated
with key used to generate Request0
, . . . , Requestr−1
by the
client C.
For non-interactive encryption schemes with r = 1, we will
simply drop all subscripts and superscripts related to Query and
Reply as there will only be one algorithm for each.
2.2 Adaptive Security and Leakage Functions
The security notion of structured encryption for multi-maps is
parameterized by two leakage functions, LSetup, LQuery. Leakage
5
Session 1C: Cloud Security I CCS ’19, November 11–15, 2019, London, United Kingdom 83
function LSetup gives an upper bound on the information leaked by
the encrypted multi-map EMM generated by Setup. Leakage function LQuery instead bounds the information leaked by the request
generated by the client using Query. Note that of the algorithms
used to perform a query (that is, Query, Reply and Result) Query
is the only one that can potentially leak information to the server S
through its output Request. We next formally present the security
notion using the simulation-based game definitions. In particular,
we will consider the adaptive variant where the query operations
may be chosen adaptively by the adversary after seeing the leakage
from previous queries.
Let Σ = (Setup, {Queryi
, Replyi
}i=0,...,r−1, Result) be a structured encryption scheme for multi-maps with r rounds of interaction. To define adaptive security, we consider the following real and
ideal experiments where A is a stateful, honest-but-curious PPT
adversary, S = (SimSetup, SimQuery) is a stateful, PPT simulator
and LSetup and LQuery are the leakage functions for the setup and
query process respectively.
RealΣ, A(1
λ
) :
(1) The adversary A selects an input multi-map MM and gives
it to the challenger.
(2) The challenger C executes (K, EMM) ← Setup(1
λ
, MM)
and sends EMM to the adversary A.
(3) The adversary A will adaptively pick a polynomial number
of queries key1
, . . . , keypoly(λ)
. For each query keyj
, the
challenger C executes the {Queryi
, Replyi
}i=0,...,r−1 with
A. A receives Requesti ← Queryi
(K, keyj
, Responsei−1
)
for all i and keyj
.
(4) Finally, the adversary A outputs a bit b ∈ {0, 1}.
IdealΣ, A,S(1
λ
) :
(1) The adversary A generates an input multi-map MM.
(2) The simulator receives LSetup(MM) and returns an encrypted
multi-map EMM.
(3) The adversary A will adaptively pick a polynomial number
of queries key1
, . . . , keypoly(λ)
.
For each query keyj
, the simulator S computes Requesti
using only LQuery(key1
, . . . , keyi
, MM) as input, for all i ∈
{0, . . . ,r − 1}. Requesti
is forwarded to the adversary A.
(4) Finally, the adversary A outputs a bit b ∈ {0, 1}.
Definition 4 (Adaptive Security for r-Interactive, Structured Encryption for MMs). The r-interactive, structured encryption scheme
for multi-maps Σ is adaptively (LSetup, LQuery)-secure if there exists a stateful, PPT simulator S such that for all PPT adversaries
A:
| Pr[RealΣ, A(1
λ
) = 1] − Pr[IdealΣ, A,S(1
λ
) = 1]| ≤ negl(λ).
2.3 Typical Leakage Functions
In this section, we describe typical leakage function that have been
considered for structured encryption for multi-maps. We will follow
the terminology introduced by Kamara et al. [33].
• Query Equality: This leakage reports the equality pattern
leaking whether two queries are to the same key or not.
Formally, for a sequence of queried keys key1
, . . . , keyt
,
qeq(key1
, . . . , keyt
) = M consists of a t × t matrix such
that M[i][j] = 1 if and only if keyi = keyj
.
• Response Length: This leakage consists of the number of
values (volume) associated with queried keys. Formally, for
a sequence of queried keys key1
, . . . , keyt and a multi-map
MM, That is, rlen(MM, key1
, . . . , keyt
) =
(|MM[keyi
]|)i ∈[t] where MM[keyi
] refers to the tuple of
values associated with keyi
.
• Maximum Response Length: This leakage pattern consists of the maximum number of values associated with any
key in the multi-map. Formally, for any multi-map MM,
mrlen(MM) = ℓ = maxkey∈K |MM[key]|.
• Domain Size: This leakage pattern refers to the total number of values in the multi-map. Formally, for any multi-map
MM, dsize(MM) = n =
Í
key∈K |MM[key]|.
From a high level, the goal of volume-hiding STE schemes is to
suppress response length leakage. We will formally define volumehiding leakage functions in the next section.
2.4 Volume-Hiding Leakage Functions
Roughly speaking, a volume-hiding leakage function ensures that
the number of values associated with any single key, the volume
of the key, is not revealed and that only the maximum volume of a
key is leaked.
We start with the following definition.
Definition 5. The signature of a multi-map MM is the sequence
of pairs ((key, ℓ(key)))key∈K where ℓ(key) is the length of tuple of
values associated with key in the multi-map.
We next define the game VHGameA, L
η
(n, ℓ) for leakage functions L = (LSetup, LQuery), adversary A, and η ∈ {0, 1}.
VHGameA, L
η
(n, ℓ):
(1) A generates two signatures S0 = {(key, ℓ0(key))}key∈K and
S1 = {(key, ℓ1(key))}key∈K with n total values and maximum volume ℓ. That is,
•
Í
key∈K ℓ0(key) =
Í
key∈K ℓ1(key) = n;
• maxkey∈K ℓ0(key) = maxkey∈K ℓ1(key) = ℓ.
(2) The challenger C receives signatures S0 and S1 from the
adversary A and generates a multi-map MM with the signature Sη. Specifically, the challenger C generates ℓη(key)
arbitrary values for each key ∈ K. The challenger C then
sends LSetup(MM) to the adversary A.
(3) The adversary adaptively picks keys key1
, . . . , keyt
for query
operations. For each keyi
, the challenger C will compute
LQuery(MM, key1
, . . . , keyi
) which is sent to the adversary.
(4) Finally, the adversary A outputs a bit b ∈ {0, 1}.
We denote by p
A, L
η
(n, ℓ) the probability that A outputs 1 when
playing game VHGameA, L
η
(n, ℓ).
Definition 6 (Volume-Hiding Leakage Functions). A leakage function L = (LSetup, LQuery) is volume-hiding if and only if for all
adversaries A and for all values n ≥ ℓ ≥ 1,
p
A, L
0
(n, ℓ) = p
A, L
1
(n, ℓ).
Given the above definition of volume-hiding leakage functions,
we can now define volume-hiding, STE schemes for multi-maps.
6
Session 1C: Cloud Security I CCS ’19, November 11–15, 2019, London, United Kingdom 84
Definition 7 (Volume-Hiding, r-Interactive, Structured Encryption
for MMs). A r-interactive, structured encryption scheme for multimaps, Σ, is volume-hiding if there exists a leakage function L =
(LSetup, LQuery) such that
(1) Σ is adaptively L-secure according to Definition 4;
(2) L is a volume-hiding leakage function according to Definition 6.
We stress that our definition of a volume-hiding leakage function
is formalized through a game in which the adversary only receives
the leakage associated with the setup and queries of the STE scheme.
Specifically, the adversary does not see any encrypted multi-map
from the setup phase or requests and responses from queries. As a
result, we are able to formalize “volume-hiding” as a property of
the leakage function as opposed to the specific implementation of
any STE scheme. As a consequence, our definition applies to any
adversary A regardless of their computational power. However,
this does not imply that a volume-hiding STE scheme is secure with
respect to unbounded adversaries as the STE scheme is proven to
be only L-secure against computational adversaries.
2.5 Differentially Private Volume-Hiding
Leakage Functions
To properly define the notion of volume-hiding within the framework of differential privacy, we consider a sanitizer San. A sanitizer
San is a randomized algorithm that takes a signature S and samples
a sanitized signature. Roughly speaking, we will say that a pair
(L, San), consisting of a leakage function L and a sanitizer San, is
(ϵ, δ)-differentially private if the probabilities that an adversary A
outputs 1 in games VHGame0 and VHGame1, respectively played
on the sanitized versions San(S0) and San(S1) of two neighboring
signatures S0 and S1, are related through ϵ and δ. Let us now proceed
more formally.
Definition 8. Signatures S0 = (key, ℓ0(key))key∈K and S1 =
(key, ℓ1(key))key∈K are neighbors if there exist key0
, key1 ∈ K
such that
(1) for all key < {key0
, key1
}, ℓ0(key) = ℓ1(key);
(2) ℓ0(key0
) = ℓ1(key0
) + 1;
(3) ℓ0(key1
) = ℓ1(key1
) − 1.
We define game dpVHη
, for η = 0, 1, as in the previous section
with the only difference that the multi-set D is constructed by
applying the sanitizer San to signature Sη.
dpVHA, L,San
η
(n):
(1) A outputs neighboring signatures S0 = (key, ℓ0(key))key∈K
and S1 = (key, ℓ1(key))key∈K with n total values. That is,
Í
key∈K ℓ0(key) =
Í
key∈K ℓ1(key) = n.
(2) The challenger C receives signatures S0 and S1 from A and
samples a sanitized signature SSan = {(key, ℓSan(key)}key∈K
by running San on Sη.
(3) The challenger C constructs a multi-map MM with signature
SSan by picking ℓSan(key) arbitrary values for each key ∈ K.
C then sends LSetup(MM) to A.
(4) The adversary A adaptively picks keys key1
, . . . , keyt
for
query operations. For each keyi
, the challenger C computes
and sends LQuery(MM, key1
, . . . , keyi
) to the adversary.
(5) Finally, the adversary A outputs a bit b ∈ {0, 1}.
We denote by p
L,S,San
η, A
the probability that adversary A outputs 1
when playing game dpVHL,S,San
η
Definition 9 (Differentially Private Volume-Hiding Leakage Functions). We say that (L,S) is (ϵ, δ)-differentially private volumehiding if for all n and for all adversaries A that output two neighboring signatures with the same total number of values n, it holds
that
p
L,S,San
0, A
(n) ≤ e
ϵ
· p
L,S,San
1, A
(n) + δ .
If δ = 0, we will simply say ϵ-differential private instead of (ϵ, δ)-
differential private. Note also that a volume-hiding leakage function
is (0, negl(n))-differentially private with respect to the identity
sanitizer Id that, for every signatures S, returns the signature itself.
Our definition follows the differentially private literature (see
[20] as an example) where the sanitizer is used to preprocesses the
data-base (the multi-map in our setting) before being stored. In our
construction of Section 4, the multi-map will be implicitly sanitized
at query time. The effect on the mitigating leakage will be identical
to sanitization at setup time but it will result in a smaller server
storage.
3 VOLUME-HIDING EMM
In this section, we describe our volume-hiding structured encryption scheme for multi-maps. To our knowledge, our construction is
the first to achieve both asymptotically optimal query and storage
complexity. Furthermore, we show that our construction is concretely efficient using experiments. In Section 5, we show that our
constructions use less server storage and improve query overhead
by a factor of 10-16x over the previous best constructions [32].
One of the major tools that will be used in our construction is
cuckoo hashing, which we now describe.
Cuckoo Hashing. Cuckoo hashing was introduced by Pagh and
Rodler [45] and consists of two algorithms Build and Search. Given
n key-value pairs (key1
, value1), . . . , (keyn, valuen), Build constructs Table consisting two arraysT1 andT2 each with the capacity
to hold t = (1 + α)n pairs for any constant α > 0. The Build algorithm inserts the pairs one at the time using two hash functions
h1,h2 : K → [t]. To insert pair X = (keyi
, valuei), Build places X
in location T1[h1(keyi
)]. If the location is empty, we are done. If the
location is currently occupied by another pair, Y = (keyj
, valuej),
Y is evicted and the algorithm attempts to inserting Y in location
T2[h2(keyj
)]. Again if the location is empty, we are done. Otherwise we evict the pair Z found in T2[h2(keyj
)] and try to insert Z
in the location of T1 specified by h1, and so on. Note that cuckoo
hashing guarantees that a pair (keyi
, valuei) is found either at
T1[h1(keyi
)] or T2[h2(keyi
)]. Thus, Search only retrieves two table
locations. We say that cuckoo hashing fails if a key-value pair is
not inserted after Θ(logn) evictions. It is possible to show that all
n key-value pairs will be successfully inserted with large constant
probability. Unfortunately, this failure probability is too large for
privacy reasons and this has been used to compromise privacy of
oblivious RAMs (see, e.g.,[39]).
Cuckoo Hashing with a Stash. As a result, we resort to a modification of cuckoo hashing presented by Kirsch, Mitzenmacher and
7
Session 1C: Cloud Security I CCS ’19, November 11–15, 2019, London, United Kingdom 85
Wieder [38] that introduces a stash S of some fixed capacity s. After
Θ(logn) evictions, if a key-value pair has not been inserted yet, the
pair is be inserted into the stash. Cuckoo hashing with a stash fails
if strictly more than s items are attempted to be inserted into the
stash. The introduction of the stash reduces the failure probability
exponentially in the stash size:
Theorem 10. For constants d, α > 0, there exists algorithm Build
that stores n pairs into two arrays T1 and T2 of size (1 + α)n and a
stash S. Then. the probability that, after all n pairs have been inserted
with at most d logn evictions, S has size greater than s is O(n
−s
).
For a proof, see Theorem 2.1 of [38] and the extension to nonconstant sized stashes in [24].
High-Level Description of vhMM. We start by describing our
volume-hiding, multi-map encryption scheme from an intuitive
level. Consider any multi-map MM storing {keyi
, v®i }i ∈[m] with
n total values and a maximum volume of ℓ. The Setup algorithm
will store the n values using cuckoo hashing with a stash with two
tables,T1 andT2, of size t = (1+α)n for any constant α > 0. We will
use a PRF F that output values in the range [t]. Consider the j-th
value, v®i[j] associated with keyi
. Then, (keyi
, v®i[j]) will be assigned
locations T1[FK (keyi
|| j || 0)], T2[FK (keyi
|| j || 1)] or the stash
using the cuckoo hashing insertion algorithm. If we set the stash to
be f (n) = ω(1), then the insertion will fail with probability at most
O(n
f (n)
) = negl(n). All empty table locations will be filled with a
dummy value. All table locations are then encrypted. The resulting
encrypted table will be the encrypted multi-map EMM outsourced
to the server. The small stash containing at most f (n) = ω(1) values
will be stored by the client.
We now move onto the query operation for our STE scheme.
The Query algorithm executed by the client will simply send the
2ℓ values {FK (keyi
|| j || 0), FK (keyi
|| j || 1)}j ∈[ℓ]
to the server. The
server executes Reply by returning the encrypted values located at
{T1[FK (keyi
|| j || 0)],T2[FK (keyi
|| j || 1)]}j ∈[ℓ]
. The client retrieves
the tuple of associated values by decrypting all table locations in
the server’s response as well as checking the stash.
Formal Description of vhMM. We now formally present our
first volume-hiding STE scheme for multi-maps vhMM. In particular, our construction will use pseudorandom family of functions
F = {Fs }s ∈ {0,1}⋆ and an IND-CPA secure encryption scheme
E = (Enc, Dec). Furthermore, our construction is parameterized by
a function f (n) = ω(1) and a constant α > 0.
(K, EMM) ← vhMM.Setup(1
λ
, MM = {keyi
, v®i }i ∈[m]
):
(1) Randomly select PRF seed KPRF ← {0, 1}
λ
.
(2) Randomly select encryption key KEnc ← {0, 1}
λ
.
(3) Create two empty arrays, T1,T2 of length t = (1 +α)n where
n =
Í
i ∈[m]
|v®i
|.
(4) Initialize Stash ← ∅.
(5) For each i ∈ [m] and each j ∈ [|v®i
|]:
(a) Insert (keyi
, v®i[j]) using the cuckoo hashing with a stash
insertion algorithm where (keyi
, v®i[j]) is assigned to one
of T1[FKPRF (keyi
|| j || 0)], T2[FKPRF (keyi
|| j || 1)] or Stash.
(6) If Stash contains more than f (n) items, abort.
(7) For each location in T1 or T2 that is empty, insert (⊥, ⊥) into
the location.
(8) For each i ∈ [t]:
(a) Set T1[i] ← Enc(KEnc,T1[i]).
(b) Set T2[i] ← Enc(KEnc,T2[i]).
(9) Set the private key as K ← (KPRF,KEnc, Stash).
(10) Set EMM ← (T1,T2).
(11) Return (K, EMM).
Request ← vhMM.Query(K, key):
(1) Parse K as (KPRF,KEnc, Stash).
(2) Return (FKPRF (key ||i || 0), FKPRF (key ||i || 1))i ∈[ℓ]
.
Response ← vhMM.Reply(Request, EMM):
(1) Parse Request as {ind0,i
, ind1,i }i ∈[ℓ]
.
(2) Return (T1[ind0,i],T2[ind1,i])i ∈[ℓ]
.
v® ← vhMM.Result(K, key, Response):
(1) Parse K as (KPRF,KEnc, Stash).
(2) Parse Response as (ct0,i
, ct1,i)i ∈[ℓ]
.
(3) Set v® ← ∅.
(4) For each i ∈ [ℓ]:
(a) Set (key′
, value′
) ← Dec(KEnc, ct0,i).
(b) If key′ = key, v® ← v® ∪ {value′
}.
(c) Set (key′
, value′
) ← Dec(KEnc, ct1,i).
(d) If key′ = key, v® ← v® ∪ {value′
}.
(5) For each (key′
, value′
) ∈ Stash:
(a) If key′ = key, v® ← v® ∪ {value′
}.
(6) Return v®.
Security. We now describe the leakage of vhMM due to algorithms
Setup and Query. From a high level, the EMM reveals to the adversarial server (2 + 2α)n encrypted key-value pairs. As a result,
LSetup = dsize which is the leakage functions that reveals the number n of total values in MM. For each query, the adversarial server
learns two things. First, the adversarial server learns query equality
by observing identical 2ℓ PRF values. Secondly, the adversary learns
the maximum volume of a key in MM. So, LQuery = (qeq, mrlen).
Note, that LQuery and LSetup do not include the response length
leakage rlen and thus, intuitively, vhMM is volume-hiding. We
prove the following two lemmata in Appendix A.
Lemma 1. Let L = (dsize, (qeq, mrlen)). For every constant α > 0
and f (n) = ω(1), vhMM is an adaptive L-secure non-interactive STE
scheme for multi-maps.
Lemma 2. Leakage function L = (dsize, (qeq, mrlen)) is volumehiding.
By combining the two lemmas above we obtain the main theorem
of this section
Theorem 11. Non-interactive STE for multi-maps vhMM is volumehiding.
Efficiency. By Theorem 10, the probability that the Stash grows
larger than f (n) is at most n
−f (n) = negl(n). The outsourced EMM
contains exactly (2 + 2α)n encryptions of key-value pairs. The
client generates 2ℓ PRF values during vhMM.Query and the server
responds with 2ℓ key-value encryptions during vhMM.Reply. The
client stores two private keys and the Stash consisting of at most
f (n) key-value pairs.
Theorem 12. Non-interactive STE for multi-maps vhMM aborts
with negligible probability. It requires (2 + 2α)n storage on the server.
8
Session 1C: Cloud Security I CCS ’19, November 11–15, 2019, London, United Kingdom 86
Each query requires 4ℓ communication between the client and the
server. The client stores O(1) private keys as well as at most f (n) =
ω(1) key-value pairs.
3.1 Improving Communication
In this section, we present an improvement to our construction
vhMM from the previous section. First, we take a careful look at
vhMM to look for any wasteful parts. In particular, consider the
way that each of the n key-value pairs of the input multi-map are
assigned to table locations. For vhMM, any value v®i[j] associated
with keyi will be assigned to locations FKPRF (keyi
|| j || 0) and
FKPRF (keyi
|| j || 1). As a result, vhMM.Query requires the client
to send 2ℓ PRF values. This seems quite wasteful as the 2ℓ table
locations associated with keyi are very structured. We show that
we can modify vhMM such that the Request generated by Query
can be compressed to only contain a single PRF value as opposed
to 2ℓ values. To do this, we will use delegatable PRFs.
Delegatable PRFs. A family of delegatable PRFs (dPRF), first discussed in [37], enables the owner of the secret seed K to delegate
an untrusted party to compute FK (x) for all values x ∈ S, where S
is a subset taken from a specified family of subsets. The delegation
is obtained by computing a token tokS that allows the computation
of the PRF for all x ∈ S, without any further intervention of the
owner without accessing the secret seed. The security requirement
is that all values FK (x) for x < S remain indistinguishable from
truly random values even for an adversary that has access to tokS .
Note that this can be trivially achieved by having the owner release
the value of FK (x) for all x ∈ S. Thus, the goal of dPRFs is to construct tokens of size o(|S |). To construct efficient dPRFs, we will use
the famous GGM PRF construction which we describe next.
The GGM PRF construction. The GGM construction [22] builds a
family of PRFs F = {FK (·)} from a length-doubling pseudorandom
generator G as follows. For any input v of length λ bits, G(v) will
result in 2λ bits. For convenience, we denote the first λ bits of
the G(v) as G0(v) and the last λ bits of G(v) as G1(v). Consider a
function F{0,1}
λ : {0, 1}
t → {0, 1}
λ with a private key and output
of the same length λ. The GGM construction uses a binary tree
of height t where each node of the tree is labeled with a binary
string encoding the path from the root to the node itself using
the convention that left is encoded by a “0” and right is encoded
by a “1” and the root at level 0 is labeled with the empty string
⊥. Every node with label x1, . . . , xi ∈ {0, 1} is associated with
value FK (x1, . . . , xi) computed in the following recursive manner.
The root, labeled with the empty string ⊥, is assigned the value
FK (⊥) := K. If a node is associated with value v, then its left child
is associated withG0(v), the first λ bits ofG(v), and its right child is
associated with G1(v), the last λ bits of G(v). This recursive rule is
equivalent to defining FK (x1, . . . , xi) := Gxi
(Gxi−1
(· · ·Gx1
(K) · · · )).
The PRF output FK (X) for any t-bit string X ∈ {0, 1}
t
is the value
associated with the leaf with label X. The authors of [22] show
that values associated with leaf nodes are indistinguishable from
random values for any computational adversary.
Delegating Prefixes. In [37], the above GGM construction of a PRF
is used to implement a delegatable PRF for subsets of strings with
matching prefixes. More formally, the construction of [37] consists
of two efficient algorithms: algorithm dPRF.GenTok that takes as
input the private dPRF key K and an s-bit prefix X = x1, . . . , xs
with s ≤ t and outputs a token tokX ; and algorithm dPRF.Eval that
takes the token for the s-bit prefix X, tokX and string Y ∈ {0, 1}
t−s
and computes the value FK (X || Y). In other words, dPRF.Eval
enables computation of the PRF evaluation of any string whose
prefix is X.
dPRF.GenTok for a prefixX is implemented by returning tokX :=
FK (X) where F is the GGM PRF construction. For any string Y with
prefix X, dPRF.Eval is implemented by simply computing the values the node labeled Y from its ancestor node labeled by X in the
GGM PRF construction. This can be done since the pseudorandom
generator G is public. For security of dPRF, we only consider adversaries that perform prefix-free string queries. Prefix-free string
queries refer to the fact that each query must not be a prefix of
any query. In [37], it is shown that the resulting queried tokens are
computationally indistinguishable from random values.
High-Level Description of dprfMM. We now describe the modifications to vhMM using prefix delegatable PRFs. The main idea is
to replace all instances of a PRF in vhMM with a prefix dPRF. For
cuckoo hashing, a value v®i[j] associated with keyi will be assigned
to the locations FK (keyi
|| j || 0) in table 1 and FK (keyi
|| j || 1) in
table 2 where F is the GGM PRF construction. Furthermore, each
j ∈ [ℓ] will be represented using a ⌈log2
ℓ⌉-bit string.
We modify Query such that to query any key, the client will
construct a token tokkey that will delegate the computation for
the PRF for any value whose prefix matches key. In particular,
this enables the adversarial server to compute the set of PRF values {FK (key || i || 0), FK (key || i || 1)}i ∈[ℓ] as they all have
the shared prefix key. Note that tokkey consists of the single PRF
value FK (key). As a result, dprfMM reduces the client-to-server
communication from 2ℓ PRF values to just a single PRF value.
Detailed Description of dprfMM. The functions Setup and Reply
remain the same as vhMM except replacing the PRF F with the
prefix dPRF F construction above.
Request ← dprfMM.Query(K, key):
(1) Parse K as (KPRF,KEnc, Stash).
(2) Compute tokkey ← dPRF.GenTok(KPRF, key).
(3) Return tokkey.
Response ← dprfMM.Reply(Request, EMM):
(1) Parse Request as tokkey.
(2) For each i ∈ [ℓ]:
(a) Compute FKPRF (key || i || 0) ← dPRF.Eval(tokkey,i || 0).
(b) Compute FKPRF (key || i || 1) ← dPRF.Eval(tokkey,i || 1).
(3) Return {T1[FKPRF (key || i || 0)],T2[FKPRF (key || i || 1)]}i ∈[ℓ]
.
Security. We note that the leakage of dprfMM is identical to vhMM
where LSetup = dsize and LQuery = (qeq, mrlen). The proof of
security can be found in Appendix B.
Theorem 13. dprfMM is an adaptive L = (dsize, (qeq, mrlen))-
secure STE scheme for multi-maps when f (n) = ω(1) and any constant α > 0.
Theorem 14. dprfMM is volume-hiding.
Efficiency. Note that dprfMM reduces the client-to-server communication from 2ℓ PRF values to one PRF seed of length equal to the
9
Session 1C: Cloud Security I CCS ’19, November 11–15, 2019, London, United Kingdom 87
security parameter. Server-to-client communication stays 2ℓ which
is asymptotically optimal.
Theorem 15. Construction dprfMM requires (2 + 2α)n storage
on the server. Each query requires ℓ + 1 communication between the
client and the server. The client stores O(1) private keys as well as at
most f (n) = ω(1) key-value pairs. Both the client and server perform
O(ℓ) computation.
4 DIFFERENTIALLY PRIVATE
VOLUME-HIDING EMM
In this section, we describe our construction of a STE scheme for
multi-maps which is differentially private volume-hiding. In particular, we will slightly modify the dprfMM to be differentially private
while improving the query complexity significantly. In the resulting
scheme, the client will have to fetch some information from the
server before being able to actually issue the query and thus the
scheme is not non-interactive.
Note, all volume-hiding constructions pad queries to the maximum volume resulting in Ω(ℓ) query complexity. To be completely
volume-hiding, this is necessary to hide the queried key with the
largest volume as opposed to other queries with smaller volumes.
For differentially private volume-hiding, we can relax our privacy
guarantees. Instead, we will perturb the volume of each key by a
small amount related to the privacy budget ϵ. As a result, the query
complexity for any key is dependent only on the volume of the
key as opposed to the maximum volume. We now implement these
ideas to obtain our differentially private volume-hiding scheme.
High-Level Description of dpMM. To obtain dpMM, we perform
a slight modification to dprfMM. Setup will store all the values of
the multi-map using cuckoo hashing via a delegatable PRF. Additionally, the server will also construct an additional cuckoo hash
table for a count table. Specifically, the count table will store ℓ(key),
denoting the number of values associated with key, for each key
in the input multi-map with non-zero volume.
Queries will be two rounds as opposed to one round. First, the
client downloads ℓ(key) using cuckoo hashing from the server.
Next, the client will generate tokkey using the dPRF. However, the
client will also generate an integer that is dependent on the volume
of key denoted by ℓ(key). In particular, the client will also send the
value f (ℓ(key), λ) := 2ℓ(key)+l
∗
(λ)+noise(key) along with tokkey.
The value noise(key) is drawn according to distribution Lap(2/ϵ),
which is the Laplacian distribution with parameter 2/ϵ. We point
out that this value will be identical each time key is queried. This
is accomplished by drawing from a Laplacian distribution using
pseudorandom bits derived using key. We pick the value l
∗
(λ) later.
Reply is modified such that the server will only expand the
dPRF at values FK (key || i || 0), FK (key || i || 1) where 1 ≤ i ≤
f (ℓ(key), λ). Similarly, the server will only return the encrypted
values at table locations for these values. As a result, the query
complexity is f (ℓ(key), λ). Note that if noise(key) = Lap(2/ϵ) <
−l
∗
(λ), then our construction might be lossy as some possible values
associated with key stored in the cuckoo hash tables will not be
returned to the client. As a result, we pick l
∗
(λ) = ω(log λ) such that
Pr[Lap(2/ϵ) < −l
∗
(λ)] is negligible in λ. Therefore, all associated
values will be returned except with negligible probability.
Detailed Description of dpMM. Setup will be almost identical
except that the client will also store a count table in the EMM using
cuckoo hashing. For an input multi-map {keyi
, v®i }i ∈[m]
, the client
will store CT := {keyi
, ℓ(keyi
)}i ∈[m] where ℓ(keyi
) is the number
of values associated with keyi
. Note, dpMM will consist of four
functionsQuery0
, Reply0
,Query1
and Reply1 which constitutes the
additional round of interaction.
(K, EMM) ← dpMM.Setup(1
λ
, MM = {keyi
, v®i }i ∈[m]
):
(1) Execute (K, EMM) ← dprfMM.Setup(1
λ
, MM).
(2) Create two empty arrays, CT1,CT2 of length t = (1 + α)n.
(3) Generate a StashCT ← ∅.
(4) For each i ∈ [m]:
(a) Insert (keyi
, ℓ(keyi
)) using the cuckoo hashing with a
stash insertion algorithm where (keyi
, ℓ(keyi
)) is assigned
to one ofT1[FKPRF (CT || keyi
|| 1)],T2[FKPRF (CT || keyi
||
1)] or StashCT.
(5) If StashCT contains more than f (n) items, abort.
(6) For each location in CT1 or CT2 that is empty, insert (⊥, ⊥)
into the location.
(7) For each i ∈ [t
′
]:
(a) Set CT1[i] ← Enc(KEnc,CT1[i]).
(b) Set CT2[i] ← Enc(KEnc,CT2[i]).
(8) Set the private key as K ← K ∪ StashCT.
(9) Set EMM ← EMM ∪ {CT1,CT2}.
(10) Return (K, EMM).
Request0 ← dpMM.Query0
(K, key):
(1) Parse K as (KPRF,KEnc, Stash).
(2) Return tokCT | |key ← dPRF.GenTok(KPRF,CT || key).
Response0 ← dpMM.Reply1
(Request0
, EMM):
(1) Parse Request as tokCT | |key.
(2) Get FKPRF (CT || key || 0), FKPRF (CT || key || 1) using
dPRF.Eval(tokCT | |key, 0) and dPRF.Eval(tokCT | |key, 1).
(3) Return CT1[FKPRF (CT || key || 0)],CT2[FKPRF (CT || key ||
1)].
Request1 ← dpMM.Query1
(K, key, Response0
):
(1) Use StashCT and Response0
to retrieve ℓ(key). If ℓ(key) is
not found, set ℓ(key) ← 0.
(2) Parse K as (KPRF,KEnc, Stash).
(3) Compute tokkey ← dPRF.GenTok(KPRF, key).
(4) Compute noise(key) ← Lapkey(2/ϵ).
(5) Compute X ← ℓ(key) + l
∗
(λ) + noise(key).
(6) Return (tokkey,X).
Response1 ← dpMM.Reply1
(Request1
, EMM):
(1) Parse Request as (tokkey,X).
(2) For each i ∈ [X]:
(a) Compute FKPRF (key || i || 0) ← dPRF.Eval(tokkey,i || 0).
(b) Compute FKPRF (key || i || 1) ← dPRF.Eval(tokkey,i || 1).
(3) Return {T1[FKPRF (key || i || 0)],T2[FKPRF (key || i || 1)]}i ∈[X]
.
dpMM.Result is identical to dprfMM except that the server’s
response will contain less than ℓ encrypted key-value pairs.
Correctness. The probability that not all values are retrieved is
upper bounded by the probability that noise(key) < −l
∗
(λ). Since
10
Session 1C: Cloud Security I CCS ’19, November 11–15, 2019, London, United Kingdom 88
noise(key) is distributed according to Lap(2/ϵ), we obtain that this
probability is O(e
l
∗
(λ)
) which is negligible in λ, as l
∗
(λ) = ω(log λ).
Security. We note that dpMM has almost identical leakage to both
dprfMM and vhMM except that dpMM also leaks the value ℓ(key)+
l
∗
(λ)+Lapkey(2/ϵ) for each queried key. Additionally, dpMM leaks
the number of unique keysm from the size of the cuckoo hash table
for the count table. We prove that dpMM is a differentially private
volume-hiding STE scheme for multi-maps in Appendix C due to
lack of space.
Theorem 16. dpMM is ϵ-differentially private volume-hiding.
Efficiency. Note that dpMM has almost identical efficiency to
dprfMM except for two major differences. The number of encrypted
key-value pairs in the server’s response generated by Reply is
2ℓ(key) + l
∗
(λ) + Lapkey(2/ϵ). Note, that l
∗
(λ) + Lapkey(2/ϵ) =
ω(log λ) except with probability negligible in λ. For keys with volume significantly smaller than the maximum volume ℓ, dpMM
achieves much better query complexity. Also, the outsourced EMM
consists of two cuckoo hash schemes instead of one. So, we get:
Theorem 17. For any α > 0, construction dpMM requires (2 +
2α)(m + n) storage on the server. Each query requires 1 + ℓ(key) +
ω(log λ) communication between the client and the server except
with probability negligible in λ. The client stores O(1) private keys
as well as at most f (n) = ω(1) key-value pairs. Both the client and
server perform O(ℓ(key)) + ω(log λ) computation. Furthermore, the
construction dpMM is lossy with probability negligible in λ.
4.1 Discussion of Differential Privacy
In this section, we present a discussion of when differentially private
volume-hiding suffices for security as opposed to volume-hiding.
Deciding which security definition is completely dependent on the
setting. Consider the case of input multi-maps drawn from a distribution of multi-maps with extremely different volume signatures,
In this setting, volume-hiding seems necessary.
On the other hand, consider multi-maps that closely follow the
Zipf distribution. Here, the volumes of the same key in different
possible multi-maps will not differ significantly. Therefore, differentially private volume-hiding would suffice here. Additionally,
suppose we wish to hide the identity of queried keys amongst other
keys with similar volumes. In this case, differential privacy may also
be used as the keys with similar volume will have similar leakage.
To summarize, differentially private volume-hiding is useful
when all possible input multi-maps have similar volume signatures.
Differentially private volume-hiding can protect input multi-maps
that do not have very different volumes. When attempting to protect significantly different input multi-maps, normal volume-hiding
security seems necessary. Therefore, the choice of whether to use
dprfMM or dpMM depends on the situation.
5 EXPERIMENTAL EVALUATION
In this section, we present our experimental evaluation of our two
main volume-hiding STE schemes for multi-maps: dprfMM and
dpMM. We start by describing the setup of our experiments as well
as the choice of parameters of our constructions. Then, we compare
both dprfMM and dpMM with the Densest Subgraph Transform
construction described in [32].
By performing these experiments, we attempt to answer two important questions. First, are the constructions dprfMM and dpMM
more concretely efficient compared to the previous most practically efficient construction (Densest Subgraph Transform [32])?
Secondly, what is the total cost of dprfMM and dpMM?
We will use multipliers to describe improvements in efficiency.
When we say construction A is a 2x improvement in communication
over construction B, we mean that construction A uses half the
communication used in construction B.
5.1 Experimental Setup
Our experiments are performed using the same machine for both
the client and the server. The machines used for the client and
server are Ubuntu PCs with 12 cores, 3.5 GHz Intel Xeon E5-1650
and 32 GB of RAM. All the results of our experiments have standard
deviations less than 10% of their average. Network resources costs
are measured at the application layer. Both the client and server
binaries are built using the gRPC library [1].
Input Multi-Maps. In our experiments, we will consider multimaps containing n ∈ {2
16
, 2
18
, 2
20
, 2
22} total values. We note that
all constructions under experimentation consider general multimap inputs. As a result, their efficiencies do not depend on the
structure of the multi-map but are completely determined by the
parameters n and ℓ (the maximum volume) of the input multi-map.
All keys and values will be 8 byte strings.
Primitives. In all our experiments, we consider PRFs with 16 byte
keys as well as 16 byte outputs. In particular, we implement our PRFs
using SHA256. We also use SHA256 as the pseudorandom generator
for our delegatable PRF construction. We will use AES in CBC mode
as our symmetric encryption scheme. Note that encrypting a single
key-value pair which is 16 bytes would result in a 32 byte ciphertext.
As a result, naive encryption of the input multi-map will result in a
2x overhead in storage.
5.2 Cost of Densest Subgraph Transform [32]
In the concrete parameters described in [32], it is shown that the
number of bins must be at most O(n/log2
n) to ensure that the storage overhead remains linear in the number of total values O(n).
Querying in this scheme is equivalent to downloading ℓ bins. Furthermore, each of the bins are padded to the size of the maximum
bin. Therefore, it is beneficial to ensure that the bin size remains
small. To do this, we can attempt to ensure that the number of bins
is large. For practical constants, we pick the number of bins to be
2n/(log2
n) such that the average bin size will be log2
n/2. For a
concrete EMM implementation, we use a similar delegatable PRF
scheme as our own. As a result, the upload consists of a single 16
byte PRF output. Downloading a single result consists of downloading an entire bucket which is padded to the maximum bucket
size. For each query, ℓ results will be downloaded to ensure that
the construction is volume-hiding. The experimental results of this
construction can be found in the first column of Table 2.
5.3 Cost of dprfMM
We implement the dprfMM construction in C++ using OpenSSL
for all the underlying cryptographic primitives (SHA256 and AES).
For the cuckoo hash table sizes, we will set the constant α = 0.3
11
Session 1C: Cloud Security I CCS ’19, November 11–15, 2019, London, United Kingdom 89
Densest Subgraph
Transform [32] dprfMM dpMM
Input Multi-Map
Number of Values (n) 2
16 2
18 2
20 2
22 2
16 2
18 2
20 2
22 2
16 2
18 2
20 2
22
Plaintext Raw Byte Size (MB) 1.05 4.19 16.78 67.11 1.05 4.19 16.78 67.11 1.05 4.19 16.78 67.11
EMM Storage
Server (MB) 5.53 22.74 88.25 384.40 5.45 21.81 87.24 348.97 6.81 27.26 109.05 436.21
Client Stash (KB) N/A N/A N/A N/A 0.16 0.50 1.52 4.84 0.21 0.63 1.97 6.18
Query Communication
Upload (Bytes) 16 16 16 16 16 16 16 16 36 36 36 36
Download (Bytes Per Result) 675.2 780.8 841.6 1008.0 64 64 64 64 64 64 64 64
CPU Costs
Query (Client ms) < 0.01 < 0.01 < 0.01 < 0.01 < 0.01 < 0.01 < 0.01 < 0.01 < 0.01 < 0.01 < 0.01 < 0.01
Reply (Server ms Per Result) 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02
Result (Client ms Per Result) 0.01 0.01 0.01 0.01 < 0.01 < 0.01 < 0.01 < 0.01 < 0.01 < 0.01 < 0.01 < 0.01
Table 2: Microbenchmarks for server and network costs comparing volume-hiding STE schemes. We denote n as the total
number of values in the input multi-map. If ℓ is the maximum volume of any key, then the first two column constructions
must download ℓ results. On the other hand, the number of results for dpMM will be significantly smaller than ℓ on average.
The above results apply for any input multi-map structure, query distribution as well as any value ℓ. We denote milliseconds
by ms.
such that both tables hold a total 2.6n encrypted key-value pairs.
We set the number of maximum evictions before being placed into
the stash at 5 log2
n. A query consists of uploading a single 16 byte
PRF output and downloading two encrypted locations per result.
Comparing to the Densest Subgraph Transform [32], we see
that dprfMM uses smaller server storage overall. Furthermore, as
the multi-map increases size, dprfMM starts using significantly
smaller amounts of server storage. For example, for the 2
22 value
multi-map, dprfMM uses approximately 40 MB less server storage.
In terms of query overhead, dprfMM is significantly better. For
each result, dprfMM downloads two encrypted locations resulting
in only 64 bytes. This is a 10-16x improvement over the Densest
Subgraph Transform [32] which requires 675 bytes (10 times more
than dprfMM) per result for the multi-map with 2
16 values and
increases to 1 KB (16 times more than dprfMM) per result for the
multi-map with 2
22 values. Looking at the pattern, dprfMM will
have even better query overhead improvements as we consider
larger multi-maps. The only tradeoff that is made is that the client
must store an additional stash. However, the stash is very small in
practice consisting of at most 4 KB. This additional client storage is
much smaller than the server storage gains of dprfMM.
In terms of CPU cost, we note that dprfMM is almost identical
to the Densest Subgraph Transform [32]. The main difference is
that during Reply, the Densest Subgraph Transform has to decrypt
significantly larger strings as opposed to dprfMM. As a result, the
CPU cost of dprfMM in Reply is smaller.
5.4 Cost of dpMM
We also implement dpMM in C++ using OpenSSL for all underlying
cryptographic primitives. In particular, we modify dprfMM in two
ways to obtain dpMM. First, dpMM additionally sends an integer
during query as well as another PRF for retrieving an entry from the
count table costing another 16 byte PRF value. For our experiments
appearing in Table 2, we assume close to the worst case in our
experiments for dpMM where the number of keys is m = n/4
which causes a very large cuckoo hashing table for counts.
The cost of slightly increased server storage for dpMM is offset
by the main benefit of dpMM, which is that the total number of
results that will be downloaded is much smaller than the other two
constructions. To demonstrate these gains, we consider a natural
setting of a multi-map of n = 2
20 values and m = n/8 = 2
17
keys following the Zipf distribution with parameters m and 1. As a
result, the volumes of the multi-map from largest to smallest will be
(
n
Hm
, . . . ,
n
m·Hm
) where Hm :=
Í
i ∈[m]
i
−1
is the harmonic number.
In our case, Hm ≈ 12.36 when m = 2
17
.
We construct dpMM with a privacy budget of ϵ = 0.2 for strong
differential privacy guarantees. To pick the value l
∗
(λ), we will
ensure that dpMM is lossy with probability at most 2
−64. We know
that Pr[Lap(2/ϵ) ≤ 2t/ϵ] ≤ e
−t
. By setting t := 56.1, we can
guarantee that the probability that a single key is truncated is
Pr[Lap(2/ϵ) ≤ 2t/ϵ] ≤ 2
−64−17. Therefore, the probability that at
least one of the m = 2
17 is truncated is at most 2
−64. By our choice,
we set l
∗
(λ) = 5610. Note, we are being very pessimistic as we
picked a small privacy budget of ϵ = 0.2 and a small truncation
probability of 2
−64. By choosing larger privacy budgets or larger
truncation probabilities which might be suitable in certain settings,
dpMM would incur smaller query overhead.
In Figure 1, we show the number of results downloaded by
dpMM and dprfMM. It is clear that for all queried keys except the
one with the largest volume, dpMM downloads significantly fewer
results compared to dprfMM. Consider the average case where
keys are chosen uniformly at random from the input multi-map
following Zipf’s distribution. In this case, the volume of the average
key is 8. As a result, the average number of returned results for
dpMM is 5618 while dprfMM must return more than 84,000 results (15 times more than dpMM). Since both dpMM and dprfMM
communicate 64 bytes per result, dpMM is a 15x improvement in
query communication over dprfMM. Additionally, we note that the
12
Session 1C: Cloud Security I CCS ’19, November 11–15, 2019, London, United Kingdom 90
Figure 1: Comparison of number of downloaded results by
dprfMM and dpMM.
Densest Subgraph Transform [32] also returns 84,000 results but
each result requires communicating 841.6 bytes. As a result, dpMM
is an 150-240x improvement in average query overhead over the
Densest Subgraph Transform.
6 CONCLUSIONS
In this work, we present a volume-hiding scheme dprfMM that is
practically more efficient than any previous volume-hiding scheme.
dprfMM always uses less server storage compared to the previous
construction. Furthermore, dprfMM improves the communication
costs of queries by a factor of 10-16x over the previous best constructions [32] when encrypting multi-maps that occupy 1-67 MB in the
plaintext and consist of 2
16
-2
22 total values. From an asymptotic
perspective, dprfMM is the first construction with both asymptotically optimal storage and query overhead. We also present the first
formal definition of volume-hiding leakage functions.
In addition, we also introduce the notion of differentially private volume-hiding which strikes a better, tunable balance between
privacy and efficiency. We present dpMM that is able to significantly improve the average query overhead over the previous best
volume-hiding schemes [32] by a factor of 150-240x when encrypting multi-maps with 2
16
-2
22 total values that occupy 1-67 MB in
the plaintext.
Altogether, we significantly further the field of volume-hiding
encrypted multi-maps by presenting both conceptual (formal definitions) and algorithmic (constructions that are both asymptotically
and practically efficient) contributions.