One of the fundamental challenges that hinder further adaption
of decentralized cryptocurrencies is scalability. Because current
cryptocurrencies require that all transactions are processed and
stored on a distributed ledger – the so-called blockchain – transaction throughput is inherently limited. An important proposal
to significantly improve scalability are off-chain protocols, where
the massive amount of transactions is executed without requiring
the costly interaction with the blockchain. Examples of off-chain
protocols include payment channels and networks, which are currently deployed by popular cryptocurrencies such as Bitcoin and
Ethereum. A further extension of payment networks envisioned for
cryptocurrencies are so-called state channel networks. In contrast to
payment networks that only support off-chain payments between
users, state channel networks allow execution of arbitrary complex
smart contracts. The main contribution of this work is to give the
first full specification for general state channel networks. Moreover,
we provide formal security definitions and prove the security of our
construction against powerful adversaries. An additional benefit of
our construction is the use of channel virtualization, which further
reduces latency and costs in complex channel networks.
CCS CONCEPTS
• Security and privacy → Cryptography;
KEYWORDS
state channel networs; virtualization; blockchain protocols; provable secure protocols
1 INTRODUCTION
In recent years we have witnessed a growing popularity of distributed cryptocurrencies such as Bitcoin [25] or Ethereum [34].
The underlying main innovation of these currencies is a consensus mechanism that allows their users to maintain the so-called
blockchain (or ledger). One of the most interesting potential applications of such currencies are the microtransactions [23, 28, 30, 33],
i.e., transactions of very small values (typically less than 1 cent) that
are executed instantaneously. Once implemented, they could enable
many novel business models, e.g., fair sharing of WiFi connection,
or devices paying to each other in the “Internet of Things”.
Unfortunately, blockchain-based systems face inherent challenges that make it very hard, if not impossible, to use them directly
for microtransactions. Firstly, each transaction that is processed via
the network has to be stored on the blockchain. Moreover, consensus on the blockchain requires significant time to confirm transactions, e.g., in Bitcoin confirmation takes at least around 10 minutes.
This imposes a fundamental limit on how many transactions can be
processed per second (for instance, the Bitcoin network is currently
limited to process up to 7 transactions per second [3]). Finally, the
miners that process transactions, ask for fees. Once these fees surpass the actual value assigned to a transaction, micropayments
become much less attractive.
A prominent tool for addressing the above challenges are offchain channels [2, 8, 19–21, 29, 31] that allow two users to rapidly
exchange money between each other without sending transactions
to the blockchain. Channels are implemented using so-called smart
contracts, which allow to transfer money according to complex
program rules. Below we will first briefly describe this concept, and
then give a short introduction to the state of the art in off-chain
channels.
Smart contracts. Informally speaking, smart contracts (or simply:
“contracts”) are programmable money, described in form of selfenforcing programs that are published on the ledger. Technically,
the term “smart contract” can have two meanings: (1) a contract
code which is a static object written is some programming language,
and (2) a contract instance (a dynamic object that executes this code
and is running on a blockchain, or inside of a state channel, see
below). In the sequel we will often use this distinction (which is
similar to the distinction between “programs” and “processes” in
operating systems). One can think of a smart contract instance
as a trusted third party to which users can send coins, and that
can distribute coins between the parties, according to conditions
written in its code. Probably the best known currency that supports
contracts of an arbitrary complexity is Ethereum [34], and its most
popular contract language is Solidity. In this system, a contract
instance never acts by itself, and its actions have to be triggered by
the users (who pay the so-called fees for every contract execution).
The users communicate with the contract instances using functions
calls (from the contract code). An instance is deployed on the ledger
by a call from a special function called constructor. For more details
on smart contracts and their formal modeling we refer to Sec. 3.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 949
Payment channels. Payment channels are one of the most promising proposals for addressing the scalability challenges in cryptocurrencies. The main idea behind this technology is to keep the massive bulk of transactions off-chain. To this end, the parties that
want to open a channel deploy a special “channel contract” on the
blockchain and lock a certain amount of coins in it. Afterwards
they can freely update the channel’s balance without touching the
ledger. The blockchain is contacted only when parties involved in
the payment channel want to close the channel, or if they disagree,
in which case the channel contract handles fair settlement. In the
normal case, when the two parties involved in the payment channel
play honestly and off-chain transactions never hit the blockchain
before the channel is closed, payment channels significantly improve on the shortcomings of standard blockchain-based payments
mentioned above: they limit the load put on the blockchain, allow
for instantaneous payments, and reduce transaction fees.
The idea of payment channels has been extended in several directions. One of the most important extensions are the so-called
payment networks, which enable users to route transactions via
intermediary hubs. To illustrate this concept, suppose that P1 has
a payment channel with P2, and P2 has a payment channel with
P3. A channel network allows P1 to route payments to P3 via the
intermediary P2 without the need for P1 and P3 to open a channel between each other on the ledger. This reduces the on-chain
transaction load even further. The most well known example of
such a system is the Ligthning network that has been designed and
implemented by Poon and Dryja over Bitcoin [29]. It is based on a
technique called hash-locked transactions, in which each transaction
that is sent from P1 to P3 is routed explicitly via P2 – meaning that
P2 confirms that this transaction can be carried out between P1 and
P3. For further details on hash-locked transactions, we refer the
reader to, e.g., the description of the Lightning network [29] and to
the full version of this paper [13].
Virtual payment channels. An alternative technique for connecting channels has recently been proposed in [12] under the name
“channel virtualization”. Using this technique two parties can open a
virtual channel over two “extended payment channels” running on
the ledger.1 Consider the example already mentioned above, where
P1 and P3 are not connected by a payment channel, but each of
them has an extended payment channel with an intermediary called
P2. In contrast to connecting payment channels via hash-locked
transactions, virtual payment channels have the advantage that the
intermediary P2 does not need to confirm each transaction routed
via him. As argued in [12], virtual channels can further reduce
latency and fees, while at the same time improving availability.2
To distinguish the standard channels from the virtual ones, the
former ones are also called ledger channels. In [12] the authors
present only a construction of virtual payment channels over a single intermediary hub, leaving the general construction as an open
research problem. Addressing this shortcoming is one important
contribution of our work.
1Concretely, the contract representing the extended payment channel offers additional
functionality to support connecting two payment channels.
2Availability is improved because payments via the virtual channel can be completed
even if the intermediary is temporarily off-line.
State channels. A further generalization of payment channels
are state channels [5], which radically enrich the functionality of
payment channels. Concretely, the users of a state channel can,
besides payments, execute complex smart contracts in an off-chain
way. Alice and Bob who established a state channel between each
other can maintain a “simulated ledger for contracts” and perform
the execution of contracts on it “without registering them on the
real blockchain”. This happens as long as the parties do not enter
into a conflict. The security of this solution comes from the fact
that at any time parties can “register” the current off-chain state
of the channel on the real blockchain, and let the channel contract
fairly finish the execution of the contract. Examples of use cases for
state channels are manifold and include contracts for digital content
distribution, online gaming or fast decentralized token exchanges.
In contrast to payment channels, there has been only little work
on general state channels.3 One prominent project whose final goal
is to implement general state channels over Ethereum is called
Raiden [1], but currently it only supports simple payments, and a
specification of protocols for full state channel networks has not
been provided yet. The concept of an off-chain state maintained by
parties was formalized in the work of Miller et al. [24], where it is
used as a main building block for the payment channel construction.
In contrast to [24], our general state channel construction allows
two parties to have a virtual state channel whose opening does
not require any interaction with the blockchain. This significantly
improves the time complexity and the cost of a state channel creation. To our best knowledge, the only work considering longer
general state channels is [4] recently published by Coleman et
al. and developed independently from our work. The work of [4]
lacks formal definitions and security proofs. On the other hand, it
includes several features useful for practical implementation. We
are in contact with the authors of [4] and planing collaboration to
further improve our construction and move provably secure state
channel networks closer to practice.
1.1 Our contribution
As described above, until now there has not been any satisfactory
formal construction or security definition of general state channel
networks. The main contribution of this work is to address this
shortcoming by providing the first construction for building state
channel networks of arbitrary complexity together with a formal
definition and security analysis. Our construction (i) allows users
to run arbitrary complex smart contracts off-chain, and (ii) permits
to build channels over any number of intermediaries. Below we
describe our core ideas in more detail.
Constructing state channel networks. In order to construct the
general state channel networks, we follow a modular recursive
approach where virtual state channels are built recursively on top
of ledger or other – already constructed – virtual state channels. For
a high-level description of our recursive approach see Sec. 2 (and
Fig. 1 therein). As long as everybody is honest, the intermediaries in
the virtual channel are contacted only when the channel is opened
and when it is closed (and the ledger is never contacted). On the
3A state channel that is not application specific and allows to run arbitrarily complex
contracts, is called a general state channel. Since we consider only general state channels
in this work, we usually omit the word “general” for brevity.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 950
other hand, let us stress that no intermediary can lose its coins even
if all other parties are dishonest and every user of a virtual state
channel has the guarantee that he can execute a contract created
in a virtual state channel even if all other parties collude.
Modeling state channel networks and security proofs. In addition
to designing the first protocols for state channel networks, we develop a UC-style model for “state channel networks” – inspired by
the universal composability framework introduced in the seminal
work of Canetti [9]. To this end, similarly to [12], we model money
via a global ledger ideal functionality Lband describe a novel ideal
functionality for state channel networks that provide an ideal specification of our protocols. Using our model, we formally prove that
our protocols satisfy this ideal specification. Key challenges of our
analysis are (i) a careful study of timings that are imposed by the
processing of the ledger, and (ii) the need to guarantee that honest
parties cannot be forced to lose money by the fact that the contracts
are executed off-chain even if all other parties collude and are fully
malicious.
We emphasize that in the context of cryptocurrencies, a sound
security analysis is of particular importance because security flaws
have a direct monetary value and hence, unlike in many other
settings, are guaranteed to be exploited. The later is, e.g., illustrated
by the infamous attacks on the DAO [32]. Thus, we believe that
before complex off-chain protocols are massively deployed and
used by potentially millions of users, their specification must be
analyzed using formal methods as done in our work using UC-style
proofs.
Optimistic vs. pessimistic execution times. While constructing our
protocols we will provide the “optimistic” and “pessimistic” execution times. The “optimistic” ones refer to the standard case when
all parties behave honestly. In the optimistic case all our protocols
allow for instantaneous off-chain contract execution, and a possible
delay depends only on the latency of the network over which parties
communicate. The “pessimistic” case corresponds to the situation
when the corrupt parties try to delay the execution as much as they
can by forcing contract execution on the blockchain. In our solution
the pessimistic execution times grow linearly with the number of
intermediaries ℓ involved. Notice that these pessimistic times can in
reality happen only in the unlikely case when all but one party are
corrupt. Since the main goal of this paper is to introduce the general
framework, and not to fine-tune the parameters, we leave it as an
important direction for future work to improve our construction
and optimize these timings, possibly using the techniques of [24].
Further related work. One of the first proposals for building payment channels is due to Decker [11], who in particular also introduced a construction for duplex payment channels. An alternative
proposal for payment channel networks has been given by Miller
et al. [24]. In this work, the authors show how to reduce the pessimistic timings to constant time (i.e., independent of the length of
the channel path). It is an interesting question for future work to
combine the techniques from [24] with the channel virtualization.
Several works focus on privacy in channel networks, path finding
or money re-balancing in payment channels [19, 21, 31]. In particular, [12, 21, 24] also provide a UC-based security analysis of their
P1 P2 P3 P4 P5 P6
γ1
γ3
γ4
γ2
Figure 1: Example of a recursive construction of a virtual
state channel γ4 (of length 5) between P1 and P6.
constructions. Channel constructions based on the sequence number maturity (that we also use in this paper) have been mentioned
already in [29], and recently described in more detail (as “stateful
duplex off-chain micropayment channels”) by Bentov et al. in [8].
Another challenge in building and maintaining complex channel
networks is the fact that parties have to continuously watch what
happens on the blockchain regarding the state of their channels.
This problem can be addressed using so-called watchtowers [22, 27],
to which users can outsource the task of watching the blockchain.
1.2 Organization of the paper
We begin with an informal description of our state channel construction in Sec. 2, where we explain how state channels are created
and how they can be used. Due to the page limit, the complete protocol description is given in the the full version of this paper [13],
but the specification, which, we believe is more important for future work, e.g., for protocol design, is presented in details in the
main body (see Sec. 4). We introduce the necessary formalism and
present security and efficiency properties required from a general
state channel in Sec. 3. Our modular approach of building state
channels is discussed in Sec. 5. Finally, we conclude in Sec. 6.
2 STATE CHANNEL CONSTRUCTION
Before we proceed to the more technical part of this work, let us give
an intuitive explanation of our virtual state channel construction.
We would like to emphasize that the description of our approach
as presented in this section is very simplified and excludes many
important technicalities. Formal definitions, detailed explanations
of our protocols, and their full description are presented in Sections
3—5, Appx. A and in the full version of this paper [13]. As already
mentioned in Sec. 1.1, we follow a recursive approach, which is
shown for the case of 6 parties on Fig. 1 where we consider parties
P1, . . . , P6, with each Pi being connected with Pi+1 via a ledger state
channel Pi ⇔ Pi+1. To build a virtual state channel γ4 := P1 ↔ P6,
we first create a virtual state channel γ1 := P1 ↔ P3 using ledger
state channels P1 ⇔ P2 and P2 ⇔ P3. Then a virtual state channel
γ2 := P4 ↔ P6 is created using ledger state channels P4 ⇔ P5 and
P5 ⇔ P6. The other virtual state channels are created recursively,
as follows: first, channel γ3 := P1 ↔ P4 is created using the virtual
state channel γ1 and the ledger state channel P3 ⇔ P4, and then
channel γ4 is created using the virtual state channels γ3 and γ2.
Ledger state channels – an overview. The terminology for ledger
state channels is given in Sec. 3. and their construction is discussed
in detail in Appx. A.1.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 951
Below we explain only the main idea of the ledger state channel construction. A ledger state channel δ between Alice and Bob
allows them to execute off-chain instances of some contract code
C. An example could be a lottery game contract Clot, where each
user deposits 1 coin and then one user is randomly chosen to receive 2 coins. Technically, this is implemented using the standard
cryptographic method based on commitment schemes (see, e.g.,
[6]), where the execution of the contract happens in the following
steps: first the parties deposit their coins in the contract instance
(call the resulting initial state of the game G0)
4
, then Alice sends to
the contract her commitment to a random bit rA ∈ {0, 1} (which
results in stateG1), afterwards Bob sends his random bitrB ∈ {0, 1}
to the contract (denote the resulting state G2). Then, Alice opens
her commitment, the final state G3 is computed, and 2 coins are
given to Alice if rA ⊕ rB = 0, or to Bob (otherwise). Finally, the
contract instance terminates. Technically, the previous steps are
implemented via function calls. For example: sending a bit rB by
Bob can be implemented as function call Reveal(rB) (where Reveal
is a function available in Clot that stores rB in the storage of the
contract).
As described in Sec. 1, two parties create a ledger state channel
by deploying a state channel contract, (SCC), in which each party
locks some amount of coins. Once the ledger state channel δ is
established, parties can open instances of the contract code C in
the channel and execute them. For example the parties can open a
channel in which each of them locks 10 coins and then run several
instances of the lottery contract Clot in this channel. Every contract
instance locks 1 coin of each party (from the coins that are locked
in channel δ). A locked coin cannot be used for any other contract
instance in δ. Once the contract instance terminates, the coins are
unlocked and distributed back to the channel δ according to the
rules of C. The state channel contract on the blockchain guarantees
that if something goes wrong during the off-chain execution (parties
disagree on a state of some contract instance, one of the parties
stops communicating, etc.), they can always fairly resolve their
disagreement and continue the execution via the state channel
contract on the blockchain.
Off-chain contract execution in the ledger state channels. Let us
now take a closer look how the off-chain contract execution is done
via the ledger state channel. Let C be a contract code, and let G
denote the (dynamically changing) instance of C that is executed
in δ. To deploy G both parties agree on the initial state G0 of G.
The parties then exchanging signatures on (G0, 0). The rest of the
execution is done by exchanging signatures on further states of G
together with indices w that denote the version numbers. Assume
that Alice wants to call a function f (with some parameters m) in
the contract instance. Let (Gw ,w) be the last state of the contract
instance G on which the parties exchanged their signatures. She
then (1) computes locally the new valueGw+1 of the state, by calling
f (m) on Gw , and then (2) sends signed (Gw+1,w + 1) together with
f and m to Bob. Bob checks if Alice’s computation was correct, and
if yes then he replies with his signature on (Gw+1,w + 1). When
4A reader familiar with Ethereum may object that “simultaneous” contract instance
deployment is not allowed (as Ethereum does not support “multi-input” transactions).
We stress that the example above illustrates a contract that is run “inside of a channel”
(not on blockchain) and is compatible with our construction.
the instance G terminates, the coins resulting from this execution
are distributed between the parties according to the outcome of the
game.
For example if G is an instance of the lottery contract Clot described above then the states of the game are G0,G1,G2 and G3.
Since the first move of the game is done by Alice, she locally computes the new state G1 and sends it to Bob together with her commitment to rA and her signature on (G1, 1). Then Bob replies with
his signature on (G1, 1). Thereafter, Bob makes his move, i.e., he
computes G2, sends signed (G2, 2) together with his random bit rB
to Alice, and so on. Note that the interaction of the parties with
the contract instance is always “local”, i.e., the parties themselves
compute the new states of G and then just exchange signatures.
As long as both Alice and Bob are honest, everything is done
without any interaction with the blockchain. If, however, one party
cheats (e.g. by refusing to communicate), the other party can always
ask the SCC contract to finish the game. The version number w is
used to make sure that SCC gets always the latest state of the game.
More concretely: the contract is constructed in such a way that if a
malicious party submits an old state, then the other party can always
“overwrite” this state by providing a signed state of the contract
instance with a higher version number. Once the SCC contract learns
the latest state Gw , the game can be finished (starting from Gw )
on-chain via SCC.
Virtual state channels – an overview. As described above, the
virtual state channels are constructed recursively “on top” of the
ledger state channels. Suppose that Alice and Bob want to run some
contract code C (e.g. the lottery game) in an off-chain way in γ .
This time, however, they do not have an open ledger state channel
between each other. Instead, both Alice and Bob have a channel
with a third party, which we call Ingrid. Denote these channels α
and β respectively. With the help of Ingrid but without interacting
with the blockchain, Alice and Bob can open a virtual state channel
γ that has the same functionality and provides the same guarantees
as if it would be a ledger state channel between them. In particular,
Alice and Bob are allowed to create a contract instance of C in
their channel γ and execute it just by communicating with each
other (i.e. play their game without talking to any third party or the
blockchain).
Recall that in case of the ledger state channels every dispute
between Alice and Bob is resolved by the state channel contract,
SCC. For the virtual state channel γ the role of such a “judge” is
played by Ingrid. The main difference from the previous case is
that, unlike SCC (that is executed on the ledger), Ingrid cannot be
trusted, and in particular, she may even collude with a corrupt
Alice or Bob. In order to prevent parties from cheating, we create
special contracts in each of the ledger state channels α and β. Their
code will be called “virtual state channel contract” (VSCC) and their
instances will be denoted να and νβ
, respectively. The instances να
provides security guarantees for Alice, and νβ
for Bob. In addition,
both contract instances together provide guarantees for Ingrid. The
contract code VSCC has to depend on the code C since it needs to
interpret the code C in case the parties enter into a dispute (see
below). Note that SCC depends on VSCC, and hence, indirectly, on C.
This dependence is summarized in Fig. 2.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 952
Alice Ingrid Bob
Blockchain
α
VSCC
β
VSCC
γ
C
SCC SCC
Figure 2: Construction of a virtual state channel γ1 of length
2 in which a contract instance of C is created.
Creating the virtual state channel. Let us explain the virtual state
channel creation in more detail. In the first step Alice and Bob
inform Ingrid about their intention to use her as an intermediary
for their virtual state channel γ . Alice does so by proposing to open
an instance να of VSCC in the channel α. This instance will contain
all information about the virtual state channel γ (for example: how
many coins each party wants to lock in the channel). In some sense
να can be viewed as a “copy” of the virtual state channel γ in which
Ingrid plays the role of Bob — for example, if the initial balance in
γ is 1 coin for Alice and 5 coins for Bob, then Alice would lock 1
coin and Ingrid 5 coins in να . Symmetrically, Bob proposes a new
instance νβ of VSCC in the ledger state channel β that can be viewed
as a “copy” of the virtual state channel γ in which Ingrid plays the
role of Alice. In the example above, Ingrid would lock 1 coin and
Bob 5 coins in νβ
. If Ingrid receives both proposals and she agrees
to be the intermediary of the virtual state channel γ , she confirms
both requests.
Contract execution in the virtual state channel γ . The off-chain
contract execution in the virtual state channel is performed exactly
in the same way as in case of the ledger state channels (see paragraph “Off-chain contract execution in the ledger state channels”
above). That is, as long as both Alice and Bob are honest, they
execute a contract instance G by exchanging signatures on new
versions of the game states without talking to Ingrid at all, and
without updating να and νβ
. The case when Alice and Bob disagree
needs to be handled differently, since the parties cannot contact
the blockchain contract, but have to resolve this situation using
the channels α and β that they have with Ingrid. Consider, for example, the situation when, in the scenario described above, Bob
is malicious and stops communicating with Alice, i.e. he does not
send back his signature on (Gw+1,w + 1). In this situation, Alice
has to make her move “forcefully” by using the channel α she has
with Ingrid. More concretely, she will execute the contract instance
να . It is very important to stress that the virtual state channel construction uses this instance in a black-box way, i.e., when describing
the protocols for virtual state channel execution this protocol uses
the execution of να in a black-box way via the interface of the
underlying channel. Internally, of course this is done by a protocol
between Alice and Ingrid realizing the off-chain execution of να
(as long as Alice and Ingrid are honest).
First, Alice starts the “state registration procedure”. The goal is to
let να know that she has a disagreement with Bob, and to convince
να that Gw is the latest state of the contract instance G. To this end,
she sends to να the state (Gw ,w,sB), where sB is Bob’s signature on
(Gw ,w). She does it by calling a function “register” (see Step 1 on
Fig. 3). Of course να has no reason to believe Alice that this is really
the latest state of G. Therefore να forwards this message to Ingrid5
,
that, in turn, calls a function “register(Gw ,w,sB)” of the contract
instance νβ
in channel β (see Step 2). Bob now replies (in Step 3)
to νβ with his latest version of the contract instance (i.e. he calls
“register(Gw′,w
′
,sA)”, where sA is Alice’s signature). When Ingrid
learns about Bob’s version from νβ
, she forwards this information
to να (see Step 4). Suppose that w > w
′
, i.e., Alice is honest, and
Bob is cheating by submitting and old version of the instance (the
other case is handled analogously). Then, both να and νβ decide
that (Gw ,w) is the latest version of G (i.e. they “register Gw ”).
From the point of view of Ingrid, the most important security
feature of this procedure is that there is a consensus among να and
νβ about the latest state of G (even is Alice and Bob are both dishonest and playing against her). This consensus will be maintained
during the entire execution of G in instances να and νβ
. This is
important, as otherwise she could lose coins.6 This invariant will be
maintained throughout the rest of the “forced execution procedure”.
After the state registration is over, Alice calls (in Step 5, Fig. 3)
a function “execute(f (m))” of να , “asking” να to execute f (m) on
the contract instance G starting from the registered state (Gw ,w).
Since we want to maintain the “consensus invariant” mentioned
above, we cannot simply let να perform this execution immediately
after it receives this call. This is because some contracts may allow
both parties to call functions at the same time7
, and Bob could
simultaneously call some other function execute(f
′
(m′
)) of νβ
. This
situation is especially subtle because function execution is generally
not commutative, i.e., executing f (m) and then f
′
(m′
) can produce
different result than doing it in the different order. Consequently,
this could result in να and νβ having different states of their local
copies of γ . We solve this problem by delaying the execution of f (m)
until it is clear that no other function can be executed before f (m).
More precisely, the contract code VSCC is defined in such a way that
f (m) is only stored in the storage of the contract instance νA, resp.
νB. The internal execution of f (m) in νA, resp. νB, is performed only
when the contract instance is being terminated (which happens
when then virtual state channel γ is being closed).
Let us emphasize that the purpose of the description above is
to explain the concepts and main ideas of our construction. The
final protocol, however, works slightly differently due to several
optimizations. For example, in order to decrease the pessimistic
time complexity, the registration phase and the force execution
phase for virtual state channels are run in parallel (i.e. Step 1 and
Step 5 are happening in the same round). We refer the reader to
Appx. A.2 for more details about the construction.
Applying recursion. As already highlighted earlier, longer virtual
state channels are constructed recursively. The key observation that
enables this recursion is that the state channels α and β that are
5Recall again that this execution is realized by a protocol between Alice and Ingrid.
6
Imagine, e.g, that the final state of G in να is that Alice gets all the coins locked in G,
and the final state of G in νβ is that Bob gets all the coins locked in G. Then Ingrid
loses these coins in both channels α and β.
7Note that it is not the case of the Clot contract, since there its always clear which
party is expected to “make a move” in the game. However, in general, we do not want
to have such restrictions on contracts in this paper.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 953
Alice Ingrid Bob
α β
γ
G
να
νβ
1.
register
(Gw ,w,sB)
2.
register
(Gw ,w,sB) 3.
register
(Gw′,w
′
,sA)
4.
register
(Gw′,w
′
,sA) 5.
execute
(f (m))
6.
execute
(f (m))
Figure 3: Illustration of the forced execution process from
our example in which Alice and Bob have a virtual state
channel γ in which they opened a contract instance. Only
the function calls are shown (the messages sent by the contracts are omitted).
used to build γ are accessed in a “black-box” way. In other words,
the only property of α and β needed in the construction of γ is
that one can execute off-chain contracts in them. This “black-box”
property guarantees that our virtual state channel construction
works also if the channels α and β are virtual (not ledger), or in
case one of them is virtual, and the other one is ledger.
Let us illustrate this on the situation depicted in Fig. 1. Consider
first the virtual state channel γ3 – a virtual state channel of length 3
build on top of a virtual state channel γ1 of length 2 and the ledger
state channel P3 ⇔ P4. Assume that C is the contract code whose
instances can be opened in γ3. Following the construction described
earlier in this section, γ3 can be created if both the underlying state
channels γ1 and P3 ⇔ P4 support contract instances of the virtual
state channel contract VSCC which depends on C. This, in particular,
implies that the ledger state channels P1 ⇔ P2 and P2 ⇔ P3, on
top of which the virtual state channel γ1 is created, must support
contract instances of the virtual state channel contract VSCC′ which
depends on VSCC (thus indirectly also on C).
This reasoning can be repeated for longer channels. For example,
if C is a contract code whose instances can be opened in the virtual
state channel γ4, then contract instances of VSCC must be supported
by both γ2 and γ3, contract instances of VSCC′ must be supported
by γ1, P3 ⇔ P4, P4 ⇔ P5 and P5 ⇔ P6. Finally, contract instances
of the virtual state channel contract VSCC′′, which depends on
VSCC′
, must be supported by the ledger state channels P1 ⇔ P2,
P2 ⇔ P3. More details of this recursion, including the analysis of
pessimistic and optimistic timing, are provided in further sections.
Let us just mention here that in order to achieve linear pessimistic
time complexity (in the channel length), our construction assumes
that virtual state channels are built in a balanced way as in Fig. 1
(i.e. the two state channels used to build a virtual state channel
have approximately the same length).
The notion of time. In the description above we ignored the notion of time. This was done to simplify this informal description.
We define this notion in the technical part of the paper (see Sec. 3.3).
In our construction parties are always aware of the current time,
and they pass the time information to the contract functions in the
state channels. Time is modeled as a natural number, and the time
unit is called a round (think of it as 1 second, say).
Other key features of our construction. An important property of
our construction and our model is that we support full concurrency.
That is, we allow several virtual state channels to be created simultaneously over the same ledger state channels, and allow parties to
be involved in several concurrent executions of (possibly complex)
contracts. This is possible because our ledger state channels can
store and execute several contracts “independently”.
Another important feature of our modular construction is that
it naturally allows for building channels via multiple (possible incompatible) cryptocurrencies as long as they have a sufficiently
complex scripting language (in particular, they allow to deploy a
state channel contract). For illustration, consider Alice having a
ledger state channel with Ingrid in cryptocurrency called “A-coin”,
and Bob having a ledger state channel with Ingrid in cryptocurrency called “B-coin”. Now, Alice and Bob can build a virtual state
channel over Ingrid, where Alice (resp. Bob) is oblivious of the
details of B-coin (resp. A-coin). This makes sense as long as the
exchange rate between the currencies does not change too much
during the lifetime of the virtual channel. Note that, since the virtual channel opening and closing does not require interacting with
the ledger, the lifetime of a virtual state channel can be made very
short (minutes or hours). In addition, virtual state channels also
improve on privacy. This is the case because channel updates are
fully P2P and do not require involvement of intermediaries.
Finally, we point out that our concept of higher-level channel
virtualization has the key feature that it adds further “layers of
defense” against malicious parties before honest users need to communicate with the blockchain. Consider, for example, the situation
shown in Fig. 1. Even if P6 and the intermediary P4 in the virtual
state channel γ4 are corrupt, then P1 can resolve possible conflicts
via the intermediary P3 using the virtual state channel γ1, i.e. P1
does not need to communicate with the ledger.
3 DEFINITIONS AND SECURITY MODEL
In the sequel, following [12], we present tuples of values using
the following convention. The individual values in a tuple T are
identified using keywords called attributes: attr1, attr2, . . .. Strictly
speaking an attribute tuple is a function from its set of attributes
to {0, 1}
∗
. The value of an attribute attr in a tuple T (i.e. T (attr))
will be referred to as T .attr. This convention will allow us to easily
handle tuples that have dynamically changing sets of attributes.
We assume that (Gen, Sign, Vrfy) is a signature scheme that is
existentially unforgeable against a chosen message attack (see, e.g.,
[17]). The ECDSA scheme used in Ethereum is believed to satisfy
this definition.
3.1 Definitions of contracts and channels
We now present our syntax for describing contracts and channels.
The notation presented in this section can be viewed as an extension
of the one used in [12]. In the rest of this paper we assume that the
set P = {P1, . . . , Pn } of parties that use the system is fixed.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 954
Contracts. We consider only contracts executed between two
parties. A contract storage is an attribute tuple σ that contains at
least the following attributes: (1) σ .userL, σ .userR ∈ P that denote
the users involved in the contract, (2) σ .locked ∈ R≥0 that denotes
the total amount of coins that is locked in the contract and (3)
σ .cash: {σ .userL, σ .userR } → R that denotes the amount of coins
that the users have freely available. It must hold that σ .locked ≥
σ .cash(σ .userL) + σ .cash(σ .userR). Let us explain the difference
between locked coins and freely available coins as well as the above
inequality on a concrete example. Assume that parties are playing
a game where each party initially invests 5 coins. During the game,
parties make a bet, where each party puts 1 coin in the “pot". Now
the amount of coins locked in the game did not change, it is still
equal to 10 coins; however, the amount of freely available coins
decreased (each party has only 4 freely available coins). In addition
to the attributes mentioned above, a contract storage may contain
other application-specific data.
We will now define formally the notion of contract code that
was already described informally in Sec. 1. Formally a contract
code consists of some functions (in Ethereum they are written
in Solidity) that operate on contract storage. The set of possible
contract storages is usually restricted (e.g. the functions expect
that it has certain attributes defined). We call the set of restricted
storages the admissible contract storages and typically denote it Λ.
Formally, we define a contract code as a tuple C = (Λ,д1, . . . ,
дr, f1, . . . , fs ), where Λ are the admissible contract storages and
д1, . . . ,дr are functions called contract constructors, and f1, . . . , fs
are called contract functions. Each contract constructor дi
is function
that takes as input a tuple (P, τ , z), with P ∈ P, τ ∈ N, and z ∈
{0, 1}
∗
, and produces as output an admissible contract storage σ
or a special symbol ⊥ (in which case we say that the contract
construction failed). The meaning of these parameters is as follows:
P is the identity of the party that called the function, τ is the current
round (see Sec. 3.3 for more on how we model time and rounds),
and z is used to pass additional parameters to дi
. The constructors
are used to create a new instance of the contract. If the contract
construction did not fail, then дi(P, τ , z) is the initial storage of a
new contract instance.
Each contract function fi takes as input a tuple (σ, P, τ , z), with
σ ∈ Λ being an admissible contract storage, P ∈ {σ .userL, σ .userR },
τ ∈ N and z ∈ {0, 1}
∗
(the meaning of this parameters is as before).
It outputs a tuple (σ˜ , addL, addR,m), where σ˜ is the new contract
storage (that replaces contract storage σ in the contract instance),
values addL, addR ∈ R≥0 correspond to the amount of coins that
were unlocked from the contract storage to each user (as a result
of the execution of fi
), and m ∈ {0, 1}
∗ ∪ {⊥} is an output message.
If the output message is ⊥, we say that the execution failed (we
assume that the execution always fails if a function is executed
on input that does not satisfy the constraints described above, e.g.,
it is applied to σ that is not admissible). If the output message
m , ⊥, then we require that σ˜ is an admissible contract storage
and the attributes userL and userR in σ˜ are identical to those in σ.
In addition, it must hold that addL + addR = σ .locked − σ˜ .locked.
Intuitively, this condition guarantees that executions of a contract
functions can never result in unlocking more coins than what was
originally locked in the contract storage.
As described in Sec. 1 a contract instance represents an instantiation of a contract code. Formally, a contract instance is an attribute tuple ν with a contract storage and code, where ν .code =
(Λ,д1, . . . ,дr, f1, . . . , fs ) is a contract code, and ν .storage ∈ Λ is a
contract storage.
Ledger state channel. We next present our terminology for ledger
state channels, which is inspired by the notation for payment channels used in [12]. Formally, a ledger state channel γ is defined as
an attribute tuple γ := (γ .id,γ .Alice,γ .Bob,γ .cash,γ .cspace). We
call the attribute γ .id ∈ {0, 1}
∗
the identifier of the ledger state
channel. Attributes γ .Alice ∈ P and γ .Bob ∈ P are the identities of
parties using the ledger state channel γ . For convenience, we also
define the set γ .end–users := {γ .Alice,γ .Bob} and the function
γ .other–party as γ .other–party(γ .Alice) := γ .Bob and γ .other–
party(γ .Bob) := γ .Alice. The attribute γ .cash is a function mapping the set γ .end–users to R≥0 such that γ .cash(T ) is the amount
of coins the party T ∈ γ .end–users has locked in the ledger state
channel γ . Finally, the attribute γ .cspace is a partial function that
is used to describe the set of all contract instances that are currently open in this channel. It takes as input a contract instance
identifier cid ∈ {0, 1}
∗
and outputs a contract instance ν such that
{ν .storage.userL, ν .storage.userR } = γ .end–users. We will refer
to γ .cspace(cid) as the contract instance with identifier cid in the
ledger state channel γ .
Virtual state channel. Formally, a virtual state channel γ is a tuple
γ := (γ .id,γ .Alice,γ .Bob,γ .Ingrid,γ .subchan,γ .cash,γ .cspace,γ .
length,γ .validity). The attributes γ .id, γ .Alice, γ .Bob, γ .cash and
γ .cspace, are defined as in the case of a ledger state channel. The
same holds for the set γ .end–users and the function γ .other–party.
The new attribute γ .Ingrid ∈ P denotes the identity of the intermediary of the virtual state channel. For technical reasons (see the
full version of this paper [13] for more on this) we restrict γ .cspace
for virtual state channels to contain only a single contract instance.
We emphasize that this is not a restrictions of the functionality
since ledger state channels support an arbitrary number of contract instances, and hence we can build any number of virtual state
channels.
The attribute γ .subchan is a function mapping the set γ .end–
users to {0, 1}
∗
. The value of γ .subchan(γ .Alice) equals the identifier of the ledger/virtual state channel between γ .Alice and γ .Ingrid.
Analogously for the value of γ .subchan(γ .Bob). We often call these
channels the subchannels of the virtual state channelγ . The attribute
γ .validity denotes the round in which the virtual state channel γ
will be closed (see Sec. 3.3 for more on the notion of rounds). The
reason to have this parameter is to ensure that the channel γ will not
remained open forever. Otherwise γ .Ingrid could have her money
blocked forever, as (unlike γ .Alice and γ .Bob) she cannot herself
request the channel closing. Finally, the attribute γ .length ∈ N>1
refers to the length of the virtual state channel, i.e., the number of
ledger state channels over which it is built. For example in Fig. 1
(see Page 3) we have: γ1.length = 2, γ2.length = 2, γ3.length =
3, γ4.length = 5. Sometimes it will be convenient to say that ledger
state channels have length one.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 955
3.2 Security and efficiency goals
Before presenting our formal security model in Sec. 3.3, let us start
by listing some security guarantees that are desirable for a state
channel network. In the following description, if it is not important
whether γ is ledger state channel or a virtual state channel, and
hence we will refer to γ as a state channel.
(1) Consensus on creation: A state channel γ can be successfully created only if all users of γ agree with its creation.
(2) Consensus on updates: A contract instance in a state channel γ can be successfully updated (this includes also creation
of the contract instance) only if both end-users of γ agree
with the update.
(3) Guarantee of execution: An honest end-user of a ledger
state channel γ can execute a contract function f of a created
contract instance in any round τ0 on input value z even
if the other end-user of γ is corrupt. This property holds
also for virtual state channels with the restriction that τ0 <
γ .validity.
(4) Balance security: The intermediary of a virtual state channel γ never loses coins even if both end-users of γ are corrupt.
While property (4) provides a strong monetary security guarantee
to the intermediary of a virtual state channel, the guarantees for
the end-users given by properties (2) and (3) only ensure that party
can not be forced to create a contract instance and that contract
instances can be executed at any time. We emphasize that this is
similar to what is guaranteed by the ledger to on-chain contracts.
Concretely, this means that if the contract rules allow that a certain
end-user may lose money (e.g., by losing the lottery as described
in the example from Sec. 2), then this is not in violation with the
security properties guaranteed by a state channel network.
In addition to the security properties, we identify the following
two efficiency goals. Below, by constant number of rounds we mean
that the required rounds for executing the procedure is independent
of the channel length and the ledger delay ∆ (looking ahead, the
parameter ∆ models the fact that changes on a blockchain come
with a certain delay, see Sec. 3.3 for more details).
(1) Constant round optimistic update/execute: In the optimistic case when both end-users of a state channel γ are
honest, they can update/execute a contract instance in γ
within a constant number of rounds.
(2) Constant round virtual state channel creation: Successful creation of a virtual state channel γ takes a constant
number of rounds.
3.3 Our model
To formally model the security of our construction, we use a UCstyle model following the works of [7, 12] that consider protocols
that operate with coins.
8
In particular, our model uses a synchronous
version of the global UC framework (GUC) [10] which extends the
standard UC framework [9] by allowing for a global setup.
Protocols and adversarial model. We consider an n-party protocol
π that runs between parties from the set P = {P1, . . . , Pn } which
are connected by authentic communication channels. A protocol
8Throughout this work, the word coin refers to a monetary unit.
is executed in the presence of an adversary Adv that takes as input a security parameter 1
λ
(with λ ∈ N) and an auxiliary input
z ∈ {0, 1}
∗
, and who can corrupt any party Pi at the beginning of
the protocol execution (so-called static corruption). By corruption
we mean that Adv takes full control over Pi
including learning its
internal state. Parties and the adversary Adv receive their inputs
from a special party – called the environment Z – which represents anything “external” to the current protocol execution. The
environment also observes all outputs returned by the parties of
the protocol. In addition to the above entities, the parties can have
access to ideal functionalities G1, . . . , Gm. In this case we say that
the protocol works in the (G1, . . . , Gm)-hybrid model.
Modeling communication and time. We assume a synchronous
communication network, which means that the execution of the
protocol happens in rounds. Let us emphasize that the notion of
rounds is just an abstraction which simplifies our model (see, e.g,
[15, 16, 18, 26] for a formalization of this model and its relation to
the model with real time). Whenever we say that some operation
(e.g. sending a message or simply staying in idle state) takes at most
τ ∈ N∪ {∞} rounds we mean that it is up to the adversary to decide
how long this operation takes (as long as it takes at most τ rounds).
Let us now discuss the amount of time it takes for different entities
to communicate with each other. The communication between two
parties Pi takes exactly one round. All other communication – for
example, between the adversary Adv and the environment Z –
takes zero rounds. For simplicity we assume that any computation
made by any entity takes zero rounds as well.
Handling coins. We follow [12] and model the money mechanics
offered by crypotcurrencies such as Bitcoin or Ethereum via a global
ideal functionality Lbusing the global UC (GUC) model [10]. The
state of the ideal functionality Lbis public and can be accessed by all
parties of the protocol π, the adversary Adv and the environment
Z. It keeps track on how much money the parties have in their
accounts by maintaining a vector of non-negative (finite precision)
real numbers (x1, . . . , xn), where each xi
is the amount of coins
that Pi owns.9 The ledger functionality Lb is formally defined in
the full version of this paper [13] and informally described below.
The functionality Lbis initiated by the environment Z that can
also freely add and remove money in user’s accounts, via the operations add and remove. While parties P1, . . . , Pn cannot directly
perform operations on Lb, the ideal functionalities can carry out
add and remove operations on the Lb (and hence, indirectly, Pi
’s
can also modify Lb, in a way that is “controlled” by the functionalities). Every time an ideal functionality issues an add or remove
command, this command is sent to Lb within ∆ rounds, for some
parameter ∆ ∈ N. The exact round when the command is sent is
determined by the adversary Adv. The parameter ∆ models the fact
that in cryptocurrencies updates on the ledger are not immediate.
We denote a ledger functionality Lb with maximal delay ∆ by L( b ∆)
and an ideal functionality G with access to L( b ∆) by G
L( b ∆)
.
The GUC-security definition. Let π be a protocol working in the Ghybrid model with access to the global ledger L( b ∆). The output of an
environment Z interacting with a protocol π and an adversary Adv
9This is similar to the concept of a safe of [7].
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 956
on input 1
λ
and auxiliary input z is denoted as exec
L( b ∆), G
π,Adv, Z
(λ, z).
If π is a trivial protocol in which the parties simply forward their
inputs to an ideal functionality F, then we call the parties dummy
parties, the adversary a simulator Sim, and we denote the above
output as ideal
L( b ∆)
F,Sim, Z
(λ, z).
To simplify the description of our protocols and the ideal functionalities, we consider a class of restricted environments which we
denote Eres. These restrictions typically disallow the environment
to carry out certain actions, e.g., we forbid Z to instruct one party
to start a protocol without instructing the other party to start the
protocol as well.10 We emphasize that these restrictions can easily
be eliminated by integrating additional checks into the protocols
and functionalities. The restrictions defining Eres are informally
introduced in Sec. 4 and their complete list can be found in the
full version of this paper [13]. We are now ready to state our main
security definition.
Definition 3.1. Let E be some set of restricted environments. We
say that a protocol π working in a G-hybrid model emulates an
ideal functionality F with respect to a global ledger L( b ∆) against
environments from class E if for every adversary Adv there exists a
simulator Sim such that for every environment Z ∈ E we have

exec
L( b ∆), G
π,Adv, Z
(λ, z)

λ ∈N,
z ∈ {0,1}
∗
c
≈

ideal
L( b ∆)
F,Sim, Z
(λ, z)

λ ∈N,
z ∈ {0,1}
∗
(where “≈
c
” denotes computational indistinguishability of distribution ensembles, see, e.g., [14]).
Informally, the above definition says that any attack that can be
carried out against the real-world protocol π can also be carried
out against the ideal functionality F. Since the ideal functionality
is secure by design (see Sec. 4.2), also the protocol offers the same
level of security. In Sec. 5 we will discuss in more detail the roles of
F and G.
Simplifying assumptions. To simplify exposition, we omit the
session identifiers sid and the sub-session identifiers ssid. Instead,
we will use expressions like “message m is a reply to message
m′
”. We believe that this approach improves readability. Another
simplifying assumption we make is that before the protocol starts
the following public-key infrastructure is setup by some trusted
party: (1) For every i = 1, . . . ,n let (pkPi
,skPi
) ←$ KGen(1
λ
), (2)
For every i = 1, . . . ,n send the message (skPi
, (pkP1
, . . . , pkPn
)) to
Pi
. We emphasize that the use of a PKI is only an abstraction, and
can easily be realized using the blockchain.
4 STATE CHANNELS IDEAL FUNCTIONALITY
In this section, we describe the ideal functionality that defines
how ledger state channels and virtual state channels are created,
maintained and closed. Before we do so, let us establish several conventions which simplify the description of the ideal functionality.
10For readers familiar with UC, we notice that general UC composition of course
requires arbitrary environments. In the full version of this paper [13] we prove that
for our particular set of restrictions composition of our sub-protocols is preserved. An
alternative approach would be to use a wrapper. However, due to the complexity of
our protocol the description, of the wrapper would be highly convoluted.
4.1 Abbreviated notation
When it is clear from the context which state channel γ we are
talking about, we will denote the parties of γ as A := γ .Alice,
B := γ .Bob and I := γ .Ingrid. We also introduce symbolic notation
for sending and receiving messages. Instead of the instruction “Send
the messagemsд to party P in round τ ”, we writemsд
τ
,−→ P. Instead
of the instruction “Send the message msg to all parties in the set
γ .end–users in round τ ”, we write msg
τ
,−→ γ .end–users. By msg
τ←−- P we mean that an entity ( i.e. the ideal functionality) receives
a message msg from party P in round τ , and we use msg
τ ≤τ1 ←−−−−- P
when an entity receives msg from party P latest in round τ1. In the
description of the ideal functionality we use two “timing functions”:
TimeExeReq(i) that represents the maximal number of rounds it
takes to inform a party that execution of a contract instance in a
state channel of length i > 0 was requested by the other party, and
TimeExe(i) that represents the maximal number of rounds it takes
to execute of a contract instance in a state channel of length i > 0.
Both of these functions are of the orderO (∆ · i) (see the full version
of this paper [13] for formal definition of these function and their
relationship).
Each entity stores and maintains a set of all state channels it is
aware of. Following [12] this set will be called channel space and
denoted Γ. Sometimes we will abuse notation and interpret the
channel space as a function which on input id ∈ {0, 1}
∗
returns
a state channel with identifier id if such state channel exist and
otherwise ⊥. Every time a new contract instance in some of the
state channels stored in Γ is successfully created (or an existing one
is executed), the channels space Γ must be updated accordingly. To
this end we define an auxiliary procedure UpdateChanSpace. The
procedure takes as input a channel space Γ, a channel identifier
id, a contract instance identifier cid, a new contract instance ν and
two values addA and addB representing the required change in the
cash values of the state channel with identifier id. The procedure
sets Γ(id).cspace(cid) := ν, adds addA coins to Γ(id).cash(A) and
adds addB coins to Γ(id).cash(B). Finally, it outputs the updated
channel space Γ. Formal definition can be found in the full version
of this paper [13].
4.2 The ideal functionality
We denote the state channel ideal functionality by F
L( b ∆)
ch (i, C), where
i ∈ N is the maximal length of a state channel that can be opened
via the functionality, and C denotes the set of contract codes whose
instances can be created in the state channels. The ideal functionality F
L( b ∆)
ch (i, C) communicates with parties from the set P, and has
access to the global ideal functionality Lb(the ledger). F
L( b ∆)
ch (i, C)
maintains a channel space Γ containing all the open state channels.
The set Γ is initially empty.
Since inputs of parties and the messages they send to the ideal
functionality do not contain any private information, we implicitly
assume that the ideal functionality forwards all messages it receives
to the simulator Sim. More precisely, upon receiving the message
m from party P the ideal functionality sends the message (P,m)
to the simulator. The task of the simulator is to instruct the ideal
functionality to make changes on the ledger and to output messages
to the parties in the correct round (both depends on the choice made
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 957
by the adversary Adv in the real world). In the description of the
ideal functionality, we do not explicitly mention these instructions
of Sim, but instead use the following abbreviation. By saying “wait
for at most ∆ rounds to remove/add x coins from P’s account on
the ledger” we mean that the ideal functionality waits until it is
instructed by the simulator, which will happen within at most ∆
rounds, and then request changes of P’s account on the ledger. Let
us emphasize this abbreviated notation does not affect the reactive
nature of the ideal functionality (meaning that every action of the
functionality has to be triggered by some other entity).
We present the formal definition of the F
L( b ∆)
ch (i, C) functionality
in Fig. 4. Here we provide some intuitions behind this definition,
introduce the most important restrictions on the environment (see
Sec. 3.3), and argue why the ideal functionality satisfies all the
security and efficiency properties stated in Sec. 3.2. Let us note that
the constants appearing in the formal description of F
L( b ∆)
ch (i, C)
follow from the technical details of our protocols which can be
found, together with the formal proof of the security and efficiency
properties, in the full version of this paper [13].
State channel creation. The F
L( b ∆)
ch (i, C) functionality consists of
two “state channel creation” procedures: one for ledger and one for
virtual state channels. The ledger state channel creation procedure
starts with a “create” message from A (without loss of generality
we assume that A always initiates the creation process). The functionality removes the coins that A wants to deposit in the ledger
state channel from A’s account on the ledger, and waits for B to
declare that he wants to create the ledger state channel as well. If
this happens within ∆ rounds, then B’s coins are removed from
the ledger and the ledger state channel is created which is communicated to the parties with the “created” message. Otherwise A
can get her money back by sending a “refund” message. Since both
parties have to send the message “create”, the consensus on creation
security property is clearly satisfied for ledger state channels.
The creation procedure for a virtual state channelγ works slightly
differently since its effects are visible on the subchannels of γ . The
intention to create γ is expressed by P ∈ γ .end–users∪ {I } by sending a “create” message to the functionality. Once such a message is
received from P, the coins that are needed to create γ are locked immediately in the corresponding subchannel of γ (if P = I, then coins
are locked in both subchannels of γ ). If the functionality receives
the “create” messages from all three parties within three rounds,
then the virtual state channel is created, which is communicated
to γ .end–users by the “created” message.11 Thus, the consensus on
creation security property is satisfied also for virtual state channels
and since the successful creation takes three rounds, the constant
round virtual state channel creation holds as well.
After the virtual state channel is created, γ .end–users can use it
until round γ .validity. When this round comes, the parties initiate
the closing procedure. The functionality then distributes the coins
of γ back to its subchannels according to the balance in γ ’s last
version. In case there exists cid such that γ .cspace(cid) is a contract
instance with locked coins, then all of these coins go back to I in
11Note that the intermediary I is not informed whether the virtual channel has been
created. This choice is made to keep the protocol as simple as possible. Note also that
I does not need this information, as she is not allowed to update this virtual channel.
both subchannels of γ . This is to guarantee that I never loses coins
even if end-users of γ do not terminate their contract instance in γ
before γ .validity.
In both cases (“ledger” and “virtual”) we assume that all the
honest parties involved in channel creation initiate the procedure
in the same round and that they have enough funds for the new
state channel. In case of a virtual state channel, we additionally
assume that the length of its two subchannels differ at most by
one.12
Contract instance update. The procedure for updating a contract
instance is identical for ledger and virtual state channels (this procedure is also used for creating new contract instances). It is initiated
by a party P ∈ γ .end–users that sends an “update” message to the
ideal functionality. This message has parameters id and cid that
identify a state channel γ and a contract instance in this state channel (respectively). The other parameters, σ˜ and C, denote the new
storage and code of the contract instance. The party Q := γ .other–
party(P) is asked to confirm the update via an “update-requested”
message. IfQ replies with an “update-reply” message within 1 round
if both parties are honest and withinT rounds otherwise (whereT is
a function of state channel length, see Step 2), the contract instance
with identifier cid in γ gets replaced with a contract instance determined by the tuple (σ˜ , C). In the next round, both parties in γ .end–
users get notified via an “updated” message. Note that Q always
has to confirm the update which implies the consensus on update
security property. The constant round optimistic update efficiency
property holds as well since the update takes exactly 2 rounds if
both parties are honest.
We assume that the environment never asks the parties to do
obviously illegal things, like updating a contract instance in a state
channel that does not exits, or creating a contract instance when
there are not enough coins in the subchannels. Moreover, we assume
that the environment never asks to update a contract instance when
it is already being updated or executed.13
Contract instance execution. The procedure for executing a contract instance is initiated by one of the parties P ∈ γ .end–users that
sends an “execute” message to the ideal functionality in round τ0.
This message has parameters id and cid whose meaning is as in the
update procedure. Other parameters are: f denoting the contract
function to be executed, and z which is an additional input parameter to the function f . The execution results in updating the contract
instance with identifier cid according to the result of computing
f (σ, P, τ , z), where σ is the current storage of the contract instance
and τ := τ0 in case P is honest and determined by the simulator
otherwise. The other party of the state channel is notified about
the execution request before round τ0 + 5 in the optimistic case and
before round τ0 +T1 otherwise. Both parties from the set γ .end–
users learn the result of the execution before round τ0 + 5 in the
optimistic case (which implies the constant round optimistic execute)
12As discussed in Sec. 2, we make this assumption to achieve pessimistic time complexity which is linear in the state channel length.
13Although we forbid parallel updates of the same contract instance, we do not make
any restrictions about parallel updates of two different contract instances even if they
are in the same ledger state channel. This in particular means that we allow concurrent
creation of virtual state channels.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 958
Functionality F
L( b ∆)
ch (i, C)
This functionality accepts messages from parties in P. We use the abbreviated notation defined in Sec. 4.1.
Ledger state channel creation
Upon (create,γ )
τ0 ←−- A where γ is a ledger state channel:
(1) Within ∆ rounds remove γ .cash(A) coins from A’s account on Lb.
(2) If (create,γ )
τ1≤τ0+∆ ←−−−−−−−- B, remove within 2∆ rounds γ .cash(B) coins from B’s account on Lb and then set Γ(γ .id) := γ , send
(created,γ ) ,−→ γ .end–users and stop.
(3) Otherwise upon (refund,γ )
>τ0+2∆ ←−−−−−−- A, within ∆ rounds add γ .cash(A) coins to A’s account on Lb.
Virtual state channel creation
(1) Upon (create,γ ) ←−- P, where P ∈ γ .end–users ∪ {I }, record the message and proceed as follows:
• If P ∈ γ .end–users proceed as follows: If you have not yet received (create,γ ) from I, then remove γ .cash(P) coins from P’s
balance in γ .subchan(P) and γ .cash(γ .other-party(P)) coins from I’s balance in γ .subchan(P).
• If P = I, then for both P ∈ γ .end–users proceed as follows: If you have not yet received (create,γ ) from P then remove
γ .cash(P) coins from P’s balance in γ .subchan(P), and γ .cash(γ .other-party(P)) coins from I’s balance in γ .subchan(P).
(2) If within 3 rounds you record (create,γ ) from all users in γ .end–users∪ {γ .Ingrid}, then define Γ(γ .id) := γ , send (created,γ ) ,−→
γ .end–users and wait for channel closing in Step 4 (in the meanwhile accepting the update and execute messages concerning γ ).
(3) Otherwise wait until round γ .validity. Then within 2 · (TimeExeReq(⌈j/2⌉) + TimeExe(⌈j/2⌉)) rounds, where j := γ .length,
refund the coins that you removed from the subchannels in Step 1.
Automatic closure of virtual state channel γ when round γ .validity comes:
(4) Let j := γ .length. Within 2 · (TimeExeReq(⌈j/2⌉) + TimeExe(⌈j/2⌉)) rounds proceed as follows. Let γˆ be the current version of
the virtual state channel, i.e. γˆ := Γ(γ .id), and let cˆA := γˆ.cash(A) and cˆB := γˆ.cash(B).
(5) Add cˆA coins to A’s balance and cˆB coins to I’s balance in γ .subchan(A). Add cˆA coins to I’s balance and cˆB coins to B’s balance
in γ .subchan(B). If there exists cid ∈ {0, 1}
∗
such that σcid := γˆ.cspace(cid).storage , ⊥ and cˆ := σcid .locked > 0, then add cˆ
coins to I’s balance in both γ .subchan(A) and γ .subchan(B). Erase γˆ from Γ and (closed,γ .id) ,−→ γ .end–users.
Contract instance update
Upon (update, id,cid, σ˜ , C)
τ0 ←−- P, let γ := Γ(id), j = γ .length. If P < γ .end–users then stop. Else proceed as follows:
(1) Send (update–requested,id,cid, σ˜ , C)
τ0+1
,−−−→ γ .other–party(P) and set T := τ0 + 1 in optimistic case when both parties in γ .end–
users are honest. Else if j = 1, set T := τ0 + 3∆ + 1 and if j > 1, set T := τ0 + 4 · TimeExeReq(⌈j/2⌉) + 1.
(2) If (update–reply, ok, id,cid)
τ1≤T ←−−−−- γ .other–party(P), then set Γ := UpdateChanSpace(Γ, id,cid, σ˜ , C, addA, addB), where
addA := −σ˜ .cash(A) if γ .cspace(cid) = ⊥ and addA := σ .cash(A) − σ˜ .cash(A) otherwise for σ := γ .cspace(cid).storage.
The value addB is defined analogously. Then send (updated, id,cid)
τ1+1
,−−−→ γ .end–users and stop.
Contract instance execution
Upon (execute, id,cid, f , z)
τ0 ←−- P, let γ := Γ(id) and j = γ .length. If P < γ .end–users then stop. Else set T1 and T2 as:
• In the optimistic case when both parties in γ .end–users are honest, set T1 := τ0 + 4 and T2 := τ0 + 5.
• In the pessimistic case when at least one party in γ .end–users is corrupt, setT1,T2 := τ0 +4∆+5 if j = 1 and setT1 := τ0 +2 ·Time
ExeReq(⌈j/2⌉) + 5, T2 := τ0 + 4 · TimeExeReq(⌈j/2⌉) + 5 if j > 1.
(1) In round τ1 ≤ T1, send (execute–requested, id,cid, f , z)
τ1
,−→ γ .other–party(P).
(2) In round τ2 ≤ T2, let γ := Γ(id), ν := γ .cspace(cid), σ := ν .storage, and τ := τ0 if P is honest and else τ is set by the simulator.
Compute (σ˜ , addL, addR,m) := f (σ, P, τ , z). If m = ⊥, then stop. Else set Γ := UpdateChanSpace(Γ, id,cid, σ˜ , ν .code, addL,
addR) and send (executed, id,cid, σ˜ , addL, addR,m)
τ3
,−→ γ .end–users.
Ledger state channel closure
Upon (close,id)
τ0 ←−- P, let γ = Γ(id). If P < γ .end–users then stop. Else wait at most 7∆ rounds and distinguish the following two cases:
(1) If there exists cid ∈ {0, 1}
∗
such that σcid := γ .cspace(cid).storage , ⊥ and σcid .locked , 0, then stop.
(2) Otherwise wait up to ∆ rounds to add γ .cash(A) coins to A’s account and γ .cash(B) coins to B’s account on the ledger L. Then
set Γ(id) := ⊥, send (closed,id)
τ2≤τ0+8∆
,−−−−−−−−→ γ .end–users and stop.
Figure 4: The state channel ideal functionality.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 959
and before round τ0 +T2 otherwise. The values T1 and T2 are functions of state channel length, see the formal description in Fig. 4.
Observe that contract instance execution initiated by party P does
not require approval of the other party of the channel (although the
other party is informed about the execution request). This implies
that the guarantee of execution security property is satisfied.
We would like to emphasize that if two different execute messages are received by the ideal functionality at the same time (or
not too many rounds from each other), then it is up to the adversary
to decide which function is executed first.14 Designers of contract
codes and users of the protocols should be aware of this possible
asynchronicity.
Ledger state channel closure. The procedure for closing a ledger
state channel γ starts when a party P ∈ γ .end–users sends to the
ideal functionality a message (close,id), where id is the identifier
of ledger state channel γ to be closed. The functionality checks (in
Step 1) if there are no contract instances that are open over γ . If
not, then in Step 2 the functionality distributes the coins from γ to
the ledger accounts of the parties according to γ ’s latest balance,
and notifies the parties about a successful closure.
4.3 Using the state channel ideal functionality
Let us now demonstrate how to use our ideal functionality for
generalized state channel networks in practice. We do it on a concrete example of the two party lottery (already discussed in Sec. 2).
The first step is to define a contract code Clot(i) which allows two
parties to play the lottery in a state channel of length at most i.
A contract storage σ of Clot(i) has, in addition to the mandatory
attributes σ .userL, σ .userR, σ .cash and σ .locked (see Sec. 4.1), the
attribute σ .start ∈ N, whose purpose it to store the construction
round, the attribute σ .com ∈ {0, 1}
∗
, to store the commit value
when submitted by σ .userL, and the attribute σ .bit ∈ {0, 1} to store
the secret bit when provided by σ .userR.
The contract code has one constructor Initlot which generates
the initial contract storage σ such that both σ .cash(σ .userL) and
σ .cash(σ .userR) are equal to 1 (each user deposits 1 coin). The
contract functions are: (i) Com which, if executed by σ .userL on
inputc, storesc in σ .com, (ii) Reveal which, if executed by σ .userR
on input rB, stores rB in σ .bit, (iii) Open which allows σ .userL to
open the commitment stored in σ .com and pays out 2 coins to the
winner, and (iv) Punish which allows a party to unlock coins from
the contract instance in case the other party misbehaves. See the
full version of this paper [13] for a formal definition of Clot(i).
Assume now that parties Alice and Bob have a virtual state
channel γ created via the ideal functionality F
L( b ∆)
ch (i, C), where
Clot(i) ∈ C. If Alice wants to play the lottery using γ , she first locally executes the constructor Initlot to obtain the initial contract
storage σ. Then she sends the message (update,γ .id,cid, σ, Clot(i))
to F
L( b ∆)
ch (i, C) for some contact instance identifier cid never used before. The ideal functionality informs Bob about Alice’s intention to
play by sending the message (update–requested,γ .id,cid, σ, Clot(i))
to him. If Bob agrees with playing the game, he sends the reply
(update–reply, ok,γ .id,cid). Alice and Bob can now start playing
in a way we describe below (let τ0 be the current round).
14Note that this is the case also for execution of smart contracts on the blockchain.
(1) Commit: In round τ0 Alice locally chooses a random bit
rA ∈ {0, 1} and a random string s ∈ {0, 1}
λ
, where λ is the
security parameter, locally computes the commit value c
using the randomness s. Then she submits c by sending the
message (execute,γ .id,cid, Com,c) to the ideal functionality.
(2) Reveal: If before round τ0 + TimeExe(i) Bob receives a message from the ideal functionality that Alice committed to
her secret bit, Bob locally chooses a random bit rB ∈ {0, 1}
which he submits by sending the message (execute,γ .id,
cid, Reveal,rB) to the ideal functionality. Otherwise, in round
τ0 + TimeExe(i), he sends the message (execute,γ .id,cid,
Punish, ⊥) to the ideal functionality to unlock all coins from
the lottery contract by which he punishes Alice for her misbehavior.
(3) Open: If before round τ0 + 2 · TimeExe(i) Alice receives a
message from the ideal functionality that Bob reveled his
secret bit rB, she opens her commitment by sending the message (execute,γ .id,cid, Open, (rA,s)). Otherwise, in round
τ0 +2 ·TimeExe(i), she sends the message (execute,γ .id,cid,
Punish, ⊥) to unlock all coins from the lottery contract by
which she punishes Bob for his misbehavior.
(4) Finalize: If until round τ0+3·TimeExe(i) Bob did not receive
a message from the ideal functionality that Alice opened
her commitment, Bob sends the message (execute,γ .id,cid,
Punish, ⊥) to the ideal functionality to unlock all coins from
the lottery contract and finalize the game.
5 AN OVERVIEW OF OUR APPROACH
In this section we provide a high level idea of the modular design of our protocol realizing the state channel ideal functionality
F
L( b ∆)
ch (i, C) (the main ideas behind our construction were already
presented in Sec. 2).
Ledger state channels. Our first step is to define an ideal functionality F
L( b ∆)
scc (C) which models the behavior of a concrete smart
contract, which we call state channel contract. This contract allows
two parties to open, maintain and close a ledger state channel on
the blockchain. The ideal functionality is parametrized by the set of
contract codes C whose instances can be opened in the ledger state
channels created via this ideal functionality. The ideal functionality
F
L( b ∆)
scc (C) together with the ledger functionality Lb can be implemented by a cryptocurrency which supports such state channel
contracts on its blockchain (a candidate cryptocurrency would be,
e.g., Ethereum). We use this contract ideal functionality to design a
protocol Π(1, C) which realizes the ideal functionality F
L( b ∆)
ch (1, C)
(i.e. the protocol for ledger state channels).
The outline of the protocol is given in Appx. A.1. The formal description of the protocol Π(1, C) and the ideal functionality F
L( b ∆)
scc (C)
can be found in the full version of this paper [13], where we also
prove that the protocol Π(1, C) emulates the ideal functionality
F
L( b ∆)
ch (1, C) in the F
L( b ∆)
scc (C) hybrid world. This statement is formalized by the following theorem.
Theorem 5.1. Suppose the underlying signature scheme is existentially unforgeable against chosen message attacks. The protocol
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 960
Π(1, C) working in F
L( b ∆)
scc (C)-hybrid model emulates the ideal functionality F
L( b ∆)
ch (1, C) against environments from class Eres for every
set of contract codes C and every ∆ ∈ N.
Virtual state channels. As already mentioned in Sec. 2, our technique allows to create virtual state channels of arbitrary length,
via using the state channel functionality recursively. By this we
mean that a protocol for constructing state channels of length up
to i will work in a model with access to an ideal functionality for
constructing state channels of length up to i − 1. More formally,
for every i > 1 we construct a protocol Π(i, C) realizing the ideal
functionality F
L( b ∆)
ch (i, C) in the F
L( b ∆)
ch (i − 1, C
′
)-hybrid world. Here
C
′
is a set of contract codes defined as C
′
:= C ∪ VSCCi(C), where
VSCCi(C) is a contract code, which we call the virtual state channel
contract, that allows to create a virtual state channel of length i in
which contract instance with code from the set C can be opened.
Thus importantly, the hybrid ideal functionality F
L( b ∆)
ch (i − 1, C
′
)
allows to create state channels that can serve as subchannels of a
virtual channel of length i.
Very briefly, the hybrid ideal functionality is used by parties
of the protocol Π(i, C) as follows. If a party receives a message
regarding a state channel of length j < i, then it simply forwards
this message to the hybrid ideal functionality F
L( b ∆)
ch (i − 1, C
′
). The
more interesting case is when a party receives a message regarding a virtual state channel γ of length exactly i. Then it uses the
hybrid ideal functionality F
L( b ∆)
ch (i − 1, C
′
) to make changes in the
subchannels of the virtual state channels γ .
See Appx. A.2 for the outline of the protocol Π(i, C). In the full
version of this paper [13] we provide the formal description of
the protocol Π(i, C), the code of the virtual state channel contract
VSCCi(C), and we prove the following theorem.
Theorem 5.2. Suppose the underlying signature scheme is existentially unforgeable against chosen message attacks. The protocol
Π(i, C) working in F
L( b ∆)
ch (i − 1, VSCCi(C) ∪ C)-hybrid model emulates the ideal functionality F
L( b ∆)
ch (i, C) against environments from
class Eres for every set of contract codes C, every i > 1 and every
∆ ∈ N.
By applying the composition recursively, we get a construction
of a protocol realizing F
L( b ∆)
ch (i, C) in the F
L( b ∆)
scc (C) b -hybrid model,
where Cbis a result of applying the “C := C ∪ VSCCi(C)” equation i
times recursively. See Fig. 5 for an example for i = 3.
Fch(3, C) ∼ Π(3, C)
Fch(2, C
′
) ∼ Π(2, C
′
)
Fch(1, C
′′) ∼ Π(1, C
′′)
Fscc(C′′)
Figure 5: Our modular approach. Above Fch := F
L( b ∆)
ch , Fscc :=
F
L( b ∆)
scc , C
′
:= C ∪ VSCC3(C) and C
′′ := C
′ ∪ VSCC2(C′
).
6 CONCLUSION
We showed how to build general state channel networks, i.e., state
channels of arbitrary length in which arbitrary contracts can be
opened and executed off-chain. Our modular approach allows for
a recursive construction of state channels (i.e. a virtual channel
of length i is build on top of two state channels of length ⌈i/2⌉)
which significantly simplifies the description of our construction.
All protocols were proven to be secure in the global UC model
and their optimistic time complexity is independent of the channel
length. In the pessimistic case when malicious parties try to delay
the protocol execution as much as possible, the time complexity
of our construction is linear in channel length. We did not aim to
optimize the pessimistic time complexity of our protocols since
this would make their description even more complex. More fine
grained timing analysis, which would reduce the constants in the
pessimistic time complexity, and corresponding optimization of our
state channel protocol would be highly recommended before the
implementation. Another question is whether virtual state channels
with time complexity independent of the channel length could be
designed (for example using techniques from [24]).
Incentivizing intermediaries. An important practical question is
why would a party want to become an intermediary of a virtual state
channel. Although our construction does guarantee that an honest
intermediary will never lose coins, the fact that an intermediary
has to lock coins for the entire lifetime of the virtual channel makes
this role unattractive. This problem can be solved by adding the
concept of service fees to our construction. Let us sketch how this
could be done: both Alice and Bob would lock some additional
coins in the VSCCi contract instance each of them opens in their
channel with Ingrid during the virtual state channel creation. More
precisely, in order to create a virtual state channel γ , Alice would
lock γ .cash(A) + serviceFee coins in the channel α she has with
Ingrid and Bob would lock γ .cash(B) + serviceFee coins in the
channel β he has with Ingrid. During the closure of γ (assuming
that it was successfully created), the service fee would be unlocked
from the VSCC contract instances in favor of Ingrid in both channels
α and β.
Suitable contract codes – a cautionary note. We would like to point
out one subtle issue, that users of future real-life implementations
need to be aware of. As discussed in Sec. 3.2, the security guarantees
provided to the end-users of a state channel are strongly dependent
on the code of the contract instance that is opened in the state
channel (in other words: our system is only as secure as the contract
that the user run in the channel). In principle, this is the same as
in case of the standard contracts on the ledger, however there
are several additional aspects that have to be taken into account
when designing contract codes for state channels. Recall that all
coins that are locked in a contract instance when the underlying
virtual state channel is closed are assigned to the intermediary of
the channel. Therefore, it is important that a contract instance is
terminated by any end-user before the validity of the underlying
virtual state channel expires. Another important point to keep in
mind is that although our construction guarantees that end-user of
a state channel can execute a contract instance in any round and on
any contract function, it might take (in the pessimistic case) up to
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 961
TimeExeReq(i) rounds before the other party is notified about the
execution and TimeExe(i) rounds before the execution takes place
(where i denotes the length of the state channel). Thus, compared to
the contract deployment directly on the blockchain, the notification
and execution delay might be longer.