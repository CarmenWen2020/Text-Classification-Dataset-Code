Byzantine fault tolerant state machine replication (SMR) provides
powerful integrity guarantees, but fails to provide any privacy guarantee whatsoever. A natural way to add such privacy guarantees
is to secret-share state instead of fully replicating it. Such a combination would enable simple solutions to difficult problems, such
as a fair exchange or a distributed certification authority. However, incorporating secret shared state into traditional Byzantine
fault tolerant (BFT) SMR protocols presents unique challenges. BFT
protocols often use a network model that has some degree of asynchrony, making verifiable secret sharing (VSS) unsuitable. However,
full asynchronous VSS (AVSS) is unnecessary as well since the BFT
algorithm provides a broadcast channel.
We first present the VSS with share recovery problem, which
is the subproblem of AVSS required to incorporate secret shared
state into a BFT engine. Then, we provide the first VSS with share
recovery solution, KZG-VSSR, in which a failure-free sharing incurs
only a constant number of cryptographic operations per replica.
Finally, we show how to efficiently integrate any instantiation of
VSSR into a BFT replication protocol while incurring only constant
overhead. Instantiating VSSR with prior AVSS protocols would
require a quadratic communication cost for a single shared value
and incur a linear overhead when incorporated into BFT replication.
We demonstrate our end-to-end solution via a a private keyvalue store built using BFT replication and two instantiations of
VSSR, KZG-VSSR and Ped-VSSR, and present its evaluation.
1 INTRODUCTION
Combining the power of Byzantine Fault Tolerant (BFT) replication
with secret sharing, one can build a decentralized service that acts
over private values in a coordinated manner by consensus decrees.
This powerful combination can be leveraged in various ways to
build an automated, decentralized threshold trusted third party
(T3P) where clients can store private data. For example, it may be
used to build a decentralized T3P escrow. Crucially, escrowed secrets will be opened by consensus decree, not necessarily requiring
client interaction. This greatly simplifies traditionally difficult problems such as a fair exchange. A fair exchange can be implemented
by having one party confidentially store one value, another party
confidentially store a second value and a consensus decree that
opens both. Another such example is a certification engine, which
computes decentralized threshold signatures to certify documents
based on some policy. Using polynomial secret sharing, multiple
values entrusted to a decentralized T3P may be aggregated without
client involvement. Simple additive aggregations are trivial to implement. Arbitrary multi-party computation is possible (e.g., [16, 43]),
though more costly.
In all of these use-cases, the enabling core is a mechanism called
Verifiable Secret Sharing (VSS) [14] used for populating a decentralized service with secret values. Our use of VSS weaves it into BFT
replication in order to automate the handling of secret values. For
example, in our private key-value store, a client request to store an
entry is broken into two parts, public and private. The public part
works as a normal BFT replication request. The private part uses
VSS for the client to directly share the private entry. Importantly,
replicas delay their participation in the ordering protocol until they
obtain a verifiable share of this private entry from the client.
Due to the need to weave VSS into an arbitrary BFT replication
engine, the setting of interest to us is asynchronous. A synchronous
protocol can simply wait until all honest replicas have received a
share, while such a technique breaks in asynchronous settings.
It is crucial for the VSS protocol to simply inherit the network
model from the BFT replication engine and not require additional
assumptions. Thus, we need to solve the problem of share recovery,
which only prior works in asynchronous VSS (AVSS) schemes have
directly addressed.
The best known Asynchronous VSS (AVSS) solutions require a
client (dealer) to incur quadratic computation and communication
complexities in order to store a single value [1, 31]. This, in turn,
imposes a linear computation and storage cost on each replica,
which means that the performance overhead increases linearly with
Session 10C: Secret Sharing CCS ’19, November 11–15, 2019, London, United Kingdom 2387
the cluster size. When AVSS and BFT replication solutions were
originally developed, most BFT solutions were aimed for systems
of four (tolerating f = 1 faults) or seven (f = 2) replicas. However,
today, BFT replication is being revisited at scale in blockchain
systems of hundreds or thousands of replicas [26, 46, 52]. Incurring
such a large degradation in service performance for privacy may
be prohibitively expensive.
To incorporate VSS into BFT protocols, this paper introduces
a new verifiable secret sharing framework called VSSR. VSSR is
a framework that, given a VSS scheme with certain properties,
adds share recovery with only a constant factor overhead from
the original VSS scheme. We instantiate VSSR in two ways: (1)
KZG-VSSR, which uses Kate, et al.’s secret sharing scheme [31] to
instantiate a VSS that has constant time share verification and (2)
Ped-VSSR, which uses Pedersen’s secret sharing scheme [44] which,
while only providing linear time share verification and recovery,
uses cheaper cryptographic operations and is faster for smaller
clusters. Our framework is based on one key concept: the recovery
polynomial. The recovery polynomial is a single polynomial that
encodes recovery information for f shares. Thus, by only sharing
a small, constant number of additional polynomials, the client can
enable all 3f + 1 shares to be recovered.
We intertwine Ped-VSSR and KZG-VSSR in a BFT replication system and build a full private key-value store solution. Our key-value
store performs well in practice, with only a 30% to 50% throughput
overhead over a non-private key-value store with request latencies
less than 35 milliseconds.
This paper contributes a new framework for incorporating VSS
into BFT replication systems through the use of recovery polynomials, VSSR. We then instantiate VSSR using two verifiable secret sharing schemes and benchmark the overhead that our new framework
adds. Finally, we incorporate our two instantiations into PBFT [13]
and evaluate a private, Byzantine Fault Tolerant key value store.
2 TECHNICAL OVERVIEW
In this section, we provide a high-level, informal overview of the
core technique we use to solve the VSS with share recovery problem. We first introduce the asynchronous VSS (AVSS) problem and
show how share recovery arises in the AVSS setting and its relation to Byzantine Fault Tolerance. We then discuss some prior
works in AVSS and common techniques for solving the share recovery problem. Finally, we provide a high level overview of our
contribution.
2.1 The Asynchronous VSS Problem
In the asynchronous VSS problem, a dealer shares to a group of
n participants a polynomial s. The API for sharing is denoted by
vssShare. If the sharing completes anywhere, then eventually every
non-faulty participant completes the sharing. The basic method for
secret sharing is to provide participant i a point (xi
,s(xi
)) on the
polynomial s. The method fulfills two key properties, hiding and
binding.
Loosely speaking, hiding means that for a polynomials of degree
f , any k = f + 1 shares suffice to reconstruct it via interpolation
(API: vssReconstruct), and that no combination of f or less reveal
any information about it. Binding means that every participant
receives, in addition to its private share, a global commitment c to
the polynomial s that binds the share it receives as a verifiable valid
share of s (API: vssVerify).
In asynchronous settings, a dealer can wait for at most n − f
participants to acknowledge receiving a valid share, before it inevitably may walk away. Note that it is possible for the dealer
to walk away before all of the honest replicas have a valid share.
The asynchronous VSS problem requires that if the dealer (or any
participant) completes the share protocol, then every correct participant can eventually reconstruct its share using a distributed
protocol with f + 1 correct participants: Participants contribute recovery information (API: vssRecoverContrib∗
), which is validated
by the recipient (API: vssRecoverVerify∗
) and then combined to
reconstruct the missing share (API: vssRecover∗
).
VSS in Byzantine Fault Tolerance Incorporating VSS into
Byzantine Fault Tolerance (BFT) presents some unique challenges.
BFT protocols have a large variety of network assumptions and
consequently have to handle the scenario where a replica is missing part of the state. In traditional BFT protocols, the replicated
state is identical across replicas, making state recovery a matter
of transmitting and validating the state. With secret shared state,
each replica stores a unique share of the replicated private state,
which makes the problem of share recovery much more complicated. AVSS protocols have minimal assumptions on the network
and must solve an analogous version of share recovery.
There are a few key design goals to meet when incorporating
AVSS into BFT. For example, it is acceptable for a Byzantine client to
lose the hiding guarantee. However, every sharing must always be
binding, since otherwise the replicated state machine can be in an
inconsistent state. Typical AVSS schemes need a reliable broadcast
protocol to guarantee this binding property. However, state machine replication (SMR) also solves the reliable broadcast problem,
eliminating the need for VSSR to implement reliable broadcast. In
particular, VSSR does not make any assumptions about the network
itself.
Additionally, there are many different Byzantine Fault Tolerance (BFT) algorithms in the literature that have been optimized to
perform under certain circumstances. For example, some BFT algorithms [26, 34] have often incorporated a linear "fast-path" suitable
for cases where there are few failures. In particular, this search for
more optimized performance in the common case is something that
we foresee continuing in the BFT literature.
Thus, it is important for a secret sharing scheme to have minimal
overhead in the common case. In particular, a verifiable secret
sharing scheme used in BFT must meet the requirement that sharing
a secret only requires replicas to compute a constant number of
cryptographic operations. This ensures that the same techniques
will be reusable for more scalable BFT protocols that work with
larger clusters.
2.2 Existing Solutions
The seminal work by Shamir [49] introduced the idea of employing
polynomial interpolation, a technique that was used before for error
correction codes, to share a secret with unconditional security.
A line of work emanated from this result and addressed many
additional features, such as share verifiability, asynchrony, and
proactive share refresh.
Session 10C: Secret Sharing CCS ’19, November 11–15, 2019, London, United Kingdom 2388
Share verifiability tackles the problem of a malicious dealer that
equivocates and maliciously shares values that are inconsistent.
There are many such schemes with different properties, from classical works such as Feldman’s [22] and Pedersen’s [44] schemes
to newer works such as Kate et al. [31] and SCAPE [12]. VSSR can
take many of these works as input and construct a verifiable secret
sharing scheme that provides share recovery.
Original solutions for asynchronous VSS in the informationtheoretic setting were introduced in the context of Byzantine agreement and secure MPC [11]. They incur communication complexity
of O(n
6
logn) and message complexity O(n
5
).
AVSS. The first practical asynchronous VSS solution in the computational setting was introduced by Cachin et al. [8]. We will refer
to it by the name AVSS. To handle share recovery, AVSS uses a
bivariate secret polynomial sˆ(·, ·). Share i consists of two univariate
polynomials, sˆ(i, ·), sˆ(·,i), and so the dealer sends O(n) information
to each participant. A missing i’th share can be reconstructed from
f + 1 evaluations of sˆ(i, ·) and f + 1 evaluations of sˆ(·,i), incurring linear communication overhead per recovery, for an overall
recovery complexity of O(n
2
) messages and O(n
3
) bits.
Additionally, participants need to verify that all shares are bound
to the same polynomial. AVSS makes use of Pedersen polynomial
commitments [44] for all polynomials sˆ(i, ·), sˆ(·,i), i = 1..n. This
commitment scheme leverages the hardness of discrete log in a
multiplicative group of order q with generator д. A commitment
c(v) to a value v ∈ Zq is a value д
vh
r
, where h is another element
of the group and r is a secret drawn at random from Zq. A Pedersen commitment to a polynomial s(·) ∈ Zq[x] consists of a set of
commitments to n values, i.e., c(s(·)) = {⟨xi
,c(s(xi
))⟩}n
i=1
. Given
any pair ⟨x,s(x)⟩, it is possible to verify that this point is on s(·)
using the commitment’s homomorphic properties, i.e., that for any
v1,v2 ∈ Zq, c(v1)c(v2) is a valid commitment to v1 +v2 mod q.
AVSS weaves into the sharing protocol the dissemination of
commitments [7] while incurring message complexity O(n
2
) and
communication complexity O(n
3
).
eAVSS-SC. Kate et al. [31] introduces a polynomial commitment
that has constant size. This commitment scheme leverages the hardness of the q-Strong Diffe-Hellman assumption in some group with
order p where д is a generator. In Kate et al., a commitment c(s(·))
is defined as c(s(·)) = д
s (τ )
, where τ is unknown to all participants
and s(τ ) is the polynomial s evaluated at τ . To commit to a particular evaluation (or share) s(i), the dealer also produces a witness,
д
s (τ )−s (i)
τ −i . Given any triple of share, witness and commitment, it
is possible to verify that the share is indeed the evaluation of the
polynomial at that point using a bilinear map. The technique was
employed by Backes et al. [3] to construct an asynchronous VSS
scheme called eAVSS-SC that incurs both message and communication complexities O(n
2
).
In eAVSS-SC, a dealer chooses, in addition to the secret polynomial s, another n polynomials sˆi
, i = 1..n. sˆi encodes share i of s
for recovery purposes. Each of s, sˆi
, has a constant-size polynomial
commitment due to the scheme by Kate et al. [31]. The commitments are constructed such that a commitment of sˆi validates it
as a share of s. Using the homomorphism of the commitments,
eAVSS-SC weaves into the sharing protocol the dissemination of
commitments while incurring O(n
2
) message and bit complexity.
Technique Sharing Phase Recovery Phase
Client Replica Replica
Bivariate Polynomials [42] O(n
2
) O(n) O(n
2
)
Resharing [36] O(n) O(1) O(n
2
)
Batching [1] O(n
2
) O(n) O(n
2
)
KZG-VSSR O(n) O(1) O(n)
Ped-VSSR O(n
2
) O(n) O(n
2
)
Table 1: Communication overhead of possible VSSR designs
in the typical scenario when the dealer is honest. n denotes
the number of replicas. For the recovery phase, we present
the cost of the recovering replica.
2.3 Share Recovery Techniques
AVSS schemes, like the above, and proactive secret sharing [30]
present possible solutions to the problem of verifiable secret sharing
with share recovery. However, these schemes are not amenable for
use in Byzantine Fault Tolerance protocols.
In prior AVSS schemes, the dealer computes O(n
2
) commitment
values and sends O(n
2
) bits. Hence, to date, all asynchronous VSS
solutions require a dealer storing a single secret to incur O(n
2
)
communication complexities, which means that a replica’s CPU
must typically perform O(n) cryptographic operations for a single
sharing. This can be quite prohibitive for moderate n values, e.g.,
n = 1, 000, and infeasible for n = 50, 000. Fundamentally, prior
asynchronous VSS schemes allow share recovery by having the
dealer enumerate all pairwise responses between replicas during
recovery. In other words, if replica i is helping replica ˆi recover,
the dealer has shared with i the response to send to ˆi. This must
necessarily incur quadratic bandwidth on the dealer and linear CPU
overhead on each replica.
Prior proactive secret sharing schemes (PSS) offer other approaches to share recovery. Some PSS schemes have the dealer
enumerate all pairwise responses through the use of bivariate polynomials [36, 42]. This approach shares the same performance overhead and weaknesses as state-of-the-art AVSS schemes. Other PSS
schemes use a resharing technique [6, 41], where each replica first
constructs a secret sharing of their original share and then reconstructs a new share through interpolation. While this has low
overhead in the sharing phase, this forces every replica to obtain a
new share whenever a single replica needs to initiate share recovery. A third technique employed by PSS schemes is batching [4, 5],
where the cost is still quadratic but O(n) shares can be shared in
parallel. Batching was also leveraged by a recent AVSS protocol to
have a linear amortized overhead [1]. While batching has the same
asymptotic overheads as KZG-VSSR in a failure free environment,
it requires waiting for O(n) shares which incurs high latency when
n is large.
VSSR uses a different approach, where we make use of a distributed pseudorandom function (DPRF) and generate recovery
responses dynamically using information shared in the setup phase.
Table 1 compares the bandwidth costs of the different ways to
instantiate VSSR.
Session 10C: Secret Sharing CCS ’19, November 11–15, 2019, London, United Kingdom 2389
2.4 VSSR
Our solution, named VSSR (for ‘VSS with Recovery’), is the first in
which the replica work is constant per sharing in the failure free
case. In the worst case, when there are f participant failures or
the dealer is Byzantine, the overhead is still quadratic as in prior
schemes. We present a strawman solution that introduces the key
insight behind VSSR and describe how our final solution fixes the
issues present in the strawman.
Our strawman uses proactive secret sharing [30] to help a participant re-compute the original share that they were given. Informally,
suppose that a replica i has share s(i), which is simply a point on the
polynomials. In order to recover this share, we are given a Recovery
Polynomial (RP), which is random at every point except fori, where
si
(i) = 0. Thus, if the recovering replica i receives shares of the sum
of the original polynomial and the masking polynomial, si
(·) +s(·),
it can recover its own share without obtaining any information
about any other share.
The strawman solution assumes that the recovery polynomial
is given for free. We solve this by having the dealer construct
the recovery polynomials and sharing it with the replicas. The
system assumes optimistically that the dealer is honest in sharing
the recovery polynomials. If, later on, the dealer is found to be
dishonest, then the privacy guarantee for the dealer is broken and
the secret is revealed. At this point, our scheme still pays a quadratic
overhead in the common case.
The second problem our strawman solution has is that it requires
one recovery polynomial for each share. This means that the dealer
must construct n recovery polynomials and incur a quadratic overhead. We bring this overhead down by a factor of f , which equals
n
3
in our case, by allowing f shares to be recovered by a single
recovery polynomial. We do this by removing the constraint that
si
(i) = 0 and using a distributed pseudorandom function in order
to communicate the value of si
(i) efficiently. This means that the
dealer constructs four recovery polynomials, which is a constant
factor overhead to the original VSS scheme.
We now present a high level description of our final protocol.
To share a secret, the dealer partitions the secret shares of s into
ℓ = ⌈n/f ⌉ groups, and uses ℓ recovery polynomials (RPs)sj
, j = 1..ℓ,
to encode the corresponding groups. Every one of the original n
shares of s is encoded in one of the RPs. The dealer shares both s
and the sj
’s among the n participants, and participants use the sj
’s
for share recovery.
More specifically, an RP sj
is a random polynomial of degree f
that has f pre-defined points. For (j − 1)f ≤ i < j f , the recovery
polynomial sj
is constructed so that sj
(i) = yi
, where yi = F (i)
for a DPRF F with reconstruction threshold f . In our actual construction, yi = F (⟨r,i⟩) for a random value r, to ensure that sj
is
distinct for each sharing, but we elide r for our discussion here.
To recover its share, participant i probes other participants, to
which each participant responds with its share ofs+sj for j = ⌈i/f ⌉.
Each participant ˆi can construct its response from its shares ofs and
sj
. In addition, participant ˆi also responds with their shares of F (i),
i.e., of the secret value sj
(i). (In API terms, vssRecoverContrib∗
returns a share of s + sj and a share of F (
ˆi).) Participant ˆi then
reconstructs s + sj
in full and computes (s + sj
)(i) − F (i) = s(i)
(API: vssRecover∗
).
To verify a recovery share (vssRecoverVerify∗
), participant i first
validates each share ofs+sj that it receives against the commitment
c(s + sj
), which it computes from c(s) and c(sj
). Then it validates
the recovery result against the commitment c(s).
If validation fails, then participant i can prove to the other participants that the dealer is bad. In that case, different from AVSS
and eAVSS-SC, participants expose the dealer’s secret.
The complexities incurred by different participants at different
steps of the VSSR protocol instantiated with Kate et al. [31] are
as follows. A dealer provides each of n participants shares and
constant-size commitments on ℓ +1 polynomials. The total communication complexity is O(ℓn), or simply O(n) since in our setting, ℓ
is four. When a participant receives a recovery request, it sends a
constant amount of information to the requester, for a total O(t)
communication for t requests. Finally, each participant requiring
share recovery obtains shares from other participants incurring
O(n) communication, for a total O(tn) communication for t requests.
3 SHARE RECOVERY IN VSS
In this section, we detail our VSS protocol and its security. We
begin with the definitions of distributed pseudorandom functions
(Section 3.1) and verifiable secret sharing (Section 3.2). We will
then detail our goals (Section 3.3), further assumptions on which
our scheme builds (Section 3.4), our construction (Section 3.5) and
its security (Section 3.6). Finally, we show how to instantiate our
implementation (Section 3.7).
Note that our proofs are applicable to any schemes that satisfy
our descriptions below. To highlight the generality of our descriptions, we instantiate our secret sharing scheme described in Section 3.2 in two ways [31, 44], of which one gives us the desired
asymptotic complexity while the other uses more inexpensive cryptographic operations.
3.1 Distributed Pseudorandom Functions
A distributed pseudorandom function (DPRF) is a pseudorandom
function that requires the cooperation of k replicas out of n total replicas to evaluate [40]. A DPRF F provides the following
interfaces, where [n] = {1, . . . ,n}.
• dprfInit is a randomized procedure that returns a set of pairs
{⟨dpki
, dski⟩}i ∈[n] ← dprfInit(1
κ
, k,n, D, R). Each dpki
is
public key, and each dski
is its corresponding private key.
• dprfContrib is a randomized procedure that returns a contribution d ← dprfContrib(dski
, x) if x ∈ D and failure (⊥)
otherwise.
• dprfVerify is a deterministic procedure that returns a boolean
value. We require that dprfVerify(dpki
, x,d) returns true if
d is output from dprfContrib(dski
, x) with nonzero probability, for the private key dski corresponding to dpki
.
• dprfEval is a deterministic procedure that returns a value
y ← dprfEval(x, {di}i ∈I
), where y ∈ R, if x ∈ D, |I | ≥ k and
for all i ∈ I, dprfVerify(dpki
, x,di
) returns true. Otherwise,
dprfEval(x, {di}i ∈I
) returns ⊥.
Security for a distributed pseudorandom function (DPRF), informally, is defined by an adversary that is unable to distinguish the
Session 10C: Secret Sharing CCS ’19, November 11–15, 2019, London, United Kingdom 2390
output from the DPRF from a random oracle even if it has the ability
to compromise any set of k − 1 replicas.
More formally, security for a distributed pseudorandom function is defined as follows. An adversary AF is provided inputs
⟨dpki
⟩i ∈[n]
, k, n, D, and R, where {⟨dpki
, dski⟩}i ∈[n] ←
dprfInit(1
κ
, k,n, D, R). In addition, AF is given oracle access to
n + 1 oracles. The first n oracles, denoted ⟨OF ,i
⟩i ∈[n]
, each supports two types of queries. AF can invoke OF ,i
.contrib(x), which
returns dprfContrib(dski
, x), or it can invoke OF ,i
.compromise,
which returns dski
. The last oracle provided to AF is denoted
O
?
F
: D → R and is instantiated as one of two oracles, either O
real
F
or O
rand
F
. Oracle O
real
F
, on input x, selects a subset I ⊆ [n] at random of size |I | = k, invokes di ← OF ,i
.contrib(x) for each i ∈ I,
and returns dprfEval(x, {di}i ∈I
). Oracle O
rand
F
is instantiated as a
function chosen uniformly at random from the set of all functions
from D to R. For any x ∈ D, let Ix be the oracle indices such that
for each i ∈ Ix , AF invokes OF ,i
.compromise or OF ,i
.contrib(x).
Then, AF is legitimate if |Ix | < k for every x for which AF invokes O
?
F
(x). Finally, AF outputs a bit. We say that the distributed
pseudorandom function is secure if for all legitimate adversaries
AF that run in time polynomial in κ,
P

A
⟨OF ,i⟩i∈[n]
, O
real
F
F
(⟨dpki
⟩i ∈[n]
, k,n, D, R) = 1
!
− P

A
⟨OF ,i⟩i∈[n]
, O
rand
F
F
(⟨dpki
⟩i ∈[n]
, k,n, D, R) = 1
! (1)
is negligible in κ.
3.2 Verifiable Secret Sharing
Verifiable Secret Sharing (VSS) is a way to share a secret so that
it requires a coalition of k replicas out of n total replicas in order
to reconstruct the secret. A VSS scheme provides the following
interfaces:
• vssInit is a randomized procedure that returns
⟨q, {⟨vpki
, vski⟩}i ∈[n]
⟩ ← vssInit(1
κ
, k,n). Here, q is a prime
of length κ bits. Each vpki
is a public key, and each vski
is
its corresponding private key.
• vssShare is a randomized procedure that produces
⟨c, {ui}i ∈[n]
⟩ ← vssShare(s,q, {vpki
}i ∈[n]
). Here, s ∈ Zq[x]
is a degree k − 1 polynomial, and q and {vpki
}i ∈[n] are as
output by vssInit. The value c is a commitment, and each ui
is a share.
• vssVerify is a deterministic procedure that returns a boolean.
We require that vssVerify(vpki
,c,ui
) return true if ⟨c,ui⟩
(i.e., with arbitrary {uˆi
}ˆi,i
) is output from
vssShare(s,q, {vpki
}i ∈[n]
) with nonzero probability.
• vssReconstruct is a deterministic procedure that returns
a value s ← vssReconstruct(c, {⟨vpki
,ui⟩}i ∈I
) where s ∈
Zq[x] of degree k − 1, if |I | ≥ k and for all
i ∈ I, vssVerify(vpki
,c,ui
) returns true. Otherwise,
vssReconstruct(c, {⟨vpki
,ui⟩}i ∈I
) returns ⊥.
The security of a VSS scheme lies in its hiding and binding properties.
3.2.1 Hiding. Informally, the hiding property is set up in the following way. Suppose you have an adversary that gave the client
two secrets, of which the client picked one randomly and shared
it using our VSS scheme. Even with access to k − 1 of the replicas
and their secrets, the adversary cannot tell which secret was shared
with high probability. Note that our hiding definition is computational since we would like our transformation to be as ambivalent to
the underlying secret sharing scheme as possible. Any information
theoretic secret sharing scheme would satisfy these requirements
as well.
More formally, a hiding adversary AV is provided inputs q and
{vpki
}i ∈[n]
, where ⟨q, {⟨vpki
, vski⟩}i ∈[n]
⟩ ← vssInit(1
κ
, k,n), and
access to n + 1 oracles. The first n oracles are denoted ⟨OV,i
⟩i ∈[n]
;
each OV,i
is initialized with vski and can be invoked as described
below. The last oracle provided to AV is denoted O
b
V
, where b ∈
{0, 1}. AV can invoke this oracle with two inputss0,s1 ∈ Zq. When
invoked, O
b
V
generates a randomsˆ ∈ Zq[x] of degree k−1 such that
sˆ(0) = sb and performs ⟨c, {ui}i ∈[n]
⟩ ← vssShare(sˆ,q, {vpki
}i ∈[n]
),
providing c to AV and ⟨c,ui⟩ to OV,i
. The oracles ⟨OV,i
⟩i ∈[n]
can be invoked by AV as follows. AV can invoke OV,i
.contrib(c),
which returns the share ui provided to OV,i with commitment c
by O
b
V
. AV can also invoke OV,i
.compromise, which returns vski
and all ⟨c,ui⟩ pairs received from O
b
V
. For any c, let Ic be the oracle
indices such that for each i ∈ Ic , AV invokes OV,i
.compromise
or OV,i
.contrib(c). Then, AV is legitimate if |Ic | < k for every c.
Finally, AV outputs a bit. We say that the VSS V is hiding if for
all legitimate adversaries AV that run in time polynomial in κ,
P

A
⟨OV,i⟩i∈[n]
, O
1
V
V
(q, {vpki
}i ∈[n]
) = 1
!
− P

A
⟨OV,i⟩i∈[n]
, O
0
V
V
(q, {vpki
}i ∈[n]
) = 1
! (2)
is negligible in κ.
3.2.2 Binding. Informally, the binding property says that an adversarial dealer’s public commitment uniquely identifies the secret
that is reconstructed. Essentially, the probability that the dealer
can cause two different secrets to be reconstructed with the same
public commitment is negligible.
Formally, a binding adversary AV is provided inputs
⟨q, {⟨vpki
, vski⟩}i ∈[n]
⟩ ← vssInit(1
κ
, k,n). AV outputs c, {ui}i ∈I
and {uˆi}
i ∈ ˆI
. We say that VSS V is binding if for all binding adversaries AV that run in time polynomial in κ,
P
*
.
,
vssReconstruct(c, {⟨vpki
,ui⟩}i ∈I
) = s
∧ vssReconstruct(c, {⟨vpki
,uˆi⟩}i ∈ ˆI
) = sˆ
∧ s , ⊥ ∧ sˆ , ⊥ ∧ s , sˆ
+
/
-
is negligible in κ, where the probability is taken with respect to
random choices made in vssInit and by AV .
3.3 Goals
Given such a VSS scheme V and a DPRF F , our goal is to construct
a new VSS scheme V∗
that provides the vssInit, vssShare, vssVerify,
and vssReconstruct algorithms (denoted vssInit∗
, vssShare∗
, vssVerify∗
and vssReconstruct∗
for V∗
, respectively) as defined in Section 3.1,
as well as three more algorithms, denoted vssRecoverContrib∗
,
vssRecoverVerify∗
, and vssRecover∗
. We allow the vssShare∗
algorithm to accept additional arguments (a set of private keys for a
DPRF) and to return an additional value r that is provided as input to
all procedures except for vssInit∗
. The algorithms vssRecoverContrib∗
,
Session 10C: Secret Sharing CCS ’19, November 11–15, 2019, London, United Kingdom 2391
vssRecoverVerify∗
, and vssRecover∗
together permit a replica to recover its share from other replicas, and behave as follows:
• vssRecoverContrib∗
is a randomized procedure that returns
v
∗
i ← vssRecoverContrib∗
(c
∗
,r, vsk∗
i
,u
∗
i
,
ˆi) where v
∗
i
is a
recovery share with properties described below.
• vssRecoverVerify∗
is a deterministic procedure that returns
a boolean. vssRecoverVerify∗
(c
∗
,r,v
∗
i
, vpk∗
i
,
ˆi) must return
true ifv
∗
i
is output from vssRecoverContrib∗
(c
∗
,r, vsk∗
i
,u
∗
i
,
ˆi)
with nonzero probability and vssVerify∗
(vpk∗
i
,c
∗
,r,u
∗
i
) returns true.
• vssRecover∗
is a deterministic procedure that returns u
∗
ˆi
←
vssRecover∗
(c
∗
,r, {⟨vpk∗
i
,v
∗
i
⟩}i ∈I
,
ˆi, vpk∗
ˆi
) if
|I | ≥ k, vssRecoverVerify∗
(c
∗
,r,v
∗
i
, vpk∗
i
,
ˆi) returns true for
all i ∈ I, and vssVerify∗
(vpk∗
ˆi
,c
∗
,r,u
∗
ˆi
) returns true. Otherwise, vssRecover∗
(c
∗
,r, {⟨vpk∗
i
,v
∗
i
⟩}i ∈I
,
ˆi, vpk∗
ˆi
) returns ⊥.
Due to the additional interfaces above, we change the definition
of hiding security as follows. Each oracle OV∗
,i additionally supports a query OV∗
,i
.recover(c
∗
,
ˆi) that returns
v
∗
i ← vssRecoverContrib∗
(c
∗
,r, vsk∗
i
,u
∗
i
,
ˆi). For any c
∗
, let Ic
∗ be
the oracle indices such that for each i ∈ Ic
∗ , AV∗ invokes
OV∗
,i
.compromise, OV∗
,i
.contrib(c
∗
), or {OV∗
,
ˆi
.recover(c
∗
,i)}ˆi ∈ ˆI
where |
ˆI | ≥ k. Then, AV∗ is legitimate if |Ic
∗ | < k for every c
∗
.
3.4 Assumptions on Underlying VSS
Our construction combines an existing VSS scheme with a DPRF for
which, if ⟨q, {⟨vpki
, vski⟩}i ∈[n]
⟩ ← vssInit(1
κ
, k,n), then R = Zq
and each share ui output from vssShare is in Zq. In addition, we
require that the VSS offer additional procedures, as follows.
• There is a procedure vssMakeSecret that creates
s ← vssMakeSecret(q, {⟨xi
,yi⟩}i ∈I
)
where s ∈ Zq[x] is of degree |I |, and so that if
⟨c, {ui}i ∈[n]
⟩ ← vssShare(s,q, {vpki
}i ∈[n]
)
then ui = yi for any i ∈ I.
• There is a procedure vssCombineCommitments such that if
vssReconstruct(c, {⟨vpki
,ui⟩}i ∈I
) = s
vssReconstruct(cˆ, {⟨vpki
,uˆi⟩}i ∈I
) = sˆ
where s,sˆ , ⊥, and if
cˇ ← vssCombineCommitments(c,cˆ)
then
vssReconstruct(cˇ, {⟨vpki
, (ui + uˆi
)⟩}i ∈I
) = s + sˆ
An example of such a scheme is that due to Pedersen [44].
3.5 VSS Scheme with Recovery
Below we describe the procedures that make up the VSS scheme V∗
.
The algorithms are expressed in terms of constants n (the number
of replicas), k (the reconstruction threshold), and ℓ = ⌈n/(k − 1)⌉.
Each share u
∗
i
and commitment c
∗
is a zero-indexed vector of ℓ + 1
elements. We denote the j-th element of each by u
∗
i
[j] and c
∗
[j],
respectively, for 0 ≤ j ≤ ℓ. Line numbers below refer to Figure 1.
vssInit∗
initializes the underlying VSS V in line 2, as well as a
DPRF F in line 3. The public key vpk∗
i
for replica i consists of its
public key vpki
for V and its public key dpki
for F (line 7) and
similarly for the private key vsk∗
i
(line 6).
vssShare∗
is modified to take in all of the private keys {dski}i ∈[n]
for the DPRF F , as well as the other arguments included in its
definition in Section 3.2. (For this reason, our construction requires
each dealer to have a distinct set of parameters for its sharings,
i.e., produced by its own call to vssInit∗
.) This enables the dealer to
evaluate F itself, which it does on ⟨r,i⟩ for each i ∈ [n] (lines 10–
12), where r is a new, random κ-bit nonce (line 9). The resulting
values {yi}i ∈[n] are divided into ℓ groups of size k − 1, each group
being used to construct a set of k − 1 points Pointsj ← {⟨i,yi⟩ |
(j − 1)(k − 1) < i ≤ j(k − 1)} (line 14) on which vssMakeSecret
is invoked (line 15). The resulting sj ∈ Zq[x] is then shared using
V (line 16). Recall that by the definition of vssMakeSecret, each
u
∗
i
[j] thus produced satisfies u
∗
i
[j] = yi
. Of course, the input secret
s is also shared (line 17). The results of these sharings are grouped
according to replica index i and returned as u
∗
i
for each i ∈ [n],
along with all of the sharing commitments c
∗
and the nonce r
(line 18).
vssVerify∗
and vssReconstruct∗ operate in the natural way.
vssVerify∗
verifies the commitment c
∗
[0] and share u
∗
i
[0] (line 21)
produced in the sharing of s, as well as verifying the commitment
c
∗
[j] and share u
∗
i
[j] (line 28) produced in the sharing of sj
. In
addition, it verifies (intuitively) that u
∗
i
[j] = yi
(line 25). The latter
two verifications are skipped if u
∗
i
[1] = ⊥ (line 23), which occurs
if the share u
∗
i was recovered (see below). In this case, u
∗
i
[j] = ⊥
for all j ∈ [ℓ] (or should be, and so any j ∈ [ℓ] for which u
∗
i
[j] , ⊥
is just ignored). vssReconstruct∗
simply uses vssVerify∗
to verify
each share u
∗
i
provided as input (line 33) and then submits c
∗
[0]
and the inputs {⟨vpki
,u
∗
i
[0]⟩}i ∈I
to vssReconstruct to reconstruct
s (line 36).
vssRecoverContrib∗
(c
∗
,r, vsk∗
i
,u
∗
i
,
ˆi) is invoked at replica i to
construct its contribution to enable replica ˆi to reconstruct its share
u
∗
ˆi
. vssRecoverContrib∗
returns u
∗
i
[0] blinded by u
∗
i
[j] (line 41)
where j ← ⌈ˆi/(k − 1)⌉. Then, so that replica ˆi can recover its share
of the original secret, replica i also returns its share of the DPRF
scheme F evaluated at ⟨r,
ˆi⟩ (line 39).
vssRecoverVerify∗
(c
∗
,r,v
∗
i
, vpk∗
i
,
ˆi) is executed by replica ˆi to
verify that replica i performed vssRecoverContrib∗
correctly. The
output of vssRecoverContrib∗
contributed by replica i is passed into
vssRecoverVerify∗
as v
∗
i
and is parsed into its constituent components in line 44. First, the DPRF contribution di
is checked on line 46
to ensure that it corresponds to a correct evaluation of the DPRF
scheme F at the point ⟨r,
ˆi⟩. vssRecoverVerify∗
then combines the
commitments (line 48) and uses vssVerify (line 49) to check that
the blinded share u was created correctly. If both checks pass, then
vssRecoverVerify∗
returns true.
vssRecover∗
(c
∗
,r, {⟨vpk∗
i
,v
∗
i
⟩}i ∈I
,
ˆi, vpk∗
ˆi
) is executed at replica ˆi
to recover its share u
∗
ˆi
. In particular, u
∗
ˆi
[0] will be a share of the original polynomial for ˆi. vssRecover∗ first invokes vssRecoverVerify∗
to make sure that the share sent by each replica i ∈ I is correct
(line 55). vssRecover∗
then leverages vssReconstruct (line 60) to
reconstruct a polynomial s ∈ Zq[x] that is the sum of the polynomial originally shared in vssShare∗
that resulted in commitment
c
∗
[0] and the j-th masking polynomial sj that resulted in commitment c
∗
[j], where j = ⌈
ˆi/(k − 1)⌉. vssRecover∗
then evaluates s(
ˆi)
Session 10C: Secret Sharing CCS ’19, November 11–15, 2019, London, United Kingdom 2392
1: procedure vssInit∗
(1
κ
, k,n)
2: ⟨q, {⟨vpki
, vski⟩}i ∈[n]
⟩ ← vssInit(1
κ
, k,n)
3: ⟨{⟨dpki
, dski⟩}i ∈[n]
⟩ ← dprfInit(1
κ
, k,n, {0, 1}
κ × [n], Zq )
4: for i ∈ [n] do
5: vpk∗
i ← ⟨vpki
, dpki
⟩
6: vsk∗
i ← ⟨vski
, dski⟩
7: return ⟨q, {⟨vpk∗
i
, vsk∗
i
⟩}i ∈[n]
⟩
8: procedure vssShare∗
(s,q, {dski}i ∈[n]
, {vpk∗
i
}i ∈[n]
)
9: r
$← {0, 1}
κ
10: for i ∈ [n] do
11: ⟨vpki
, dpki
⟩ ← vpk∗
i
12: yi ← dprfEval(⟨r,i⟩, {dprfContrib(dskˆi
,⟨r,i⟩)}ˆi ∈[n]
)
13: for j ∈ [ℓ] do
14: Pointsj ← {⟨i,yi⟩ | (j − 1)(k − 1) < i ≤ j(k − 1)}
15: sj ← vssMakeSecret(q, Pointsj
)
16: ⟨c
∗
[j], {u
∗
i
[j]}i ∈[n]
⟩ ← vssShare(sj
,q, {vpki
}i ∈[n]
)
17: ⟨c
∗
[0], {u
∗
i
[0]}i ∈[n]
⟩ ← vssShare(s,q, {vpki
}i ∈[n]
)
18: return ⟨c
∗
,r, {u
∗
i
}i ∈[n]
⟩
19: procedure vssVerify∗
(vpk∗
i
,c
∗
,r,u
∗
i
)
20: ⟨vpki
, dpki
⟩ ← vpk∗
i
21: if vssVerify(vpki
,c
∗
[0],u
∗
i
[0]) = false then
22: return false
23: if u
∗
i
[1] , ⊥ then
24: j ← ⌈i/(k − 1)⌉
25: if dprfVerify(dpki
,⟨r,i⟩,u
∗
i
[j]) = false then
26: return false
27: for j ∈ [ℓ] do
28: if vssVerify(vpki
,c
∗
[j],u
∗
i
[j]) = false then
29: return false
30: return true
31: procedure vssReconstruct∗
(c
∗
,r, {⟨vpk∗
i
,u
∗
i
⟩}i ∈I
)
32: for i ∈ I do
33: if vssVerify∗
(vpk∗
i
,c
∗
,r,u
∗
i
) = false then
34: return ⊥
35: ⟨vpki
, dpki
⟩ ← vpk∗
i
36: return vssReconstruct(c
∗
[0], {⟨vpki
,u
∗
i
[0]⟩}i ∈I
)
37: procedure vssRecoverContrib∗
(c
∗
,r, vsk∗
i
,u
∗
i
,
ˆi)
38: ⟨vski
, dski⟩ ← vsk∗
i
39: di ← dprfContrib(dski
,⟨r,
ˆi⟩)
40: j ← ⌈ˆi/(k − 1)⌉
41: return ⟨di
, (u
∗
i
[0] + u
∗
i
[j])⟩
42: procedure vssRecoverVerify∗
(c
∗
,r,v
∗
i
, vpk∗
i
,
ˆi)
43: j ← ⌈ˆi/(k − 1)⌉
44: ⟨di
,u⟩ ← v
∗
i
45: ⟨vpki
, dpki
⟩ ← vpk∗
i
46: if dprfVerify(dpki
,⟨r,
ˆi⟩,di
) = false then
47: return false
48: c ← vssCombineCommitments(c
∗
[0],c
∗
[j])
49: if vssVerify(vpki
,c,u) = false then
50: return false
51: return true
52: procedure vssRecover∗
(c
∗
,r, {⟨vpk∗
i
,v
∗
i
⟩}i ∈I
,
ˆi, vpk∗
ˆi
)
53: j ← ⌈ˆi/(k − 1)⌉
54: for i ∈ I do
55: if vssRecoverVerify∗
(c
∗
,r,v
∗
i
, vpk∗
i
,
ˆi) = false then
56: return ⊥
57: ⟨di
,ui⟩ ← v
∗
i
58: ⟨vpki
, dpki
⟩ ← vpk∗
i
59: c ← vssCombineCommitments(c
∗
[0],c
∗
[j])
60: s ← vssReconstruct(c, {⟨vpki
,ui⟩}i ∈I
)
61: yˆi ← dprfEval(⟨r,
ˆi⟩, {di}i ∈I
)
62: u
∗
ˆi
← ⟨(s(
ˆi) − yˆi
), ⊥, . . . , ⊥⟩
63: if vssVerify∗
(vpk∗
ˆi
,c
∗
,r,u
∗
ˆi
) = false then
64: return ⊥
65: return u
∗
ˆi
Figure 1: Pseudocode for our VSS scheme
and subtractssj
(
ˆi) = dprfEval(⟨r,
ˆi⟩, {di}i ∈I
) (lines 60–62) to obtain
u
∗
ˆi
[0].
3.6 Security
Below, we sketch a proof that our modified VSS scheme preserves
the security properties from the underlying VSS protocol.
Hiding. First note that if a hiding adversary AV∗ for V∗
is
legitimate, then it is legitimate for both F and V. Consider an
execution in which O
?
F
(used in place of dprfEval) is instantiated
as O
rand
F
. For any commitment c
∗
, the set of indices I for which
AV∗ obtains the shares {u
∗
i
[0]}i ∈I produced in line 17 (i.e., in its
invocation of O
b
V∗
that returned c
∗
) satisfies |I | < k. To see why,
note that AV∗ can obtain u
∗
i
[0] for any i in one of three ways: (i)
by invoking OV∗
,i
.compromise; (ii) by invoking OV∗
,i
.contrib(c
∗
);
or (iii) by invoking OV∗
,
ˆi
.recover(c
∗
,i) at each ˆi ∈ ˆI where |
ˆI | ≥
k, in which case AV∗ can recover u
∗
i
[0] using the vssRecover∗
routine (line 62). Critically, invoking OV∗
,
ˆi
.recover(c
∗
,i) at each
ˆi ∈ ˆI where |
ˆI | < k yields no information about u
∗
i
[0], since when
|
ˆI | < k, the value yi
is random (line 61) and so u
∗
i
[0] = s(i) −
yi
(line 62) is hidden information-theoretically. Because AV∗ is
legitimate, it thus obtains u
∗
i
[0] for only fewer than k values of i,
and so if its success (in the sense of Equation (2)) is nonnegligible
in κ, then we can construct a hiding attacker for V with success
nonnegligible in κ, as well.
Now suppose AV∗ has success in the execution above that is
only negligible in κ, and consider an execution in which O
?
F
is
instead instantiated as O
real
F
. If AV∗ now has success that is nonnegligible in κ, then we can use AV∗ to construct a DPRF attacker
for F with success nonnegligible in κ (in the sense of Equation (1)).
Session 10C: Secret Sharing CCS ’19, November 11–15, 2019, London, United Kingdom 2393
To summarize, if there is a hiding attacker that breaks V∗ with
nonnegligible probability, then either there is a hiding attacker that
breaks V with nonnegligible probability or there is a DPRF attacker
that breaks F with nonnegligible probability.
Binding. A binding adversary AV∗ is provided inputs ⟨q, {⟨vpk∗
i
,
vsk∗
i
⟩}i ∈[n]
⟩ ← vssInit∗
(1
κ
, k,n), and succeeds if it outputsc
∗
, {u
∗
i
}i ∈I
and {uˆ
∗
i
}
i ∈ ˆI
for which
vssReconstruct∗
(c
∗
,r, {⟨vpk∗
i
,u
∗
i
⟩}i ∈I
) = s
∧ vssReconstruct∗
(c
∗
,r, {⟨vpk∗
i
,uˆ
∗
i
⟩}i ∈ ˆI
) = sˆ
∧ s , ⊥ ∧ sˆ , ⊥ ∧ s , sˆ
Let s and sˆ be values satisfying this condition. Then,
s = vssReconstruct(c
∗
[0], {⟨vpki
,u
∗
i
[0]⟩}i ∈I
)
sˆ = vssReconstruct(c
∗
[0], {⟨vpki
,u
∗
i
[0]⟩}i ∈ ˆI
)
where ⟨q, {⟨vpki
, vski⟩}i ∈[n]
⟩ ← vssInit(1
κ
, k,n) (see lines 2 and 36).
That is, breaking binding for V∗
implies breaking binding for V,
and so if V ensures the binding property, then so does V∗
.
3.7 Instantiating VSSR
Now we discuss how to instantiate VSSR concretely given a DPRF
scheme [40] and a VSS scheme from Kate et al. [31]. We also instantiate our VSSR with a VSS scheme from Pedersen [44], whose
details can be found in Appendix B.
3.7.1 Kate et al. Secret Sharing. We describe how to fit the secret
sharing scheme from Kate et al. [31] into our framework. Note that
this secret sharing scheme also has a witness, which proves that
a particular share is consistent with the polynomial commitment.
Witnesses are additively homomorphic as well and can be manipulated the same way as the shares can. In particular, we can perform
polynomial interpolation in order to take a set of f witnesses and
obtain the witness for any other share. Additionally, we only need
to send a witness when we transmit the corresponding share. Thus,
witnesses only increase the communication overhead by a constant
factor. In the description below, we assume that we have the witness
corresponding to each share.
• vssInit(1
κ
, k,n) first chooses a safe prime q at least κ bits in
length. Then, we initialize two groups of order q: G and Gt
such that there exists a bilinear map e : G × G → Gt
. We
then generate a τ ∈ Zq and pick a generator д ∈ G. Set vpki
to be ⟨G, Gt
, e,д, {д
τ
j
}j ∈[f ]
⟩ and vski to be ⊥ for all i. Then,
we delete τ . Finally, vssInit returns ⟨q, {⟨vpki
, vski⟩}i ∈[n]
⟩.
• vssShare(s,q, {vpki
}i ∈[n]
) first extracts the public key and
gets д and {д
τ
j
}j ∈[f ]
. Let sj be the coefficient of the x
j
term
in s and s(i) be the evaluation ofs at pointi. We now compute
д
s (τ ) by computing Qf
j=0
(д
τ
j
)
sj and assign it to c. Now, using polynomial division, we can compute the coefficients of
s (x )−s (i)
x−i
, which will allow us to compute д
s (τ )−s (i)
τ −i which is
the witness for ui
. We also set ui to be s(i). Finally, vssShare
returns ⟨c, {ui}i ∈[n]
⟩.
• vssVerify(vpki
,c,ui
) first extracts д
s (τ )
from c, s(i) from ui
,
and e, д, д
τ
from vpki
. We also have access to the value
д
s (τ )−s (i)
τ −i since the witness for the share is transmitted along
with the share. Then, vssVerify returns true if e (д
s (τ )
,д)
equals e (д
s (τ )−s (i)
τ −i ,
д
τ
д
i
)e (д,д)
s (i)
and false otherwise.
• vssReconstruct(c, {⟨vpki
,ui⟩}i ∈I
) first calls
vssVerify(vpki
,c,ui
) for all i ∈ I. If all of vssVerify calls
return true, then we continue. Otherwise, vssReconstruct returns ⊥. Then, we extract s(i) from each ui and do Lagrange
interpolation to identify the original polynomial and return
that value.
• vssMakeSecret(q, {⟨xi
,yi⟩}i ∈I
) does a Lagrange interpolation in order to identify the unique degree k − 1 polynomial
in Zq[x] that goes through (xi
,yi
) and returns that as s.
• vssCombineCommitments(c,cˆ) first extracts д
s (τ )
from c
and д
sˆ(τ )
from cˆ. We then set cˇ to (д
sτ
)(д
sˆ(τ )
) and return
that value.
3.7.2 DPRF Instantiation. Our distributed pseudorandom function
F consists of four algorithms: dprfInit, dprfContrib, dprfVerify,
and dprfEval. Our implementation defines them as follows [40]:
• dprfInit(1
κ
, k,n, D, Zq ), first chooses a generator h of G of
order q. A k out of n secret sharing of a private value α ∈ Zq
is produced using Shamir secret sharing [49], of which the
shares are {αi}i ∈[n]
. dpkˆi
is set to ⟨h,h
α
, {h
αi }i ∈[n]
⟩ for all
ˆi = 1..n. dskˆi
is set to αˆi
for all ˆi = 1..n. dprfInit outputs
{⟨dpki
, dski⟩}i ∈[n]
.
• dprfContrib(dski
, x) first computes fi
(x) = H(x)
αi where
H : {0, 1}
∗ → G is a hash function that is modeled as a
random oracle. Here, αi
is obtained from the dski
. Let r be
a randomly generated element of Zq
′. Then, we let ci ←
H
′
(H(x),h, fi
(x),h
αi
,H(x)
r
,h
r
), where H
′
: {0, 1}
∗ → Zq
is a hash function modeled as a random oracle. We set zi ←
αici + r mod q. dprfContrib then outputs ⟨fi
(x), zi
,ci⟩.
• dprfVerify(dpki
, x,d) first extracts fi
(x), ci
, and zi from d.
Then, h and h
αi are extracted from dpki
. Finally, dprfVerify
returns true if
ci = H
′
(H(x),h, fi
(x),h
αi
,H(x)
zi
fi
(x)
−ci
,h
zi
(h
αi
)
−ci
).
• dprfEval(x, {di}i ∈I
) first verifies each di using dprfVerify. If
any of the verifications returns false, then dprfEval returns
⊥. Otherwise, we extract fi
(x) values from each di
. Since
the exponents of fi
(x) were shared in the exponent using
Shamir secret sharing, dprfEval uses Lagrange interpolation
in the exponent to get the value of F at x, hashes it into an
element of Zq and outputs that value.
4 SECRET SHARED STATE ON PBFT
In this section, we describe how to build a private replicated key/value
store with Byzantine Fault Tolerance by incorporating VSSR into
PBFT [13]. The service provides put(K,V ) and get(K) APIs for writing and reading the value of a key respectively.
Our design assumes a partial asynchronous Byzantine model.
Specifically, we have n = 3f +1 replicas, ≤ f of which are Byzantine.
The correctness of the value read from a key is ensured despite
up to f Byzantine-faulty replicas, and values are also kept private
from f faulty replicas, using our verifiable secret-sharing approach.
Similar to previous works (e.g., [10, 39]), a client shares a secret
value directly among the replicas, and a consensus protocol drives
agreement on a verifiable digest of the value.
Session 10C: Secret Sharing CCS ’19, November 11–15, 2019, London, United Kingdom 2394
The network is assumed to be asynchronous, but will eventually
go through periods of synchrony in which messages are delivered within a known time bound and correct replicas and clients
make progress at a known rate. The network assumption is due
to PBFT’s [13] network assumptions. VSSR’s construction is completely independent of the network model of the underlying BFT
protocol. We assume that each message is signed by its sender so
that its origin is known, subject to standard cryptographic assumptions.
Every client in the system is allowed to view all keys in the store.
However, the service maintains a (potentially dynamic) access control policy that specifies which values each client can open. Under
these assumptions, we provide the standard guarantees provided
by a Byzantine fault tolerant protocol:
• Linearizability [28]. If a client sends a request to the replicated service, then the service’s response is consistent with
an execution where the client’s request was executed instantaneously at some point between when the request was sent
and the response was received.
• Liveness. If the network is synchronous, then every client
request will get a response.
In addition to these standard properties, our design offers the
following privacy property:
• Privacy. A value written to a key by a correct client where
the access-control policy prohibits access by any faulty client,
remains hidden from f Byzantine servers.
4.1 Setup
In addition to setting up authenticated communication channels
among all parties in a setup phase, vssInit∗
is called for every client
in the system and is part of the public/private key infrastructure.
The client takes the role of the dealer in vssInit∗ while each replica
takes the role of a participant. In particular, each client knows the
secret keys for all replicas returned from its invocation of vssInit∗
.
Every replica stores a full copy of the K-V store. For each key
there are two value entries, a public value (keyed K-pub) and a
private value (keyed K-priv). A replica maintains a bounded log
of pending commands that cannot grow beyond a certain systemwide parameter W . Once a command in the log is committed by
the system, it is applied to the K-V store.
Views. Our solution employs a classical framework [13, 21] that
revolves around an explicit ranking among proposals via view numbers. Replicas all start with an initial view, and progress from one
view to the next. They accept requests and respond to messages
only in their current view. In each view there is a single designated
leader. In a view, zero or more decisions may be reached. If a sufficient number of replicas suspect that the leader is faulty, then a
view change occurs and a new leader is elected. The precise way
views are changed are described in Appendix C.
4.2 Common Mode Protocol
A client put is split into two parts, public and private. More specifically, in a put(K,V ) request, the client privately sharesV via vssShare∗
,
and sends each share to its corresponding replica. The public part
of put(K,V ) consists of a client sending a put(K,cV ) request to the
client
leader
put(	 K,	cV ) vssShare(V)
wait
wait
prepare commit put	ACK pre-prepare
(a) faultless IO path
client
leader
put(	 K,	cV ) vssShare(V)
wait
prepare commit put	ACK
sharerecovery
pre-prepare prepare
(b) IO path with recovery
Figure 2: put common mode
current leader. cV is a global commitment to the polynomial s that
binds the share of each replica as a verifiable share of s.
The leader waits until its local log has length < W . It then
extends its local log with the put request, and sends a pre-prepare
(ordering-request) containing its log tail.
A replica accepts a pre-prepare from the leader of the current
view if it is well-formatted, if it extends any previous pre-prepare
from this leader, if its log has fewer than W pending entries, and if
the replica received a valid share corresponding to cV . If the leader
pre-prepare message has a valid format, but the replica did not
receive the corresponding share for it, it starts a timer for sharerecovery (see Appendix C).
After accepting the pre-prepare, a replica follows the regular
PBFT protocol. The replica first extends its local log to include
the new request and broadcasts a prepare message to all replicas
that includes the new log tail. Replicas wait to collect a commitcertificate, a set of 2f + 1 prepare responses for the current log
tail. Then the replica broadcasts a commit message carrying the
commit-certificate to the other replicas. A decision is reached in
a view on a new log tail when 2f + 1 distinct replica have sent a
commit message for it.
When a replica learns that a put(K,V ) request has been committed to the log, it inserts to its local key-value store two entries, a
global entry (K-pub,cV ) containing the global commitment to V ,
and a private entry (K-priv,u
∗
i
) containing the replica’s private
share u
∗
i
. The replica then responds to the client with a put acknowledgement message containing K and cV . A client waits to
receive 2f + 1 put responses to complete the request. Figure 2a
depicts the put io path, and Figure 2b the put io path when shares
are missed.
The client get(K) protocol consists of sending the get request to
the current leader. The pre-prepare, prepare and commit phases
of the ordering protocol are carried as above, without the need to
Session 10C: Secret Sharing CCS ’19, November 11–15, 2019, London, United Kingdom 2395
wait for shares. At the final stage, when a replica executes the get
requests, it returns its share to the client in a response. If the replica
is missing its share, it initiates the share-recovery protocol. The
client waits to receive f +1 valid get responses. It uses vssVerify∗
to
verify each response, and vssReconstruct∗
to reconstruct the secret
value from the responses.
4.3 Share-Recovery Protocol
There are several circumstances in the protocol when a replica
discovers it is missing its private share of a request and needs to
recover it. To initiate share-recovery, a replica broadcasts a recovery
request. Other replicas respond to a share-recovery request with
the output of vssRecoverContrib∗
. After receiving a response, the
original replica uses vssRecoverVerify∗
to check the response. If
the response is valid, then it is stored, and if it is invalid, then it is
dropped. When it receives f + 1 valid responses, the replica uses
vssRecover∗
to recover its missing secret share.
4.4 Common mode performance
The common mode protocol incurs the following performance costs.
The client interaction with the BFT replicated service is linear, since
it needs to populate all replicas with shares. Additionally, the client
collects f + 1 responses from servers.
The communication among the replicas to achieve an ordering
decision is quadratic. There are several practical variants of BFT
replication that achieve linear communication during periods of
synchrony and when a leader is non-faulty (e.g., [26, 33, 37]) These
improvements are left outside the scope of this paper. However, our
modified VSS protocol is designed so it can be incorporated within
them without increasing the asymptotic complexity of the common
mode.
In terms of latency, the sharing protocol is non-interactive and
single-round, and so it can be performed concurrently with the
leader broadcast. Recovery incurs extra latency since each replica
must ask at least f +1 correct replicas for their contributions. In the
original BFT protocol, recovering a missing request only requires
asking 1 correct replica for the request data. In both cases, the
recovery protocol is interactive and single-round, so there are no
asymptotic increases in latency. However, in practice, there will be
a difference in latency between the two scenarios.
Proof Intuition. The full proof that our construction satisfies the
linearizability, liveness and privacy properties above is in Appendix A. We present high level intuition behind our proofs here.
To show linearizability and liveness, we show that every execution of our secret shared PBFT protocol can be mapped to an
execution of an unmodified PBFT protocol. Since the original PBFT
protocol satisfies linearizability and liveness, so does our modified
protocol. Privacy is shown by using the fact that to recover a secret
shared value, an adversary must obtain the cooperation of at least
one correct replica.
5 IMPLEMENTATION
We implement a secret shared BFT engine by layering PBFT [13]
with our secret sharing scheme. Our implementation consists of
4700 lines of Python and 4800 lines of C. We optimize our design
for multi-core environments, with one network thread running
on a core which never blocks. Additionally, we use one thread for
every other core in order to do all cryptographic operations that are
required by PBFT and our secret sharing scheme. We use elliptic
curve signatures with the secp256k1 library for all signature checking operations and the Relic library [2] for all other cryptographic
operations related to our scheme. We also make a few optimizations
for the Kate et al. and Pedersen secret sharing schemes in order to
make them faster.
Kate et al. Kate et al.’s secret sharing scheme lends itself for extensive caching during setup time. Once the powers д
τ
j
are known
for all j, we construct precomputation tables for each coefficient so
that all exponentiations during runtime leverage these tables for
efficiency. In the sharing step, we first use the well known Horner’s
method to optimize the share evaluation. However, we also note
that each intermediate value obtained in Horner’s method when
evaluating s(i) is also the coefficient of the quotient polynomial
s (x )−s (i)
x−i which means that we can do the necessary division required for free before using our precomputation tables to evaluate
the quotient at τ . In the share verification step, every verification
requires the value of e (д,д) so we can precompute that as well to
save a bilinear map operation. Also in the share verification phase,
the division of д
τ
д
i only has n possible values, which means that
we can precompute all of these values as well. Finally, when doing
Lagrange interpolation, we know that the indices range from 0 to
n − 1 and in the denominator, we need to compute the product
of differences of these indices. Thus, to avoid taking inverses, we
simply take inverses of all n values of the differences which means
that during runtime, we only have to do multiplications.
Pedersen. Pedersen’s secret sharing scheme does not lend itself
to as much caching since most of the values are unknown beforehand. However, we do generate precomputation tables for both д
and h during setup and compute the inverses to make Lagrange
interpolation easier.
6 EVALUATION
Our evaluation seeks to answer two basic questions. First, we investigate the costs of each API call in our secret sharing scheme. Then,
we look at how expensive it is to incorporate our secret sharing
scheme into a BFT key value store. We instantiate VSSR using the
DPRF in Naor et al. [40] and two different VSS schemes: Pedersen’s VSS scheme [44] and Kate et al.’s VSS scheme [31]. We call the
Pedersen instantiation Ped-VSSR and the Kate et al. instantiation
KZG-VSSR. Our implementation uses the Relic [2] cryptographic
library and, for our elliptic-curve algorithms, the BN_P254 curve.
We build a private BFT key value store using PBFT replication [13], implemented in Python and C, incorporating VSSR into
the write path of the algorithm.
6.1 Microbenchmarks
For our microbenchmarks, we evaluate each function in our VSSR
scheme. We vary the number of replicas from 4 to 211 and measure the latency and throughput of each operation. We use EC2
c5.xlarge instances in order to run our microbenchmarks, which
have 4 virtual CPUs per instance.
Session 10C: Secret Sharing CCS ’19, November 11–15, 2019, London, United Kingdom 2396
(a) vssShare∗
throughput (b) vssShare∗
latency
Figure 3: vssShare∗
latency and throughput vs. n
The module that implements our secret sharing scheme optimizes for throughput, while compromising slightly on latency. Each
API call runs on a single core; the task is run to completion and the
result is returned in the order that the tasks were enqueued. This
maximizes for throughput due to the lack of cross core communication, but at the expense of request latency as many of the underlying
cryptographic operations can leverage multi-core environments to
execute faster.
Each microbenchmark ran for at least 60 seconds and collected
at least 30 samples. Before computing the final statistic, we ignored
any requests that were completed in the first 10 seconds and the
last 10 seconds of the run. We report the aggregate throughput
during the run and the mean and standard deviation of the latency
of each request completed in our run.
Figure 4: Volume the dealer
transmits per replica to share
a secret among n replicas
6.1.1 vssShare∗ Microbenchmark. Figure 3a shows that
Ped-VSSR can sustain more
sharings per second than
KZG-VSSR for all cluster
sizes. This gap increases as
the number of replicas increases. The difference between Ped-VSSR and KZGVSSR is due to the underlying VSS scheme. KZGVSSR computes witnesses
for each share, which involves evaluating a polynomial in the elliptic curve
group. Additionally, the throughput decrease is quadratic since
evaluating each share (or witness) takes O(n) CPU time and there
are n shares. So, vssShare∗
takes O(n
2
) time for both KZG-VSSR
and Ped-VSSR. We see this cost mirrored in the latency graph as
well in Figure 3b.
Figure 4 shows the size of the share and associated metadata
that is sent to each replica when the client shares a single 254 bit
integer, which is equal to the disk space that the replica needs to
store a secret shared value. As expected, Ped-VSSR has a linearly
increasing bandwidth and storage footprint with respect to the
cluster size. Meanwhile, KZG-VSSR only requires each replica to
store 860 bytes of information irrespective of the cluster size.
(a) vssVerify∗
throughput (b) vssVerify∗
latency
Figure 5: vssVerify∗
latency and throughput vs. n
(a) vssReconstruct∗
throughput (b) vssReconstruct∗
latency
Figure 6: vssReconstruct∗
latency and throughput vs. n
(a) vssRecoverContrib∗
throughput (b) vssRecoverContrib∗
latency
Figure 7: vssRecoverContrib∗
latency and throughput vs. n
6.1.2 vssVerify∗ Microbenchmark. Figure 5 shows that the throughput and latency of verifying a share, which is done by the replicas upon receiving a share. We see that KZG-VSSR’s latency and
throughput stays constant at 117 operations per second with a 350
millisecond mean latency irrespective of the cluster size. Meanwhile,
Ped-VSSR’s throughput decreases and latency increases as the number of replicas in the cluster increases. We see that KZG-VSSR
is asymptotically faster than Ped-VSSR, but Ped-VSSR’s cheaper
cryptographic operations still causes it to outperform KZG-VSSR.
6.1.3 vssReconstruct∗ Microbenchmark. vssReconstruct∗ has almost identical performance between KZG-VSSR and Ped-VSSR,
as we see in Figure 6. vssReconstruct∗ does not include the time
taken to run vssVerify∗
since share verification happens when the
message itself is verified. Figure 6a shows that vssReconstruct∗
can occur at very high throughput with its performance dropping
off quadratically. Figure 6b similarly shows that the latency is increasing quadratically as the cluster size increases. This quadratic
performance hit is due to the quadratic number of modular multiplications each vssReconstruct∗
requires.
Session 10C: Secret Sharing CCS ’19, November 11–15, 2019, London, United Kingdom 2397
(a) vssRecoverVerify∗
throughput (b) vssRecoverVerify∗
latency
Figure 8: vssRecoverVerify∗
latency and throughput vs. n
(a) vssRecover∗
throughput (b) vssRecover∗
latency
Figure 9: vssRecover∗
latency and throughput vs. n
6.1.4 vssRecoverContrib∗ Microbenchmark. Figure 7 shows that
vssRecoverContrib∗
throughput and latency is independent of the
cluster size for both KZG-VSSR and Ped-VSSR. Additionally, PedVSSR’s vssRecoverContrib∗ has exactly half the throughput (430 vs.
860) and twice the latency (118 ms vs. 59 ms) of KZG-VSSR. This
is a side effect of using recovery polynomials to do share recovery.
vssRecoverContrib∗ only has to do a constant amount of work per
recovery. Ped-VSSR’s vssRecoverContrib∗ operation requires two
polynomial shares to be recovered while while KZG-VSSR only
requires one.
6.1.5 vssRecoverVerify∗ Microbenchmark. Figure 8 shows that KZGVSSR’s vssRecoverVerify∗ operation has higher throughput and
lower latency than Ped-VSSR. This performance difference occurs
since vssRecoverVerify∗ must combine commitments and witnesses
from the contributions received from vssRecoverContrib∗
. KZGVSSR performs this computation using a constant number of elliptic curve multiplications whereas Ped-VSSR computes this using a
linear number of elliptic curve multiplications. Thus, as the cluster
size increases, Ped-VSSR’s performance also degrades accordingly.
6.1.6 vssRecover∗ Microbenchmark. Similar to vssReconstruct∗
,
share verification via vssRecoverVerify∗ happens in our implementation upon receiving each share from a replica. Figure 9 shows
that vssRecover∗
incurs costs primarily due to interpolation (like
vssReconstruct∗
), evaluation of the DPRF and interpolation of any
witnesses. Therefore, asymptotically, we see in Figure 9a and Figure 9b that vssRecover∗ behaves similarly to vssReconstruct∗ but
with an order of magnitude lower throughput and an order of magnitude higher latency.
(a) PUT operation throughput (b) PUT operation latency
Figure 10: PUT operation latency and throughput vs. n
6.2 Incorporating VSSR into PBFT
We incorporate VSSR into a PBFT implementation in order to implement a threshold trusted third party (T3P). We instantiate our T3P
using KZG-VSSR and Ped-VSSR, which we will refer to as KZG-T3P
and Ped-T3P. We also implement and evaluate a key-value store on
top of KZG-T3P, Ped-T3P, and PBFT.
To generate load in our evaluation, a client sends PUT requests
asynchronously to the primary. The client pregenerates the requests
to send to the cluster and loops through them once they are finished.
For our throughput experiments, the clients asynchronously send
enough requests at a time to saturate the system. For our latency
benchmarks, the clients send requests serially and measure the
latency of each request. We used Amazon AWS to run our tests and
used c5.4xlarge instances for all clients and replicas.
Similar to our microbenchmarks, our implementation uses the
Relic [2] cryptographic library for most cryptographic operations
and the BN_P254 elliptic curve. For signatures in PBFT, our implementation uses the optimized secp256k1 library used in Bitcoin.
6.2.1 Benchmarks. Figure 10b shows that for all schemes and cluster sizes, the request latency is less than 35 milliseconds. We see the
expected performance hits, such as KZG-T3P having lower performance than Ped-T3P and secret sharing having some overhead over
vanilla PBFT. However, the total latencies show that our scheme is
efficient enough to be used in certain scenarios.
Figure 10a shows the throughput overhead of secret sharing.
Due to the quadratic overhead of Ped-T3P and PBFT, we see that
the performance penalty stays roughly constant over all cluster
sizes. Since KZG-T3P is linear, we see the performance overhead
shrinking slightly as the cluster size increases. PBFT took a 78%
performance hit in throughput when going from n = 4 to n = 25.
Similarly, Ped-T3P took a 79% performance hit. However, KZG-T3P
did a linear number of cryptographic operations that dominated
the performance overhead and only suffered a 60% drop.
7 RELATED WORK
This paper makes three primary contributions: VSSR, a framework
for building VSS schemes that provides share recovery; KZG-VSSR,
an instantiation of VSSR that has linear dealer cost on the sharing
phase; and a threshold trusted third party (T3P) built by combining
VSSR with a Byzantine Fault Tolerant state machine. We discuss
the related works below.
Session 10C: Secret Sharing CCS ’19, November 11–15, 2019, London, United Kingdom 2398
7.1 Proactive secret sharing
A treatment of the prior work in verifiable secret sharing and asynchronous verifiable secret sharing is given in Section 2.2. Unlike
those prior works though, another way to approach share recovery
is through proactive secret sharing. Proactive secret sharing has
been used in threshold signature schemes [15, 17] and in storage
systems [6, 51]. Using proactive secret sharing for share recovery
would require sending a random polynomial that has nothing in
common with the original shared polynomial except for the share
that the recovering replica is interested in.
Prior work in proactive secret sharing [30] is difficult to apply
directly to the problem of share recovery, however. Some works [29,
30] assume a synchronous broadcast channel that delivers to all
replicas instantaneously, which greatly simplifies the problem of
agreeing on a random recovery polynomial. Other proactive secret
sharing systems [6, 18, 23, 41, 42, 51] require replicas to reshare their
secret shares and a new polynomial is formed through interpolation.
Batching [4, 5] and parallelization [24] also have been explored in
proactive secret sharing schemes, and while batching provides
similar asymptotic guarantees to KZG-VSSR, it does so at a large
latency cost. PVSS [53] does not make any such assumption and can
be used in VSSR, but it suffers from an exponential setup cost in the
number of faults it tolerates, making it unusable for tolerating more
than a few faults. MPSS [48] uses a Byzantine agreement protocol
in order to explicitly agree on the random recovery polynomial,
which would add a few additional rounds to VSSR if used in share
reconstruction. CHURP [36] uses bivariate polynomials and thus
the share refresh protocol incurs a quadratic cost.
Although closest “in spirit” to proactive recovery schemes, VSSR
addresses only the share phase. It is left for future work to see
whether proactive share recovery can be expedited with techniques
borrowing from VSSR.
7.2 Privacy in BFT
Methods to store data across n storage nodes in a way that ensures
the privacy, integrity, and availability of the data despite up to k of
these nodes being compromised is a theme that has been revisited
numerous times in the last 30 years (e.g., [19, 25, 27, 35, 50]). The
proposals in this vein of research often do not defend against the
misbehavior of the data writers. In particular, a data writer might
deploy data to the storage nodes in a way that makes data recovery
impossible or ambiguous, in the sense that the data reconstructed
depends on which correct nodes cooperate to do so. Protecting
against corrupt data writers is one of the primary goals of verifiable
secret sharing and its derivatives, for which we’ve surveyed the
most directly related works in Section 2.
With the rise of blockchains supporting smart contracts, there
has been a resurgence of activity in finding ways to add privacy
guarantees to Byzantine fault-tolerant algorithms, and indeed this
is one motivation behind our work. Another class of approaches to
this problem uses zero knowledge proofs [38, 47] for privacy. These
approaches provide a very strong guarantee where it is impossible
for anyone (other than the data owner) to recover the sensitive data,
but where anyone can validate that the data satisfies some prespecified properties. However, such systems only work for a limited set
of applications, rather than general purpose state machines that we
target here. Additionally, these systems do not have any control
over the data itself; i.e., the sensitive data must be managed by the
owner, which is not suitable for a large class of applications.
CALYPSO [32] resolves this through the use of a publicly verifiable secret sharing scheme, but they require two BFT clusters—one
for access control and one for secret management. Thus, their protocol requires more replicas to operate. Additionally, CALYPSO
requires the access-control policy to be specified ahead of time by
the client, whereas a T3P can easily allow dynamic access-control
policies.
A related line of work addresses the problem of causal ordering in
Byzantine systems using secret sharing [9, 20, 45]. However, these
systems use secret sharing to hide commands from the replicated
service for fairness and consequently reveal the commands immediately. Thus, these techniques do not help with our key problem
of share recovery.
8 CONCLUSION
This paper investigates how to incorporate verifiable secret sharing
(VSS) into Byzantine fault tolerance (BFT) protocols. Solving the
VSS with share recovery problem is a necessary first step towards
that goal. Thus, we presented a framework, VSSR, and instantiated it
using two distinct VSS schemes in order to solve the VSS with share
recovery problem. We then incorporated these two instantiations
into PBFT and evaluated them with a private key value store.