ARM TrustZone builds a trusted execution environment based on
the concept of hardware separation. It has been quite successful in
defending against various software attacks and forcing attackers to
explore vulnerabilities in interface designs and side channels. The
recently reported CLKscrew attack breaks TrustZone through software by overclocking CPU to generate hardware faults. However,
overclocking makes the processor run at a very high frequency,
which is relatively easy to detect and prevent, for example by hardware frequency locking.
In this paper, we propose an innovative software-controlled hardware fault-based attack, VoltJockey, on multi-core processors that
adopt dynamic voltage and frequency scaling (DVFS) techniques
for energy efficiency. Unlike CLKscrew, we manipulate the voltages
rather than the frequencies via DVFS unit to generate hardware
faults on the victim cores, which makes VoltJockey stealthier and
harder to prevent than CLKscrew. We deliberately control the fault
generation to facilitate differential fault analysis to break TrustZone.
The entire attack process is based on software without any involvement of hardware. We implement VoltJockey on an ARM-based
Krait processor from a commodity Android phone and demonstrate
how to reveal the AES key from TrustZone and how to breach
the RSA-based TrustZone authentication. These results suggest
that VoltJockey has a comparable efficiency to side channels in
obtaining TrustZone-guarded credentials, as well as the potential
of bypassing the RSA-based verification to load untrusted applications into TrustZone. We also discuss both hardware-based and
software-based countermeasures and their limitations.
CCS CONCEPTS
• Security and privacy → Security in hardware; Embedded
systems security; Hardware attacks and countermeasures.
KEYWORDS
TrustZone; fault injection attack; voltage manipulation; low voltage
error; dynamic voltage and frequency scaling (DVFS).
1 INTRODUCTION
TrustZone technology extends the hardware and software architectures of ARM-based system-on-chip (SoC) to provide an isolated
trusted execution environment for a wide array of devices, including handsets, tablets, wearable devices, and enterprise systems.
Almost all of the current ARM-based processors are designed to
enable TrustZone. For example, there are more than one billion
smart phones worldwide equipped with TrustZone. Meanwhile,
more and more applications have been developed taking advantage
of TrustZone’s security such as payment protection, digital rights
management, bring your own device (BYOD), and various secured
enterprise solutions [66].
TrustZone utilizes the hardware-assured security methodologies
that have intrinsically tight interfaces to direct software executions
for a trusted and secure execution environment. Current attacks
to TrustZone mainly rely on the implementation vulnerabilities of
software interfaces, such as secure monitor call (SMC), interrupt
request (IRQ), fast interrupt request (FIQ), shared memory access,
and trusted application-specific calls [66]. Amending unsafe functions is effective to defend against those attacks. In addition to the
software vulnerability-based attacks, it has also been reported successful attacks by exploiting hardware imperfections such as side
channel [49] and hardware fault injection attack [65]. Although side
channel attacks can only steal sensitive information, the hardware
fault injection attacks can be deployed to invalidate the security
measures of TrustZone and allow the attackers to gain control of
it. For example, the CLKscrew attack [65] breaks TrustZone by
overclocking CPU with software. However, this attack is also easy
to be addressed by hardware frequency locking.
In this study, we propose an innovative hardware-fault injection
method to break TrustZone. Our method manipulates the voltage
of the multi-cores processor to induce hardware faults and hence
earns the name VoltJockey. The basic idea is to lower the voltage
deliberately such that fault could occur because of the vulnerability
driven by the hardware dynamic voltage and frequency scaling
Session 2A: Side Channels I CCS ’19, November 11–15, 2019, London, United Kingdom 195
(DVFS) technique [14]. Compared to the CLKscrew attack [65],
which motivates our work and is the most relevant, VoltJockey has
the following two advantages: 1) it does not rely on the overclocking
mechanism or manipulating frequencies; 2) the entire attack process
is carried out under the normal functions of DVFS, and the glitch
voltages are also valid voltages for DVFS. Both make VoltJockey a
more practical and dangerous attack than CLKscrew.
Although changing voltage was mentioned in the original CLKscrew
paper, the authors also acknowledged that the system crashes when
they manipulate the voltage. Indeed, they have reported that when
the device is set to any voltage outside the range 0.6V to 1.17V ,
it either reboots or freezes [65]. This suggests that the voltagechange based attack they have experimented follows the same idea
of CLKscrew. That is, running the system at voltage level outside
the normal range allowed by DVFS. This could be the reason of
their failure in extending CLKscrew attack from overclocking to
"overVoltage". Even if they manage to implement such "overVoltage"
attack, it can be easily detected and prevented by voltage guardians
or locking techniques. From this point of review, VoltJockey is
different from CLKscrew.
VoltJockey exploits the voltage management-related vulnerabilities of DVFS. The DVFS technique aims at saving energy by
enabling software to adjust frequencies and voltages of cores. It
has been employed by most of the modern commercial processors
including those by ARM and Intel. Processors can reliably work
at a fixed clock frequency with a range of voltage levels. However, if the voltage is inappropriately low, the processor could not
reach the expected frequency and this will cause delay in delivering
data from one function/component to another. Thus, next function/component might be using the incorrect data and results in
wrong functional behaviors and/or hardware faults. Similarly, if the
voltage is inappropriately high, the processor might also work with
unpredictable functional behaviors and thus introduced unexpected
errors to the running applications on it. Both kinds of faults make it
possible for the attackers to analyze sensitive data or alter software
outputs with differential fault analysis techniques.
We validate VoltJockey on an ARM-based Krait processor, whose
voltage is controlled by a common hardware regulator. The attack
is launched as follows: we first provide a high frequency to a victim
core and a low frequency to an attacker core, and then give the processor a transitory voltage that is sufficiently high for the attacker
core to perform tasks correctly but is not for the victim core to work
normally. As a consequence, such glitch voltage will trigger functional errors into the victim core without bringing any hazardous
impacts to the attacker core. The error output will be collected
for differential fault analysis. We implement this and successfully
obtain the AES key protected by TrustZone and circumvent the
RSA-based signature verification so we can load any applications
into TrustZone.
Our main contributions in this paper can be summarized as:
(1) We propose a novel software-controlled hardware faultbased attack to TrustZone, the VoltJockey, which manipulates the voltages of DVFS-enabled multi-core processors
to breach TrustZone protections.
(2) We introduce a methodology for analyzing and exploiting the
vulnerability of multi-core voltage-frequency management
of DVFS to perform the VoltJockey attack, which can realize
precise injections of the low-voltage faults into TrustZone
procedures.
(3) We validate VoltJockey on an ARM-based Krait processor
by breaking AES and RSA in TrustZone. The experiments
successfully obtain the encryption key of AES and load untrusted applications into TrustZone by invalidating the RSA
verification.
The remainder of this paper is organized as follows. Section 2
introduces the essential preliminaries of TrustZone, DVFS, and
voltage management of the ARM-based Krait micro architecture.
Section 3 describes the overall methodology and basic idea of the
VoltJockey. Section 4 gives the major challenges and corresponding
technical details in implementing the attack. Section 5 and Section
6 demonstrate the real applications of VoltJockey on the AES key
extraction and RSA output alteration in TrustZone, respectively. At
the end of the paper, Section 7 states the related work, Section 8
analyzes the possible countermeasures against the VoltJockey, and
Section 9 finally concludes the paper.
2 PRELIMINARIES
In this section, we introduce the basics on TrustZone, DVFS, and
voltage management of ARM-based Krait micro architecture, respectively.
2.1 ARM TrustZone
For enhancing the confidentiality, integrity, and availability of
trusted applications, ARM develops TrustZone technology, which
extends the hardware and software architectures of SoC to create
an trusted execution environment [2]. The processor can work in
two worlds, normal world and secure word. TrustZone virtualizes
a physical core as a virtual logical core and a virtual secure core,
which execute in a time-sliced fashion and perform the normalworld and secure-world programs, separately. A trusted application
(also expressed as a trustlet) can be loaded from normal world into
secure world with associated kernel drivers as long as it passes the
verification by the RSA-based authentication procedure [2].
Although TrustZone enhances the security of ARM-based platforms to a remarkable extent, some software vulnerabilities can
still be exploited to breach it. For example, the privilege escalation attacks can be launched if the necessary boundary check is
missed when invoking secure services [51, 57, 64]; the downgrade
attacks can be implemented if the system does not limit firmware
versions [15, 30]. However, those vulnerabilities can easily be fixed
by software upgrading. In contrast, the attacks that utilize hardware
vulnerabilities may be more difficult to be prevented due to the
upgrading overheads to both hardware and software. Such attacks
include side channel attacks [16, 49] and hardware fault injection
attacks [65]. Our proposed VoltJockey belongs to this category.
2.2 Dynamic Voltage and Frequency Scaling
The energy consumption is the integral of instantaneous dynamic
power over time. And, the instantaneous power is proportional
to the product of frequency and voltage quadratic1
[41]. In order
1
Formally, the formula of dynamic power P, voltage V , and frequency F for an
electronic component that has a capacitative load C is: P = αCV 2F .
Session 2A: Side Channels I CCS ’19, November 11–15, 2019, London, United Kingdom 196
to improve the energy efficiency, most of the current processors
enable the DVFS extension [14], which dynamically adjusts the
frequency and voltage of processors cores based on the real time
computation load. On one hand, the integrated circuits are designed
with variable voltages and corresponding frequencies available onchip at real time. On the other hand, the regulator driver provided
by hardware distributors directs hardware and exposes interfaces
for privileged software2
to change the frequency and voltage [41].
The vendor-stipulated voltage/frequency operating performance
points (OPPs) [65] attach a frequency with a particular voltage that
guarantees the processor works error-freely and energy-efficiently
under that frequency. System managers can configure the CPU
frequency manually with driver commands. However, no command
can be utilized for them to modify the CPU voltage directly.
2.3 Voltage Management of Krait Architecture
Krait [13] is a processor micro architecture designed by Qualcomm
with ARMv7-A instruction set architecture and is fabricated in 24
nanometers. It is largely embedded in Qualcomm processors, such
as, MSM8960, MSM8x60A, MSM8x30, MSM8960 Pro, APQ8064, and
APQ8084AB. Our verification experiments are mainly enforced on
Google Nexus 6, which has an APQ8084AB processor. Figure 1 illustrates the voltage management framework in Krait architecture.
The SoC usually connects to several hardware peripherals such
as memory, camera, sensor, audio, display, etc. They are usually
sourced from different vendors and may work under different rated
voltages. It is impractical to provide a fixed voltage to all the peripherals. Therefore, the Krait SoC provides a power management
integrated circuit (PMIC) (PMA8084 in Nexus 6 [32]) that integrates
several hardware regulators to provide different voltages to the
hardware peripherals.
Figure 1: The voltage management of Krait architecture.
There are two significant drivers in the software stack of voltage
regulation of the Android systems. Firstly, Qualcomm supplies a
2The kernel module of CPUfreq acts as the DVFS driver in Linux and Android systems.
The core frequencies can be changed in the power plan in Windows system.
vendor-specific regulator driver [33, 39] to direct the output of PMIC
and wrap the voltage related operations. Secondly, the common
DVFS [38] driver updates the core frequency on the requirement
of energy saving and performance, which will result in the core
voltage modification indirectly. However, all cores share the same
hardware regulator, and thus have the same working voltage which
can support a range of different frequencies for the cores to operate with. This is the hardware vulnerability that our proposed
VoltJockey will exploit.
3 VOLTAGE-BASED HARDWARE FAULT AND
OVERVIEW OF VOLTJOCKEY
Voltage is one of the key factors to ensure the correct functions of
a circuit. In this section, we discuss the fact that inappropriate voltages can violate the timing constraints and introduce unexpected
outputs in digital circuits. Based on the hardware faults introduced
by manipulated voltages, we propose the attack of VoltJockey.
3.1 Timing Constraints of a Circuit
A digital circuit usually consists of multitudinous electronic components. For an input, one electronic component spends a certain
time to give a stable and unambiguous output. Therefore, proper
timing constraint should be satisfied to fulfill the valid information
processing in the digital circuit. In fact, debugging the timing constraint is a very important and essential step when designing and
validating a sequential circuit.
Figure 2 demonstrates the timing constraint for an example
circuit that starts and ends with a sequential electronic element (flipflop (FF) in this example), separately. The middle logic components
transfer the output of the first FF to the input of the last FF. We
assume the two FFs are triggered by the clock pulse’s rising edges.
First, we make the following definitions.
Figure 2: The timing constraint of a circuit case. The rising
edge of clock controls the validation of sequential units.
• Tclk means the clock period of synchronous clock pulse,
which also reflects the circuit frequency.
Session 2A: Side Channels I CCS ’19, November 11–15, 2019, London, United Kingdom 197
• The input signal (Idst) of the last FF (Edst) should be held for
a period of Tsetup to be stable before the next rising edge of
clock pulse.
• Tsrc denotes the latency for the first sequential unit (Esrc) to
give a steady output after receiving the rising edge of clock
signal.
• Ttransfer represents the transmission time from the output
(Osrc) of Esrc to Idst, which is also the execution time of the
middle logic components.
For a settled frequency, Tclk is a constant. Besides, for a determinate Edst, Tsetup is invariable. Therefore, in order to make sure the
Odst is as expected, Tsrc and Ttransfer should be limited in equation
(1) with a very small time constant Tϵ .
Tsrc +Ttransfer ≤ Tclk −Tsetup −Tϵ (1)
3.2 Triggering Hardware Faults by
Inappropriate Voltages
If the provided voltage is lower than the expected one, Tsrc and
Ttransfer will increase, which might violate the timing constraint
in equation (1). Figure 3 demonstrates the signal transitions when
Tsrc and Ttransfer increase. Odst will remain unchanged since the
expected Idst is not prepared at the next rising edge of the clock
signal, which might trigger hardware faults and lead to bit-flip.
Figure 3: The timing constraint may be violated if Tsrc and
Ttransfer are increased due to inappropriately low voltage
against the designated frequency.
Increasing the voltage of the circuit may damage the stability of
electronic units and introduce hardware faults, too. For example,
if Esrc becomes unstable due to the fact that a high voltage is imposed, Osrc may be reversed and Odst will remain at value 1. In this
situation, hardware faults are introduced. This is elaborated with
full details in Figure 11 in the Appendix.
3.3 Attack Method
If both the frequency and voltage of a core are independent from
the other cores, attackers can induce hardware faults by fixing the
victim core’s frequency and choosing a low voltage for the victim
core. However, most of the current processors that enable DVFS are
designed with a shared hardware voltage regulator. Changing the
voltage of victim core will also modify the voltage of other cores.
The clock frequency of a core is determined by the delay of the
underlying circuit. A high voltage can provide small circuit delay
and thus result in high frequency. DVFS manages multiple discrete frequencies and thus requires different voltages. The required
voltage differentials provide the basic vulnerability for our attack.
Figure 4 shows the basic idea of how VoltJockey works. The attacker
procedure is executed on the core that has a low frequency and the
victim procedure is performed on the core that has a high frequency.
The attacker procedure provides a short-lived glitch voltage that
is harmless for the attacker core but could be detrimental for the
victim core to trigger hardware faults into the victim procedure.
For example, to attack the AES function that is securely protected
by TrustZone, the attacker can invoke the AES and induce errors
into the middle state matrix. The encryption key can be maliciously
stolen. To invalidate the signature authentication when an application is being loaded into TrustZone, the attacker can fault the
public modulus of the RSA decryption and change the final output
to cheat the authentication.
Setting
Environment
Waiting for
Victim Function
Previous
Delay
Voltage
Alteration
Voltage
Restore
Victim Function
Codes before
victim codes
Codes after
victim codes
Codes before
Victim Function
Codes after
Victim Function
Cache Layout
Processor States
Core Voltage
…
Victim codes
Fault
Figure 4: The overview of VoltJockey attack. ○1 Necessary
preparations for providing a suitable voltage glitch environment; ○2 Attacker procedure waits for the victim function to
be invoked; ○3 Attacker procedure waits for the target codes
to be executed; ○4 Attacker procedure alters the core voltage
to induce hardware faults; ○5 Recovering the core voltage.
3.3.1 Assumption. In the attack model of VoltJockey, we make the
following two assumptions
• We assume that the voltage of the target multi-cores processor can be adjusted by software. This is actually a common
practice used by a wide range of processors for efficient
energy saving by DVFS.
• We assume that the attackers have privileges to configure the
processor voltage. This requires the attackers to first acquire
the root privilege for some systems, which is a well-studied
topic and there are many ways to achieve that.
3.3.2 Attacking parameters. The attackers need to determine the
following critical parameters to launch the proposed attack:
Ffault = {Fa, Fv,Vl
,Vb
,Tw,Tp,Td
}
The meaning of each parameter is listed in Table 1.
3.3.3 Attacking procedure. The attackers can introduce hardware
faults into the victim procedure by the following five steps.
Session 2A: Side Channels I CCS ’19, November 11–15, 2019, London, United Kingdom 198
Table 1: The descriptions of attacking parameters
Para. Meaning
Fa The frequency of attacker core.
Fv The frequency of victim core.
Vl The glitch voltage that induces hardware faults.
Vb The baseline voltage before and after the fault injection.
Tw The waiting time before the victim function is executed.
Tp
The previous delay before the attacker procedure can change
the processor voltage to the glitch voltage.
Td
The duration time that the glitch voltage should be kept to
ensure a successful fault injection.
(a) Preparation setup. A suitable voltage glitch environment
should firstly be prepared before the attack is carried out. First of
all, the victim core should be configured with a high frequency
and all the other cores should be set to low frequencies. Secondly,
the attacker procedure should initialize the processor with a fixed
and secure voltage. Finally, all the residual states in the target
device should be cleared. This includes cache cache layouts, branch
prediction table, interrupt vector table, and status registers, etc. We
show how to clear the residual states in section 4.2.
(b) Waiting for victim function. In normal situations, the victim function that VoltJockey would inject faults into is a small part
of the victim procedure, and it is uncertain when the victim function would be running. Therefore, the attacker procedure needs
to wait for the target function to be invoked by monitoring the
intermediate executions of victim procedure before it can induce
desired faults. This will be further discussed in section 4.7.
(c) Waiting for appropriate injection points. The goal of the
injected hardware faults is to influence a small part of instructions
and data of the victim function, and the portion of the affected codes
should be kept as small as possible. Therefore, the fault injection
points should be elaborately controlled. The waiting time before
the fault injection can be conducted is called as the previous delay.
We show our experiment data about the previous delay on faulting
AES and RSA in section 4.11.
(d) Voltage manipulation. This step is responsible for triggering hardware faults. The value of glitch voltage and its lasting
duration are these two factors to take controllable hardware faults.
It is very important to find the proper voltage values and their
lasting time that will result in desired data changes. More details
about the two factors on attacking AES and RSA are discussed in
section 4.12.
(e) Restoring voltage. The ultimate goal of VoltJockey is to obtain sensitive data or tamper the functions of victim procedure
other than crashing the victim core. Therefore, the attacker procedure needs to restore the processor voltage to resume the victim
procedure normally as soon as the fault injection is done.
4 TECHNICAL CHALLENGES OF
VOLTJOCKEY
In this section, we present the major technical challenges that the
VoltJockey addresses, which gives the most important technical
details and experiment probings to implement such an attack.
4.1 Parallel Execution
In VoltJockey, the attacker procedure and the victim procedure
are diverse processes and executed in parallel, which also is the
most common attack scenario. System libraries provide functions
to support the binding of one thread to a dedicated core. Besides,
OS supplies operations3
for a user to fix one task on a special core.
4.2 Residual States
The system’s residual states before performing the victim procedure
can affect the execution time of instructions of the victim procedure.
This is mainly reflected from three sides. Firstly, the data access
when cache hits will take less time than cache misses, and therefore influences the instruction finish time. Secondly, the branch
predictions may also result in the execution time variations of instructions. Thirdly, the unfinished tasks or interrupts may enforce
the victim core to emit the victim procedure. Therefore, clearing the
residual states is practically significant for the attacker procedure
to acquire the precise injection points of hardware faults. In this
study, we first flush the cache memories to clear the existing data,
and then execute the victim procedure for several times to fill cache
and set processor state registers with the victim procedure-related
data. In such circumstances, the branch prediction table will also be
highly correlated to the victim procedure. Moreover, we also close
the IRQ and FIQ interrupts that target at the victim core in voltage
manipulation to shield the influences of interrupts.
4.3 Legal Voltage Enforcement
In Android systems, the OPPs are defined in the device-related dtsi
file [36]. Figure 5 shows an example OPPs (black curve) extracted
from Google Nexus 6, which gives the available frequencies and
corresponding secure voltages. VoltJockey needs to bypass the restraint of OPPs to gain the power to manipulate the voltages. We
analyze the kernel codes of the software stack of DVFS in the system
of Nexus 6 and find that the top level driver is responsible for the establishment of frequency table and frequency selection. In addition,
the vendor-specific frequency and voltage regulator drivers change
the frequency and voltage of processor cores with the request of
the top level software and do not care if the request parameters are
in the frequency table. This makes it very easy to break the legal
frequency-voltage enforcement for voltage manipulation.
4.4 Voltage Threshold
Qualcomm implants a low dropout linear regulator (LDO) mode for
the krait architecture, which delivers a stable and regulated voltage
(voltage threshold) to cores for avoiding the processor’s malfunctions. If the requested voltage is less than the voltage threshold, the
vendor-specific voltage regulator driver [33] will turn the processor
voltage mode into LDO, and the processor will be provided the
stabilized threshold voltage rather than the less one. The low voltage threshold is defined in the regulator property description file
[35] and is read in the power probe stage of the voltage regulator
driver. In this study, we change the voltage threshold by revising
3Linux provides a command of taskset for a normal user to assign one task on an
appointed core and the command is supported after Android 6.0. The core binding can
be achieved in the task manager in Windows systems.
Session 2A: Side Channels I CCS ’19, November 11–15, 2019, London, United Kingdom 199
500 1000 1500 2000 2500
Frequency (MHZ)
600
700
800
900
1000
1100
Voltage (mv)
Voltage boundary when target core is busy
Voltage boundary when target core is idle
OPPs
Figure 5: The manipulable voltages of Nexus 6 processor.
the power probe function since the influence range is smaller than
modifying the property description file.
The high voltage threshold is hardened in the last byte of the
voltage setpoint [34]. The step width of core voltage is 0.005V
in Nexus 6, which means that the core voltage is theoretically
restricted from 0V to 1.275V . We find out that the processor is
always restarted immediately when the core voltage is set to a
value that is larger than 1.275V . Therefore, it is actually unpractical
to use high voltage to take faults with software.
4.5 Voltage Down-tuning Restriction
As shown in section 2.3, all the processor cores have a common
voltage value. In order to ensure the high-frequency cores perform
tasks error-freely when tuning the voltage, the voltage regulator
driver is designed to only select the higher one between the request
voltage and the voltage that corresponds to the highest core frequency, in other words, no down-tuning voltages are accepted by
the regulator unless the frequency is lowered. In this study, we also
cancel such restriction by revising the regulator driver.
4.6 VoltJockey Kernel
We alter the voltage regulator driver to bypass the limits above.
Besides, we insert a restriction mechanism into the driver to prevent other programs from modifying the core voltage once we have
changed it. User applications cannot invoke the voltage-related operations exposed by the voltage regulator driver due to a low privilege. However, we want the attacker procedure to run in userspace
in order to make the attack more salable and extendable. Therefore,
we develop a voltage manipulator kernel module (the VoltJockey
kernel) to invoke the hardware regulator driver and provide userapplication interfaces.
The module does not need to be integrated into the kernel image
directly, and it can work in a loadable manner. In order to maintain
the timing stability of the voltage manipulating process for a better
fault injection precision, we implement most of the operations of
the five attack steps mentioned earlier into the VoltJockey kernel.
It first initializes the processor with a safe voltage and then clears
the residual states. Next, it waits for the victim function and the
injection points, and then conducts the low voltage glitches. Finally,
the working environment is cleaned and reset to the original.
4.7 Victim Procedure Monitoring
The fault injection process is right subsequent to the time when
the victim function is invoked. The attacker also needs to detect
if the expected data changes are achieved to conclude whether
the fault injection is successful. Therefore, the execution data of
the victim procedure is required to be visible to the attacker procedure. However, the attacker procedure cannot directly read the
data of victim procedure as they are different processes and are
separated by the operating system (OS). In this study, we use cache
side-channel attacks to speculate the victim procedure’s data. There
are several side-channel technologies available in the domain, for
instance, prime+probe [58], flush+reload [70], evict+reload [50], and
flush+flush [40]. Lipp et al. verified that the cache side channel
attacks are effective for TrustZone and read T-table of AES executed in TrustZone successfully [49]. In VoltJockey, we monitor the
instruction executions of the victim procedure by the method of
prime+probe.
4.8 Timing
The previous delay and voltage glitch duration are time-sensitive
factors. However, they are always a few cycles for the appropriate
fault injections in real attacks. Therefore, the timing functions4 provided by OS cannot fit the time precision demand. In the VoltJockey
kernel module, we utilize the specified loops of NOP operations to
count the execution cycles. In general, a NOP operation does nothing
except for spending a cycle, it is a wonderful operation for timing in
the clock accuracy. Besides, we embed the clock counting instructions in the required locations to eliminate the time consumption
of function calls or returns. Moreover, the timing instructions are
programmed to be not optimized by the compiler.
4.9 Voltage Manipulation
When inducing hardware faults, the abnormal voltages may make
the system reboot. Besides, some attempts may fail. In order to
avoid the system from rebooting and improve the attack efficiency
and reliability, we employ the following techniques in VoltJockey.
• Making the irrelevant cores busy.
Figure 6 shows the minimum duration for the successful hardware fault injection with respect to different glitch voltages on the
Nexus 6 processor. When the irrelevant cores (the processor cores
except the attacker and victim cores) are idle (shut down), as the
black curve shows, the minimum glitch duration is much longer
than the other two situations shown by the red and blue curves.
The reason might be that more power can be supplied to the victim
core and the hardware faults are not easy to induce. When all the
irrelevant cores are working with the normal workload (around
30%-50% core usage), as the red curve shows, the minimum duration
of glitch voltages is also longer than those of the blue curve, which
shows the case that all the irrelevant cores are busily working with
high workloads (above 80% core usage). The reason might similarly
be that more power can be supplied to the victim core when most
4
In the Linux kernel, udelay, mdelay, ndelay, and msleep are widely utilized as the
timekeeping functions.
Session 2A: Side Channels I CCS ’19, November 11–15, 2019, London, United Kingdom 200
cores are not consuming much power with low workloads and the
fault injection is harder than that in the situation with most cores
working with high workloads.
It should be noticed that it is not recommended to make all the
irrelevant cores work at high frequencies because the hardware
faults may also be induced into them. In this study, we let the
irrelevant cores work at the same low frequency as attacker core.
500 550 600 650 700 750 800 850 900
Voltage (mv)
3200
3400
3600
3800
4000
4200
4400
4600
Loop Cycles
Irrelevant cores are normal
Irrelevant cores are busy
Irrelevant cores are idle
Figure 6: The minimum duration (number of NOP loops) of
glitch voltage for the successful hardware fault injections.
In this experiment, the frequency of attacker core and all
the irrelevant cores is 0.42GHZ and the victim core’s frequency is 2.65GHZ.
• Lower baseline voltage.
From Figure 6, we can conclude that lower fault-injecting voltages result in easier fault injection process (less injection time).
However, a remarkable voltage drop is also very easy to cause system reboot and interrupts the attack. In this study, we find that the
switch from the baseline voltage to glitch voltage is more reliable
and successful when their gap is reduced. Therefore, we configure
the baseline voltage of the processor as the lowest voltage that is
just available for all the cores.
• Proper temperature.
It is significant for the VoltJockey to select a proper working
temperature to improve the injection reliability although processors
are designed to fit for an extensive range of working temperatures.
We find that an appropriately high temperature is very helpful
for the injection success. In this study, we run a computing-heavy
mission to raise the CPU temperature to the range of 35◦C to 40◦C
before attacking.
We select a frequency from frequency table for the victim core
that is idle and obtain the boundary voltages that will make the
system stable. Moreover, we run a computing task that will make
the victim core busy all the time and observe the boundary voltages
again. Figure 5 displays the experiment results. The red line shows
the lowest safe voltages for system being stable when the victim
core is idle, and the blue line is the boundary voltages when the
victim core is busy. As we can see from Figure 5, the voltage differentials among different frequencies are obvious. The boundary
voltages when the core is vacant are higher than it is busy, especially in high frequency, this may because that busy states cost
more energy. For a certain frequency, voltages between the black
line and blue line are safe, voltages between the blue line and red
line are likely to induce hardware faults, and voltages below the red
line can take hardware faults in a very high possibility. Therefore,
we can select the voltages below red line as the attack voltages.
4.10 Attacker Procedure Safety
Distributing the two different procedures to different cores can skirt
crashes of the attacker procedure taken by the hardware faults of
victim core. However, the glitch voltage may also cause the attacker
core faulty especially when the frequency of attacker core is not
lower than the victim core. Figure 5 indicates that the minimum
acceptable voltage for a core is positive correlated to the frequency
and it is possible to select a voltage that is safe for the low-frequency
but harmful for the high-frequency. Fortunately, the frequencies
of different cores are independent. Before attacking, we set the
attacker core with a low frequency and the victim core with a high
frequency. Then, we select the voltage that is safe for the attacker
core but harmful for the victim core as the reason for hardware
faults, which guarantees that the attacker procedure cannot be
influenced in each voltage glitch trial.
4.11 Previous Delay
500 1000 1500 2000 2500
Frequency (MHZ)
100
200
300
400
500
600
700
Previous delay (K Loop cycles)
Previous delay for AES
Previous delay for RSA
Previous delay for RSA in TrustZone
Figure 7: The previous delay for AES and RSA with different victim core frequencies. In this figure, the frequency of
attacker core is 0.42GHZ and core voltage is 0.6V .
The previous delay controls the fault injection sites. It is mainly
determined by four factors: 1) the program codes of victim function; 2) the frequency of victim core; 3) the frequency of attacker
core; 4) the core voltage. For a fixed victim function, peculiarly an
encryption function, its implementations are commonly public; it
is convenient to analyze the execution of the victim function and
acquire the best fault injection points in advance. In this study, we
implement an AES encryption function based on S-box and a RSA
decryption function based on the Android cryptography library. We
obtain the NOP loop cycles from the start of AES to the MixColumn
Session 2A: Side Channels I CCS ’19, November 11–15, 2019, London, United Kingdom 201
operation of the seventh round with different victim core frequencies but the same core voltage. Besides, we count the time from the
start of RSA to instructions that transfer big-endian public modulus
to little-endian modulus. Figure 7 shows the relationships between
previous delay and the frequency of victim core for AES and RSA.
4.12 Glitch Voltage and Duration Pairs
Although voltage is the source of hardware faults, the malicious
actions are decided by both voltage and its duration time. Our aim is
to inject controllable hardware faults into the input state matrix of
the eighth round of AES and the public modulus of RSA. Observing
the data modifications caused by different voltage-duration pairs
can help us select appropriate attacking parameters.
500 550 600 650 700 750 800 850 900
Voltage (mv)
3.50
3.75
4.00
4.25
4.50
4.75
5.00
5.25
5.50
Duration (K Loop Cycles)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(a) Number of byte errors on the input of the eighth round of AES.
500 550 600 650 700 750 800 850 900
Voltage (mv)
3.50
3.75
4.00
4.25
4.50
4.75
5.00
5.25
5.50
Duration (K Loop Cycles)
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
0
(b) Number of byte faults on the public modulus of RSA. We divide the numbers
with 16 to show them in figure legend obviously.
Figure 8: The number of byte alterations with different
glitch voltages and duration. In this figure, the attacker core
frequency is 0.42GHZ and victim core frequency is 2.65GHZ.
We fix the core frequencies, and then exert different core voltages
and keep the voltage for various duration time. Next, we acquire the
number of induced byte errors in the state matrix before the eighth
round of AES and the public modulus of RSA. For each voltageduration pair, we test five times and plot the average number of
modified bits as the color-varying dots/squares in the Figure 8.
5 ATTACKING TRUSTZONE AES
In this section, we first present the experiments of applying the
VoltJockey attack on the AES performed in the normal world, in
which the encryption key can be obtained. Then, we carry out the
attack to the AES running in the TrustZone, and the key can also be
obtained successfully. Without loss of generality, the target AES is a
128-bits block cipher, which encompasses 10 rounds operations on
the plaintext to generate corresponding ciphertext. There are four
operations in each round except for the last round: 1) ShiftRows
cyclically shifts the bytes in each row of the state matrix by a certain
offset; 2) SubBytes replaces the plaintext bytes with corresponding
S-box bytes; 3) AddRoundKey combines each element of the state
matrix with the related key bytes using bitwise exclusive OR (XOR);
4) MixColumns blends every column of the state matrix with a linear
transformation. The last round skips MixColumns.
The target device is a Google Nexus 6 mobile phone and the
system version number is LMY48M. The key extraction is achieved
on a DELL XPS laptop that has a virtual machine with 2G memories
and two cores, in which Ubuntu 16.04 is performed.
5.1 Differential Fault Analysis on AES with a
Single Fault
Brutely forcing the key of AES is impractically time-expensive,
especially when the key is long enough. However, researchers have
shown that the key hypotheses can be largely reduced if some errors
are introduced into the middle execution of AES [5, 11, 23, 29, 67].
Triggering hardware faults to generate errors is a convenient and
efficient choice. In this study, we employ the key extraction method
proposed by Tunstall et al. [67] who verified that the key hypotheses
can be reduced a lot using a two-stages algorithm when a single
random byte fault is introduced into the input of the eighth round.
If a byte error happens in the input of the eighth round in a 128-
bits AES, the functions SubBytes, ShiftRows, and AddRoundKey
of the eighth round will record this error into the corresponding
location of state matrix, and function MixColumns will next propagate this error to one column of state matrix. This will produce four
byte-errors to the input of the ninth round. Similarly, the four byteerrors will be spread to the complete state matrix and cause sixteen
errors to the input of the tenth round. There is no MixColumns operation in the tenth round, the other three functions replace, shift
and XOR an element of state matrix once a time. Therefore, a byte
error of input of the eighth round can be exactly propagated to the
entire output bytes. By analyzing four sets of equations between the
output bytes and the input bytes of the eighth round, the attacker
will be able to have 2
32 key assumptions for the encryption key.
The function KeyExpansion generates a key for next round using
this round key, and the key schedule is invertible. Therefore, the
ninth round key can be expressed by the key of the tenth round.
Based on their relationship, attackers can further reduce the key
conjectures to 2
8
[67]. In this study, we merge the key hypotheses
for different ciphertext pairs to further scale down the searching
space.
Session 2A: Side Channels I CCS ’19, November 11–15, 2019, London, United Kingdom 202
Table 2: Success rate with diverse parameters in AES attack.
Parameter Normal world TrustZone
Volt Dura. #Error #One Succ. #Error #One Succ
(V) (Loops) occurs byte error rate occurs byte error rate
0.50 3700 54 1 1% 48 3 3%
0.55 3900 33 2 2% 37 1 1%
0.60 4100 56 3 3% 51 2 2%
0.65 4200 35 1 1% 62 5 5%
0.70 4200 26 2 2% 28 3 3%
0.75 4100 47 1 1% 58 2 2%
0.80 4400 45 2 2% 30 1 1%
0.85 4500 48 2 2% 46 2 2%
0.90 4800 32 1 1% 42 1 1%
Average 41.8 1.7 1.7% 44.7 2.2 2.2%
0 2 4 6 8 10 12 14 16
Fault Location
0
25
50
75
100
125
150
175
Occurrence Number
0 0 0 0
18
4
0 0 0 1 0 0 0 2 0 0 1 0
54
184
8
0
4
0
8
1
107
0 0
6
0 2
Normal world
TrustZone
Figure 9: The distributions of modified bytes in AES attacks.
5.2 Normal World Attack
We select nine different parameters that take a single-byte error
from Figure 8(a) to maliciously analyze the AES key of the normal
world. We do not consider the step of waiting for the victim function due to the operations on plaintext in every round is fixed. We
try the attack on AES for 100 times for each parameter and use the
percentage of attack success to evaluate the effects of the parameter, which can be found in Table 2. In this attack, the frequency
of attacker core is 0.42GHZ and victim core has a frequency of
2.65GHZ. From the experiment results, we can observe that it is
more likely to succeed when the glitch voltage is 0.6V and the duration is 4100 NOP loops. We then obtain the distributions of modified
bytes in the input of the eighth round by conducting VoltJockey
to acquire the AES key for 200 times with the attack parameter of
{Fa = 0.42GHZ, Fv = 2.65GHZ, Vl = 0.6V, Vb = 1.055V, Tw =
0, Tp = 48132, Td = 4100}. The distributions of modified bytes are
illustrated with the yellow bar in Figure 9. We can see that the byte
errors obtained by certain parameters are relatively stable.
5.3 Secure World Attack
TrustZone core uses the same physical core as the application core,
and therefore is also vulnerable to the threats from VoltJockey like
normal world. System users cannot specify a customized program
to be executed in TrustZone, even privileged managers. In this
study, we utilize the vulnerability described in [31] to execute AES
in the TrustZone and regain the attacking parameters to perform
attacks.
5.3.1 Inserting AES into TrustZone. As with the normal world that
contains a general OS, Qualcomm provides a secure environment
operating system (QSEOS) for supplying several security services
to normal applications by means of system-calls. QSEOS does not
trust any information provided by procedures outside TrustZone
and always authenticates it. However, the system-call vulnerability
in [31] exposes risks for attackers to escalate privilege, and then
execute arbitrary codes in TrustZone. We develop shellcodes based
on our AES program and combine it with the exploit codes of the
vulnerability [31] to push AES instructions into the code cave of
widevine trustlet, which is a digital rights management application.
When the exploit codes are performed, the execution flow of TrustZone will jump to the code cave to execute the AES encryption
function.
5.3.2 Waiting time for the victim function. The exploit codes employ several memory probes to trigger the vulnerability and the
number of memory probes is uncertain. Therefore, attacking AES
running in TrustZone requires to wait for the start of AES. Regarding the execution time from the start of exploit codes to the
start of AES in a specific run as the waiting time for the victim
function is incorrect. However, once the vulnerability is activated,
the execution of exploit codes is considerably stable. We monitor
the execution time from the function call that invokes the injected
codes to the start of AES with different victim core frequencies and
depict the experimental results with the green curve in Figure 10.
500 1000 1500 2000 2500
Frequency (MHZ)
0
500
1000
1500
2000
2500
Waiting time (K Loop cycles)
Waiting time for AES in TrustZone
Waiting time for RSA in TrustZone
Figure 10: The waiting time for AES and RSA in TrustZone.
In this experiment, the frequency of attacker core is 0.42GHZ
and the core voltage is 0.6V .
5.3.3 Attacking parameters. Although TrustZone adds some securityenhanced mechanisms and always checks an operation before it is
performed, these measures are actually implemented in hardware
and have negligible influences on the execution time of trustlets.
Therefore, the attacking parameters in the normal world will be
operative for breaking AES executed in TrustZone. In order to keep
Session 2A: Side Channels I CCS ’19, November 11–15, 2019, London, United Kingdom 203
the integrity of AES in TrustZone, we utilize the cache side channel
attacks to continually check the state matrix.
5.3.4 Performing attack. We select the attacking parameters as
them in the normal world attack to steal the encryption key and
shows the success ratio in Table 2. The experiment on {Fa =
0.42GHZ, Fv = 2.65GHZ, Vl = 0.65V, Vb = 1.055V, Tw = 7680, Tp =
48132, Td = 4200} indicates that the success rate is about 5%, which
is an acceptable value.
We examine the one-byte error distributions in the input of the
eighth round by stealing AES key for 200 times with the above
attacking parameters and illustrate them using the red bar in Figure
9. The byte errors are mainly concentrated on the tenth byte of state
matrix due to the same attacking conditions. The error locations
are not the same as those in the normal world because the working
mechanisms of TrustZone is different from the normal world. When
the error location is 10, it takes about 12 minutes to generate 1892
key hypotheses using differential fault analysis [43] with the laptop.
Besides, the laptop spends around 8 minutes to generate 1159 key
candidates when the fault location is 15. The two key hypotheses
only have one common value, which is the encryption key.
6 BREACHING RSA-BASED TRUSTZONE
AUTHENTICATION
In this section, we first provide the differential fault attack to the
RSA decryption algorithm based on the signature verification function of an Android library mincrypt [37] by faulting the public
modulus N. The attack makes it possible for the adversaries to revise the decryption result into a desired one. Next, we demonstrate
the attack details of applying VoltJockey on RSA of the normal
world and TrustZone respectively.
6.1 RSA Decryption and the Differential Attack
As one of the first public-key cryptosystems, RSA is vastly deployed
on secure data transmissions, signature, and verification. However,
RSA is still vulnerable to differential fault attacks [3, 4, 12, 65].
Given ciphertext C, public modulus N, public exponent e, RSA
decrypts C to plaintext P through equation (2). Algorithm 1 shows
the RSA decryption function RSA_Decoding (the public exponent
e is limited to the widely used 65537 and 3) based on the Android
library, which is an optimized implementation of equation (2) utilizing the Montgomery modular multiplication (function MonMul)
whose output is calculated by operating the two integer parameters
x and y, modulus N, and Montgomery radix r
−1
(modular inverse of
2
2048 (modulo N)) as: MonMul(x, y, N, r
−1
) ← x ∗ y ∗ r
−1 mod N.
What should be mentioned is that Algorithm 1 applies a machine
word size radix n0inv (line 4) instead ofr
−1
to reduce the loop times
and computation complexity of function MonMul.
P = C
e
(mod N) (2)
MonMul takes advantages of little-endian data to speed-up the
multiplication operations. However, the input N and C are usually
big-endian data. RSA_Decoding utilizes the function EndianInversion to convert N (line 5) and C (line 6) into little-endian Nin
andCin as well as transfer the little-endian multiplication result into
Algorithm 1 The RSA decryption algorithm
Input: Ciphertext, C; Public modulus, N; Public key, e
Output: Decoding plaintext, P
1: procedure RSA_Decoding(C, N, e)
2: r ← 2
2048
3: R ← EndianInversion(r
2 mod N)
4: n0inv ← 2
32
- ModuleInverse(N, 2
32)
5: Nin ← EndianInversion(N)
6: Cin ← EndianInversion(C)
7: Pin ← MonMul(Cin, R, Nin, n0inv)
8: Pin_temp ← Pin
9: for i ∈ [0,bitlen(e) − 1) do
10: Pin ← MonMul(Pin, Pin, Nin, n0inv)
11: end for
12: Pin ← MonMul(Pin, Pin_temp, Nin, n0inv)
13: Pin ← MonMul(Pin, 1, Nin, n0inv)
14: P ← EndianInversion(Pin)
15: return P
16: end procedure
big-endian value as the decryption output (line 14). We append the
implementation of EndianInversion in Algorithm 2 in Appendix.
Our attack goal is to guide the RSA_Decoding to output a desired plaintext P(m), which is usually the hash of malicious message
m in data verification applications. The tremendous computation
complexity of factorizing the public modulus N is the security guarantee for RSA. Therefore, damaging N is a useful method to change
the RSA behaviors. Function EndianInversion implements several byte-level OR and shift operations on the input to achieve the
reversal of the input in machine word size. CLKscrew [65] proposes
to induce hardware faults into this function to fault N and control
the output. However, it requires the input r
−1
(similar as n0inv) of
MonMul is calculated based on the faulted N. Nevertheless, n0inv
is computed before line 5 instead of after it in Algorithm 1. In this
work, we extend the CLKscrew [65] to achieve the differential fault
attack on Algorithm 1.
Similar with [65], we change N into Nm in line 5 and fabricate
ciphertext C
′
m to get the desired plaintext P(m). Nm acts as the
public modulus of the broken decryption function, it should be
factorable and can be factorized in finite time. The Pollard’s ρ algorithm [44] can be used to factorize Nm with sufficiently small
factors of up to 60 bits. Besides, the Lenstra’s Elliptic Curve factorization Method (ECM) is proposed to factorize a big number into
up to 270 bits factors [47]. Nm does not need to exactly have two
factors as traditional RSA algorithms and it sure will have multiple factors in real attacks since it is changed with random bytes
errors. As long as it can be factorized, attackers can construct an
RSA key pair {Nm,dm, e} for the broken RSA_Decoding with the
Carmichael function [55]. Thus, they are able to encrypt P(m) to
get its ciphertext Cm with Cm = P(m)
dm mod Nm, where dm is the
private key. When {Cm, Nm, e} is inputted into the RSA_Decoding,
the result Pin of MonMul in line 7 will be as equation 3.
Pin ← Cm ∗ (r
2 mod Nm) ∗ r
−1
m mod Nm
where (r
−1
m ∗ r)%Nm ≡ 1%Nm
(3)
Session 2A: Side Channels I CCS ’19, November 11–15, 2019, London, United Kingdom 204
If the broken RSA_Decoding decrypts the constructed input C
′
m
totally based on Nm and e, the output will be P(m) if and only if
C
′
m equals to Cm. However, as we can see from Algorithm 1, N is
used in line 3 and line 4, and thus is propagated to lines 7, 10, 12,
and 13 before being altered in line 5. Therefore, the computation
result P
′
in of line 7 will be as equation 4 in real attacks.
P
′
in ← C
′
m ∗ (r
2 mod N) ∗ r
−1 mod Nm
where (r
−1
∗ r)%N ≡ 1%N
(4)
If P
′
in equals to Pin and later MonMul is irrelevant to N, the
output of RSA_Decoding will be P(m). However, r
−1
m is hard to be
equal with r
−1
since Nm is different from N. Therefore, it is very
tough to analyze C
′
m if MonMul receives r
−1
as one of the parameters. Luckily, Algorithm 1 is implemented based on n0inv instead
of r
−1
. n0inv is a machine word integer and means as equation 5.
n0inv = (−1/N)%232 (5)
If n0inv that is calculated based on Nm equals to it based on N,
the function MonMul after line 5 will be irrespective to N. In this
situation, we can get the expected output P(m) by simply making
P
′
in = Pin, which is shown in the equation (6). The r
2
, N, r
−1
m , Pin,
and Nm are known values, it is convenient to calculate C
′
m.
C
′
m ∗ (r
2 mod N) ∗ r
−1
m mod Nm ≡ Pin mod Nm (6)
In most situations, the injected hardware faults only influence
a small continuous part of N. We generate the possible Nm with
different lengths of continuous bits-errors and judge whether the
n0inv based on them equals with it based on N. Table 3 gives the
related data. For longer bits-error, it requires a mass of time to get
all of the possible Nm and we do not test them. However, as shown
in Table 3, for a specific Nm, it will have the same n0inv as N in a
very high possibility. We develop a tool to check whether a Nm can
be used in VoltJockey. Besides, we provide a tool to automatically
generate C
′
m with N, Nm, and desired P(m).
Table 3: The equal rate of n0inv based on N and possible Nm.
Len of bit-error 4 8 12 16 20 24
#Possible Nm 7680 65280 696150 8388480 106954650 1426063275
#Available Nm 7560 64260 683880 8257410 104857755 1392574380
#Equal ration(%) 98.44 98.44 98.24 98.43 98.04 97.65
6.2 Normal World Attack
We run Algorithm 1 in the normal world and provide different
external conditions to the victim core that performs it. We insert
additional program codes to check the changes on the public modulus N during the execution. Figure 8(b) shows the number of bit
modifications on N with different voltages and duration.
In this attack, we do not consider the waiting time for victim
function as the target function is determined and there are no
irrelevant codes are executed. According to our attack attempts on
the victim RSA decryption function that uses the public modulus
of Widevine (section C in Appendix), it has a good result when the
glitch voltage is 0.65V and duration time is 3800 NOP loops. Among
500 attempts, 117 of them successfully inject faults into function
EndianInversion, and 23 of them (about 4.6%) result in factorable
Nm. In all of the factorable Nm, 18 of them are equal.
6.3 Secure World Attack
Verifying a trustlet requires four RSA-based authentications, which
form a certificate chain. When loading a trustlet into TrustZone,
the trusted execution environment (TEE) [24] authenticates the
certificate chain by utilizing the RSA decryption on certificates and
recognizes whether the decryption results are the same as code
hashes. Tang et al. [65] described the signature decryption function
in TEE, which is very similar to Algorithm 1. The main difference
is that its MonMul is based on r
−1
. What is more, r
−1
relies on Nin
instead of N. In other words, if hardware faults create a factorable
Nm, we will be able to construct the poisonous input ciphertext.
6.3.1 Waiting time for the victim function. Different to the pure
normal-world RSA decryption, authenticating a trustlet requires
several calculations. Therefore, finding the best fault injection
point is critical to improve the attack reliability. RSA_Decoding is
loaded into memory with a constant start address. We utilize the
Prime+Probe cache side-channel attack [49] to monitor the instruction executions when loading widevine into TrustZone in order to
position the start time of the last RSA_Decoding. First, we load a
block of dummy instructions from the attacker procedure to fill up
the cache that RSA_Decoding will be mapped to. Then, the attacker
procedure’s dummy instructions and the victim procedure’s RSA
are executed on different cores in parallel. Because the processor
cores share the same cache and the dummy instructions take place
of the RSA’s cache sets, the dummy instructions will miss in the
cache if the processor starts to execute the last RSA_Decoding. The
Prime+Probe can know the cache-missing event because the runtime of the instruction is increased. Therefore, we can finally know
the right start time of the RSA_Decoding. We plot the waiting time
with diverse frequencies in Figure 10 .
6.3.2 Attacking parameters. The signature decryption algorithm in
TEE is invariant and the control flow transitions are fixed, therefore,
the previous delay is almost stable. Since the function EndianInversion in TEE is loaded into a certain location, we time the duration
time from the start of the last RSA decryption to the start of function EndianInversion to get the previous delay through the cache
side signals. As shown in Figure 7, the previous delay for the RSA
attack in normal world is different from it in TrustZone because
the two RSA algorithms are actually different.
Our goal is to fault N into Nm. The two RSA algorithms have
the same EndianInversion, therefore, the glitch voltage-duration
pair that is usable for the attack in the normal world is also usable
for the attack in TrustZone.
6.3.3 Performing attack. The location of Nm is hard-coded to an
address 0x0FC8952C. We utilize the vulnerability exploit codes in
AES attack to read Nm. The shell codes are implemented to transfer
Nm into normal world for accessing outside TrustZone. Note that
the relevant code sections for the signature validation are identical
across versions [65]. In this attack, we first use VoltJockey to trigger
hardware faults into the last RSA authentication to acquire an
available Nm when loading the widevine trustlet. Then, we build a
Session 2A: Side Channels I CCS ’19, November 11–15, 2019, London, United Kingdom 205
signature based on the hash of malicious codes and Nm. Next, we
replace the old signature with the new one. Finally, we perform our
attacks with the same parameters to introduce the output of the
last RSA certificate to be the desired hash at loading step.
According to our tests on different attacking parameters, the
parameter of {Fa = 0.42GHZ, Fv = 2.65GHZ, Vl = 0.65V, Vb =
1.055V, Tw = 61942, Tp = 87267, Td = 3800} results in the best
performance. Among 200 attempts, 73 of them successfully introduce faults to N, 21 of which are factorable and 15 of them are
the same value. We use the Nin that has 2 bytes (byte 146 and 147)
changed by faults to construct the attack signature C
′
m, which is
shown in section C in Appendix. An untrusted application can be
successfully loaded into TrustZone in 94 attempts on average.
7 RELATED WORKS
Fault injections [1] are originally applied as the system reliability verification technologies. However, they are also effective in
malicious attacks, especially combine with other attack methods,
such as differential fault attack (DFA) [9, 10, 68]. The faults can
be induced by hardware (changing the working environment with
supererogatory hardware units, such as, frequency [21, 69], voltage
[4, 6], temperature [42], light laser beam [18], ion radiation [62],
sound [52], electromagnetic [20], et al.), software [25, 28, 61], or simulation [27, 46]. In this section, we review the related voltage-based
and frequency-based fault injection attacks in this domain.
7.1 Voltage-based Fault Injection Attacks
Selmane et al. [63] might be the first ones to experimentally realize
a practical fault attack by underpowering a smart card that preserves an AES function using a peripheral power supply, which
is based on the random errors model invented by G. Piret and J.J.
Quisquater [53]. Barenghi et al. [4] proposed a fault model based on
the effects of underfeeding the power supply for an ARM processor and accomplished the attacks on the implementations of RSA
primitives, in which the voltage supplied to the ARM processor is
kept constantly lower than the normal voltages driven by Agilent
3631A. Barenghi et al. [6] also proposed an AES attack induced by
low voltage-based faults, which is implemented by employing an
operational amplifier to change the voltage supplied to the ARMbased development board. As an extension to the two works above
[4, 6], Barenghi et al. [7] proposed a general low voltage-based fault
attacks to break software implementations of AES and RSA.
Compared to the existing low voltage-based fault injection attacks, the VoltJockey method is more pragmatic and usable. The
VoltJockey is totally controlled by software instead of using any auxiliary hardware units. Besides, we successfully conduct VoltJockey
on a commercial device and demonstrate that the attack is dangerous to the secure execution environment. Moreover, the attack does
not influence other applications running on non-victim cores.
7.2 Frequency-based Fault Injection Attacks
The basic idea of frequency-based fault injection attacks [21, 48, 59,
69] is that the expected output of a circuit may not be ready for the
use in next unit if the frequency is too high to be met. The attacker
can then obtain target data based on the wrong output that is influenced by the error. However, most of them require the frequency is
changed by extra hardware units. Tang et al. proposed the Clkscrew
[65] that uses overclocking technique to induce hardware faults
with software. They verified that the ARM/Android devices do not
lock core frequencies and the frequency of a core can be configured
by another core in DVFS. Clkscrew exploits the above vulnerability
of DVFS to overclock ARM processors and induce hardware faults.
However, the most significant prerequisite of CLKscrew is that
the processor can be overclocked, which can be easily mitigated
by frequency locking in which the frequency is locked in a certain
range. In this study, the VoltJockey is proposed to be another usable fault-injection attack method, which exploits the legal voltage
differentials corresponding to different frequencies. The voltage
differences currently exist in most processors using the DVFS technique, no matter whether they are frequency locked or not.
8 COUNTERMEASURES AND EXTENSIONS
In this section, we discuss the possible hardware-based and softwarebased countermeasures to the VoltJockey, and also look forward to
some future extensions of this study.
8.1 Hardware-based Countermeasures
8.1.1 Limiting voltage. Limiting the core voltage to break the voltage differentials is effective to prevent VoltJockey. The simplest
method is to fix the core voltage and prevent all modifications on it
with a watchdog circuit. This is effective but will introduce more
energy wastes. Similarly, assigning a dedicated frequency to all
cores is useful but is not economical for energy, either. What is
more, the hardware can be designed to always configure the core
voltage as the maximum voltage that corresponds to all the current
core frequencies in the OPPs. The method can repel VoltJockey with
less energy loss. However, the necessary alternations on hardware
need to be implemented to limit the core voltage.
8.1.2 Abandoning shared hardware regulator. It is useful to address VoltJockey by ensuring every core has its own hardware
voltage regulator. Besides, the voltage of a core can only be alterd
by the software running on it. This countermeasure requires that
the cross-core voltage setting should be prevented and the corresponding software-based regulator drivers should be redesigned.
Another shortcoming of this design is that the energy optimization
is achieved on a local core rather than the entire processor.
8.1.3 Separating the secure core from application cores. Taking
malicious actions on the secure execution environment is the most
common target of VoltJockey since a high privilege is required to
induce hardware faults. The secure cores can be redesigned and
are separated from application cores, like CP15 co-processor in
the ARM platforms. However, the design will be resource waste
and enrich the hardware cost. Besides, the hardware regulator and
corresponding drivers of secure cores should be distinguished with
them of application cores.
8.2 Software-based Countermeasures
8.2.1 Integrity verification for regulator driver. In this study, we
break some security mechanisms (section 4.4 and section 4.5) formerly enforced by the software regulator driver, which might be
mitigated by some integrity-verification methods. The credential
Session 2A: Side Channels I CCS ’19, November 11–15, 2019, London, United Kingdom 206
of the regulator driver can be generated and stored in the secure
boot image before releasing the software system. When loading
the system into devices or calling functions of the regulator driver,
TEE regenerates the credential and compares it with that stored
in the boot image. The credential can be accomplished with RSA,
SHA-256, MD5, and so on. However, such a mechanism still relies
on the OS and software systems to guarantee the security.
8.2.2 Trusted voltage monitor. We can develop a trustlet based on
TrustZone to continually monitor the core voltage and frequencies.
If the trustlet finds that the core voltage is out of predefined legal
ranges, it triggers a warning or a privileged voltage recover operation or just a system reboot. However, the trade-off between the
voltage detection rate/reliability and power consumption may still
leave the possibility for attackers to find feasible injection points.
8.3 Future Extensions
The VoltJockey may also be promising in other related fields.
8.3.1 Attacking other cryptosystems. In addition to AES and RSA,
many other cryptosystems that have been theoretically proved to
be vulnerable to DFA, like DES [56], 3G-SNOW [19], ECC [8], SMS4
[22] and Grain family [60], may become the next targets.
8.3.2 Being a general attack helper. VoltJockey might also be employed to achieve malicious data modifications, which may help
attackers prepare vulnerabilities for other attacks. For example, OS
can be misled to update software from a disguise website if the
update source is changed and the RSA-based verification is evaded;
Internet data will be sent to another destination if it is modified
at packaging; the control flow [54] might be changed if the destinations of direct or indirect jump instructions are altered, or the
conditions of conditional instructions are modified.
8.3.3 Attacking Intel software-guard extensions (SGX). SGX [26, 45]
extends the hardware and software architectures of Intel-based SoC
for providing a trusted execution environment. The trust base of
SGX is only bound to CPU [17]. Nevertheless, DVFS is enabled by
Intel processors and the voltage differences between disparate frequencies remain subsistence even though most of Intel processors
do not enable overclocking technology5
. Therefore, the VoltJockey
might also be effective for attacking Intel SGX.
9 CONCLUSION
ARM TrustZone is a system-wide secure technology for a wide
variety of devices. Most of the current attack techniques to TrustZone are software vulnerability-based. In this paper, we propose
the VoltJockey, a hardware fault-based attack to TrustZone using
software-controlled voltage manipulation, which exploits the voltage management vulnerability of DVFS. We deploy the VoltJockey
on an ARM-based Krait multi-core processor, whose core frequencies can be different but the processor voltage is controlled with
a shared hardware regulator. Experiments show that the attack
method can successfully acquire the key of AES protected by TrustZone, and guide the RSA-based signature verification to output
5The processors whose version number ended with K support overclocking, and some
processors ended with X and E enable overclocking. However, the most deployed ultralow-voltage processors whose version number ended with U cannot be overclocked.
desired plaintexts, which suggests a comparable efficiency to side
channels in obtaining TrustZone-guarded credentials, as well as a
potential capability in cheating the RSA-based verification chain. At
the end of the paper, we also give detailed analyses and discussions
on the possible countermeasures to the attack and look forward to
other potential and promising extensions of this work.