Secure multiparty computation allows mutually distrusting parties
to compute a function on their private inputs such that nothing but
the function output is revealed. Achieving fairness — that all parties
learn the output or no one does – is a long studied problem with
known impossibility results in the standard model if a majority of
parties are dishonest.
We present a new model for achieving fairness in MPC against
dishonest majority by using public bulletin boards implemented
via existing infrastructure such as blockchains or Google’s certificate transparency logs. We present both theoretical and practical
constructions using either witness encryption or trusted hardware
(such as Intel SGX).
Unlike previous works that either penalize an aborting party or
achieve weaker notions such as ∆-fairness, we achieve complete
fairness using existing infrastructure.
KEYWORDS
Secure Multiparty Computation, Fairness
1 INTRODUCTION
Secure multiparty computation (MPC) allows a collection of mutually distrusting parties to jointly compute a function on their
private inputs while revealing nothing beyond the function output.
Since its conception three decades ago [41, 62], MPC has found
wide applicability to important tasks such as electronic auctions,
voting, valuation of assets, and privacy-preserving data mining.
Fairness. Over the years, several security definitions for MPC
have been studied. One natural and desirable definition for MPC
stipulates that either all parties receive the protocol output or no
party does. This is referred to as fair MPC.
The notion of fairness is very important (and necessary) in applications such as auctions and contract signing. For example, if Alice is the first to learn she did not win an auction, she may abort, claim
a network failure, and try again with a new bid that just exceeds
the previous winning bid. More generally when the “value” of the
function output may be enhanced by an information asymmetry,
e.g., if Alice is better off exclusively knowing the true value of a
financial asset than all parties knowing it, fairness is an issue.
In a seminal work, Cleve [25] proved that fair MPC is impossible
to realize for general functions when a majority of the parties are
dishonest. This result even holds when the parties have access to a
trusted setup such as a common reference string.
The pursuit of fairness. In light of Cleve’s impossibility result,
a vast amount of research effort has been dedicated towards the
study of mitigations to the fairness problem. In particular, two
prominent lines of research have emerged over the years. The first
research direction considers the problem of achieving fairness in
the standard model for a restricted classes of functions [7–9, 45, 47].
The second research direction studies fairness for general functions by augmenting the computation model and/or by relaxing
the definition of fairness. The prominent examples in this direction range from using a trusted party to restore fairness [20], to
weaker models where the honest parties can recover the output at
computational cost or time at most ∆-times that of the adversary
[13, 31, 34, 42, 59, 60] (where ∆ is a constant), to penalizing aborting
parties monetarily [6, 17, 52, 53]. (See Section 2 for a more elaborate
discussion.)
While these mitigations are helpful, they fall short of solving the
problem in many circumstances. In particular, they either require
appointing trusted parties for very specific tasks (related to the protocol) that can be hard to find, or require that the parties’ possess
precise estimates of the adversary’s resources and incentives. If the
adversary values exclusive knowledge of the output very highly, it
may not be practical to have a large enough computational differential or penalty to deter aborts. Indeed, in many cases it may be
impossible value the MPC output at all.
Our Model: Public Bulletin Boards. In this work, we take a new
approach to achieving complete fairness in MPC for general functions. We consider a setting where the parties have access to a
public ledger, or a bulletin board that allows anyone to publish arbitrary strings. Upon publishing its data D on the bulletin board,
a party receives a proof (or a signature) to establish that D was
published. The bulletin board is public, in that anyone can see all
of its contents. The main security requirements from the bulletin
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 719
board are that its contents cannot be erased, nor can a proof of
publish be forged.
Our choice of the bulletin board model as a viable model for fair
MPC is motivated by the fact that implementations of public bulletin
boards already exist in practice. We can realize a bulletin board from
an existing centralized system: Google’s certificate transparency
project which logs issued certificates.1
A decentralized implementation of a bulletin board can be realized from blockchain-based ledgers such as Etherium and Bitcoin
implemented with proofs of stake or proofs of work [16]. Proof of
work based blockchains rely on the assumption that the majority
of the network’s computational power is honest. In contrast, proof
of stake systems assume that some quorum of users are honest.
For each block, proof of stake systems select the quorum users,
typically at random but proportional to the amount of currency or
stake they have in the system, and that quorum must sign the next
block and (randomly) select the next quorum. The signature on a
block by the quorum constitutes an unforgeable proof that data
is on the bulletin board. In contrast to e.g. byzantine agreement
protocols, however, the user group is ad-hoc and tolerant to churn.
Proof of Stake and hybrid Proof of Stake/Proof of Work systems
are an area of active research.
1.1 Our Results
In this work, we construct theoretical and practical fair MPC protocols for general functions in the bulletin board model. We, in fact,
provide general transformations from any (possibly unfair) n-party
MPC protocol that supports t < n corruptions to a fair MPC protocol secure against the same number of corruptions. Crucially, the
assumptions used in our transformations affect fairness only: the
correctness and privacy properties of the underlying MPC scheme
are completely preserved even if the assumptions were not to hold.
I. Fair MPC from Witness Encryption. Our first contribution
is a fair MPC protocol in the bulletin board model assuming the
existence of witness encryption (WE) [37] and injective one-way
functions. In order to rely on the standard security of WE, we
require the bulletin board’s proof of publish to be implemented via
unique signatures [43, 56]. If the bulletin board is implemented via
standard signatures (e.g., in Google Transparency Certificates) or
proofs of stake (e.g., in Etherium), then we require the stronger
assumption of extractable witness encryption [19].
Candidate constructions of WE for NP [37, 39] are known from
multilinear maps [36]. Since present constructions [26, 27, 36, 38] of
multilinear maps are quite inefficient, we view our first construction
as a feasibility result. We note, however, that our construction
requires WE for a specific NP language for which constructing
efficient schemes from simpler assumptions might be easier. Indeed,
a fascinating open question for future work is whether WE for the
specific language used in our constructions can be implemented
from existing constructions for the related notion of hash proof
systems [28].
II. Fair MPC from Secure Processors. Our second contribution
is a fair MPC protocol in the bulletin board where all the parties
1Looking forward, our protocol only needs to post a constant sized token to the
blockchain and this can readily be embedded in a URL or certificate.
have access to secure processors. In fact, Cleve’s impossibility result
holds even in the presence of secure processors, and was proved
recently in [58]. For concreteness, we work with Intel SGX as a
secure processor, following the formalization of [59]. For this result, we only need standard cryptographic assumptions such as
secret-key authenticated encryption and signatures. We provide an
implementation of this protocol in Section 8.
Comparison with recent works. Recently, [6, 17] showed how
block-chain based decentralized cryptocurrencies such as Bitcoin
can be used to achieve a notion of fairness with penalties where
aborting parties are forced to pay a pre-agreed financial penalty.
We note that while we also use blockchain based bulletin boards in
our work, our end result is quite different in that we achieve the
standard notion of fairness – either all parties get the output or
none do.
Very recently, [59] studied fairness in the model where each party
has access to a secure hardware equipped with secure clock. They
achieve a notion of ∆-fairness which guarantees that if an aborting
adversary can learn the output in time T , then the honest party can
also learn the output in time ∆ · T for ∆ = 2. A disadvantage of
this model is that T is controlled by the adversary, who can set it
arbitrarily to create large delay (e.g., in the order of several minutes
or hours) between the times when it gets the output and when the
honest party does.
We note that while we also use secure hardware for our second
result, we do not require them to implement secure clocks.2 More
importantly, we achieve the standard notion of fairness.
1.2 Technical Overview
We now describe the main ideas used in our constructions. For
simplicity of exposition, we restrict this discussion to the twoparty case. It is easy to generalize the ideas presented below to the
multiparty case.
Starting Ideas. Our starting idea is to run an unfair MPC protocol
to compute an encryption of the function output as opposed to
computing it in the clear. We then design a special decryption
procedure such that either no party is able to perform the decryption
or both parties can. In other words, we reduce the fairness problem
in MPC to the problem of fair decryption.
At first, it may seem that we haven’t made any progress because
it is unclear why fair decryption would be any easier than achieving
fairness for general functions. Indeed, fair decryption was shown
to be a complete functionality for fair MPC in [46].
Our key insight is that a public bulletin board can be used to
implement a fair decryption protocol for a witness encryption scheme.
We elaborate on this idea below.
Fairness fromWitness Encryption.A witness encryption scheme
for a language L can be used to encrypt a message m with a statement x in such a manner that the resulting ciphertext can only be
decrypted using a witness w for x. We now explain how we use
witness encryption to implement our fair MPC protocol.
2
In the specific case where the bulletin board is implemented using a proof of work
blockchain, we can use secure clocks to achieve stronger security guarantees. This
is unnecessary when the bulletin board uses signatures. We discuss this further in
Section 8.
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 720
In order to securely compute a function f with complete fairness,
the parties first run a standard (possibly unfair) MPC protocol to
compute a randomized function that takes the private inputs say
(y1,y2) of the parties and returns a witness encryption ciphertext
CT of the desired output F (y1,y2). The statement x associated with
CT is set to be such that a valid witness for x corresponds to the
proof of posting a “release token” α (to be determined later) on the
bulletin board.
The only way for any party to obtain such a witness is to post
α on the bulletin board and obtain the corresponding proof of
posting σ. However, in doing so, the pair (α, σ) is made public, and
therefore, anyone can obtain it. Thus, if a malicious adversary learns
the witness for decrypting CT, then so can the honest party since
it can simply read the public bulletin board. This mechanism puts
the honest party and the adversary on equal footing and resolves
the fairness problem.
While the above constitutes the core idea behind our work, we
run into several technical issues in implementing this idea. We
discuss these next, together with the solutions.
Issue #1: Setting the release token. An immediate issue with implementing the above idea is that we cannot set the release token α to
be an a priori fixed value that is known to the adversary. Indeed,
if this is the case, then the adversary can simply abort during the
execution of the unfair MPC protocol so that it learns the ciphertext
CT, but the honest party does not. Now, even if the honest party
can obtain (α, σ) once the adversary has posted it on the bulletin
board, it cannot learn the output F (y1,y2) since it does not have
CT to decrypt.
To address this issue, we set α to be a pair of random values
(α1, α2) where αi
is chosen by the i-th party. During the initial
MPC phase, each party uses αi as an additional input such that the
output of the MPC is (β,CT) where βi = f (αi) for some one-way
function f and β = (β1, β2). Now, even given (β,CT), the value α
is not completely known to the adversary. Therefore, if it aborts
prematurely, then the honest party aborts as well, knowing that
the adversary would not be able to recover the output.
On the other hand, if the first phase is successfully completed,
then the parties execute a second phase where each party i simply
sends over αi to the other party. Of course, the adversary may abort
in this phase after learning α. However, in order to decrypt CT, it
will have to post α on the bulletin board which means the honest
party would learn it as well. This restores the balance between the
honest party and the adversary.
Issue #2: Security of WE. The standard definition of witness encryption only guarantees semantic security for a ciphertext CT if the
statement x associated with it is false. In our case, the statement
is always true. The only way to argue security in this case is to
use a stronger notion of extractable witness encryption [19] which
guarantees that for any statement x, if an adversary can distinguish
between witness encryption of m from an encryption of m′ , m,
then one can efficiently recover from that adversary a witness w
for x. Now, if the witness w is computationally hard to find, then
we can get a contradiction.
It was shown in [19] that for languages with statements that
have only polynomially many witnesses, the standard definition
of WE implies the stronger definition of extractable WE. We note
that if we set f to be an injective one-way function and implement
the proof of posting on the bulletin board via unique signatures
[43, 56], then we can bound the number of valid witnesses. In this
case, we can rely on the standard definition of WE.
Issue #3: Rewinding. We run into yet another issue while arguing
security of the above construction. Recall that in order to prove
security of a fair MPC protocol, we must construct a simulator who
can “force” the correct output on the real adversary, provided that
the adversary did not abort prematurely. In our protocol, the only
opportunity for the simulator to “program” the output is inside the
ciphertext CT computed during the initial MPC phase. However,
this point in our overall protocol is “too early” for the simulator to
determine with enough confidence whether the real adversary is
going to later abort or not. If the simulator’s decision to program the
output turns out to be wrong, then it would immediately lead to a
distinguisher between the outputs of the real and ideal experiments.
To deal with this issue, we use a rewinding strategy previously
used in [40, 44, 46] to determine the aborting probability of the
adversary with enough accuracy, while still ensuring (expected)
polynomial running time for the simulator. In order to ensure indistinguishability of the adversary’s view in the real and ideal experiments, we allow the simulator to also rewind the bulletin board
to a previous state, as and when necessary. Indeed, without this
capability, the simulator cannot prevent an adversary from “detecting rewinding” by continuously posting on the bulletin board.
A consequence of this is that we must model the bulletin board
as a “local” functionality as opposed to a “global” functionality
[21, 22]. Furthermore, since our simulator performs rewinding, we
only achieve stand-alone security.
Fairness from Secure Hardware. Roughly, the main idea in our
second protocol is to replace the witness encryption in the plain
model with a secure hardware that implements (essentially) the
same functionality as witness encryption. We require that each
party is equipped with such a secure hardware (e.g., Intel SGX).
While much of the details in this protocol are similar to the previous
one, there are some key differences. We explain them below.
Once the parties have “installed” an appropriate program P (discussed below) in their own local secure hardware and attestation of
the same is successfully performed by everyone, they run (as in the
previous protocol) an execution of a standard MPC protocol to compute an encryption CT of the desired output. Unlike the previous
scheme where CT was computed using witness encryption, here we
use a regular secret-key encryption scheme. The secret key K used
for encryption is secret-shared amongst the parties who use their
respective shares as additional inputs to the MPC. The key K is also
loaded in each party’s secure hardware, and is in fact computed by
the secure hardware devices during an initial key-exchange phase.
As in the previous protocol, we require that the ciphertext CT
can only be decrypted if the release token α has been posted on
the bulletin board. The program P loaded in each party’s secure
hardware implements such a conditional decryption mechanism.
Specifically, upon receiving a ciphertext CT, a release token α and
a corresponding proof of posting σ, the program P verifies the
validity of α and σ. If the verification succeeds, then it decrypts CT
and returns the output; otherwise it returns ⊥.
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 721
We remark upon two security issues: first, in order to prevent
malleability attacks, we require that an authenticated encryption
scheme is used in order to compute CT. Further, to prevent an adversary from performing a related key attack (by changing its input
key share in the MPC), we require that the secure hardware also
provide commitmentsCi of each key share Ki to all the parties upon
generation of K. A party i is required to input the decommitment
to Ci
in the MPC protocol, and the MPC functionality checks that
all the input key shares are valid by verifying the decommitment
information.
Second, for this protocol, we can completely dispense with rewinding and instead construct a black-box, non-rewinding simulator.
This is because the use of secure hardware allows the simulator to
“program” the output at the very end, when the adversary makes
a decryption query to its secure hardware.3
Indeed, in the secure
hardware model, the simulator has the ability to observe (and modify) the queries made by the adversary to its secure hardware. This
means that when the adversary makes a final decryption query, the
simulator can check if it is valid. If this is the case, then it queries
the trusted party to obtain the function output. At this point, the
simulator sends a “fake” decryption query to the secure hardware
that already contains the desired output. Upon receiving this query,
the secure hardware returns the programmed output to the adversary. We note that this programming technique for secure hardware
was recently used in [59].
Because of the above modifications, in this protocol, we can
model the bulletin board as a global functionality. In this manuscript,
however, we do not prove UC security of our protocol and leave it
for future work.
Realizing the Bulletin Board. Our constructions assume a public
bulletin board that is capable of producing an unforgeable proof
that a string has been published to the bulletin board. Such bulletin boards can easily be constructed practice if one is willing to
instantiate the board using a single trusted party. While this seems
a strong assumption, the advantage of this approach is that such
systems already exist and have been widely deployed in practice for
applications such as Certificate Transparency [1]. Re-using them
to achieve fairness in arbitrary MPC protocols requires no specific
to the existing systems.
Alternatively, a bulletin board can be realized using a decentralized systems such as proof of stake blockchains (e.g., [49]). These
systems allow a quorum of honest users – who together possess
a majority ownership “stake” in a cryptocurrency – to securely
authenticate an append-only log using signatures. Finally, a weaker
notion of security can be achieved using a proof of work blockchain.
In the latter case, the “proof” of publication is not a cryptographically unforgeable signature, but rather the solution to a sequence
of one or more computational puzzles which may be, in practice,
prohibitively expensive for an attacker to forge.4 We explore this
approach in our experimental implementation, although we stress
3We also use an MPC in the common random string (CRS) model (e.g., [23]) to implement the first phase of the protocol. By using the CRS trapdoor, the simulator for this
phase can avoid any rewinding of the adversary.
4
In practice, such proof of work blockchains provide a slightly weaker security that is
related to ∆-fairness. An attacker, given enough time, may be able to forge the proof
of work necessary to prove publication. However, in the trusted hardware setting we
are able to mitigate this concern to some extent by requiring the attacker to provide a
proof in a limited period of time, as judged by the hardware.
that this is merely an implementation detail. Our bulletin board
could easily be replaced with one of the alternatives above.
Optimizations. We mention a few optimizations to the above
protocols to improve efficiency. First, we can add an optimistic
decryption phase in the above protocols that allows the parties to
learn the output using a simple decryption process, without using
the bulletin board, provided that all the parties are honest. Roughly,
the MPC protocol executed in the first phase now additionally
computes another encryption CT′ of the function output, where CT′
is implemented using a regular encryption scheme. The decryption
key K
′
corresponding to CT′
is secret-shared between the parties.
Now, if the release-token exchange performed in the second phase
is successful, then the parties execute a third phase (that we refer
to as the optimistic decryption phase) where they exchange the key
shares corresponding to K
′
. If all the parties are honest, then they
all learn K
′
and use it to decrypt CT′
, without using the bulletin
board. However, if one or more parties are adversarial and abort in
this phase, then the honest parties can still post the release token α
(that they learned in the second phase) on the bulletin board and
then use the proof of posting to decrypt CT as before.
We remark that in order to avoid related key attacks by an adversary, we would need a slight modification to the above protocol
where the MPC in the first phase outputs commitments to each
key share K
′
i
to both the parties. During the optimistic decryption
phase, each party must reveal the decommitment value together
with K
′
i
. A party only accepts the key share as valid if the associated
decommitment information is correct.
Finally, we note that the size of the release token α = (α1, α2)
used in the above described protocols grows with the number of
parties N. However, it is easy to make it independent of N by setting
α = ⊕iαi and using β = f (α) to verify the correctness of release
token. An advantage of this modification is that the witness length
for the witness encryption used in our construction, as well as the
length of the string that is posted on the bulletin board becomes
independent of the number of parties.
2 RELATED WORK
A large body of research work has addressed the problem of fairness in secure protocols over the years. Below, we provide a nonexhaustive summary of prior works. A more elaborate summary
can be found, e.g., in [17].
Fairness in Standard Model. Assuming an honest majority of
parties, fair MPC can be achieved in both computational [41] and
information-theoretic setting [61]. Cleve [25] proved the impossibility of MPC for general functions n the dishonest majority setting.
Subsequently, an exciting sequence of works [7–9, 45, 47] have
shown that complete fairness can still be achieved for a restricted
class of functions. The works of [5, 14, 48] study the problem of
partial fairness.
Optimistic Models. Starting from the early work of [15], optimistic models for fair exchange have been studied in a long sequence of works [11, 12, 30, 33, 54, 57]. An optimistic model for
fair two-party computation using a semi-trusted third party was
studied in [20, 51].
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 722
Gradual Release Mechanisms. A different approach to fairness
that avoids trusted third parties was considered in a long sequence
of works [18, 32, 35, 60], following the early works of [13, 31, 42].
The protocols in these works employ a “gradual release” mechanism
where the parties take turns to release their secrets in a bit-by-bit
fashion. The intuitive security guarantee (formalized in [34]) is
that even if an adversary aborts prematurely, the honest party can
recover the output in time comparable to that of the adversary by
investing equal (or more) computational effort.
∆-Fairness. Very recently, [59] considered a notion of ∆-fairness
with the guarantee that if an adversary aborts, then the honest party
can learn the output in time ∆ ·T , where T is the time in which the
adversary would learn the output. They propose a fair two-party
computation protocol with (∆ = 2)-fairness assuming that all the
parties have secure hardware equipped with secure clocks.
Fairness with Penalties. Recently, with the popularity of decentralized cryptocurrencies such as Bitcoin, a sequence of works [6,
17, 52, 53] have shown how to implement a fairness-with-penalties
model for MPC where adversarial parties who prematurely abort
are forced to pay financial fines. Prior works in similar spirit considered fairness with reputation systems [10] and legally enforced
fairness [24, 55].
3 DEFINITIONS
3.1 Fair Multi Party Computation
A secure fair multi-party computation protocol is a protocol executed by n number of parties P1, · · · , Pn for a n-party functionality
F . We allow for parties to exchange messages simultaneously. In
every round, every party is allowed to broadcast messages to all
parties. We require that at the end of the protocol, all the parties
receive the output F (x1, . . . , xn), where xi
is the i
th party’s input.5
We formalize the security notion below.
Ideal World. We start by describing the ideal world experiment
where n parties P1, · · · , Pn interact with an ideal functionality for
computing a function F . An adversary may corrupt any subset
P
A ⊂ P of the parties. We denote the honest parties by H.
Inputs: Each party Pi obtains an initial input xi
. The adversary
Sim is given auxiliary input z. Sim selects a subset of the
parties P
A ⊂ P to corrupt, and is given the inputs xk of
each party Pk ∈ P A.
Sending inputs to trusted party: Each honest party Pi sends its
input xi
to the trusted party. For each corrupted party Pi ∈
P
A, the adversary may select any value x
∗
i
and send it to
the ideal functionality.
Trusted party computes output: Let x
∗
1
, . . . , x
∗
n
be the inputs that
were sent to the trusted party. If any of the received inputs
were ⊥, then the trusted party sends ⊥ to all the parties. Else,
the trusted party sends F (x
∗
1
, . . . , x
∗
n
) to all the parties.
Outputs: Honest parties output the function output they obtained
from the ideal functionality. Malicious parties may output
an arbitrary PPT function of the adversary’s view.
5One can also consider asymmetric functionalities where every party receives a different output. Since there are generic transformations from the symmetric case to
the asymmetric case, we only consider symmetric functionalities for simplicity of
exposition.
The overall output of the ideal-world experiment consists of
the outputs of all parties. For any ideal-world adversary Sim with
auxiliary input z ∈ {0, 1}
∗
, input vector x®, and security parameter λ,
we denote the output of the corresponding ideal-world experiment
by IDEALSim,F

1
λ
, x®, z

.
Real World. The real world execution begins by an adversary A
selecting any arbitrary subset of parties P
A ⊂ P to corrupt. The
parties then engage in an execution of a real n-party protocol Π.
Throughout the execution of Π, the adversary A sends all messages
on behalf of the corrupted parties, and may follow an arbitrary
polynomial-time strategy. In contrast, the honest parties follow the
instructions of Π.
At the conclusion of all the update phases, each honest party Pi
outputs whatever output it received from the computation. Malicious parties may output an arbitrary PPT function of the view of
A.
For any adversary A with auxiliary input z ∈ {0, 1}
∗
, input
vector x®, and security parameter λ, we denote the output of the
MPC protocol Π by REALA,Π

1
λ
, x®, z

.
MPC with Complete Fairness. We say that a protocol Π is a
secure protocol if any adversary, who corrupts a subset of parties
and runs the protocol with honest parties, gains no information
about the inputs of the honest parties beyond the protocol output.
Definition 3.1. A protocol Π is a secure n-party protocol computing F with complete fairness if for every PPT adversary A in the
real world, there exists a PPT adversary Sim corrupting the same
parties in the ideal world such that for every initial input vector x®,
every auxiliary input z, it holds that
IDEALSim,F

1
λ
, x®, z

≈c REALA,Π

1
λ
, x®, z

.
Security with Abort. For our constructions, we shall require a
weaker security notion of MPC referred to as security with abort.
This definition differs from the above only in the ideal world, where
the adversary receives the output prior to the honest parties and
then decides if the trusted party should give the output to the honest
parties or not.
3.2 Authentication Scheme with Public
Verification
An authentication scheme with public verification consists of three
polynomial algorithms (Gen, Tag, Verify).
– Gen is PPT algorithm that takes as input λ and generates a
key for signing. sk ← Gen(λ).
– Tag is a deterministic algorithm that computes a tag on a
message x. σ = Tagsk(x).
– Verify is a deterministic algorithm that allows for public
verification of the tag. Verify(x, σ) returns 1 if the tag σ
verifies.
Definition 3.2. A scheme Σ = (Gen, Tag, Verify) is an authentication scheme with public verification if for any sequence of messages
m1, . . . ,mq and any PPT adversary A, the following is negligible
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 7  
in the security parameter:
Pr







sk ← Gen(λ);
∀i σi = Tagsk(mi);
(m′
, σ
′
) ← A 
{mi
, σi }
q
i=1
 :
Verify(m′
, σ
′
) = 1
Ó
m′ < {m1, . . . ,mq }







3.3 Witness Encryption
In this section, we define witness encryption [39] and state its
relation with extractable witness encryption [19] for polynomial
witness languages.
Definition 3.3 (Extractable Witness Encryption). An extractable
witness encryption ExtWE = (Enc, Dec) for a NP language L associated with relation R consists of the following algorithms:
– Encryption, Enc(1
λ
, x,m): On input instance x and message
m ∈ {0, 1}, it outputs a ciphertext CT.
– Decryption, Dec(CT,w): On input ciphertext CT and witness w, it outputs m′
.
We require that the above primitive satisfies the following properties:
– Correctness: For every x ∈ L, letw be such that (x,w) ∈ R,
for every m ∈ {0, 1},
Pr[m ← Dec(Enc(x,m),w)] = 1
– Security: Let A be a PPT adversary such that the following
holds: for every x, m0,m1, every auxiliary information z ∈
{0, 1}
poly(λ)
:



Pr[1 ← A(1
λ
, Enc(x,m0))] − Pr[1 ← A(1
λ
, Enc(x,m1))]


 ≤ ε
Then there exists a PPT extractor Ext such that:
Pr[w ← ExtA(1
λ
, x) : (x,w) ∈ R] ≥ ε − negl
We now define the notion of polynomial witness languages.
Definition 3.4 (Witness Languages). Consider an NP language L
and let R be its associated relation. We say that L is a polynomial
witness language if there exists a fixed polynomial p such that for
every x ∈ L it holds that there exists a size p(|x |) set of witnesses
w such that w ∈ {0, 1}
poly( |x |) and (x,w) ∈ R.
Definition 3.5 (Witness Encryption). A witness encryption WE =
(Enc, Dec) for a NP language L consists of the following algorithms:
– Encryption, Enc(1
λ
, x,m): On input instance x, message m
and it outputs a ciphertext CT.
– Decryption, Dec(CT,w): On input ciphertext CT and witness w, it outputs m′
.
We require that the following properties hold:
– Correctness: For every x ∈ L, letw be such that (x,w) ∈ R,
for every m ∈ {0, 1},
Pr[m ← Dec(Enc(x,m),w)] = 1
– Message Indistinguishability: For every PPT adversary
A, there is a negligible function ε, such that for every x < L
the following holds:



Pr[1 ← A(1
λ
, Enc(x,m0))] − Pr[1 ← A(1
λ
, Enc(x,m1))]


 ≤ ε.
The following theorem was shown in [19].
Theorem 3.6. Suppose L is a polynomial witness language. Then,
witness encryption for L implies extractable witness encryption for
L.
4 MODELING THE BULLETIN BOARD
We describe briefly our modeling of the bulletin board. The bulletin
board models a public ledger that lets parties publish arbitrary
strings. On publishing the string on the bulletin board, the party
receives a proof to establish the string was indeed published. In our
setting, we model these proofs via authentication tags that can be
publicly verified and the string subsequently publicly accessible.
For security, we require that the authentication tags follow the
standard notion of unforgeability described earlier (see definition
3.2).
In addition, the bulletin board implements a counter. Each time a
string is published on the bulletin board, the counter is incremented
and the authentication tag is produced on the string and counter
pair. While the counter value of the bulletin board is assumed to
be publicly accessible, we shall model it as an explicit query. The
counter also serves as an index to the string on the bulletin board.
Hence, we model the bulletin board BB through the following
queries:
– getCurrentCounter: the bulletin board returns the current
value of the counter.
t ← BB(getCurrentCounter).
– post: on receiving value x, the bulletin board increments the
counter value by 1 to t, computes the authentication tag on
(t||x) and responds with the tag and t to the posting party.
The value and the corresponding tag can be retrieved by
querying the bulletin board on t.
(σ,t) ← BB(post, x)
such that VerifyBB(σ, (t||x)) = 1.
– getContent: on receiving input t, it returns the value and the
corresponding tag stored at counter value t. If t is greater
than the current counter value, it returns ⊥. Else,
(σ, x) ← BB(getContent,t)
We note that bulletin boards have previously been considered in
works such as [50], but their model differs significantly from ours.
5 FAIR MPC FROM WITNESS ENCRYPTION
Overview. We start by giving an overview of our protocol. Our
protocol builds on an MPC protocol that achieves the weaker notion
of security with abort, where the fairness condition is not required
to hold. The initial phase constitutes of the parties using this unfair
MPC protocol to compute a witness encryption ciphertext of the
function value they wish to compute. To decrypt, a party must
post messages of a specific form (referred to as “release tokens”)
on to the bulletin board which the bulletin board validates with
an authentication tag. The idea then is that any party can use this
posted information and authentication tag to decrypt the witness
encryption ciphertext. The release token must include shares of all
parties that are secret prior to the completion of this initial phase.
These shares must also be easily verifiable. Our construction uses
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 724
injective one-way functions, where the images of these shares are
sent out during the initial phase.
The next phase, on completion of the initial phase, constitutes
of parties sending these secrets to every other party. Once a party
releases its share, it must not abort until it is sure that the other
parties cannot post to the bulletin board, and hence decrypt the
message thereafter. Otherwise, the adversary on receiving the secret
shares will wait for the honest parties to abort before posting to the
bulletin board. This is resolved by parameterizing the protocol by a
cut-off period which once elapsed, effectively ends the protocol. If
there isn’t a valid post to the bulletin board at this time, no party
gets the output.
To argue security, we require each statement in the language
corresponding to the witness encryption to have only a polynomial
size witness set. To do so, we use an injective one-way function
and a unique signature scheme. The witness for the statement are
the pre-images of the values sent during the initial phase, and the
corresponding tag from the bulletin board. This pair is unique for
a given statement. But we need to incorporate the cut-off period
into the witness. This is enforced by the counter in the bulletin
board as described in section 4. In the protocol, this translates to
a window (set) of counter values which qualify as the additional
variable in the witness. To ensure that the number of witnesses
are still polynomial, the window size has to be polynomial. We
parameterize the protocol with the size of this window, and the
parties choose the start point of the window.
As discussed in the introduction, for the proof in this model, it
is essential that the simulator is able to reset the bulletin board to a
prior point (in essence, rewinding).
– rewind: This functionality is reserved for the simulator in
the ideal world. On receiving additional input t, the bulletin
board internally resets its counter to t and clears all data
stored beyond the counter value t. The simulator gets no
output on this query.
⊥← BB(rewind,t)
We want to stress that this additional capability is only limited
to the construction in this section and the construction in the next
section (using trusted hardware) we will not require this.
We additionally discuss an extension to an optimistic phase
where the parties can share some additional secrets (different from
before) that enable them to decrypt a (different) ciphertext containing the output, without having to post to the bulletin board.
Of course, the adversary can prematurely abort in this phase and
obtain the output for itself. To protect against this, the optimistic
phase is reached only once it has been established that the parties
have enough information that would enable them to use the bulletin
board, to decrypt to the output, in case the adversary aborts in this
phase.
Construction. We now proceed to describe our protocol Πfair. It
uses the cryptographic primitives and a bulletin board as described
below. The formal protocol description is given in Figure 1.
(1) A injective one-way functions f .
(2) An authentication scheme with public verification (Gen, Tag,
VerifyBB) such that the authentication tags are unique for a
given message.
(3) A witness encryption WE for the language
LWE,∆t =
n {yi }i ∈[n]
,T
 


∃

t, σ, {ρi }i ∈[n]

s.t.
(∀i ∈ [n], yi = f (ρi)) AND
t ∈ {T,T + 1, · · · ,T + ∆t } AND
VerifyBB((t||ρ1 || · · · ||ρn), σ) = 1
o
For a given x ∈ LWE,∆t
, if f is an injective one-way function
and (Gen, Tag, VerifyBB) is a scheme that generates unique
authentication tags, it is easy to see that there are only ∆t +1
witnesses for x. If ∆t is set to be polynomial in the size of x,
there are only polynomially many witnesses for any given
statement, and thus LWE,∆t
is a polynomial witness language
(see Definition 3.4). From Theorem 3.6, given LWE,∆t
is a
polynomial witness language, we know that a witness encryption for LWE,∆t
is also an extractable witness encryption
for LWE,∆t
.
(4) An MPC protocol that computes:
F
′
∆t
((x1, ρ1,t1), · · · , (xn, ρn,tn)) =

c, { f (ρi)}i ∈[n]
,T

where T = max(t1, · · · ,tn) and c = WE.Enc(xWE,∆t
, F (x1,
· · · , xn)) for xWE,∆t = ({ f (ρi)}i ∈[n]
,T ). We do not require
this protocol to be fair. Importantly, we use the MPC protocol
in the common random string (CRS) model. This allows for
black-box simulation of the adversary without the necessity
of rewinding. For this section, we shall drop the CRS notation,
but it will be implicit.
Remark 1. In the construction described above, the size of the
witness encryption circuit is dependent on the number of parties in
the protocol. This can be remedied by using the XOR of the ρi values
as the release token, and applying the injective one-way function on
this. The rest of the protocol remains the same.
5.1 Proof of Security
We prove the security of our construction in the F
′
∆t
-hybrid model.
Simulator S. We start by constructing a simulator S. Our simulator uses rewinding strategy similar to the one described in [44]
(which in turn builds on [40]). The simulator has access to an ideal
functionality for computing F, and simulates F
′
∆t
for the real world
adversary. In addition, for the proof in this model, the simulator reserves the right to reset the bulletin board to prior point (in essence,
rewinding). (We will not require this property in the protocol based
on secure hardware.) Further, S forwards any queries the adversary makes to the bulletin board, and returns the corresponding
response from the bulletin board.
(1) S receives inputs {(xa, ρa,ta)}a ∈A sent by the adversary
that are intended for F
′
∆t
.
(2) Mark the current value of the counter so that S can rewind
the bulletin board to this point.
tmark ← BB(getCurrentCounter)
(3) S simulates the output of ideal functionality computing F
′
∆t
as follows:
(a) Set T = max{{ta }a ∈A,tmark}.
(b) Randomly pick {ρh }h∈H for the honest parties.
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 725
Protocol Πfair in the F
′
∆t
-Hybrid model
Inputs: Each party Pi has an input xi
.
Common input: The verification key for the bulletin board vkBB.
The protocol:
(1) Computation of F
′
∆t
.
– Pi samples token ρi
$← {0, 1}
poly(λ)
.
– Pi queries the bulletin board to get the current counter value, i.e. ti ← BB(getCurrentCounter).
– Pi sends (xi
, ρi
,ti) to the ideal functionality F
′
∆t
and receives 
c, {yi }i ∈[n]
,T

. It aborts if it receives ⊥ from the ideal
functionality.
(2) Exchange of tokens. Pi broadcasts ρi to all other parties, and receives {ρbl
}l ∈[n]\{i }
.
(3) Obtaining the output. We split this into three cases, where either (i) Pi can post on the bulletin board to receive a valid
witness; or (ii) Pi waits for another party to post to the bulletin board; or (iii) no party posts to the bulletin board.
(i) Pi received ρj from all the other parties, such that ∀j ∈ [n] \ {i} : f (ρj) = yj
. In this case, Pi waits for the counter to get to T
before posting to the bulletin board. Prior to posting, it check to see if another party has already posted the same. This could
be done either by observing the broadcasts sent (to the bulletin board), or querying the bulletin board at most ∆t times. On
obtaining the appropriate authentication tag, the witness encryption can be decrypted to get the output.
(ii) Pi received a ρj such that f (ρj) , yj
, or ρj =⊥ (i.e. a party didn’t send its token). In this case, Pi checks if the right message is
posted to the bulletin board for counter values between T and T + ∆T . If it finds the right value, it obtains the authentication
tag and decrypts the witness encryption to get the output.
(iii) If there are no posts on the bulletin board satisfying the given requirements, and the counter has progressed beyond T + ∆t,
Pi aborts.
Figure 1: Πfair in the F
′
∆t
-Hybrid model. The protocol relies on the security of witness encryption for a polynomial witness
language, injective one-way functions and authentication scheme with public verification and unique tags.
(c) ∀i ∈ [n], yi B f (ρi).
(d) Compute out c ← F (xb1, · · · , xbn) where xbh = 0 for all h ∈
H.
(e) Set xWE B

{yi }i ∈[n]
,T

and compute
c ← WE.Enc 
xWE, out c

.
(f) Send (c, {yi }i ∈[n]
,T ) to the adversarial parties.
(g) If the adversary responds with an abort, S sends abort to
the ideal functionality computing F, and exits. For our
analysis, we denote this by abort1.
(4) S sends values {ρh }h∈H to the adversary. If the adversary
sends values {ρa }a ∈A such that ∀a,ya = f (ρa); or sends
a post query to the bulletin board with value (ρ1 || · · · ||ρn)
when counter value is betweenT andT +∆t such that ∀i,yi =
f (ρi), the adversary has not aborted.
(5) If the adversary aborted in the previous step, S sends abort
to the ideal functionality computing F, and exits. For our
analysis, we denote this by abort2.
(6) If the adversary didn’t abort prior to this, we need to estimate
the probability of the adversary not aborting. Let q represents
the true of probability of this event, where the randomness is
over random coins used in step 3(b) and 3(e). The estimated
probability will be denoted by qe.
(a) S fixes some number t = poly(λ).
(b) S rewinds the adversary to step 3, rewinds the bulletin
board BB(rewind,tmark) and repeats steps 3 and 4 (other
than 3(g)) with fresh randomness each time. Repeat till
the adversary has not aborted t times.
(c) S estimates q as qe=
t
# of repetitions. The polynomial defining t is chosen to be large enough that
Pr 
1
2
≤
q
qe
≤ 2

> 1 − 2
λ
.
(7) The simulator sends {xa }a ∈A to the ideal functionality for
F and receives out. S repeats the following at most t
qe
times.
(a) With fresh randomness each time, S rewinds the adversary to step 3, rewinds the bulletin board BB(rewind,
tmark) and repeats steps 3 and 4 (other than 3(g)) replacing
out c with out.
(b) If the adversary does not abort, we output its view and
the simulator terminates.
(8) If S has not terminated yet, output fail and terminate the
simulation.
Claim 1. If simulator S does not outputs fail, the hybrid world
and the ideal world are indistinguishable.
Proof. We split the analysis into two cases:
– Case 1: The adversary does not abort. Since the simulator
does not output fail, it has successfully got the adversary to
accept the transcript for the right output. In this case, the
main thread of the adversary is statistically indistinguishable
from the real execution. Additionally, since the simulator is
able to rewind the bulletin board, the adversary’s view of
the bulletin board is that of a straight line execution. Thus
the joint distribution consisting of the view of the adversary
and the honest party outputs is indistinguishable.
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 726
– Case 2: The adversary aborts. As noted in the simulator, the
adversary can abort in two phases of the protocol. We deal
with the two case separately:
abort1: The adversary aborts immediately after running the
MPC for F
′
∆t
. In both the real and ideal world, honest parties do not get any output. Thus, we need to argue that the
adversary’s view is indistinguishable when he receives a witness encryption of the actual output as opposed to when he
received the witness encryption of a random string. To the
contrary, assume that the adversary can distinguish between
these two cases. Since there only polynomially many witnesses, we use the extractor for the adversary to recover the
witness. Since the honest parties aborts without revealing its
share of the token, we can use the extractor to construct an
adversary that breaks the security of the injective one-way
function.
abort2: The adversary aborts on receiving the honest party’s
tokens without posting to the bulletin board. We use the
same technique as above, leveraging the extractor for witness encryption, to construct an adversary that breaks the
unforgability of the authentication tags issued by the bulletin
board.

Claim 2. The simulator S outputs fail with only negligible probability.
The proof can be found in Appendix A.;
We assume that the value ofT chosen in the protocol is such that
the real execution of the protocol ends in time bounded above by a
polynomial д(λ). Otherwise F
′
∆t
implements an additional check
to ensure this.
Claim 3. The simulator S runs in expected polynomial time.
Proof. With probability 1 −q, the simulator aborts prior to step
6. With probability q, the simulator goes through the estimation
phase and then attempts to force an accepting transcript onto the
adversary. The expected number of iterations for the estimation
phase is t
q
and the cut-off point for forcing the transcript is t
qb
<
t
2q
.
Hence the total expected running time is bounded by
д(λ) · q ·

t
q
+
2t
q

= д
′
(λ)
Thus S runs in expected polynomial time.
Given the above claims, the following theorem follows.
Theorem 5.1. Assuming the security of injective one-way functions, witness encryption for polynomial witness language and the
unforgeability of the authentication scheme, the above protocol satisfies Definition 3.1 in the F
′
∆t
-hybrid model.
As mentioned in the introduction, in order to rely on the standard
security of WE, we require the bulletin board’s proof of publish to be
implemented via unique signatures [43, 56]. If the bulletin board is
implemented via standard signatures (e.g., in Google Transparency
Certificates) or proofs of stake (e.g., in Etherium), then we require
the stronger assumption of extractable witness encryption [19].
6 FAIRNESS FROM SECURE HARDWARE
A key limitation of our previous constructions is the need to use
Witness Encryption (WE) to protect the output of the MPC protocol.
Unfortunately, current proposed WE construction are inefficient,
due to the high overhead of current constructions of multilinear
maps. Moreover, the Witness Encryption paradigm requires the
parties to compute a new WE ciphertext for each invocation of the
MPC protocol.
In this section we investigate an alternative paradigm that uses
secure hardware. Our work is motivated by the recent deployment
of commodity virtualization technologies such as Intel’s Software
Guard Extensions (SGX). These technologies allow for the deployment of secure “enclave” functionalities that can store secrets and
perform correct computation even when executed in an adversarial
environment. Moreover, these systems allow an enclave to remotely
attest to their correct functioning, which allows for the establishment of trustworthy communications between enclaves running
on different machines.
Model Following the approach of Pass et al. [59] we model all
available trusted hardware processors from a given manufacturer
as a single, globally shared functionality denoted Gatt (see Figure 5).
We describe the functionalities required for our construction, and
refer the reader to [59] for details. install loads the program prog
onto the attested hardware. It returns an enclave identifier eid. (For
simplicity, we skip the session identifier used in [59].) The enclave
identifier is be used to identify the enclave upon resume. resume
allows for a stateful resume using the unique enclave identifier
generated. On running over a given input, the output produced is
signed to attest that the enclave with identifier eid was installed
with a program prog, which was then executed to produce the
output. The program’s input is not included in the attestation.
Description. We describe here the main ideas in this construction
that differ from the previous construction. Upon loading the program onto the attested hardware (enclaves), there is an initial key
exchange to establish a secure authenticated channel between the
enclaves. Any information passed over this channel is hidden from
the parties. It is important that enclaves attest to the fact that they
are running the correct programs prior to the key exchange.
Next, the shares of the release token and the key are input to
the enclave. The enclaves use the established secure authenticated
channel to exchange this information and set up consistent parameters (over all enclaves) for the decryption circuit. The parties then
run an MPC protocol external to the enclaves to compute an encrypted version of the output. As in our previous construction, the
players exchange shares of the release token that they are required
to post onto the bulletin board in order to decrypt.
For technical reasons, we need to ensure that the key share that
a party sends to the enclave is the one used in the MPC. This is ensured by using a commitment scheme which the MPC computation
verifier before returning the output.
Our protocol makes requires the following primitives:
(1) A one-way function f .
6
(2) A signature schemes (Gen, Sign, Verify).
6
In practice we suggest using a hash function.
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 727  
(3) An authentication scheme with public verification (Gen, Tag,
VerifyBB).
(4) A multi-party computation in the CRS model for computing
F
′ defined as
F
′

xi
, ki
, {comij }j ∈[n]
,ri
	
i ∈[n]

=



⊥ if ∃i,i
′
s.t. 
{comij }j ∈[n]

,

{comi
′
j }j ∈[n]

⊥ if ∃i s.t. comi i , Com(ki
;ri)
y otherwise
where y = AE.EncÉn
i=1
ki
(F (x1, · · · , xn)). Essentially the
MPC takes in a the input, key share, a commitment tuple
and a decommitment from each party. It checks if the tuple
pairs received are the same throughout and the commitment
linked to each party decommits to the key share. If this check
fails it just returns ⊥, or it returns the output y.
(5) Two instances of AE scheme (Enc, Dec) with INT-CTXT
security for authentication and semantic security.
(6) A commitment scheme (Com) with computational hiding
and statistically binding.
We describe and prove the protocol in the two party setting.
Both extended naturally to the multi-party setting. The protocol is
described in Figure 2.
We note that there are two trapdoors installed into functionalities
of progfair. These are used for the security reduction of the one-way
function, and to program the output correspondingly. Specifically,
the trapdoor is used to get the enclave to attest to a value of choice.
These trapdoors can be used by an adversarial party, but this makes
no difference to the security since these values are not sent across
to the other party.
Theorem 6.1. Assume that F is one-way, the signature scheme is
existentially unforgeable under chosen message attacks, the authentication scheme satisfies standard notion of unforgeability, the encryption scheme is perfectly correct, authenticated encryption scheme that
is perfectly correct and satisfies standard notions of INT-CTXT and
semantic security, decisional Diffie-Hellman assumption holds in the
algebraic group adopted. Then, the above protocol satisfies Definition
3.1 in the (Gatt, F
′
)-hybrid model.
The proof can be found in Appendix A.2.
7 INSTANTIATING THE BULLETIN BOARD
Our proposed paradigm relies on a verifiable public bulletin board
that makes three guarantees about entries posted to it:
– The entry’s presence can be cryptographically verified using
a public operation.
– Once posted, the entry is available to all parties.
– Entries are assigned a unique monotonically increasing sequence number.
We now consider several existing techniques that we can leverage
to obtain such a bulletin board.
Certificate Transparency Logs. Certificate Transparency (CT) [1]
is a public audit log operated by a coalition of browser vendors and
certificate authorities. CT allows individual certificate authorities
to post newly-issued certificates to a public log. These entries are
then (1) signed by the log maintainer, and (2) added to a Merkle
hash tree. The root of the hash tree is also signed by (one or more)
log maintainers and published to the world.
A collection of users known as monitors can access the CT log
to view the contents of certificates. While the CT log is itself not
fundamentally tamper resistant – since the servers operating it can
remove portions and/or be disabled by remote network attacks –
any tampering is detectable due to the structure of the Merkle hash
tree. The location of the entry within the Merkle hash tree also
serves to act as a proxy for a monotonically increasing sequence
number.
Under the assumption that the existing CT logs are reliable and
trustworthy, we can use CT to build fairness systems by entombing
the required public data into a component of an X.509 certificate
signing request and requesting the certificate from a free certificate
authority such as LetsEncrypt [2]. Because LetsEncrypt submits all
certificates to a public log7
it is possible for any party to recover
these certificates and verify a cryptographic proof that the entries
have been published.
Public blockchains. Crypto-currencies such as Bitcoin or Etherium
rely on a publicly available data structure called a blockchain. Blockchains are an append-only ledger that is maintained by an ad-hoc
group of network peers. Blockchains come in two basic types. The
first type use computational proofs of work to determine which
peer should be allowed to add a new block of transactions to the
blockchain. Clients accept the longest chain that contains well
formed transactions; as a result the system is secure as long as a
supermajority of the computational power in the network is controlled by honest peers. This approach is tolerant of churn, and
thus we need not pick a set of honest parties in advance.
An alternative approach uses proof of stake [16]. In these systems
a quorum of peers is sampled from the network with probability
proportional to the fraction of monetary holdings controlled by
each peer. This quorum is responsible for producing the next block
and selecting the next quorum by the same mechanism. The peers
authenticate the resulting block by signing it using a secure digital
signature scheme. The security assumption here assumes that the
parties with the largest share of the cryptocurrency have a vested
interest in keeping it running. Proof of stake systems are in their
infancy both in terms of deployment and theory. However, they
provide an interesting middle ground between the costs of a pure
proof of work approach and the challenges with selecting a set of
trusted parties a priori to maintain the bulletin board.
8 IMPLEMENTATION
In this section we present an implementation of the protocol given
in Section 6, and show that the protocol is efficient. Our implementation consists of three major pieces: the bulletin board instantiated
using Bitcoin, the MPC protocol instantiated using the SPDZ framework [3, 29], and a “witness decryptor” instantiated using an Intel
SGX secure enclave. We describe each component in more detail
below.
7
See https://crt.sh/?id=15707024
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 728
progfair[∆t, P0, P1, vkBB,i] where i ∈ {0, 1} //for party Pi
On input (“keyex”):
Let a
$← Zp , and return д
a
On input (“init”, k, t, ρ, r):
let ki B k, ti B t, ρi B ρi
comi B Com(ki
;r), return comi
On input (“send”, д
b
):
let sk =

д
b
a
, cti ← AE.Encsk(ki
,ti
, ρi
, comi)
return cti
On input (“receive”, ct′
1−i
):
assert “init” and “send” have been called.
(k1−i
,t1−i
, ρ1−i
, com1−i) B AE.Decsk 
ct′
1−i

return com1−i
On input (“getParams”, v):
assert “init”, “send” and “receive” have been called
T B max{t0,t1}, y B f (ρ0 ⊕ ρ1), K B k0 ⊕ k1
if v ,⊥, return v, else return (T,y)
On input (“output”, ctMPC, t, ρ, σ, v):
if v ,⊥, return v
assert “getParams” has been called
assert t ∈ {T,T + 1, · · · ,T + ∆t }
assert f (ρ) = y
assert VerBB(t, ρ, σ)
return AE.DecK (ctMPC)
Protfair[F, ∆t, P0, P1, vkBB,i] where i ∈ {0, 1} //for party Pi
, Pj = P1−i
Input: xi
Protocol:
(1) let eidi ← Gatt.install(progfair[∆t, P0, P1, vkBB,i]).
(2) Initiate the key exchange procedure. Let (д
a
, σi) ← Gatt.resume(eidi
,“keyex”). Send (eidi
,д
a
, σi) to Pj
, await 
eidj
,д
b
, σj

from Pj
.
Check if Vermpk((eidj
, progfair[∆t, P0, P1, vkBB, j],д
b
), σj) = 1, else abort.
(3) ki
$← {0, 1}
λ
, ρi
$← {0, 1}
λ
, ri
$← {0, 1}
λ
, ti ← BB(getCurrentCounter).
(4) Initialize the enclave with the values obtained in the previous step. (comi
, _) B Gatt.resume(eidi
,“init”, ρi
, ki
,ti
,ri).
(5) Set up the exchange of information between enclaves. Let (cti
, _) ← Gatt.resume(eidi
,“send”). Send cti to Pj and wait for ctj
in
response. On receiving ctj
, send it to the enclave (com1−i
, _) ← Gatt.resume(eidi
,“receive”, ctj). At this point, both commitments are
available to the party.
(6) Get parameters for the MPC computation, (T,y) ← Gatt.resume(eidi
,“getParams”, ⊥)
(7) Send (xi
, ki
, com0, com1,ri) to F
′
and receive ctMPC. Abort if ⊥ is received. // ctMPC of the form AE.EncK (F (x0, x1))
(8) Send token share ρi to Pj and wait for token share ρj
.
– If ρj not received, or f (ρ0 ⊕ ρ1) , y, then wait to see if Pj posts the right value on the bulletin board, when the counter is between
T and T + ∆t. If the counter goes beyond T + ∆t, and no such value posted, abort. If the right value is posted at counter tBB,
(σBB, ρ) ← BB(getContent,tBB).
– ρj received and f (ρ0 ⊕ ρ1) = y. Wait for the counter value to get to T , and then post ρ0 ⊕ ρ1 on the bulletin board to get the
corresponding authentication tag, i.e. (σBB,tBB) ← BB(post, ρ0 ⊕ ρ1).
– Output Gatt.resume(eidi
,“output”,tBB, ρ0 ⊕ ρ1, σBB, ⊥).
Figure 2: Two party fair protocol Protfair in the (Gatt, F
′
)-hybrid model.
Initialization Decrypt
mean 1.180 ± 0.112 0.039 ± 0.001
mean 0.002 ± 0.000 0.037 ± 0.001
Table 1: Performance of SGX enclave setup and decryption (not MPC). Average and standard deviation of 500 runs.
Bitcoin as a bulletin board. For our prototype implementation
we use the Bitcoin network, which supports a limited scripting
system called Bitcoin Script. In Bitcoin each transaction contains
a script that is evaluated to ensure the transaction is authorized.
This scripting system supports an instruction named OP_RETURN,
which allows the sender of a transaction to embed up to 40 bytes of
arbitrary data into a transaction that is transmitted for inclusion in
the Bitcoin blockchain. Each block of transactions in the blockchain
contains a computational proof of work (PoW) that is computed
by the network. This proof is bound cryptographically to all of the
transactions within a block, as well as to the hash of the previous
block. At current network difficulty, computing a proof of work for
a single block requires an expected 2
64 invocations of the SHA2
hash function on the standard Bitcoin network. To verify publication on the bulletin board, our implementation requires a fragment
consisting of six consecutive blocks (where the transaction is located in the first block of the fragment). The cost of forging such a
fragment scales linearly in the number of blocks required.
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 729
We note that the use of a computational proof of work bulletin board provides somewhat different fairness properties than a
signature-based bulletin board, e.g., Certificate Transparency or a
proof-of-stake blockchain. Specifically, in this setting an attacker
with sufficient time or computational power can always “forge” a
satisfying chain of blocks, and use this private result as a witness
to enable decryption. Such an attack would be economically costly,
since the corresponding effort – if applied to crypto-currency mining – would be worth a substantial sum of money.8 However, we can
further restrict this attacker by employing a trusted clock within
the witness decryptor (e.g., Intel SGX) 9
. This optimization requires
the attacker to complete the forgery within a pre-defined time limit
that approximates the expected time for the full Bitcoin network.
Thus a successful attacker must possess most of the available hashpower of the Bitcoin network (which currently approximates the
electrical consumption of Turkmenistan).
For our experiments, we use the public Bitcoin testnet. The
Bitcoin testnet functions similarly to the main Bitcoin network, but
uses a zero-value currency and a low difficulty setting for the proof
of work. We selected testnet for our experiments mainly because
blocks are mined extremely rapidly and transactions require no
monetary expenditure for “transaction fees”. However our code can
use the production Bitcoin blockchain without any code changes.
MPC Protocol. Our protocol can be used to extend any MPC
scheme that supports efficient symmetric encryption. We note that
one could employ Intel SGX directly to perform a naive form of
MPC. However, our goal in this work is to demonstrate that our
approach works efficiently even when instantiated with a “cryptographic” MPC protocol.10
Thus for our implementation we use the SPDZ-2 framework
developed by the University of Bristol [3]. SPDZ-2 is designed to
tolerate dishonest majorities during computation. In SPDZ circuits
are designed in python and then compiled down into a circuit structure. The computation is done in two phases: an offline phase that
does not require the computation inputs and an online phase that
performs the actual computation. In order to optimize the running
time of the online phase, the pre-computation and compilation
phases are relatively more time consuming.
The maintainers of SPDZ-2 have implemented the AES-128 cipher in order to benchmark its efficiency. We repurpose this code
to build a simple authenticated encryption system for that uses 3
rounds of AES to encrypt and authenticate one 128-bit block of
data output from the computation. The encryption scheme takes
as input each party’s private computation input xi and keyshare
ki
. It computes as output a ciphertext C encrypted under msk. We
also use this AES-128 cipher to implement a commitment scheme.
8At present rates as of July 2017, this opportunity cost is approximately $28,000 per
block forged.
9Correctly accessing trusted time from within an enclave is part of the Intel SGX
specification, but it is not yet supported as it relies on platform services which are not
active. In our implementation, we include code to properly access trusted time, but do
not include it in our measurements because of the lack of support.
10Additionally, we remark that if SGX is used to implement the MPC protocol itself,
a security breach of the SGX system will result in the loss of all security properties
provided by the MPC. On the other hand, if we employ a cryptographic MPC protocol,
then a failure of Intel’s SGX risks only the fairness property. We view this as a benefit
of our approach.
The randomness of the commitment scheme is used as the key to
the cipher, with the commitment message as the plaintext.
We construct an MPC circuit for SPDZ-2 that takes in a private
input xi
, a keyshare ki
, a randomness share ri
, and commitment to
the master key com(msk;r). The first circuit computes the output
of the desired MPC functionality f (x1, . . . , xN ). Next it computes
r = ⊕1≤i ≤N ri and opens the commitment. It compares ⊕1≤i ≤N ki
with the msk from the commitment. If they do not match, sets
f (x1, . . . , xN ) = 0. Finally, the circuit computes the encryption of
f (x1, . . . , xN ) using msk and outputs the final ciphertext.
SGX as Witness Decryptor. Intel’s SGX is a set of extensions to
the x86 instruction set that allows for code to be executed in a
protected enclave. SGX programs are segmented into two pieces:
an untrusted application and a trusted enclave. The application
consists of standard software running on a standard operating
system and we assume that it may behave maliciously if the i
th
player is corrupted. Code within an enclave is verified upon startup
and isolated from inspection and tampering, even from an adversary
that controls the system’s operating system. The root of trust of
an SGX enclave is the Intel processor, which enforces the enclave’s
isolation. It is worth noting that the code run within an enclave is
not private; however secrets may be generated or retrieved after
the enclave is initialized. Note that the enclave has no direct access
to network communications, and must rely on the untrusted part
of the application.11
We adapt an existing SGX-bitcoin client called Obscuro [4] to
perform the role of the Witness Decryptor. This enclave is instantiated by each of the N parties participating in the protocol. A single
master instance of the enclave uses the sgx_read_rand function,
supplied by the SGX environment, to generate an AES master key
msk that will eventually encrypt the output of the MPC circuit.
Additionally, the master enclave generates a random 320-bit release token t that must be verifiably posted to a bulletin board
before the ciphertext can be decrypted. Next, the master applies a
secret sharing scheme to derive secret shares (k1, . . . , kN ) of msk
and (t1, . . . ,tN ) of t. Finally, the master computes a commitment
com(msk;r) and secret shares the randomness into r1 . . .rN . Now
for i = 1 to N it distributes the tuple (ki
,ti
, msk,t, com(msk;r),ri)
to the i
th enclave via a secure channel.12
Once all secrets have been distributed by the master enclave, the
channels are closed and each enclave outputs its key share ki to
the application. The users now invokes SPDZ to conduct the MPC
protocol, using as its private inputs xi
, ki
,ri
, and com(msk;r). If the
MPC protocol does not complete successfully, the application aborts
and a full restart is required. Otherwise, the application obtains a
ciphertext C output by the MPC protocol and provides this as input
to the enclave. The enclave attempts to decrypt the ciphertext under
msk and if and only if this decryption check completes successfully
(and the result is the proper format and length), it releasesti
, which
the application then transmits to all of the remaining parties.
To access the encrypted output of the MPC, at least one party
must re-compute the release token as t = (t1 ⊕ · · · ⊕ tN ) and post
11This enables the application to censor or tamper with communications between the
application and the network.
12SGX supports the creation of authenticated, secure channels using attestation and
DHKE.
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 730
this value to the Bitcoin network inside of a transaction. Each user’s
application monitors the Bitcoin network using RPC calls to a local
Bitcoin client bitcoincli which is running on the user’s machine.
This userland code then feeds the resulting blockchain fragment
(which consists of six consecutive blocks) back to the enclave, which
confirms that the release token matches its stored value t, and also
verifies the proofs of work on each block. While an adversarial user
can block this response, they are unable to falsify or tamper with it
due to the fact that such tampering would require an impractical
amount of computation. The application also supplies the enclave
with the output of the MPC C.
If all verifications succeed, the enclave decrypts the ciphertext C
using an authenticated encryption scheme under msk, and outputs
the resulting plaintext.
Optimizations. In a bid to optimize the implementation, there are
a few differences from the described protocol in section 6. They do
not make a difference to the security of the protocol, and are briefly
described here:
– Instead of each party generating its key and token shares,
a designated master enclave chooses them and distributes
them to the other enclaves.
– Instead of a commitment for each share of the key, there is
only a single “master commitment” of the key.
Sample computation and performance. For proof of concept,
we implemented a search program that takes as input a search value
x from one party and a list (y1, . . . ,yn), from the other party. These
circuits each calculate an integer output M and encrypt the result
as Enc(
Én
1
ki
; M). Since these are two-party functions we tested
with N = 2 and n = (100, 500, 1000).
Figure 3: Mean runtimes for a linear search on n items using
SPDZ taken over 50 iterations. Only the online portion of
the MPC is shown. In blue, we show the cost of running the
search without any provision for fairness. In red, the overhead from AES encryption needed for fairness.
Cost of fairness in the MPC. Our implementation demonstrates
that our approach can be used add fairness to MPC schemes efficiently using current technology. We recall that fairness in MPC is
Figure 4: Mean runtimes for our AES circuit varied over the
number of players participating. Only the online portion of
the MPC is shown. This circuit is dominated by 3 AES operations.
particularly important when the output of the MPC is extremely
valuable. While adding three rounds of AES to a simple MPC scheme
represents a high cost, it adds a only a negligible cost when considering more time consuming computations. In Figure 3 we show the
average runtime over 50 trials of a number of different circuits in
SPDZ-2. The cost of encryption is clearly dwarfed by large search
problems and set intersection.
While we ran the MPC experiments with N=2 players, SPDZ-2
allows computations with more players. In Figure 4 we consider only
the cost of running the encryption component of the MPC protocol
with higher numbers of players. Because each player contributes
a key share, the cost of running the protocol increases with each
player. While the runtime of the encryption operation does increase,
we note that it is still adds only a fraction of one second of online
computation time up to N = 6.
SGX Runtime. Intel SGX offers an extremely efficient method
of trusted program execution. We benchmark our SGX Enclave
over 500 trials of the two party protocol for some fixed parameters. We run our test on an Intel i5-6600K 3.5GHz processor with
16 GB of RAM running Ubuntu 14.04 and SGXSDK-1.7, running
both the master and minion on the same hardware. For the purpose of benchmarking, we hardcode into the master enclave the
master AES key and fix the release token to be the results of an
OP_RETURN instruction in a known block of the Bitcoin Testnet.
Additionally, we run the MPC protocol once to generate a valid
ciphertext. With the pre-fixed values, we can effectively check the
running time of the various parts of the enclave’s execution. All
key exchange and interaction with the bitcoincli is still run as in
the real protocol. In Table 1 we show the average running times of
the various segments of the enclave, both for the master instance
and minion instance. For the minion’s execution time, we pause the
timer while it is waiting for the minion to open a network connection. It is clear that the slowest piece of the program is the enclave
Session C5: Using Blockchains CCS’17, October 30-November 3, 2017, Dallas, TX, USA 731
initialization. This is because the enclave must provision all memory that it may require from the SGX driver during initialization.
Our implementation allocates more memory than it will use to be
conservative.