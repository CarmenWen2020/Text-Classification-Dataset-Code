Logic locking has been conceived as a promising proactive defense
strategy against intellectual property (IP) piracy, counterfeiting,
hardware Trojans, reverse engineering, and overbuilding attacks.
Yet, various attacks that use a working chip as an oracle have been
launched on logic locking to successfully retrieve its secret key,
undermining the defense of all existing locking techniques. In
this paper, we propose stripped-functionality logic locking (SFLL),
which strips some of the functionality of the design and hides it in
the form of a secret key(s), thereby rendering on-chip implementation functionally different from the original one. When loaded onto
an on-chip memory, the secret keys restore the original functionality of the design. rough security-aware synthesis that creates a
controllable mismatch between the reverse-engineered netlist and
original design, SFLL provides a quantiable and provable resilience
trade-o between all known and anticipated attacks. We demonstrate the application of SFLL to large designs (>100K gates) using
a computer-aided design (CAD) framework that ensures aaining
the desired security level at minimal implementation cost, 8%, 5%,
and 0.5% for area, power, and delay, respectively. In addition to
theoretical proofs and simulation conrmation of SFLL’s security,
we also report results from the silicon implementation of SFLL on
an ARM Cortex-M0 microprocessor in 65nm technology.
CCS CONCEPTS
•Security and privacy →Security in hardware; Hardware attacks and countermeasures; Hardware reverse engineering;
Hardware security implementation; •Hardware →Logic synthesis; Electronic design automation;
KEYWORDS
Design-for-trust, IP piracy, hardware Trojan, reverse engineering,
logic locking, Boolean satisability (SAT)
1 INTRODUCTION
1.1 IP piracy and reverse engineering
e increasing cost of IC manufacturing has forced many companies to go fabless over the years. With the outsourcing of IC
fabrication in a globalized/distributed design ow including multiple (potentially untrusted) entities, the semiconductor industry is
facing a number of challenging security threats. is fragility in
the face of poor state-of-the-art IP protection has resulted in hardware security vulnerabilities such as IP piracy, overbuilding, reverse
engineering, and hardware Trojans [9, 13, 19, 20, 37, 39, 45, 47–49].
To address these issues most eectively at the hardware level [32],
a number of hardware design-for-trust (DfTr) techniques such as
IC metering [1, 22, 23], watermarking [17, 18, 21, 31], IC camouaging [3, 4, 27, 28, 35, 46, 51, 56, 62], split manufacturing [14, 16], and
logic locking [34, 36, 38, 40, 41, 52, 53, 55, 61, 63] have been proposed. Logic locking, in particular, has received signicant interest
from the research community, as it can protect against a potential
aacker located anywhere in the IC supply chain, whereas other
DfTr techniques such as camouaging or split manufacturing can
protect only against a limited set of malicious entities as shown
in Table 1. Mentor Graphics, a major CAD tool provider, has announced the launch of TrustChain, a framework to support logic
locking and camouaging [26, 42].
1.2 Logic locking: defenses and attacks
Logic locking inserts additional logic into a circuit, locking the
original design with a secret key. In addition to the original inputs, a locked circuit has key inputs that are driven by an on-chip
tamper-proof memory [15, 50], as illustrated in Fig. 1. e additional logic may consist of XOR gates [34, 36, 38] or look-up tables
(LUTs) [5]. Fig. 2 presents the IC design ow incorporating logic
locking. e locked netlist passes through the untrusted design
phases. Without the secret key (i) the design details cannot be
recovered (for reverse-engineering), and (ii) the IC is not functional,
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1601
Logic
synthesis
Logic
locking Fabrication Original
netlist
Physical
synthesis
Locked
netlist Layout Activation Functional
IC
System
specs.
Test/
packaging
Locked
IC
Figure 2: Locking and activation of an IC in IC design ow. e red regions denote untrusted entities; the green regions
represent trusted entities.
Table 1: Protection oered by DfTr techniques against untrusted entities in the IC supply chain.
Techniques Foundry SoC Integrator Test User
IC metering [1, 22, 23] ✗ ✓ ✓ ✓
Watermarking [17, 18, 21, 31] ✗ ✗ ✗ ✓
IC camouaging [3, 4, 27, 28, 35, 46, 51] ✗ ✓ ✓ ✓
Split manufacturing [14, 16] ✓ ✗ ✗ ✗
Logic locking [34, 36, 38, 52, 55] ✓ ✓ ✓ ✓
i.e., it produces incorrect outputs (for over-production). A locked
IC needs to be activated by loading the secret key onto the chip’s
memory.
Traditional logic locking techniques choose key gate locations based on various gate selection algorithms, such as random (RLL) [38], fault analysis-based (FLL) [5, 36], and strong interference-based logic locking (SLL) [34, 59]. Over the years,
many key-recovery attacks have been mounted that exploit the
vulnerabilities of logic locking techniques [33, 34, 44, 54, 60]. A
summary of these attacks is presented in Table 2.
A powerful aack that broke all the logic locking techniques
existing then is Boolean satisability (SAT)-based key-pruning aack,
referred to as SAT aack. e aack is based on the notion of incorrect key elimination using distinguishing input paerns (DIPs) [44].
DIPs are computed using a miter circuit constructed using two
copies of the locked netlist; the two circuits share the primary
inputs but have different key inputs. A DIP is found when the
two copies of the locked netlist dier in their outputs. A functional IC with the secret key loaded in its memory is used as an
oracle to identify the incorrect keys in an iterative fashion. e
computational complexity of the aack is expressed in terms of
the number of DIPs generated by the SAT attack [44]. e latest
research works on logic locking have focused on defending against
the SAT attack [52, 55, 57].
1.3 SAT attack resilient logic locking
Two SAT attack resilient logic locking techniques—SARLock [55]
and Anti-SAT [52] (see Fig. 3)—have been recently proposed. ey
both use one-point functions to obtain resilience against SAT attacks. SARLock corrupts/inverts the output of the circuit for all the
incorrect keys at exactly one input pattern that is different for each
incorrect key. e correct key values are hardcoded in logic gates
to mask the output inversion for the correct key [55]. Anti-SAT
employs two complementary logic blocks that converge at an AND
gate. e output of the AND gate is always 0 only for the correct
Table 2: Attack resiliency of logic locking techniques
against the existing attacks. ✗ denotes susceptibility to the
attack and ✓ denotes resilience.
Aack RLL FLL SLL AntiSAT SARLock TTLock Proposed
[38] [5, 36] [34] [52] [55] [61] SFLL
Sensitization [34] ✗ ✗ ✓ ✓ ✓ ✓ ✓
SAT [44] ✗ ✗ ✗ ✓ ✓ ✓ ✓
AppSAT [40] ✗ ✗ ✗ ✗ ✗ ✗ ✓
Removal/SPS [57] ✓ ✓ ✓ ✗ ✗ ✓ ✓
IN Original circuit OUT
G(X,Kl1)
G(X,Kl2)
X
Kl1
Kl2
Original
circuit
?= Mask
OUT
Flip
IN
K
Flip
(a) (b)
Tamper-proof
memory
Tamper-proof
memory
Figure 3: (a) SARLock [55]. (b) Anti-SAT [52]. In both techniques, an incorrect key may assert the flip signal, producing incorrect outputs. Source: [61].
key; otherwise, it may be 1. Its output corrupts an internal node
in the original design for an incorrect key, to produce incorrect
outputs.
SARLock can be intertwined with one of the gate selectionbased logic locking techniques, such as RLL, FLL or SLL, providing
multiple layers of defense [55]. A variant of SAT attack, referred to
as AppSAT [40], was recently proposed to show that a multi-layered
defense comprising a point function and a SAT attack vulnerable
logic locking technique can be reduced to a single-layer defense
comprising the point function alone (e.g., from SARLock+FLL to
SARLock). e Double-DIP attack achieves the same objective
using more powerful 2-DIPs, i.e., DIPs that can eliminate at least
two incorrect keys in a single iteration [41]. e work in [40, 41]
elucidates that simple integration of multiple techniques together
fails to combine the resilience oered by individual techniques.
Limitations of existing work: Protection unit that can be isolated and removed. Despite their SAT attack resilience, both
SARLock [55] and Anti-SAT [52] exhibit security vulnerabilities,
as they leave the original circuit implementation, the IP-to-beprotected, as is. SARLock is vulnerable to removal aack: Given
a protected/locked netlist, an aacker can identify the comparator/mask blocks and the ip signal that directly feeds the output
by tracing the transitive-fanout of key-inputs, and remove these
blocks, retrieving the original circuit (proprietary IP). Anti-SAT
is vulnerable to signal probability skew (SPS) aack [57]: Given a
protected netlist, an aacker can identify the ip signal: it is at
the output of the gate whose inputs exhibit the maximum bias
towards opposite values. e aacker can then retrieve the original design by re-synthesizing the locked netlist with a constraint
value 0 (1) on the ip signal. Even upon additional obfuscation
using additional XOR/XNOR and multiplexer key gates [52], the
Anti-SAT block can be isolated using the AppSAT guided removal
(AGR) aack [58]. In addition, both SARLock and Anti-SAT are
also vulnerable to the Bypass aack [53]. e Bypass aack nds
a DIP that causes an incorrect output for a wrong key and bypass
circuitry is added around the Anti-SAT/SARLock block to x the
output for this DIP. is x recovers the original design as for both
SARLock and Anti-SAT the incorrect key-driven design fails for
only one input paern.
SARLock is re-architected into TTLock in [61] to gain resilience
against removal attacks. TTLock makes changes to the original
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1602
design to corrupt the output in the absence of the secret key. As
SARLock is based on a one-point function, its re-architected version
TTLock ends up protecting one input paern, that is, the modied
netlist and the original netlist dier in their outputs for one input
paern only. e work in [61] describes this SAT and removal
aack resilient architecture but provides neither a CAD framework
to eect the design changes nor a formal analysis proving resilience
against various attacks. Furthermore, protection of a single input
paern leads to a rigid scheme where the designer lacks the control
to hide an arbitrary amount of IP-critical logic in arbitrary parts
of his/her design. Protection of a single input paern, and thus,
low (and uncontrollable) corruptibility also leads to the recovery of
an approximate netlist through attacks, such as AppSAT [40] and
Double-DIP [41], which SARLock is vulnerable to as well.
1.4 Motivation, proposed approach, and
challenges
Motivation. Our ultimate goal is to develop a logic locking technique that can withstand all known and anticipated attacks. Resilience to oracle-guided attacks, such as SAT aack, should be
delivered while at the same time hardware implementation of the
design should not reveal all the details of the design IP to reverseengineers (i.e., removal attacks). A logic locking framework should
enable the designer to hide the security-critical parts of the design
IP, and thereby, to customize logic locking to the security needs of
the application.
While hiding any part of the design IP from its hardware implementation may be sucient to render general applications resilient
to reverse engineers (removal attacks), there are applications where
a designer may want to specify the parts to hide. Examples include processors with to-be-protected address spaces, for which
access is granted only to restricted entities [8]; network-on-chip
(NoC) routers where certain IP address ranges may carry particular
semantics [12]; intrusion detection systems that rely on paern
matching [24]; and digital signal processing applications, such as
comb lters [10], which accentuate/aenuate frequencies at regular
intervals.
Approach. Building on the architecture abstracted in [61], the
proposed technique strips part of the design functionality from
its hardware implementation. e design implemented in hardware is therefore no longer the same as the original design, as
the former will be missing the stripped functionality. We refer to
the proposed technique that can arbitrarily specify this stripped
functionality as Stripped-Functionality Logic Locking (SFLL). e
hardware implementation can be conceived to have an intentionally
and controllable built-in error. is error is canceled by a restore
unit only upon the application of the secret key of logic locking.
e stripped functionality can be captured eciently in terms
of input cubes1
for which the hardware-implemented design and
the original one produce different outputs. We refer to these input
cubes as protected cubes. ey can be stored in bits rather than
hardcoded in logic gates. SARLock [55] and Anti-SAT [52] protect
zero cubes, as they implement the design IP as is in hardware.
1
Input cubes refer to partially-specied input paerns; some input bits are set to
logic-0’s or logic-1’s, while other input bits are don‘t cares (x’s). An n-bit input cube
with k specied (care) bits contains 2
n−k
input paerns.
Protected cubes can also be conceived as conditions to manifest the
built-in error; a reverse-engineer applying the removal aack will
obtain a netlist with this error with respect to the original design.
For general applications that require hiding any part of the functionality, it may be sucient to protect an arbitrary set of cubes. For
applications that are specic about the part of the functionality to
hide, the proposed SFLL framework should enable the designer to
strip functionality based on IP-critical cubes that he/she can specify
and provide as input to the framework.
Challenges. e proposed approach necessitates that we discover and explore the connection between resilience to oracleguided attacks and removal attacks. is translates to another
challenge–quantifying the resilience of logic locking to attacks in
terms of properties (e.g., the number and size) of cubes protected by
them. Only then, we can implement a logic locking framework that
can enable the designer to make an informed decision on how to
trade resilience to one aack for resilience to another, and identify
the sweet spot to protect against all attacks.
1.5 Contributions
• We discover, quantify, and explore the trade-o between resilience of logic locking to different attacks.
• We develop a provably and quantiably secure and scalable logic
locking technique SFLL that thwarts all known and anticipated
attacks. We present two versions of SFLL.
(1) e rst version SFLL-HDh
, a generalized version of TTLock [61], is suitable for general application where stripping
an arbitrary part of the functionality is sucient for protection. is implementation is simple and scalable but is
capable of protecting a restricted set of input cubes, all dictated by one secret key. SFLL-HDh protects
k
h

input cubes
that are of Hamming Distance (HD) h from the k-bit secret
key. We provide a security analysis and show that k and h
dictate the trade-o between oracle-guided aack resilience
and removal aack resilience.
(2) e second version SFLL-exc×k
allows the user to specify c
IP-critical input cubes to be protected, each with k specied
bits.
– We quantify the security level and trade-o in terms
of the number and the size of these cubes.
– We develop a two-stage optimization framework that i)
compresses the input cubes, and ii) performs securityaware logic synthesis to strip functionality based on
compressed cubes while lowering the cost of implementation and adhering to security requirements.
• is is a complete approach from theory to practice. We develop
security denitions and metrics; develop a CAD framework for
SFLL; and validate SFLL’s security, cost-eectiveness, and scalability through both computer simulations on large-sized benchmark circuits (one with >100K gates) and silicon implementation
of ARM Cortex-M0 microprocessor in 65nm LPe technology. We
fabricate both the baseline and the SFLL-locked microprocessors to
perform an accurate comparative analysis.
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX, USA 160 
2 PRELIMINARIES
Before delving into further details, we rst dene the terminologies
that are used in the remainder of the paper.
Notation. We dene a set as S and its elements are denoted as
s ∈ S. We write s
$←− S to denote s has been sampled uniformly
randomly from the set S. We use cktlock , cktactv and cktr ec to
denote a logic-locked, an activated, and a reconstructed circuit,
respectively. For a circuit ckt the set of all possible inputs and
outputs are denoted as I andO respectively. We write AS
to denote
a probabilistic polynomial time (PPT) adversary A following an
aack strategy S.
Denition 2.1. A combinational circuit ckt is a netlist that implements a Boolean function F : I → O, where I = {0, 1}
n
and
O = {0, 1}
m with n inputs and m outputs. A logic locking technique L can be viewed as a triplet of algorithms, (Gen, Lock,
Activate), where:
(1) Gen is a randomized key generation algorithm, z
$←−
Gen(1
k
), where k denotes the key-size,
(2) Lock is the algorithm to lock a circuit’s functionality,
cktlock ← Lockz (ckt), and
(3) Activate is a deterministic algorithm that activates the
locked circuit, cktactv ← Activatez (cktlock ) such that
∀i ∈ I,cktactv (i) = F (i).
reat model. Consistent with the previous works, here we assume the aacker has access to an oracle, denoted, ckt(·), which
is a copy of a working chip with the secret key loaded onto its
memory. e aacker queries the oracle with a set of input patterns and observes the corresponding outputs. Apart from this, the
aacker also has the reverse-engineered netlist cktlock , which is
locked using a logic locking technique L. In this work, we assume
the aacker also knows the corresponding elements between the
original and the locked netlist; that is, he can identify the location
of the protection unit. e aack success for an adversary AS
implies recovering a circuit such that:
∀i ∈ I,cktr ec (i) = F (i), AS
: cktlock → cktr ec (1)
SAT attack resilience. SAT aack, a representative and eective
oracle-guided aack that iteratively prunes the key space, queries
the oracle cktlock (·) with an input paern d, called a distinguishing
input paern, to eliminate a set of incorrect keys in each iteration.
e aack terminates aer querying the oracle with a set of DIPs,
and outpuing a single key z
0
. e aacker ASAT reconstructs
a circuit cktr ec where cktr ec ← Activatez
0(cktlock ) such that Eq.
(1) is satised.
Denition 2.2. A logic locking technique L is called λ-secure
against a PPT adversary ASAT, making a polynomial number of
queries q(λ) to the oracle, if he/she cannot reconstruct cktr ec with
probability greater than q(λ)
2
λ
.
A logic locking technique resilient to the SAT aack is also
expected to thwart other variant key-space pruning attacks.
Sensitization attack resilience. Sensitization aack, which is
another oracle-guided aack, determines individual key bits by
generating and applying paerns that sensitize them to the outputs. In [34], two key bits are considered pairwise-secure i the
sensitization of one key bit cannot be done without controlling the
other key bit and vice versa. e same paper presents SLL that
maximizes key bits that are all pairwise-secure. For example, key
bits converging at a dominating gate are all pairwise-secure, if there
is no input assignment to block any one of them before they reach
the dominating gate.
Denition 2.3. A logic locking technique L is λ-secure against a
sensitization aack i λ key bits are all pairwise secure.
Removal attack resilience. Removal aack operates on a locked
netlist and tries to isolate and remove the protection logic. e
aack is a transformationT : cktlock → cktr ec | ∀i ∈ I,cktr ec (i) =
F (i), irrespective of the key value. Note that for a removal aack
cktr ec (p) , F (p), ∀p ∈ P, where P denotes the set of protected
paerns.
Denition 2.4. A logic locking technique L is λ-resilient against
a removal aack, where λ denotes the cardinality of the set of
protected input paerns P.
3 SFLL-HD
We rst present SFLL-HDh
for general applications that will benet
from stripping an arbitrary part of the design functionality. We
also show that SFLL-HDh
is a logic locking platform that provides
controllable resilience against all known attacks. In SFLL-HDh
, all
the protected input cubes are of the same Hamming Distance h from
the secret key; though the set of protected cubes are thus restricted,
a large number of cubes can be protected through a simple, scalable,
and cost-eective hardware.
3.1 SFLL-HD0
We rst explain SFLL-HDh
for the special case of h = 0; there is
only one protected input cube, and it is the same as the secret key.
In other words, SFLL-HD0
is functionally the same as TTLock [61].
SFLL-HD0 modies a design to invert its output for one selected
(protected) input paern; this inversion is the manifestation of the
built-in error. e functionality stripping can be eected via logic
gate insertions/replacements; the security-aware synthesis module
in SFLL-ex in Section 4.2 can also be used to strip functionality
based on a set of protected input cubes. SFLL-HD0
inverts the
erroneous output only upon the application of the correct key
to the restore unit, thereby, cancelling out the built-in error and
recovering the correct output. Moreover, SFLL-HD0
introduces one
additional error into the design along with the inverted output for
each incorrect key. Here, the secret key consists of the protected
input cube selected by the designer.
SFLL-HD0 has the following properties:
• It protects exactly one input cube.
• Each input paern can eliminate one and only one incorrect key,
thereby ensuring the SAT aack requires number of DIPs that is
exponential in terms of the key-size.
• Removal attacks, when launched against SFLL-HD0
, only recover the (minimally) modied design that exhibits incorrect
(but approximate) functionality.
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1604
Functionality
stripped circuit IN
K
Yfs
restore
Y
Restore unit
Tamper-proof		
memory	
Yfs IN k0 k1 k2 k3 k4 k5 k6 k7
✔ 0 ✖ ✔ ✔ ✔ ✔ ✔ ✔ ✔
✔ 1 ✔ ✖ ✔ ✔ ✔ ✔ ✔ ✔
✔ 2 ✔ ✔ ✖ ✔ ✔ ✔ ✔ ✔
✔ 3 ✔ ✔ ✔ ✖ ✔ ✔ ✔ ✔
✔ 4 ✔ ✔ ✔ ✔ ✖ ✔ ✔ ✔
✔ 5 ✔ ✔ ✔ ✔ ✔ ✖ ✔ ✔
✖ 6 ✖ ✖ ✖ ✖ ✖ ✖ ✔ ✖
✔ 7 ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✖
?	
HD(IN,K)	=	0	
Figure 4: Proposed SFLL-HD0 architecture for n = k = 3. e
functionality-stripped circuit (FSC) is minimally different
from the original function: they produce a different response for one protected input pattern (IN = 6). e restore
unit cancels this error for the correct key k6 and introduces
a second error for all incorrect keys. Errors are denoted by
X’s. Note that although SFLL-HD0
is functionally the same
as TTLock, the two are different in hardware architecture;
TTLock uses a comparator whereas SFLL uses a Hamming
Distance checker. Source: [61].
G2
IN2
Y
IN1
IN0
G3
G4
G1
(a)
G2
IN2
Yfs
IN1
IN0
G3
G1'
G4
(b)
Figure 5: a) Original circuit, b) FSC. Gate G1 is replaced
with G1’ in the FSC, inverting the output Yfs for IN=6.
Source: [61].
3.1.1 Construction of SFLL-HD0
. e architecture of SFLL-HDh
consists of a restore unit and an XOR gate. e restore unit computes the Hamming distance between the key inputs and the primary inputs. In the special case of SFLL-HD0
, the Hamming distance between the primary inputs and the key is zero, implying
that the restore signal is asserted only when the key inputs and
the primary inputs match. Note that for h = 0, this restore unit
can be reduced to a simple k-bit comparator rendering SFLL-HD0
functionally equivalent to TTLock, as shown in Fig. 4.
We reuse the example circuit from [61] to illustrate the architecture of SFLL-HD0 depicted in Fig. 5a. e circuit is protected by a
three-bit key, n=k=3; the protected cube is an input paern, as n = k
in this example. e original circuit is shown in Fig. 5a whereas the
functionality-stripped circuit (FSC) is shown in Fig. 5b. e original
and the functionality-stripped circuits produce a different output
for only input paern 6. Yf s column in Fig. 4 shows the inversion
(error) for this protected input paern. is error is cancelled out
by applying the correct key k6 which asserts the restore signal for
input paern 6, and thus, recovering the desired output, as depicted
in the table in Fig. 4. e table also illustrates that each incorrect
key induces one extra error in the design, leading to two inversions
in each column of the table except the one for the correct key.
3.1.2 Security analysis of SFLL-HD0
. We prove the following
theorems which establish the security of SFLL-HD0
against all
known and anticipated attacks. We assume n inputs and k key bits,
where k ≤ n. SFLL-HD0 delivers the same security properties as
TTLock [61]. To establish the security properties of SFLL-HD0
, we
develop a formal approach which was missing in [61].
SAT attack resilience. SFLL-HD0
resilience against SAT aack
is achieved by ensuring that the aack encounters its worst-case
scenario. In each iteration, a DIP eliminates exactly one incorrect
key, necessitating a number of iterations that is exponential in
the key-size. In the example shown in Fig. 4, the aack requires
7=23
-1 iterations in the worst-case. However, if the aacker is
fortuitous he/she may hit the protected input cube and eliminate
all incorrect keys at once. In the same example, the protected
input paern IN=6 helps the aacker to eliminate all the incorrect
keys immediately. However, as an aacker does not have any
information about the protected cube, the probability of such a
fortuitous hit is exponentially small in the number of key bits.
Theorem 3.1. SFLL-HD0
is k-secure against SAT aack.
Proof. First, we classify all the input cubes into two sets, the
set of protected cubes P and set of unprotected cubes Pb. Now, as
SFLL-HD0 only contains one protected input cube, P is a singleton
set. us, |P | = 1 and |Pb| = 2
k − 1.
Now, an aacker can recover the secret key, and thus, the original
functionality of the design if she can nd a protected input cube in
P. However, for a PPT aacker making only a polynomial number
of queries q(k) to the oracle, the probability of nding this cube is
|P |
2
k
+
|P |
2
k − 1
· · ·
|P |
2
k − q(k)
(2)
=
1
2
k
+
1
2
k − 1
· · ·
1
2
k − q(k)
≈
q(k)
2
k
Note, without loss of generality, we consider the sampling as without replacement as the SAT aack does not repeat any DIP. So,
from Denition 2.2, SFLL-HD0
is k-secure against SAT aack.
Sensitization attack resilience.
Theorem 3.2. SFLL-HD0
is k-secure against a sensitization aack.
Proof. In SFLL-HD0
, all the k bits of the key converge within
the comparator inside the restore unit to produce the restore signal.
erefore, sensitizing any key bit through the restore signal to the
output requires controlling all the other key bits. All k bits are therefore pairwise-secure. SFLL-HD0
is k-secure against sensitization
aack.
Removal attack resilience. Since the restore signal is highly
skewed towards zero, it can be easily identied by a signal probability skew (SPS) aack. However, any removal aack would recover
only the FSC, without leaking any information about the original
design. As the FSC produces an erroneous response for the protected input cube, the design is resilient against removal aack.
Theorem 3.3. SFLL-HD0
is 2
n−k
-resilient against removal aack.
Proof. Suppose the aacker recovers a circuit cktr ec by identifying and removing the restoration logic. Now, cktr ec produces
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1605  
an incorrect output for the set of protected input cubes, denoted as
P. However, we know that each cube contains 2n−k
input paerns.
us, if Γ denotes the set of all input paerns contained in P,
cktr ec (i) , F (i), ∀i ∈ Γ
|Γ| = |P | × 2
n−k
(3)
= 1 × 2
n−k
= 2
n−k
So, from Denition 2.4, SFLL-HD0
is 2n−k
-resilient against a removal aack.
3.2 SFLL-HDh
In this section, we generalize for h; SFLL-HDh
can protect all input
cubes that are of Hamming distance of h from the secret key. e
number of protected input cubes is
k
h

.
3.2.1 Construction of SFLL-HDh
. With a HD of h, an input-size
of n, and key-size of k, SFLL-HDh
inverts the FSC output Yf s for

k
h

input cubes, which contains 2n−k
·

k
h

paerns. e restore
unit, which comprises of k XOR gates and an adder to compute
the Hamming distance, recties all these errors for the correct
key, while it introduces a different but possibly overlapping set of
errors for any incorrect key. Fig. 6 depicts the architecture of the
proposed SFLL-HDh
along with an example where n = k = 3 and
h = 1. As can be seen from the architecture, the implementation
overhead of the restore unit is independent of h, which is a hardcoded (non-secret) constant that feeds the comparator inside the
restore unit.
3.2.2 Security analysis of SFLL-HDh
. We assume n inputs and k
key bits, k ≤ n. Proofs of theorems are provided in Appendix B.1.
SAT attack resilience.
Theorem 3.4. SFLL-HDh
is (k − dlog2

k
h

e)-secure against SAT
aack.
Sensitization attack resilience.
Theorem 3.5. SFLL-HDh
is k-secure against sensitization aack.
Functionality
stripped circuit IN
?	
HD(IN,K)	=	h	 K
Yfs
restore
Y
Restore unit
Tamper-proof		
Memory	
Yfs IN k0 k1 k2 k3 k4 k5 k6 k7
✔ 0 ✖ ✖ ✖ ✔ ✖ ✔ ✔ ✔
✔ 1 ✔ ✔ ✔ ✖ ✔ ✖ ✔ ✔
✖ 2 ✔ ✖ ✖ ✔ ✖ ✖ ✔ ✖
✔ 3 ✔ ✖ ✖ ✔ ✔ ✔ ✔ ✖
✖ 4 ✔ ✖ ✖ ✖ ✖ ✔ ✔ ✖
✔ 5 ✔ ✖ ✔ ✔ ✖ ✔ ✔ ✖
✔ 6 ✔ ✔ ✖ ✔ ✖ ✔ ✔ ✖
✖ 7 ✖ ✖ ✖ ✔ ✖ ✔ ✔ ✖
Figure 6: SFLL-HDh architecture for n=k=3 and h=1. Yfs includes
k
h

errors, denoted by X’s. Restore unit recties all
errors for the correct key k6. For the incorrect keys, restore
unit introduces
k
h

additional errors (at
k
h

input patterns),
which may possibly coincide and cancel errors in Yfs.
Removal attack resilience.
Theorem 3.6. SFLL-HDh
is 2
n−k
·

k
h

-resilient against removal
aack.
As these theorems show, h can be adjusted to trade resilience
to one aack for resilience to another. Values of h closer to either
0 or k deliver higher resilience to SAT and other key-pruning attacks, whereas resilience to the removal aack can be maximized
by seing h=k/2.
4 SFLL-FLEX
In contrast to SFLL-HDh
, SFLL-exc×k
allows the user to specify,
and thus, protect the IP-critical input paerns; the restore unit
stores the protected input paerns in a compact form, i.e., in the
form ofc input cubes, each with k specied bits. In this context, the
input cubes can be conceived as the secret keys to be loaded onto
the chip for the restore unit to recover the stripped functionality.
We will use the terms “protected input cubes” and “secret keys”
interchangeably for SFLL-exc×k
. e SFLL-exc×k
framework
is shown in Fig. 7; in this section, we elaborate on the individual
processes in this framework.
In a design with multiple outputs, not every output needs protection; only the IP-critical part of the design has to be protected to
control the cost of logic locking, which is at the discretion of the
designer. SFLL-exc×k
enables the outputs to be selectively ipped
(and restored) for the protected input cubes; a ip vector associated
with each protected input cube holds information regarding which
outputs are to be ipped for the protected input cube.
Example. Fig. 8 presents an overview of SFLL-exc×k
. e FSC
diers from the original circuit for two protected input cubes x01x1
and x10x1, collectively representing 8 input paerns. e restore
unit stores the two input cubes and the corresponding ip vectors.
In this example, only three out of ve outputs are protected.
4.1 Architecture
e restore unit of SFLL-exc×k
consists of a tamper-proof [50]
look-up table (LUT) and XOR gates. e LUT stores c k-bit input
cubes along with the corresponding f -bit ip vectors (for protecting
f out of m outputs) that dictate the functionality stripped from
the circuit.2 When the input matches an entry in the LUT, the
associated ip vector is retrieved from the table and XORed with
the outputs to restore the original functionality.
Cost. e cost of SFLL-exc×k
is proportional to the size of
the LUT, in addition to f XOR gates inserted at the outputs of
the FSC. e cost of the LUT is denoted as c × (k + f ), where f
is a designer-dened parameter. Cost minimization requires the
minimization of c and k. Additionally, functionality stripping can
be used as an opportunity to reduce implementation cost as will be
discussed in Section 4.3. us, the net cost of SFLL-exc×k
is this
saving subtracted from the LUT cost.
2One extreme case of SFLL-exc×k
is to strip the entire functionality of the design;
such an approach would incur a prohibitive overhead, as the entire truth table, whose
size is exponential in the number of inputs, needs to be stored on-chip.
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX,          
Simulated
annealing
Security-aware logic synthesis
Logic cone
optimization
Cube
compression
Cube bit
selection
Initial
cubes
Security
level
Final
cubes
Cube compaction Locked
netlist
Flip
vectors
Figure 7: Proposed SFLL-exc×k
logic locking. e user-specied input cubes are compressed to reduce the on-chip storage
requirements. Security-aware logic synthesis is then used to strip functionality from the circuit based on compressed cubes.
Functionality-stripped
circuit
I0
I1
I2
I3
I4
O0
O1
O2
O3
O4
Input cube
011
101
Flip vector
011
101 3 3
Figure 8: SFLL-ex2×3
for a circuit with ve inputs and ve
outputs. k=3 in the example as only three bits of the protected input cubes are specied by the designer. f=3 as three
outputs are protected. e circuit is re-synthesized to strip
the functionality from the original design based on the input cubes; these cubes are used along with the ip vectors to
restore the original functionality.
4.2 Challenges
As already pointed out, the applicability of SFLL-ex depends on
addressing the following research problems:
• How can a minimal set of protected input cubes be produced
from those provided by the designer to reduce the storage cost
while ensuring the desired security level?
• Can the functionality strip be used as an opportunity to reduce
the implementation cost?
We address these problems in the following section.
4.3 Optimization framework for SFLL-exc×k
Given a desired security level s and a set of input cubes (or input
paerns) Cinit to be protected, both provided by the designer for a
netlist N, the proposed stripped-functionality logic locking should
be implemented at minimal cost: we should minimize Costs f + c ×
k, where Costs f is the implementation cost of the functionalitystripped netlist Ns f , and c × k is the implementation cost of the
LUT. is is an optimization problem that can be formulated as:
minimize Costs f + c × k such that k − loд2c ≥ s
where k − loд2c is the security level aained against SAT attacks,
as proved later in this section.
We break this optimization problem down to two smaller processes. In the rst process, we compress the input cubes (or input
paerns) to minimize the LUT cost = c ×k, producing the resulting
keys in the process, while honoring the security constraint. In the
second process, we re-synthesize the logic of the protected outputs
based on the keys obtained from the rst process with the goal of
minimizing Costs f . Such a sequential approach where the output
of the rst process is fed into the second process may fail to deliver
the overall optimum solution, which rather necessitates a holistic
and intertwined approach. In this work, however, we choose to
follow a computationally-tractable approach for simplicity at the
expense of sub-optimality.
4.3.1 Process 1: Cube compression. In this process, our objective
is to reduce the LUT cost c × k, the major component of overall
implementation cost, thus, reducing our optimization objective to:
minimize c × k such that k − loд2c ≥ s
ere are a couple of strategies that can be followed to solve this
optimization problem. In one strategy, we can create the keys that
will ip at least one output for every paern in every cube in Cinit .
e problem then is nding minimum cubes that collectively cover
each cube in Cinit ; this is the classical problem of minimum-cube
cover in 2-level logic optimization [30], and any synthesis tool can
be utilized to solve this problem.
In another strategy, we can create the keys that will ip at least
one output for at least one input paern in every cube in Cinit . In
this case, the problem is to nd minimum cubes that, this time,
collectively intersect each cube in Cinit . To solve this problem,
we provide a heuristic approach, as described in Algorithm 1. e
rst step of the algorithm is cube compression wherein compatible
cubes are merged to reduce c. To achieve the required security level
s = k − log2
c, we may not need to consider all the k bits in a cube,
reducing k. e second step of the algorithm is to eliminate (or
turn into x’s) the bits that are conicting among the cubes, while
adhering to security level s. is second step may further reduce c,
as certain cubes become compatible for merging.
Example. Consider c17 ISCAS benchmark circuit shown in
Fig. 9, a set of four 5-bit initial cubes, and security level s = 3, as
specied by the designer. e two initial cubes 0x100 and x1x00
can be merged into one cube 01100, reducing c to three. Next, we
can reduce k to four by eliminating the rightmost bit in all the cubes.
Elimination of bits in conict also leads to further reduction in c to
two, as more cubes can now be merged; the achieved security level
s = 3. us, compared to initial 4 × 5 = 20 bits, only 2 × 4 = 8 bits
need to be stored on-chip.
4.3.2 Process 2: Security-aware synthesis. If the designer explicitly species which output is ipped for each cube, then the ip
vectors are already determined. Such a rigid scheme does not oer
any opportunity for optimization; the selected output functions
are ipped for the corresponding input paerns included in the
protected input cubes. Any logic synthesis tool can be used for this
purpose. On the other hand, if the designer chooses not to specify
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1607
G6 O2
Initial cubes Final cubes
0x100
x1x00
01101
0111x
I1
I2
I3
I4
I5
O1 G1
G2
G5
G4
G6 O2
I1
I2
I3
I4
I5
O1
G1
G2
G5
G4
G6 O2
Cube
0110
0111
FlipVector
00
10
4
G7
01100
01101
0111x
0110
0111
Compressed cubes
(b) (c) (d)
I1
I2
I3
I4
I5
O1 G1
G2
G3
G5
G4
(a)
Figure 9: Application of SFLL-ex to c17 ISCAS circuit. a) Original circuit. b) Cube compression. c) FSC. d) Locked circuit.
Algorithm 1: Cube compression algorithm
Input :Initial cubes Cinit , Security level s
Output : Final cubes C
1 C ← merge compatible cubes(Cinit )
2 snew ← k − log2
c
3 while snew ≥ s do
4 C ← eliminate conicting bit(C)
5 C ← merge compatible cubes(C)
6 snew ← update security level(c, k)
7 end
Algorithm 2: Security-aware synthesis algorithm
Input :Original netlist N, Final cubes C
Output : Functionality-stripped netlist Ns f , Flip vector V
1 V ← init ip vector(N)
2 Ns f ←rand soln(N,C)
3 costs f ← cost(Ns f )
4 T = 1.0,Tmin = 0.00001, α = 0.9
5 while T > Tmin do
6 for i = 1 to 200 do
7 Nnew ←neighbor(Ns f ,C)
8 costnew ← cost(Nnew )
9 if Rand(0, 1) < exp(
costnew −costs f
T
) then
10 Ns f ← Nnew
11 costs f ← costnew
12 V ← update ip vector(Ns f ,po)
13 end
14 end
15 T = T × α
16 end
the ip vectors, a security-aware synthesis process can leverage
this exibility to minimize implementation cost of the functionalitystripped design Ns f without compromising security. e process
also produces the ip vectors, denoted by V , as described in Algorithm 2.
Algorithm 2 starts with the original netlist N and a set of cubes
C. Initially, a random solution Ns f with the associated cost costs f
is generated by initializing the ip vector V with a random value.
From this random solution, simulated annealing starts optimization
by selecting a neighboring solution at each iteration. A new solution
Nnew is generated by changing a random bit in the ip vector V ,
which leads to inclusion/exclusion of the corresponding cube for
a particular output. e solution Nnew is accepted if it yields cost
savings, i.e. costnew < costs f . An inferior solution may be accepted
with a probability of exp(
costopt −costnew
T
). is is a key feature of
simulated annealing for exploring a larger search space without
geing stuck at a local optimum.
Example. Let us consider the application of security-aware
synthesis to the c17 circuit in Fig. 9. Algorithm 2 operates on the
original c17 netlist and the nal cubes produced by Algorithm 1,
and produces the FSC; AND gate G3 is removed from the logic cone
O1. e ip vector 10 will restore the stripped functionality for
logic cone O1 by ipping its output for the cube 0110x.
4.4 Security analysis for SFLL-exc×k
In this section, we discuss the resilience of SFLL-exc×k
against the
state-of-the-art attacks. e proofs of theorems below are provided
in Appendix B.2.
SAT attack resilience. An aacker, following a SAT-based or a
random guess aack model, must identify all input paerns of the
protected input cubes in SFLL-exc×k
to be able to recover the
correct functionality of the original design from the on-chip implementation; in contrast to SFLL-HDh
, the protected input cubes can
be arbitrary in SFLL-exc×k
, and one cube does not infer another.
is requires the retrieval of the content of the entire LUT that
represents the stripped functionality. Nevertheless, we assess the
security strength of SFLL conservatively; aack success is dened
by the aacker’s ability to retrieve any input paern that belongs to
one of the protected input cubes. e following theorem establishes
the resilience of SFLL-exc×k
against SAT aack.
Theorem 4.1. SFLL-exc×k
is (k − dlog2
ce)-secure against SAT
aack.
Sensitization attack resilience.
Theorem 4.2. SFLL-exc×k
is k-secure against sensitization attack.
Removal attack resilience.
Theorem 4.3. SFLL-exc×k
is c · 2
n−k
-resilient against removal
aack.
As these theorems show, the number and the size of the protected
input cubes, denoted by c and k respectively, dictate the trade-o
between resilience to oracle-guided and removal attacks.
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1608
2
9
2
11
2
13
2
15
# DIPs
h=0
2
8
2
10
2
12
2
14 h=1
2
4
2
6
2
8
2
10
2
12
2
14 h=2
11 12 13 14
Key size (k)
0.0
0.4
0.8
1.2
1.6
Exec. time (s)
1e4
11 12 13 14
Key size (k)
0.0
0.4
0.8
1.2
1.6 1e4
11 12 13 14
Key size (k)
0.0
0.4
0.8
1.2
1.6 1e4
s35932 s38417 s38584 b14 b15 b17 b18 b20 b21 b22
Figure 10: Results for SFLL-HDh
for h={0,1,2}, and k={11,12,13,14}; the number of DIPs required for the SAT attack [44], and
the corresponding execution time in seconds.
5 SIMULATION RESULTS
5.1 Experimental setup
In this section, we present the experimental results to validate the
security expectations and demonstrate the eectiveness of the proposed SFLL techniques. e experiments are executed on a 28-core
Intel Xeon processors running at 2GHz with 128 GB of RAM. We
lock the combinational part of the sequential benchmark circuits
from the ISCAS’89 [7] and ITC’99 [11] suites in our experiments.
Table 3 shows the statistics for the circuits; the largest circuit b18
has >100K gates. e area, power, and delay (APD) overhead for
SFLL-HD and SFLL-ex versions are obtained using Synopsys Design Compiler along with Global Foundries 65nm LPe library. We
present the results of security analysis wherein different variants
of the SAT aack are launched on various versions of SFLL-HD
and SFLL-ex. In particular, we launch the SAT aack [44] and the
AppSAT [40] against the proposed techniques. Each aack experiment is repeated ten times to improve the statistical signicance;
average results of the ten runs are reported.
5.2 SFLL-HDh
5.2.1 Security analysis. e resilience of SFLL-HDh
is dictated
by the key-size k and h, which together dictate the number of
protected input cubes
k
h

. In SFLL-HD experiments, we protect
the largest logic cone in each circuit. e number of DIPs required for the SAT aack to succeed on SFLL-HDh
circuits, and
Table 3: Statistics for the largest ITC’99 [11] and ISCAS’89 [7] benchmarks. LLC denotes the largest logic cone.
Benchmark Functionality Inputs Outputs Gate count LLC inputs
Small
s35932 N/A 1763 2048 12,204 195
s38417 N/A 1664 1742 8709 99
s38584 N/A 1464 1731 11448 147
b14 Viper processor 277 299 9,767 218
b15 80386 processor 485 519 8,367 306
Large
b17 3× b15 1452 1512 30,777 308
b18 2× b14 + 2× b17 3357 3343 111,241 271
b20 2× modied b14 522 512 19,682 282
b21 2× b14 522 512 20,027 282
b22 3× modied b14 767 757 29,162 283
the corresponding execution time are presented in Fig. 10 for
k={11, 12, 13, 14} and h={0, 1, 2}. Although the actual security levels required in a practical seing are much larger (e.g., 64-bit or
128-bit), we cannot empirically assess the security of SFLL for such
high values due to computational limitations. For the sake of understanding the trends, we experiment with these small key-sizes.
Impact of key size k. Fig. 10 demonstrates that the number of
DIPs required for the SAT aack to succeed grows exponentially
in k, conrming our theoretical expectation. For instance, the
expected number of DIPs required to break SFLL-HD0
is 2k−1
. e
same trend holds for SFLL-HD1
and SFLL-HD2
as well, except for
a few cases, where an aacker may be fortuitous and the aack
terminates earlier, reducing the average number of DIPs.
e execution time of the SAT aack is proportional to the number of DIPs, although there is a slight variation of 3× to 4× across
the benchmark circuits; the execution time grows exponentially in
k.
Impact of Hamming distance h. SFLL-HDh
is(k− dlog2

k
h

e)-
secure. us, an increase in h leads to a signicant change in the
security level and the expected number of DIPs required for the
SAT aack. For example, the average number of DIPs for the circuit
s38584 for h={0, 1, 2} and k=14 is 15K, 10K, and 5K, respectively, as
shown in Fig. 10.
5.2.2 APD overhead. e APD overhead is obtained using Synopsys DC Compiler using Global Foundries 65nm LPe library [43]
and is shown in Fig. 11 for k=128. e overhead for SFLL-HD can
be aributed to two sources: the restore unit and the functionalitystripped circuit. SFLL-HDh
restore unit comprises a single k-bit
comparator along with an adder unit, where the overhead is anticipated to increase linearly in k but to remain constant for h, which
is a hard-coded constant (as it need not be a secret). e 128-bit
comparator and adder blocks incur a signicant area, power, and
delay overhead on small-sized circuits; for the smallest ve benchmarks (˜10K gates), area, power, and delay overhead are 28%, 50%,
-2%, respectively. For larger-sized circuits, however, the overhead
of the restore unit is amortized; for the largest ve benchmarks, the
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX, USA 16  
0
50
100
Area (%)
0
50
100
Power (%)
s35932
s38417
s38584
b14
b15
b17
b18
b20
b21
b22
20
10
0
10
Delay (%)
h=0
h=4
h=8
h=12
Figure 11: Area, power, and delay overhead for SFLL-HDh
for k=128 and h={0,4,8,12}. e APD overhead for the larger
ve benchmarks are 10%, 6%, and -5%, respectively; for the
smaller ve benchmarks, they are 28%, 50%, and -2%, respectively.
s35932
s38417
s38584
b14
b15
b17
b18
b20
b21
b22
0.0
0.5
1.0
Exec.time (s)
1e3
h=0
h=4
h=8
h=12
Figure 12: Execution time of SFLL-HDh
for k=128.
average area, power and delay overhead are only 10%, 6%, and -5%,
respectively, boding well for even larger-sized industrial circuits.
5.2.3 Scalability. SFLL-HDh
algorithm operates on the RT-level
circuit. Fig. 12 shows that the execution time of the SFLL-HD
algorithm is only a few minutes, irrespective of h. For b18 circuit
with more than 100K gates, the execution time is only about 15
minutes, conrming the scalability of the proposed SFLL-HDh
.
5.3 SFLL-exc×k
5.3.1 Security analysis. To validate the security of SFLL-ex,
we launch the SAT aack [44] and AppSAT [40] aack on circuits
locked using SFLL-ex for c = {1, 2, 3} and k = {11, 12, 13, 14}.
e results shown in Fig. 13 demonstrate that the number of DIPs
for SFLL-ex is exponential in k. With increasing c, we observe
a logarithmic decrease in the number of DIPs, in line with our
theoretical expectation. e trends for the execution time is similar
to that for DIPs, except that the increase in execution time is more
prominent. While the DIPs double for each increment in k, the
execution time may increase by 3-5×. e AppSAT [40] aack on
SFLL-ex again fails in 100% of the cases.
5.3.2 Cube compression. e savings for the cube compression
technique are presented in Table 4. In our experiments, we generate test cubes for randomly selected cinit stuck-at faults by using
Atalanta test paern generation tool [25], and treat these test cubes
Table 4: Cube compression ratio R for SFLL-exc×k
.
Bench s=64 s=128
c = 32 c = 64 c = 32 c = 64
s35932 867.9 1735.9 437.3 874.7
s38417 403.4 806.8 136.5 409.6
s38584 354.9 1441.5 180.2 360.4
b14 26.5 52.9 6.7 14.9
b15 238.8 115.8 120.3 79.6
b17 352.0 469.3 59.1 70.4
b18 813.8 3305.4 832.7 234.3
b20 126.5 61.4 31.9 42.5
b21 49.9 99.7 31.9 36.4
b22 91.6 183.2 62.9 74.9
Average 332.5 827.2 190.0 219.8
as the designer-provided input cubes Cinit . e compression ratio
R is computed as the ratio of the initial number of key bits to be
stored cinit × kinit to that of compressed key bits cf inal × kf inal ;
kinit equals the number of inputs n. e results are presented for
two different security levels s = 64 and 128 and for two different
numbers of initial cubes c = 32 and 64. On average, a compression
level of 400× is achieved, while still maintaining the desired security level. ese compression levels directly translate to a reduction
in implementation cost for the restore unit. It can be noted that a
lower security level (s = 64) enables a higher compression level.
5.3.3 Security-aware synthesis. We report the area, power, and
delay (APD) overhead separately for 1) the “optimal-cost” FSC (without the restore unit) and 2) the overall circuit (with the restore unit
comprising the LUT and the surrounding combinational logic). e
APD overhead is shown in Fig. 14a and Fig. 14b for target security
levels s = 64 bits and 128, respectively. e simulated-annealing
based optimization is accomplished using area as the primary cost
metric. e ABC [6] synthesis tool is used to convert a design to
And-Invert-Graph and the gate count is taken as the cost metric. It
can be inferred that security-aware synthesis incurs only a minimal
overall overhead of 5%, 4% and 2% for area, power, and delay for a
security level s = 64, and 11%, 8% and -1% for a security level s =
128. In these gures, negative values denote a reduction in APD
when compared to the original circuit due to the functionality-strip
operation; e.g., this can be seen for the circuit s35932 in its area
footprint. However, due to the overhead of the restore unit comprising mostly sequential elements, the overall overhead is positive. In
majority of the cases, the delay overhead is almost negligible (˜0%).
is is due to the fact that adding the restore unit does not actually
aect the delay of the critical path, thus, incurring no signicant
performance penalty.
e combined execution time for cube compression and securityaware synthesis is presented in Fig. 15. e execution time for cube
compression is in the order of a few seconds. e execution time for
security-aware synthesis is directly determined by the simulated
annealing parameters (the temperature T and the gradient α) and
the size (number of gates) of a circuit. As can be seen from the gure,
even for large circuits such as b18 with >100K gates, the synthesis
is completed in about two hours. Our empirical results indicate
that the execution time remains independent of the security level s
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1610
2
7
2
9
2
11
2
13
2
15
# DIPs
c=1
2
7
2
9
2
11
2
13
2
15 c=2
2
6
2
8
2
10
2
12
2
14 c=3
11 12 13 14 k
0.0
0.4
0.8
1.2
Exec. time (s)
1e3
11 12 13 14 k
0.0
0.4
0.8
1.2
1e3
11 12 13 14 k
0.0
0.4
0.8
1.2
1.6 1e3
s35932 s38417 s38584 b14 b15 b17 b18 b20 b21 b22
Figure 13: Results for SFLL-exc×k
for c={1,2,3} and k={11,12,13,14}; the number of DIPs required for the SAT attack [44] and
the corresponding execution time (seconds).
10
0
10
20
 Area (%)
5
0
5
10
 Power (%)
s35932
s38417
s38584
b14
b15
b17
b18
b20
b21
b22
10
0
10
20
30
 Delay (%)
fs(c=32)
fs(c=64)
overall(c=32)
overall(c=64)
(a)
20
0
20
40
 Area (%)
10
0
10
20
30
 Power (%)
s35932
s38417
s38584
b14
b15
b17
b18
b20
b21
b22
10
5
0
5
10
 Delay (%)
fs(c=32)
fs(c=64)
overall(c=32)
overall(c=64) (b)
Figure 14: Area, power, and delay overhead for SFLL-exc×k
for number of initial cubes c=32 and c=64 and for security
level (a) s=64 and (b) s=128. e overhead of the functionality stripped circuit, denoted as fs, is shown with dark shade
and overhead of the overall circuit including restore unit is
shown with light shade. e average overhead for the largest
ve benchmarks are 6%, 4%, and -1.5% for area, power, and delay, respectively; for the smallest ve benchmarks, the numbers are 10%, 8%, and 1.5%, respectively.
s35932
s38417
s38584
b14
b15
b17
b18
b20
b21
b22
0
2
4
6
8
Exec.time (s)
1e3
k=64,c=32
k=64,c=64
k=128,c=32
k=128,c=64
Figure 15: Combined execution time of cube compression
and security-aware synthesis for SFLL-exc×k
.
and the number of protected cubes k, conrming the scalability of
the proposed SFLL-exc×k
.
5.4 Double-DIP/AppSAT attack results
While the SAT aack terminates only upon retrieving the correct
key, the AppSAT [40] and Double-DIP [41] attacks may (counterintuitively) terminate earlier returning an incorrect key value, which
results in an approximate netlist [40]. e termination criteria
for AppsAT is dictated by an error rate specied by the aacker,
whereas, Double-DIP terminates when it can no longer nd DIPs
that eliminate at least two incorrect keys.
Double-DIP. Each of the 2-DIPs employed by the Double-DIP
aack can eliminate at least two incorrect keys. Since no such 2-
DIPs exist for SFLL-HD0
and SFLL-ex1×k
, the aack will terminate
immediately, recovering an approximate netlist. For larger h and c
values, each input paern is a 2-DIP, leading to scalability issues
for the Double-DIP aack. As illustrated in Fig. 16, the aack then
behaves similarly to the SAT aack, except that the execution time
of the two attacks may vary depending on the DIPs employed by
the two attacks.
AppSAT. In our rst set of AppSAT experiments, we used the
default AppSAT parameters as reported in [40], i.e., 50 random
queries to the oracle were employed at every 12th iteration of
the aack. We observed that estimating the error rate using such
a small number of paerns can be misleading and result in premature termination of the AppSAT aack, even for circuit with
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1611
Table 5: AppSAT [40] attack results (with default AppSAT setting) against SFLL-HDh and SFLL-exc×k
. Only 50 random queries
are applied as per the default AppSAT settings [40]. e attack fails to retrieve the correct key, and thus, we report it as failure.
Benchmark s35932 s38584 s38417 b14 b15 b17 b18 b20 b21 b22
Success/failure Fail Fail Fail Fail Fail Fail Fail Fail Fail Fail
0 1 2 3 4 5 6 7 8 h
2
10
2
12
2
14
2
16
2
18
Exec. time (sec)
Timeout: 48 hours
Timeout for all attacks
Approx. netlist
 recovered by AppSAT
SAT
AppSAT
Double-DIP
Figure 16: Execution time of the SAT, AppSAT, and DoubleDIP attack on (k=) 32-bit s38417 circuit plotted as a function
of h. 1000 random queries are applied aer every 12 AppSAT
iterations. In the shaded region, all the three attacks time
out. Double-DIP is not applicable for h=0.
high corruptibility. Table 5 reports that the “default” AppSAT aack
terminates erroneously for all of the SFLL circuits, failing to retrieve
the correct netlist.
For more realistic corruptibility estimates, we repeated the experiments on s38417 SFLL-HD circuit with 32 key bits. 1000 random
queries were applied aer every 12 iterations. Fig. 16 shows that
for h ≤ 3, the aack terminated quickly, recovering an approximate
netlist. However, for the same h values, the SAT aack failed to
complete within the time limit of 48 hours. Moreover, for the larger
values of h, representing higher corruptibility, AppSAT behaves exactly like the SAT aack, failing to retrieve an approximate netlist.
For example, for h = 4 (implying security level of 32− dlog2

32
4

e=15
bits), both AppSAT and the SAT aack fail to succeed within the
time limit of 48 hours. Note that due to the inclusion of the random
queries (and additional clauses in the SAT formula), the execution
time of AppSAT may be occasionally higher than that of the SAT
aack. See Section 7.3 for further discussion.
5.5 Trade-o: resilience to different attacks
Fig. 17 illustrates the wide spectrum of solutions oered by the
proposed SFLL-HD and SFLL-ex techniques; it shows the trade-o
between the removal aack resilience (in terms of the number of
protected input paerns) and the security level s against oracleguide (e.g., SAT) attacks for the largest ve benchmark circuits. We
observe that for SFLL-HDh
, the security-level s aained against
SAT attacks varies polynomially with h (h ∈ [0, k]); the larger the
number of protected paerns, the lower the security level. e
security level depends only on k and h, irrespective of the circuit.
For the maximum number of protected paerns, i.e., h=n/2, the
security level s is minimal. e security level is at its maximum at
h = 0 or h = k.
For SFLL-exc×k
, however,s decreases only logarithmically with
c (s = k − dlog2
ce). As an example, for c = 128 cubes, the security
level s aained is 121, irrespective of the circuit. e number of
protected paerns increases linearly with c. For example, for the
0 32 64 96 128
h
2
1384
2
3215
2
2384
629
# protected
 pattterns
b17
b18
b20
b21
b22
0
32
64
96
128
Security level s
(a)
0 32 64 96 128
c
2
1384
2
3215
2
2384
629
# protected
 pattterns
b17
b18
b20
b21
b22
0
32
64
96
128 Security level
(b)
Figure 17: SAT attack resilience vs. removal attack resilience; k=128. (a) SFLL-HDh and (b) SFLL-exc×k
.
circuit b20, the number of protected paerns increases from 2384
for c=1 to 2391 for c=128.
Both variants of SFLL enable the protection of a large number of
input paerns. While SFLL-HD allows the designer to choose only
the secret key value and the Hamming distance h, SFLL-ex allows
him/her to specify the complete set of input cubes to be protected.
6 CASE STUDY: SILICON IMPLEMENTATION
OF SFLL-HD0 ON ARM CORTEX-M0
PROCESSOR
With the objective of deploying SFLL for IoT applications, we
present the details of silicon implementation of SFLL on an in-house
designed microcontroller using ARM Cortex-M0 microprocessor [2].
For accurate comparisons, we fabricated both the baseline and the
SFLL-locked microcontroller. Cortex-M0 belongs to the family of
Cortex-M 32-bit RISC processor series from ARM, suitable for a
variety of low-cost microcontrollers. e microcontroller includes
ARM AHB-Lite as its BUS, UART interface, and 64 KB of SRAM.
6.1 Logic locking on ARM Cortex-M0
e baseline ARM Cortex-M0 is locked using 128-bit SFLL-HD0
along with 128-bit FLL [36]. FLL is a technique to achieve high
output corruptibility, while SFLL ensures security against any SATbased aack. Due to tight scheduling constraints, we were able to
tape-out only one version with SFLL-HD0
. In our implementation,
we chose to lock the program counter (PC) to safeguard against
unauthorized execution. is ensures that an aacker with an
incorrect key would end up with an incorrect execution due to the
corrupted PC. Ideally, the secret key is stored in a tamper-proof
memory, such as one-time programmable fuse ROM. However, in
our implementation, the 256-bit key for the locked processor is
stored in a write-only conguration register. e locked processor
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX, USA 161 
(a)
(b)
Figure 18: Top-view of the fabricated silicon chips for ARM
Cortex-M0. (a) Baseline version and (b) Locked version.
Figure 19: Test set-up for the baseline as well as the locked
processor. e program is loaded onto the processor via
UART interface.
is activated by loading the secret key onto the conguration register
through UART.
Chip design/fabrication ow. We used Synopsys VCS for
simulation, Synopsys Design Compiler for RTL synthesis, Synopsis
IC Compiler for back-end implementation, Synopsys Prime Time for
static timing analysis, Synopsys Formality for logical equivalence
checking, PrimeRail for IR drop analysis, and Cadence PVS for
physical verication. e baseline and the locked versions with the
maximum frequency of 100 MHz have been fabricated using Global
Foundries 65nm LPe process. A microscopic view of the bare dies
for the baseline and the locked versions are shown in Fig. 18a and
Fig. 18b, respectively. Fig. 19 illustrates the test setup for the chip.
6.2 Implementation overhead
e APD overhead along with other parameters for the baseline
and locked processors are shown in Table 6. e proposed 128-bit
FLL+128-bit SFLL-HD0
incurs a minimal overhead of 2.16%, 5.62%,
and 5.38% for area, power and delay, respectively, when compared
to the baseline design.
A brief look at other implementation parameters, such as RAM
size, combinational/sequential area or wirelength demonstrates
that the two versions of the processor are quite similar. e most
signicant dierence is in the combinational area, which is about
15.2%. is increase in area for the locked processor can be attributed to the key gates introduced by FLL, and the restore unit
introduced by SFLL. e additional routing resources required for
the additional logic translate into a wirelength overhead of 7.6%
Table 6: Baseline ARM Cortex-M0 vs. locked ARM CortexM0 (128-bit FLL + 128-bit SFLL-HD0
).
Baseline Locked Overhead (%)
Gate count 46800 51397 9.82
RAM area (µm2
) 349240 349240 0
Combinational area (µm2
) 61404 70765 15.24
Sequential area (µm2
) 36876 37169 0.79
IO pads (µm2
) 150000 150000 0
Wirelength (µm) 985233 1060502 7.64
Overall area (µm2
) 597521 607175 1.62
Power (µW ) 6.66 7.03 5.62
Delay (ns) 8.00 8.43 5.38
(a)
(b)
Figure 20: Execution of the SFLL-locked ARM Cortex-M0
with the (a) correct key and (b) incorrect key. e content
of the program counter EXP:CM0 PC is highlighted to show
the dierence in execution.
6.3 Security analysis
e locked processor protects against all oracle-guided attacks. e
sensitization aack [34] terminates in a few minutes but without
returning the correct key. When the SAT aack [44] is launched
on the locked processor, the aack does not terminate within the
specied time limit of 48 hours. Since we implement compound
logic locking (SFLL+FLL) on the processor, the AppSAT aack [40]
would be able to reduce the compound logic locking problem to
SFLL alone; indeed the AppSAT aack on the locked processor
terminates aer 46 hours, but fails to identify the SFLL key.
6.4 Operation of the locked processor
We use the simple example code below that performs one addition
operation to explain the impact of logic locking (i.e., hardwarelevel protection) on processor operations (i.e., soware execution).
int a,b;
GPCFG->SPARE0=0x0000000F;
GPCFG->SPARE1=0x00000001;
a=GPCFG->SPARE0;
b=GPCFG->SPARE1;
GPCFG->GPTACFG=a+b;
is C code is compiled for the ARM Cortex-M0 using ARM
IAR Embedded Workbench and the corresponding binary images
are loaded onto the SRAM via the UART interface. e activated
processor (that has the secret key loaded on the chip) executes
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1613
the code correctly as shown in Fig. 20a; the addition of 0x01 and
0x0F produces 0x10 as expected. On the other hand, the locked
processor (with an incorrect key loaded) cannot execute the code
correctly, as shown in Fig. 20b, as the program counter is corrupted.
An exception handler is then called, reseing the PC to the default
value of 0xFFF7 FFFE, causing the execution to go into an innite
loop.
7 DISCUSSION
7.1 Comparative security analysis
Table 7 presents a comparison of SFLL-HD and SFLL-ex with other
logic locking techniques. Existing SAT aack resilient techniques
such as SARLock and Anti-SAT are vulnerable to removal attacks.
e proposed SFLL thwarts all known attacks on logic locking.
Further, it allows a designer to cost-eectively explore the trade-o
between resilience to SAT and removal attacks.
7.2 Choosing between SFLL-HD and SFLL-ex
While SFLL-HD is suitable for generic applications where the main
requirement is to protect a large number of input paerns with minimal overhead, SFLL-ex allows a designer to protect specic input
cubes. e capability to specify IP-critical cubes to protect, even
a small number of them, may be very benecial for applications
such as microprocessors with IP-critical controllers, digital signal
processing applications with IP-critical coecients, etc. e exibility required in SFLL-ex necessitates a slightly more expensive
restore unit mainly due to the LUT, compared to SFLL-HD, which
has a generic, simple, and scalable restore unit. In either case, the
security-aware synthesis framework enables the designer to aain
the desired security level.
7.3 Resilience against the derivative attacks
In this section, we discuss the security of SFLL against the attacks
that have been derived from the SAT aack, namely AppSAT [40],
Double-DIP [41], and Bypass [53]. ese attacks mainly target
compound (multi-layered) logic locking techniques. AppSAT and
Double-DIP are approximate attacks as they only reduce a compound logic locking technique (e.g. SARLock+SLL) to a SAT aack
resilient technique (e.g. SARLock). e Bypass aack, however, is
an exact aack; the aack, if successful, returns a netlist functionally equivalent to the oracle (functional IC).
ese attacks rely on the classication of compound logic locking
key bits into two classes: key bits for RLL/SLL etc. that introduce
high corruptibility and key bits for SARLock/Anti-SAT etc. that
induce low corruptibility at the outputs. ese attacks can quickly
determine the correct values for the high corruptibility key bits. e
AppSAT and Double-DIP attacks then assign a random value for the
low corruptibility key bits, whereas, the Bypass aack introduces
additional logic to x the occasional corruption at the outputs.
ese attacks will not be eective against SFLL as all the key bits in
SFLL incur uniform corruptibility and it is not feasible to partition
the key search space into low/high corruptibility regions.
AppSAT. ere are two main dierences between AppSAT and
the SAT aack. First, AppSAT is constructed by augmenting the
SAT aack with random queries to the oracle at regular intervals.
As reported in [40], AppSAT involves 50 random queries every 12
iterations of the aack. Second, AppSAT can terminate much earlier
than the SAT aack, i.e., when the error rate (or Hamming distance
at the outputs) is below a certain threshold (e.g., 1
2
k
). While the
AppSAT aack can quickly recover an approximate netlist for lowcorruptibility SFLL circuits (with low h orc ), it behaves similarly to
the SAT aack for high-corruptibility SFLL circuits since the early
termination condition is not satised. us, SFLL resilience against
AppSAT is similar to that against the SAT aack.
e 50 queries as per the default AppSAT seings are sucient
to separate the key bits into two classes in case of compound locking techniques. However, no such classes of key bits exist in SFLL
where the corruptibility is uniform for all the key values. As reported in Section 5.2.1, when the aack is launched on SFLL circuits
with varying corruptibility values (represented using h), the aack
terminated erroneously even for high corruptibility circuits. e
error is beer estimated with 1000 random queries. e aack then
quickly extracts the approximate netlist for the smaller values of h.
For the larger h values, the aack performance is similar to that of
the SAT aack.
Double-DIP. Compared to the SAT aack, the Double-DIP attack uses a larger miter circuit comprising four copies of the locked
netlist [41]. e 2-DIPs computed by the aack eliminate at least
two incorrect keys per DIP. e aack terminates when no more
2-DIPs can be found, implying that only DIPs that can eliminate
at most one incorrect key remain in the search space. e aack
returns an approximate netlist. While the aack can break compound logic locking techniques, it is not scalable, especially if the
locked circuit has multiple correct keys.
Except for SFLL-HD0 or SFLL-Flex1×k
(whrere there are no 2-
DIPs), the Double-DIP aack, when launched on SFLL circuits, will
run into scalability issues as it will compute an exponential number
of DIPs before it terminates. Rarely, when the aack is fortuitous
and selects one of the protected paerns as a DIP (the protected
paern may be a 2-DIP), it can eliminate most of the incorrect keys
in a single iteration of the aack. In such cases, the aack returns
returns the exact netlist, similar to the basic SAT aack, but this is
highly unlikely for large enough key sizes.
Bypass. e Bypass aack selects two random key values as
constraints for the two locked netlists in the miter circuit [53]. e
aack then computes all the DIPs that result in diering outputs for
the two key values. For the traditional low corruptibility locking
techniques such as SARLock, only a few DIPs will be extracted. e
aacker then determines the correct key values for those DIPs from
the output of functional IC. One of the two key values is designated
as the secret key and an additional bypass circuit is added around
the locked netlist to x the output for the selected DIPs.
In SFLL, a protected input paern produces the same incorrect
output for most of the incorrect key values. Occasionally, the
output may be correctly restored even for incorrect key values, as
illustrated earlier in Figure 4. When applied to SFLL, the Bypass
aack fails to compute the complete set of DIPs that lead to incorrect
outputs for the two key values. Most of the DIPs yield exactly the
same incorrect output for both incorrect keys, and as such, cannot
be extracted using the miter construction employed by the Bypass
aack. e bypass circuitry, when constructed using an incomplete
set of DIPs, will be erroneous.
Session G5: Hardening Hardware CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1614
Table 7: Comparative security analysis of logic locking techniques against existing attacks. SFLL is secure against all attacks.
Various versions of SFLL oer a trade-o between SAT attack resilience and removal attack resilience.
Attack/Defense Anti-SAT [52] SARLock [55] TTLock [61] SFLL-HDh
SFLL-ex
c×k
SAT k-secure k-secure k-secure k − dlog2

k
h

e-secure (k − dlog2
c e)-secure
Sensitization k-secure k-secure k-secure k-secure k-secure
Removal 0-resilient 0-resilient 2
n−k
-resilient
k
h

· 2
n−k
-resilient c · 2
n−k
-resilient
7.4 Limitations and future work
While SFLL oers resilience against all known and anticipated
attacks in addition to oering trade-os between aack resilience,
it might be occasionally broken if the aacker is fortuitous enough
to nd one of the protected paerns. Currently, a linear increase in
the number of protected paerns leads to a logarithmic decrease
in SAT aack resilience. As part of our future work, we will rene
SFLL algorithm so that the decrease in SAT aack resilience is
sub-logarithmic with increasing number of protected paerns.
Our current SFLL implementation relies on the existing securityagnostic tools such as Synopsys DC Compiler and ABC [6] for
synthesis. Netlists synthesized using these tools may leave behind
traces for an aacker to exploit. In future, we plan to modify the
ABC tool and oer security guarantees against synthesis-driven
attacks [29].
Currently, SFLL relies on a designer to specify which parts of a
design are security-critical. In future, we plan to automate this process by developing metrics that quantify the criticality of different
circuit components. Another related research question is to identify
the paerns-to-be-protected that incur the least implementation
overhead, or can even yield area, power, or delay savings.
8 CONCLUSION
We propose stripped-functionality logic locking: a low-cost, secure, and scalable logic locking technique that provably thwarts
all known and anticipated attacks. We quantify the resilience of
any logic locking technique against a given aack in terms of the
number and the size of the protected input cubes. Based on this
nding, we develop a CAD framework that allows the designer to
strip functionality from the hardware implementation of the design
based on a set of input cubes to be protected; we also propose a
security-aware synthesis process that can strip functionality with
the objective of minimizing the cost of implementation. By adjusting the number and the size of the protected cubes, the designer
can explore the trade-o between resilience to different attacks.
e stripped functionality is hidden from untrusted entities, such
as the foundry and the end-user (potential reverse-engineer). Only
the secret key, i.e., the protected cubes, can successfully recover
the stripped functionality through an on-chip restore operation.
Another flexibility that the proposed framework oers is that
for general applications, it enables the designer to protect any
number of a restricted set of cubes, leading to a simple and scalable
architecture. It also supports specialized applications that require
IP-critical input cubes to be protected. e designer can thus choose
the solution that best ts the security needs of his/her application.
Upon implementing the proposed logic locking technique on
large-sized benchmarks (> 100K gates) and launching all known
attacks on them, we conrm that the proposed technique is secure and cost-ecient. For further validation, we also apply the
proposed logic locking technique on an industry-strength microprocessor design that we then implement in silicon; the data obtained
from the fabricated chips also conrm the practicality, security,
and scalability of our technique. e proposed technique can be
seamlessly integrated into the IC design ow to thwart IP piracy,
reverse engineering, and overbuilding attack