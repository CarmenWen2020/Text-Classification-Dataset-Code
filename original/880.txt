We introduce the key reinstallation attack. This attack abuses design
or implementation flaws in cryptographic protocols to reinstall an
already-in-use key. This resets the key’s associated parameters such
as transmit nonces and receive replay counters. Several types of
cryptographic Wi-Fi handshakes are affected by the attack.
All protected Wi-Fi networks use the 4-way handshake to generate a fresh session key. So far, this 14-year-old handshake has
remained free from attacks, and is even proven secure. However,
we show that the 4-way handshake is vulnerable to a key reinstallation attack. Here, the adversary tricks a victim into reinstalling an
already-in-use key. This is achieved by manipulating and replaying
handshake messages. When reinstalling the key, associated parameters such as the incremental transmit packet number (nonce) and
receive packet number (replay counter) are reset to their initial
value. Our key reinstallation attack also breaks the PeerKey, group
key, and Fast BSS Transition (FT) handshake. The impact depends
on the handshake being attacked, and the data-confidentiality protocol in use. Simplified, against AES-CCMP an adversary can replay
and decrypt (but not forge) packets. This makes it possible to hijack
TCP streams and inject malicious data into them. Against WPATKIP and GCMP the impact is catastrophic: packets can be replayed,
decrypted, and forged. Because GCMP uses the same authentication
key in both communication directions, it is especially affected.
Finally, we confirmed our findings in practice, and found that
every Wi-Fi device is vulnerable to some variant of our attacks.
Notably, our attack is exceptionally devastating against Android 6.0:
it forces the client into using a predictable all-zero encryption key.
KEYWORDS
security protocols; network security; attacks; key reinstallation;
WPA2; nonce reuse; handshake; packet number; initialization vector
1 INTRODUCTION
All protected Wi-Fi networks are secured using some version of
Wi-Fi Protected Access (WPA/2). Moreover, nowadays even public
hotspots are able to use authenticated encryption thanks to the
Hotspot 2.0 program [7]. All these technologies rely on the 4-way
handshake defined in the 802.11i amendment of 802.11 [4]. In this
work, we present design flaws in the 4-way handshake, and in
related handshakes. Because we target these handshakes, both WPAand WPA2-certified products are affected by our attacks.
The 4-way handshake provides mutual authentication and session key agreement. Together with (AES)-CCMP, a data-confidentiality and integrity protocol, it forms the foundation of the 802.11i
amendment. Since its first introduction in 2003, under the name
WPA, this core part of the 802.11i amendment has remained free
from attacks. Indeed, the only currently known weaknesses of
802.11i are in (WPA-)TKIP [57, 66]. This data-confidentiality protocol was designed as a short-term solution to the broken WEP
protocol. In other words, TKIP was never intended to be a longterm secure solution. Additionally, while several attacks against
protected Wi-Fi networks were discovered over the years, these did
not exploit flaws in 802.11i. Instead, attacks exploited flaws in Wi-Fi
Protected Setup (WPS) [73], flawed drivers [13, 20], flawed random
number generators [72], predictable pre-shared keys [45], insecure
enterprise authentication [21], and so on. That no major weakness
has been found in CCMP and the 4-way handshake, is not surprising. After all, both have been formally proven as secure [39, 42].
With this in mind, one might reasonably assume the design of the
4-way handshake is indeed secure.
In spite of its history and security proofs though, we show that
the 4-way handshake is vulnerable to key reinstallation attacks.
Moreover, we discovered similar weaknesses in other Wi-Fi handshakes. That is, we also attack the PeerKey handshake, the group
key handshake, and the Fast BSS Transition (FT) handshake.
The idea behind our attacks is rather trivial in hindsight, and can
be summarized as follows. When a client joins a network, it executes
the 4-way handshake to negotiate a fresh session key. It will install
this key after receiving message 3 of the handshake. Once the key
is installed, it will be used to encrypt normal data frames using a
data-confidentiality protocol. However, because messages may be
lost or dropped, the Access Point (AP) will retransmit message 3 if
it did not receive an appropriate response as acknowledgment. As
a result, the client may receive message 3 multiple times. Each time
it receives this message, it will reinstall the same session key, and
thereby reset the incremental transmit packet number (nonce) and
receive replay counter used by the data-confidentiality protocol.
We show that an attacker can force these nonce resets by collecting
and replaying retransmissions of message 3. By forcing nonce reuse
in this manner, the data-confidentiality protocol can be attacked,
e.g., packets can be replayed, decrypted, and/or forged. The same
technique is used to attack the group key, PeerKey, and fast BSS
transition handshake.
When the 4-way or fast BSS transition handshake is attacked,
the precise impact depends on the data-confidentiality protocol
being used. If CCMP is used, arbitrary packets can be decrypted.
In turn, this can be used to decrypt TCP SYN packets, and hijack
TCP connections. For example, an adversary can inject malicious
Session F3: Crypto Pitfalls CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1313
CCS’17, October 30–November 3, 2017, Dallas, TX, USA. Mathy Vanhoef and Frank Piessens
content into unencrypted HTTP connections. If TKIP or GCMP is
used, an adversary can both decrypt and inject arbitrary packets.
Although GCMP is a relatively new addition to Wi-Fi, it is expected
to be adopted at a high rate in the next few years [58]. Finally,
when the group key handshake is attacked, an adversary can replay
group-addressed frames, i.e., broadcast and multicast frames.
Our attack is especially devastating against version 2.4 and 2.5 of
wpa_supplicant, a Wi-Fi client commonly used on Linux. Here, the
client will install an all-zero encryption key instead of reinstalling
the real key. This vulnerability appears to be caused by a remark
in the 802.11 standard that suggests to clear parts of the session
key from memory once it has been installed [1, §12.7.6.6]. Because
Android uses a modified wpa_supplicant, Android 6.0 and Android
Wear 2.0 also contain this vulnerability. As a result, currently 31.2%
of Android devices are vulnerable to this exceptionally devastating
variant of our attack [33].
Interestingly, our attacks do not violate the security properties
proven in formal analysis of the 4-way and group key handshake.
In particular, these proofs state that the negotiated session key
remains private, and that the identity of both the client and Access
Point (AP) is confirmed [39]. Our attacks do not leak the session
key. Additionally, although normal data frames can be forged if
TKIP or GCMP is used, an attacker cannot forge EAPOL messages
and hence cannot impersonate the client or AP during (subsequent)
handshakes. Instead, the problem is that the proofs do not model
key installation. Put differently, their models do not state when a
negotiated key should be installed. In practice, this means the same
key can be installed multiple times, thereby resetting nonces and
replay counters used by the data-confidentiality protocol.
To summarize, our main contributions are:
• We introduce key reinstallation attacks. Here, an attacker
forces the reinstallation of an already-in-use key, thereby
resetting any associated nonces and/or replay counters.
• We show that the 4-way handshake, PeerKey handshake,
group key handshake, and fast BSS transition handshake are
vulnerable to key reinstallation attacks.
• We devise attack techniques to carry out our attacks in practice. This demonstrates that all implementations are vulnerable to some variant of our attack.
• We evaluate the practical impact of nonce reuse for all dataconfidentiality protocols of 802.11.
The remainder of this paper is structured as follows. Section 2
introduces relevant aspects of the 802.11 standard. Our key reinstallation attack is illustrated against the 4-way and PeerKey handshake
in Section 3, against the group key handshake in Section 4, and
against the fast BSS transition handshake in Section 5. In Section 6
we asses the impact of our attacks, present countermeasures, explain where proofs failed, and discuss lessons learned. Finally, we
present related work in Section 7 and conclude in Section 8.
2 BACKGROUND
In this section we introduce the 802.11i amendment, the various
messages and handshakes used when connecting to a Wi-Fi network, and the data-confidentiality and integrity protocols of 802.11.
2.1 The 802.11i Amendment
After researchers showed that Wired Equivalent Privacy (WEP) was
fundamentally broken [30, 65], the IEEE offered a more robust solution in the 802.11i amendment of 802.11. This amendment defines
the 4-way handshake (see Section 2.3), and two data-confidentiality
and integrity protocols called (WPA-)TKIP and (AES-)CCMP (see
Section 2.4). While the 802.11i amendment was under development,
the Wi-Fi Alliance already began certifying devices based on draft
version D3.0 of 802.11i. This certification program was called Wi-Fi
Protected Access (WPA). Once the final version D9.0 of 802.11i was
ratified, the WPA2 certification was created based on this officially
ratified version. Because both WPA and WPA2 are based on 802.11i,
they are almost identical on a technical level. The main difference
is that WPA2 mandates support for the more secure CCMP, and
optionally allows TKIP, while the reverse is true for WPA.
Required functionality of both WPA and WPA2, and used by all
protected Wi-Fi networks, is the 4-way handshake. Even enterprise
networks rely on the 4-way handshake. Hence, all protected Wi-Fi
networks are affected by our attacks.
The 4-way handshake, group key handshake, and CCMP protocol, have formally been analyzed and proven to be secure [39, 42].
2.2 Authentication and Association
When a client wants to connect to a Wi-Fi network, it starts by
(mutually) authenticating and associating with the AP. In Figure 2
this is illustrated in the association stage of the handshake. However,
when first connecting to a network, no actual authentication takes
places at this stage. Instead, Open System authentication is used,
which allows any client to authenticate. Actual authentication will
be performed during the 4-way handshake. Real authentication is
only done at this stage when roaming between two APs of the same
network using the fast BSS transition handshake (see Section 3).
After (open) authentication, the client associates with the network. This is done by sending an association request to the AP.
This message contains the pairwise and group cipher suites the
client wishes to use. The AP replies with an association response,
informing the client whether the association was successful or not.
2.3 The 4-way Handshake
The 4-way handshake provides mutual authentication based on a
shared secret called the Pairwise Master Key (PMK), and negotiates
a fresh session key called the Pairwise Transient Key (PTK). During
this handshake, the client is called the supplicant, and the AP is
called the authenticator (we use these terms as synonyms). The
PMK is derived from a pre-shared password in a personal network,
and is negotiated using an 802.1x authentication stage in an enterprise network (see Figure 2). The PTK is derived from the PMK,
Authenticator Nonce (ANonce), Supplicant Nonce (SNonce), and
the MAC addresses of both the supplicant and authenticator. Once
generated, the PTK is split into a Key Confirmation Key (KCK), Key
Encryption Key (KEK), and Temporal Key (TK). The KCK and KEK
are used to protect handshake messages, while the TK is used to
protect normal data frames with a data-confidentiality protocol. If
WPA2 is used, the 4-way handshake also transports the current
Group Temporal Key (GTK) to the supplicant.
Session F3: Crypto Pitfalls CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1314
Key Reinstallation Attacks: Forcing Nonce Reuse in WPA2 CCS’17, October 30–November 3, 2017, Dallas, TX, USA.
header replay counter nonce RSC MIC Key Data
82 bytes variable encrypted
Figure 1: Simplified layout of an EAPOL frame.
Every message in the 4-way handshake is defined using EAPOL
frames. We will briefly discuss the layout and most important fields
of these frames (see Figure 1). First, the header defines which message in the handshake a particular EAPOL frame represents. We will
use the notation message n and MsgN to refer to the n-th message
of the 4-way handshake. The replay counter field is used to detect
replayed frames. The authenticator always increments the replay
counter after transmitting a frame. When the supplicant replies
to an EAPOL frame of the authenticator, it uses the same replay
counter as the one in the EAPOL frame it is responding to. The
nonce field transports the random nones that the supplicant and
authenticator generate to derive a fresh session key. Next, in case
the EAPOL frame transports a group key, the Receive Sequence
Counter (RSC) contains the starting packet number of this key. The
group key itself is stored in the Key Data field, which is encrypted
using the KEK. Finally, the authenticity of the frame is protected
using the KCK with a Message Integrity Check (MIC).
Figure 2 illustrates the messages that are exchanged during the
4-way handshake. In it, we use the following notation:
MsgN(r, Nonce; GTK)
It represents message N of the 4-way handshake, having a replay
counter of r, and with the given nonce (if present). All parameters
after the semicolon are stored in the key data field, and hence are
encrypted using the KEK (recall Figure 1).
The authenticator initiates the 4-way handshake by sending message 1. It contains the ANonce, and is the only EAPOL message that
is not protected by a MIC. On reception of this message, the supplicant generates the SNonce and derives the PTK (i.e., the session
key). The supplicant then sends the SNonce to the authenticator in
message 2. Once the authenticator learns the SNonce, it also derives
the PTK, and sends the group key (GTK) to the supplicant. Finally,
to finalize the handshake, the supplicant replies with message 4 and
after that installs the PTK and GTK. After receiving this message,
the authenticator also installs the PTK (the GTK is installed when
the AP is started). To summarize, the first two messages are used to
transport nonces, and the last two messages are used to transport
the group key and to protect against downgrade attacks.
Note that in an existing connection, the PTK can be refreshed
by initiating a new 4-way handshake. During this rekey, all 4-way
handshake messages are encrypted by the data-confidentiality protocol using the current PTK (we rely on this in Section 3.4).
2.4 Confidentiality and Integrity Protocols
The 802.11i amendment defines two data-confidentiality protocols.
The first is called the Temporal Key Integrity Protocol (TKIP). However, nowadays TKIP is deprecated due to security concerns [74].
The second protocol is commonly called (AES-)CCMP, and is currently the most widely-used data-confidentiality protocol [69]. In
2012, the 802.11ad amendment added a new data-confidentiality
protocol called the Galios/Counter Mode Protocol (GCMP) [3]. This
Supplicant (client) Authenticator (AP)
Authentication Request
Authentication Response
(Re)Association Request
(Re)Association Response
association stage
optional 802.1x authentication
Msg1(r, ANonce)
Derive PTK Msg2(r, SNonce)
Derive PTK Msg3(r+1; GTK)
Msg4(r+1)
Install PTK & GTK Install PTK
4-way handshake
encrypted data frames can now be exchanged
Refresh GTK
Encx
ptk{ Group1(r+2; GTK) }
Ency
ptk{ Group2(r+2) }
Install GTK Install GTK
group key handshake
Figure 2: Messages exchanged when a supplicant (client) connects with an authenticator (AP), performs the 4-way handshake, and periodically executes the group key handshake.
amendment also adds support for short-range communications in
the 60 GHz band, which requires a fast cipher such as GCM [3].
Right now, 802.11ad is being rolled out under the name Wireless
Gigabit (WiGig), and is expected to be adopted at a high rate over
the next few years [58]. Finally, the 802.11ac amendment further
extends GCMP by adding support for 256-bit keys [2].
When TKIP is used, the Temporal Key (TK) part of the session
key (PTK) is further split into a 128-bit encryption key, and two
64-bit Message Integrity Check (MIC) keys. The first MIC key is
used for AP-to-client communication, while the second key is used
for the reverse direction. RC4 is used for encryption, with a unique
per-packet key that is a mix of the 128-bit encryption key, the sender
MAC address, and an incremental 48-bit nonce. This nonce is incremented after transmitting a frame, used as a replay counter by the
receiver, and initialized to 1 when installing the TK [1, §12.5.2.6].
Message authenticity is provided by the Michael algorithm. Unfortunately, Michael is trivial to invert: given plaintext data and its
MIC value, one can efficiently recover the MIC key [66, 69].
The CCMP protocol is based on the AES cipher operating in
CCM mode (counter mode with CBC-MAC). It is an Authenticated
Encryption with Associated Data (AEAD) algorithm, and secure as
long as no Initialization Vector (IV) is repeated under a particular
Session F3: Crypto Pitfalls CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1315
CCS’17, October 30–November 3, 2017, Dallas, TX, USA. Mathy Vanhoef and Frank Piessens
key1
. In CCMP, the IV is the concatenation of the sender MAC
address, a 48-bit nonce, and some additional flags derived from
the transmitted frame. The nonce is also used as a replay counter
by the receiver, incremented by one before sending each frame,
and initialized to 0 when installing the TK [1, §12.5.3.4.4]. This
is supposed to assure that IVs do not repeat. Additionally, this
construction allows the TK to be used directly as the key for both
communication directions.
The GCMP protocol is based on AES-GCM, meaning it uses
counter mode for encryption, with the resulting ciphertext being
authenticated using the GHASH function [28]. Similar to CCMP, it
is an AEAD cipher, and secure as long as no IV is repeated under a
particular key. In GCMP, the IV is the concatenation of the sender
MAC address and a 48-bit nonce. The nonce is also used as a replay
counter by the receiver, incremented by one before sending each
frame, and initialized to 0 when installing the TK [1, §12.5.5.4.4].
This normally assures each IV is only used once. As with CCMP,
the TK is used directly as the key for both communication directions. If a nonce is ever repeated, it is possible to reconstruct the
authentication key used by the GHASH function [43].
To denote that a frame is encrypted and authenticated using a
data-confidentiality protocol, we use the following notation:
Encn
k
{·}
Here n denotes the nonce being used (and thus also the replay
counter). The parameter k denotes the key, which is the PTK (session key) for unicast traffic. For group-addressed traffic, i.e., broadcast and multicast frames, this is the GTK (group key). Finally, the
two notations
Data(payload)
GroupData(payload)
are used to represent an ordinary unicast or group-addressed data
frame, respectively, with the given payload.
2.5 The Group Key Handshake
The authenticator periodically refreshes the group key, and distributes this new group key to all clients using the group key handshake. This handshake was proven to be secure in [39], and is
illustrated in the last stage of Figure 2. The authenticator initiates
the handshake by sending a group message 1 to all clients. The
supplicant acknowledges the receipt of the new group key by replying with group message 2. Depending on the implementation, the
authenticator installs the GTK either after sending group message 1,
or after receiving a reply from all connected clients (see Section 4).
Finally, group message 1 also contains the current receive replay
counter of the group key in the RSC field (see Figure 1).
Both messages in the group key handshake are defined using
EAPOL frames, and are represented using Group1 and Group2 in
Figure 2. Note that group message 1 stores the new group key in
the Key Data field, and hence is encrypted using the KEK (recall
Figure 1). Since at this point a PTK is installed, the complete EAPOL
frame is also protected using a data-confidentiality protocol.
Finally, if a client transmits a broadcast or multicast frame, she
first sends it as a unicast frame to the AP. The AP then encrypts
1Note that we deviate from official 802.11 terminology, where what we call the nonce
is called the packet number, and what we call the IV is called the nonce.
PTK-INIT
PMK = shared master secret
PTK-START
Calculate SNonce
TPTK = CalcPTK(PMK, ANonce, SNonce)
Send Msg2(SNonce)
PTK-NEGOTIATING
PTK = TPTK
Send Msg4()
PTK-DONE
MLME-SETKEYS.request(PTK)
MLME-SETKEYS.request(GTK)
802.1X::portValid = TRUE
Enter 4-way handshake stage
Msg1 Received
Msg3 Received && MIC-Verified &&
!ReplayedMsg
Msg1 Received
unconditional Msg3 Received &&
MIC-Verified &&
!ReplayedMsg
Msg1 Received
Figure 3: Supplicant 4-way handshake state machine as defined in the 802.11 standard [1, Fig. 13-17]. Keys are installed
for usage by calling the MLME-SETKEYS.request primitive.
the frame using the group key, and broadcasts it to all clients. This
assures all clients within the range of the AP receive the frame.
3 ATTACKING THE 4-WAY HANDSHAKE
In this section we show that the state machine behind the 4-way
handshake is vulnerable to a key reinstallation attack. We then
demonstrate how to execute this attack in real-life environments.
3.1 Supplicant State Machine
The 802.11i amendment does not contain a formal state machine describing how the supplicant must implement the 4-way handshake.
Instead, it only provides pseudo-code that describes how, but not
when, certain handshake messages should be processed [4, §8.5.6].
2
Fortunately, 802.11r slightly extends the 4-way handshake, and does
provide a detailed state machine of the supplicant [1, Fig. 13-17].
Figure 2 contains a simplified description of this state machine.
When first connecting to a network and starting the 4-way handshake, the supplicant transitions to the PTK-INIT state (see Figure 3).
Here, it initializes the Pairwise Master Key (PMK). When receiving
message 1, it transitions to the PTK-START stage. This may happen when connecting to a network for the first time, or when the
session key is being refreshed after a previous (completed) 4-way
handshake. When entering PTK-START, the supplicant generates a
random SNonce, calculates the Temporary PTK (TPTK), and sends
its SNonce to the authenticator using message 2. The authenticator
will reply with message 3, which is accepted by the supplicant if
2
Strangely, this pseudo-code is only present in the original 802.11i amendment. Later revisions of the 802.11 standard, which are supposed to combine all existing amendments
into one updated document, no longer contain this pseudo-code.
Session F3: Crypto Pitfalls CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1316
Key Reinstallation Attacks: Forcing Nonce Reuse in WPA2 CCS’17, October 30–November 3, 2017, Dallas, TX, USA.
the MIC and replay counter are valid. If so, it moves to the PTKNEGOTIATING state, where it marks the TPTK as valid by assigning
it to the PTK variable, and sends message 4 to the authenticator.
Then it immediately transitions to the PTK-DONE state, where the
PTK and GTK are installed for usage by the data-confidentiality
protocol using the MLME-SETKEYS.request primitive. Finally, it
opens the 802.1x port such that the supplicant can receive and send
normal data frames. Note that the state machine explicitly takes
into account retransmissions of either message 1 or 3, which occur
if the authenticator did not receive message 2 or 4, respectively.
These retransmissions use an incremented EAPOL replay counter.
We confirmed that the state machine in 802.11r matches the original state machine, that was “defined” in 802.11i using textual descriptions scattered throughout the amendment. Most importantly,
we verified two properties which we abuse in our key reinstallation
attack. First, 802.11i states that the AP retransmits message 1 or 3 if
it did not receive a reply [4, §8.5.3.5]. Therefore, the client must handle retransmissions of message 1 or 3, matching the state machine
of 802.11r. Additionally, 802.11i states that the client should install
the PTK after processing and replying to message 3 [4, §8.5.3.3].
This again matches the state machine given in 802.11r.
3.2 The Key Reinstallation Attack
Our key reinstallation attack is now easy to spot: because the supplicant still accepts retransmissions of message 3, even when it is
in the PTK-DONE state, we can force a reinstallation of the PTK.
More precisely, we first establish a man-in-the-middle (MitM) position between the supplicant and authenticator. We use this MitM
position to trigger retransmissions of message 3 by preventing
message 4 from arriving at the authenticator. As a result, it will
retransmit message 3, which causes the supplicant to reinstall an
already-in-use PTK. In turn, this resets the nonce being used by the
data-confidentiality protocol. Depending on which protocol is used,
this allows an adversary to replay, decrypt, and/or forge packets.
In Section 6.1 we will explore in detail what the practical impacts
of nonce reuse are for each data-confidentiality protocol.
In practice, some complications arise when executing the attack.
First, not all Wi-Fi clients properly implement the state machine. In
particular, Windows and iOS do not accept retransmissions of message 3 (see Table 1 column 2). This violates the 802.11 standard. As
a result, these implementations are not vulnerable to our key reinstallation attack against the 4-way handshake. Unfortunately, from
a defenders perspective, both iOS and Windows are still vulnerable to our attack against the group key handshake (see Section 4).
Additionally, because both OSes support 802.11r, it is still possible
to indirectly attack them by performing a key reinstallation attack
against the AP during an FT handshake (see Section 5).
A second minor obstacle is that we must obtain a MitM position between the client and AP. This is not possible by setting up
a rouge AP with a different MAC address, and then forwarding
packets between the real AP and client. Recall from Section 2.3
that the session key is based on the MAC addresses of the client
and AP, meaning both would derive a different key, causing the
handshake and attack to fail. Instead, we employ a channel-based
MitM attack [70], where the AP is cloned on a different channel
Table 1: Behaviour of clients: 2nd column shows whether retransmission of message 3 are accepted, 3rd whether plaintext EAPOL messages are accepted if a PTK is configured,
4th whether it accepts plaintext EAPOL messages if sent immediately after the first message 3, and 5th whether it is affected by the attack of Section 3.4. The last two columns denote if the client is vulnerable to a key reinstallation attack
against the 4-way or group key handshake, respectively.
Implementation
Re. Msg3
Pt. EAPOL
Quick Pt.
Quick Ct.
4-way
Group
OS X 10.9.5 ✓ ✗ ✗ ✓ ✓ ✓
macOS Sierra 10.12 ✓ ✗ ✗ ✓ ✓ ✓
iOS 10.3.1 c ✗ N/A N/A N/A ✗ ✓
wpa_supplicant v2.3 ✓ ✓ ✓ ✓ ✓ ✓
wpa_supplicant v2.4-5 ✓ ✓ ✓ ✓a ✓a ✓
wpa_supplicant v2.6 ✓ ✓ ✓ ✓b ✓b ✓
Android 6.0.1 ✓ ✗ ✓ ✓a ✓a ✓
OpenBSD 6.1 (rum) ✓ ✗ ✗ ✗ ✗ ✓
OpenBSD 6.1 (iwn) ✓ ✗ ✗ ✓ ✓ ✓
Windows 7 c ✗ N/A N/A N/A ✗ ✓
Windows 10 c ✗ N/A N/A N/A ✗ ✓
MediaTek ✓ ✓ ✓ ✓ ✓ ✓
a Due to a bug, an all-zero TK will be installed, see Section 6.3.
b Only the group key is reinstalled in the 4-way handshake.
c Certain tests are irrelevant (not applicable) because the implementation does not accept retransmissions of message 3.
with the same MAC address as the targeted AP. This assures the
client and AP derive the same session key.
The third obstacle is that certain implementations only accept
frames protected using the data-confidentiality protocol once a PTK
has been installed (see Table 1 column 3). This is problematic for our
attack, because the authenticator will retransmit message 3 without
encryption. This means the retransmitted message will be ignored
by the supplicant. Although this would seem to foil our attack, we
found a technique to bypass this problem (see Section 3.4).
In the next two Sections, we will describe in detail how to execute our key reinstallation attack against the 4-way handshake
under various conditions. More precisely, we first explain our attack
when the client (victim) accepts plaintext retransmissions of message 3 (see Table 1 column 3). Then we demonstrate the attack when
the victim only accepts encrypted retransmissions of message 3 (see
Table 1 column 4). Table 1 column 6 summarizes which devices are
vulnerable to some variant of the key reinstallation attack against
the 4-way handshake. We remark that the behaviour of a device
depends both on the operating system, and the wireless NIC being
used. For example, although Linux accepts plaintext retransmissions of message 3, the Wi-Fi NICs used in several Android devices
Session F3: Crypto Pitfalls CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1317
CCS’17, October 30–November 3, 2017, Dallas, TX, USA. Mathy Vanhoef and Frank Piessens
reject them. However, Android phones with a different wireless
NIC may in fact accept plaintext retransmissions of message 3.
3.3 Plaintext Retransmission of message 3
If the victim still accepts plaintext retransmissions of message 3 after
installing the session key, our key reinstallation attack is straightforward. First, the adversary uses a channel-based MitM attack
so she can manipulate handshake messages [70]. Then she blocks
message 4 from arriving at the authenticator. This is illustrated in
stage 1 of Figure 4. Immediately after sending message 4, the victim
will install the PTK and GTK. At this point the victim also opens
the 802.1x port, and starts transmitting normal data frames (recall
Section 2.3). Notice that the first data frame uses a nonce value
of 1 in the data-confidentiality protocol. Then, in the third stage
of the attack, the authenticator retransmits message 3 because it
did not receive message 4. The adversary forwards the retransmitted message 3 to the victim, causing it to reinstall the PTK and
GTK. As a result, it resets the nonce and replay counter used by the
data-confidentiality protocol. Note that the adversary cannot replay
an old message 3, because its EAPOL replay counter is no longer
fresh. We ignore stage 4 of the attack for now. Finally, when the
victim transmits its next data frame, the data-confidentiality protocol reuses nonces. Note that an adversary can wait an arbitrary
amount of time before forward the retransmitted message 3 to the
victim. Therefore, we can control the amount of nonces that will
be reused. Moreover, an adversary can always perform the attack
again by deauthenticating the client, after which it will reconnect
with the network and execute a new 4-way handshake.
Figure 4 also shows that our key reinstallation attack occurs
spontaneously if message 4 is lost due to background noise. Put
differently, clients that accept plaintext retransmissions of message 3, may already be reusing nonces without an adversary even
being present. Inspired by this observation, an adversary could also
selectively jam message 4 [70], resulting in a stealthy attack that is
indistinguishable from random background interference.
We now return to stage 4 of the attack. The goal of this stage
is to complete the handshake at the authenticator side. This is not
trivial because the victim already installed the PTK, meaning its last
message 4 is encrypted.3 And since the authenticator did not yet
install the PTK, it will normally reject this encrypted message 4.4
However, a careful inspection of the 802.11 standard reveals that
the authenticator may accept any replay counter that was used in
the 4-way handshake, not only the latest one [1, §12.7.6.5]:
“On reception of message 4, the Authenticator verifies
that the Key Replay Counter field value is one that it
used on this 4-way handshake.”
In practice, we found that several APs indeed accept an older replay
counter. More precisely, some APs accept replay counters that were
used in a message to the client, but were not yet used in a reply
from the client (see column 2 in Table 2 on page 8). These APs
will accept the older unencrypted message 4, which has the replay
3The 802.11 standard says that a retransmitted message 4 must be sent in plaintext in
the initial 4-way handshake [1, §12.7.6.5], but nearly all clients send it using encryption.
4
Similar to fixes in [63, 64], a non-standard implementation may already install the
PTK for reception-only after sending message 3. We found no AP doing this though.
Supplicant (victim) Adversary (MitM) Authenticator
Msg1(r, ANonce) Msg1(r, ANonce)
Msg2(r, SNonce) Msg2(r, SNonce)
Msg3(r+1; GTK) Msg3(r+1; GTK)
Msg4(r+1)
○1
Install PTK & GTK
Enc1
ptk{ Data(. . .) } ○2
Msg3(r+2; GTK) Msg3(r+2; GTK)
Enc2
ptk{ Msg4(r+2) }
Reinstall PTK & GTK
○3
Enc2
ptk{ Msg4(r+2) }
Msg4(r+1)
Install PTK ?
○4
next transmitted frame(s) will reuse nonces
Enc1
ptk{ Data(. . .) } Enc1
ptk{ Data(. . .) } ○5
Figure 4: Key reinstallation attack against the 4-way handshake, when the supplicant (victim) still accepts plaintext
retransmissions of message 3 if a PTK is installed.
counter r + 1 in Figure 4. As a result, these AP will install the PTK,
and will start sending encrypted unicast data frames to the client.
Although Figure 4 only illustrates nonce reuse in frames sent by
the client, our attack also enables us to replay frames. First, after
the client reinstalls the GTK in stage 3 of the attack, broadcast and
multicast frames that the AP sent after retransmitting message 3
can be replayed. This is because replay counters are also reset when
reinstalling a key. Second, if we can make the AP install the PTK,
we can also replay unicast frames sent from the AP to the client.
We confirmed that the attack shown in Figure 4 works against
MediaTek’s implementation of the Wi-Fi client, and against certain
versions of wpa_supplicant (see Section 6.3). How we attacked
other implementations is explained in the next section.
3.4 Encrypted Retransmission of message 3
We now describe how we can attack clients that, once they installed
the PTK, only accept encrypted retransmissions of message 3. To
accomplish this, we exploit an inherent race condition between the
entity executing the 4-way handshake, and the entity implementing
the data-confidentiality protocol.
As a warm-up, we first attack Android’s implementation of the
supplicant. Here we found that Android accepts plaintext retransmissions of message 3 when they are sent immediately after the
original message 3 (see column 4 of Table 1). Figure 5 shows why
Session F3: Crypto Pitfalls CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1318
Key Reinstallation Attacks: Forcing Nonce Reuse in WPA2 CCS’17, October 30–November 3, 2017, Dallas, TX, USA.
Main CPU Wireless NIC Adversary (MitM)
Supplicant (victim)
Msg1(r, ANonce) Msg1(r, ANonce)
Msg2(r, SNonce) Msg2(r, SNonce)
○1
Msg3(r+1; GTK)
Msg3(r+2; GTK)
Msg3(r+1; GTK)
Msg3(r+2; GTK)
○2
Msg4(r+1)
Msg4(r+1)
Install-keys command
Install PTK & GTK
○3
Msg4(r+2) Enc1
ptk{ Msg4(r+2) }
Install-keys command
Reinstall PTK & GTK
○4
next transmitted frame will reuse nonce 1
Data(. . .) Enc1
ptk{ Data(. . .) }
○5
Figure 5: Key reinstallation attack against the 4-way handshake, when the victim accepts a plaintext message 3 retransmission if sent instantly after the first one. We assume
encryption and decryption is offloaded to the wireless NIC.
this happens, and how it can be exploited. Note that the AP is not
drawn in this figure: its actions are clear from context. In our attack,
we first let the client and AP exchange Message 1 and 2. However,
we do not forward the first message 3 to the client. Instead we wait
until the AP retransmits a second message 3. In stage two of the
attack, we send both message 3’s instantly after one another to the
client. The wireless NIC, which implements the data-confidentiality
protocol, does not have a PTK installed, and hence forwards both
messages to the packet receive queue of the main CPU. The main
CPU, which implements the 4-way handshake, replies to the first
message 3 and commands the wireless NIC to install the PTK. In
stage 4 of the attack, the main CPU of the client grabs the second
message 3 from its receive queue. Although it notices the frame
was not encrypted, Android and Linux allow unencrypted EAPOL
frames as an exception, and therefore the main CPU will process
the retransmitted message 3. Because the NIC has just installed the
PTK, the reply will be encrypted with a nonce value of 1. After this,
it commands the wireless NIC to reinstall the PTK. By doing this,
the NIC resets the nonce and replay counter associated to the PTK,
meaning the next transmitted data frame will reuse nonce 1.
Main CPU Wireless NIC Adversary (MitM)
Supplicant (vitcim)
initial 4-way or FT handshake
Install PTK & GTK
○1
pairwise rekey in progress
Encx
ptk{ Msg3(r+1; GTK) }
Encx+1
ptk { Msg3(r+2; GTK) }
Msg3(r+1; GTK)
Msg3(r+2; GTK)
○2
Msg4(r+1) Ency
ptk{ Msg4(r+1) }
Install-keys command
Install PTK′ & GTK
○3
Msg4(r+2) Enc1
ptk′
{ Msg4(r+2) }
Install-keys command
Reinstall PTK′ & GTK
○4
next transmitted frame will reuse nonce 1
Data(. . .) Enc1
ptk′
{ Data(. . .) }
○5
Figure 6: Key reinstallation attack against the 4-way handshake, when the victim only accepts encrypted message 3
retransmissions once a PTK is installed. We assume encryption and decryption is offloaded to the wireless NIC.
We now show how to attack OpenBSD, OS X, and macOS (see
Table 1 column 5). These devices only accept encrypted retransmissions of message 3. Similar to the Android attack, we abuse race
conditions between the wireless NIC and main CPU. However, we
now target a 4-way handshake execution that refreshes (rekeys) the
PTK. Recall from Section 2.3 that all messages transmitted during a
rekey undergo encryption by the data-confidentiality protocol.
Figure 6 illustrates the details of the attack. Note that the AP is
not draw in this figure: its actions are clear from context. Again the
adversary uses a channel-based MitM position [70]. She then lets
the victim and adversary execute the initial 4-way handshake, and
waits until a second 4-way handshake is initiated to refresh the PTK.
Even though she only sees encrypted frames, messages in the 4-way
handshake can be detected by their unique length and destination.
At this point, the attack is analogous to the Android case. That is,
in stage 2 of the attack, the adversary does not instantly forward
the first message 3. Instead, she waits until the AP retransmits
message 3, and then forwards both messages right after one another
to the victim (see Figure 6 stage 2). The wireless NIC will decrypt
Session F3: Crypto Pitfalls CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1319
CCS’17, October 30–November 3, 2017, Dallas, TX, USA. Mathy Vanhoef and Frank Piessens
both messages using the current PTK, and forwards them to the
packet receive queue of the main CPU. In the third stage of the
attack, the main CPU of the victim processes the first message 3,
replies to it, and commands the NIC to install the new PTK. In
the fourth stage, the main CPU picks the second message 3 from
the receive queue. Since a PTK is installed, OpenBSD, OS X, and
macOS (here called the main CPU) will mandate that the message
was encrypted. However, they do not check under which key the
message was encrypted. As a result, even though the message was
decrypted under the old PTK, the main CPU will process it. The
message 4 sent as a reply is now encrypted under the new PTK
using a nonce value of 1. After this, the main CPU commands the
NIC to reinstall the PTK, thereby resetting the nonce and replay
counters. Finally, the next data frame that the victim transmits
will again be encrypted using the new PTK with a nonce of 1. We
confirmed this attack against OpenBSD 6.1, OS X 10.9.5, and macOS
Sierra 10.12.
OpenBSD is only vulnerable if encryption is offloaded to the wireless NIC. For example, the iwn driver and associated devices support
hardware encryption, and therefore are vulnerable. However, the
rum driver performs software encryption in the same entity as the
4-way handshake, and is not vulnerable (see Table 1 column 5).
This attack technique requires us to wait until a rekey of the
session key occurs. Several APs do this every hour [66], some examples being [24, 26]. In practice, clients can also request a rekey by
sending an EAPOL frame to the AP with the Request and Pairwise
bits set. Coincidently, Broadcom routers do not verify the authenticity (MIC) of this frame, meaning an adversary can force Broadcom
APs into starting a rekey handshake. All combined, we can assume
a rekey will eventually occur, meaning an adversary can carry out
the key reinstallation attack.
3.5 Attacking the PeerKey Handshake
The PeerKey handshake is related to the 4-way handshake, and
used when two clients want to communicate with each other directly in a secure manner. It consists of two phases [1, §12.7.8]. In
the first phase, a Station-To-Station Link (STSL) Master Key (SMK)
handshake is performed. It negotiates a shared master secret between both clients. In the second phase, a fresh session key is
derived from this master key using the STSL Transient Key (STK)
handshake. Although this protocol does not appear to be widely
supported [49], it forms a good test case to gauge how applicable
our key reinstallation technique is.
Unsurprisingly, the SKM handshake is not affected by our key
reinstallation attack. After all, the master key negotiated in this
handshake is not used by a data-confidentiality protocol, meaning
there are no nonces or replay counters to reset. However, the STK
handshake is based on the 4-way handshake, and it does install a
key for use by a data-confidentiality protocol. As a result, it can
be attacked in precisely the same manner as the 4-way handshake.
The resulting attack was tested against wpa_supplicant. To carry
out the test, we modified another wpa_supplicant instance to send
a second (retransmitted) message 3. This confirmed that an unmodified wpa_supplicant will reinstall the STK key when receiving a
retransmitted message 3 of the STK handshake. However, we did
Table 2: Behaviour of Access Points. The 2nd column shows
whether it accepts replay counters it used in a message to the
client, but did not yet receive in a reply, or if it only accepts
the latest used counter. Column 3 shows whether the GTK
is installed immediately after sending group message 1, or if
this is delayed until all clients replied with group message 2.
Implementation Replay Check GTK Install Time
802.11 standard not yet received delayed
Broadcom latest only immediate
Hostapd not yet received delayed
OpenBSD latest only delayed
MediaTek latest only immediate
Aironet (Cisco) latest only immediate
Aerohive not yet received delayed
Ubiquiti not yet received delayed
macOS Sierra 10.12 latest only a
immediate
Windows 7 latest only The group key is
Windows 10 latest only never refreshed
a Retransmitted handshake messages do not use a new replay counter, so at all times there is only one allowed value.
not find other devices that support PeerKey. As a result, the impact
of our attack against the PeerKey handshake is rather low.
4 BREAKING THE GROUP KEY HANDSHAKE
In this section we apply our key reinstallation technique against the
group key handshake. We show all Wi-Fi clients are vulnerable to
it, enabling an adversary to replay broadcast and multicast frames.
4.1 Details of the Group Key Handshake
Networks periodically fresh the group key, to assure that only recently authorized clients posses this key. In the most defensive case,
the group key is renewed whenever a client leaves the network. The
new group key is distributed using a group key handshake, and this
handshake has been formally proven as secure in [39]. As shown
in Figure 2, the handshake is initiated by the AP when it sends a
group message 1 to all clients. The AP retransmits this message if
it did not receive an appropriate reply. Note that the EAPOL replay
counter of these retransmitted messages is always incremented
by one. In our attack, the goal is to collect a retransmitted group
message 1, block it from arriving at the client, and forward it to
the client at a later point in the time. This will trick to client into
reinitializing the replay counter of the installed group key.
The first prerequisite of our attack, is that clients will reinitialize
the replay counter when installing an already-in-use group key.
Since clients also use the MLME-SETKEYS.request primitive to
install the group key, this should be the case. We confirmed that in
practice all Wi-Fi clients indeed reinitialize the replay counter of
an already-in-use group key (see Table 1 column 7). Therefore, all
Wi-Fi clients are vulnerable to our subsequent attacks.
Session F3: Crypto Pitfalls CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1320
Key Reinstallation Attacks: Forcing Nonce Reuse in WPA2 CCS’17, October 30–November 3, 2017, Dallas, TX, USA.
The second prerequisite is that we must be able to collect a group
message 1 that the client (still) accepts, and that contains a group
key that is already in use by the AP. How to achieve this depends
on when the AP starts using the new group key. In particular, the
AP may start using the new group key immediately after sending
the first group message 1, or it may delay the installation of the
group key until all clients replied using group message 2. Table 2,
column 3, summarizes this behaviour for several APs. Note that
according to the standard, the new group key should be installed
after all stations replied with a group message 2, i.e., the GTK
should be installed in a delayed fashion [1, Fig. 12-53]. When the
AP immediately installs the group key, our key reinstallation attack
is straightforward. However, if the AP installs the group key in a
delayed fashion, our attack becomes more intricate. We will discuss
both these cases in more detail in Section 4.2 and 4.3, respectively.
Recall from Section 2.3 that only the AP will transmit real broadcast and multicast frames (i.e., group frames) which are encrypted
using the group key. Since our key reinstallation attack targets the
client, this means we cannot force nonce reusing during encryption.
However, the client resets the replay counter when reinstalling the
group key, which can be abused to replay frames towards clients.
Most APs refresh the group key every hour. Some networks even
refresh this key whenever a client leaves the network. Additionally,
clients can trigger a group key handshake by sending an EAPOL
frame having the flags Request and Group [1, §12.7.7.1]. Again,
Broadcom routers do not verify the authenticity of this message,
meaning an attacker can forge it to trigger a group key update. All
combined, we can assume most networks will eventually execute a
group key update, which we can subsequently attack.
4.2 Attacking Immediate Key Installation
Figure 7 illustrates our key reinstallation attack when the AP immediately installs the group key after sending group message 1 to all
clients. Notice that the group key handshakes messages themselves
are encrypted using the data-confidentiality algorithm under the
current PTK. On receipt of group message 1, the client installs the
new GTK, and replies with group message 2. The adversary blocks
this message from arriving at the AP. Hence, the AP will retransmit
a new group message 1 in stage 2 of the attack. We now wait until
a broadcast data frame is transmitted, and forward it to the victim.
After this, we forward the retransmitted group message 1 from
stage 2 to the victim. As a result, the victim will reinstall the GTK,
and will thereby reinitialize its associated replay counter. This allows us to replay the broadcast data frame (see stage 5). The client
accepts this frame because its replay counter was reinitialized.
It is essential that the broadcast frame we replay is sent before the
retransmission of group message 1. This is because group message 1
contains the group key’s current value of the replay counter (recall
Section 2.5). Therefore, if it is sent after the broadcast frame, it
would contain the updated replay counter and therefore cannot be
abused to reinitialize the replay counter of the victim.
We confirmed this attack in practice for APs that immediately
install the group key after sending group message 1 (see Table 2 column 3). Based on our experiments, all Wi-Fi clients are vulnerable
to this attack when connected to an AP behaving in this manner.
Supplicant (victim) Adversary (MitM) Authenticator
initial 4-way or FT handshake
Refresh GTK
Encx
ptk{ Group1(r; GTK) } Encx
ptk{ Group1(r; GTK) }
Install GTK Install GTK
Ency
ptk{ Group2(r) }
○1
Encx+1
ptk { Group1(r+1; GTK) } ○2
Enc1
gtk Enc { GroupData(. . .) } 1
gtk{ GroupData(. . .) } ○3
Encx+1
ptk { Group1(r+1; GTK) }
Reinstall GTK
○4
Enc1
gtk{ GroupData(. . .) } ○5
Figure 7: Key reinstallation attack against the group key
handshake, when the authenticator (AP) immediately installs the GTK after sending a Group Message 1 to all clients.
4.3 Attacking Delayed Key Installation
Attacking the group key handshake when the AP installs the GTK
in a delayed fashion is more tedious. Note that the previous attack
would fail because the broadcast frame transmitted in stage 3 of
Figure 7 would still be encrypted under the old group key. Indeed,
at this point the AP did not yet receive group message 2 from the
client, meaning it is still using the old group key. This is problematic
because group message 1 (re)installs the new group key, and hence
cannot be abused to reset the replay counter of the old group key.
One way to deal with this problem is illustrated in Figure 8. The
first two stages of this attack are similar to the previous one. That is,
the AP generates a new group key, transports it to the victim, and
the adversary blocks group message 2 from arriving at the AP. This
makes the AP retransmit group message 1 using an incremented
EAPOL replay counter of r + 1. In stage 3 of the attack, however,
we forward the older group message 2 with replay counter value r
to the AP. Interestingly, the AP should accept this message even
though it does not use the latest replay counter value [1, §12.7.7.3]:
On reception of [group] message 2, the AP verifies
that the Key Replay Counter field value matches one
it has used in the group key handshake.
The standard does not require that the replay counter matches the
latest one that the AP used. Instead, it must match one that was
used in the group key handshake, that is, one used in any of the
(re)transmitted group message 1’s. In practice we discovered that
several implementations indeed accept this older not-yet-received
replay counter (see Table 2 column 2). As a result, the AP installs the
Session F3: Crypto Pitfalls CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1321
CCS’17, October 30–November 3, 2017, Dallas, TX, USA. Mathy Vanhoef and Frank Piessens
Supplicant (victim) Adversary (MitM) Authenticator
initial 4-way or FT handshake
Refresh GTK
Encx
ptk{ Group1(r; GTK) } Encx
ptk{ Group1(r; GTK) }
Install GTK
○1
Ency
ptk{ Group2(r) }
Encx+1
ptk { Group1(r+1; GTK) } ○2
Ency
ptk{ Group2(r) }
Install GTK
○3
Enc1
gtk Enc { GroupData(. . .) } 1
gtk{ GroupData(. . .) } ○4
Encx+1
ptk { Group1(r+1; GTK) }
Reinstall GTK
○5
Enc1
gtk ○6 { GroupData(. . .) }
Figure 8: Key reinstallation against the group key handshake, when the AP installs the GTK after accepting replies
with a non-yet-received replay counter from all clients.
new group key. From this point on, the attack proceeds in a similar
fashion as the previous one. That is, we wait until a broadcast frame
is transmitted, perform the group key reinstallation in stage 5 of
the attack, and then replay the broadcast frame in stage 6.
Again it is essential that the broadcast frame we want to replay
is sent before the retransmission of group message 1. Otherwise it
includes the updated replay counter of the group key.
We tested this attack against APs that install the GTK in a delayed
fashion, and that accept replay counters it has used in a message to
the client, but did not yet receive in a reply (recall Table 2 column 2).
Note that we already know that all Wi-Fi clients reset the replay
counter when reinstalling a GTK, and hence are all vulnerable.
Finally, an OpenBSD AP is not vulnerable because it installs the
GTK in a delayed fashion, and only accepts the latest replay counter.
5 ATTACKING THE 802.11R FT HANDSHAKE
In this section we introduce the Fast BSS Transition (FT) handshake,
and show that implementations of it are also affected by our key
reinstallation attack.
5.1 The Fast BSS Transition (FT) Handshake
Amendment 802.11r added the Fast Basic Service Set (BSS) Transition (FT) handshake to 802.11 [5]. Its goal is to reduce the roaming
time when a client moves from one AP, to another one of the same
protected network (i.e. of the same Basic Service Set). Traditionally,
this required a handshake that includes a new 802.1x and 4-way
handshake (recall Figure 2). However, because the FT handshake
relies on master keys derived during a previous connection with
the network, a new 802.1x handshake is not required. Additionally,
it embeds the 4-way handshake stage in the authentication and
reassociation frames.
A normal FT handshake is shown in stage 1 of Figure 9. Observe
that unlike the 4-way handshake, the FT handshake is initiated
by the supplicant. The first two messages are an Authentication
Request (AuthReq), and an Authentication Response (AuthResp).
They are functionality equivalent to Message 1 and 2 of the 4-way
handshake, respectively, and carry randomly generated nonces that
will be used to derive a fresh session key. After this, the client
sends a Reassociation Request (ReassoReq), and the AP replies
with a Reassociaton Response (ReassoResp). They are similar in
functionality to Message 3 and 4 of the 4-way handshake, finalize
the FT handshake, and transport the GTK to the client.
Only the two reassociation messages are authenticated using a
MIC (see Figure 9). Additionally, none of the messages in the FT
handshake contain a replay counter. Instead, the FT handshake relies on the random SNonce and ANonce to provide replay protection
between different invocations of the handshake [1, §13.5.2].
According to the standard, the PTK must be installed after the
authentication response is sent or received [1, §13.9]. This is illustrated by the gray boxes in stage 1 of Figure 9. Additionally, the
802.1x logical port is only opened after sending or receiving the reassociation request. This assures that, even though the PTK is already
installed while the handshake is still in progress, the AP and client
only transmit and accept data frames once the handshake completed. Combined, this implies that the FT handshake, as defined
in the 802.11r amendment, is not vulnerable to a key reinstallation
attack. However, through experiments and code inspections, we
found that most implementations actually install the PTK, as well as
the GTK, after sending or receiving the reassociation response. This
behaviour is illustrated by the black boxes in stage 1 of Figure 9. As
a result, in practice most implementations of the FT handshake are
vulnerable to a key reinstallation attack.
5.2 A Key Reinstallation Attack against the AP
Since the AP installs the PTK in response to a reassociation request,
our goal will be to replay this frame. We remark that, in practice,
APs must accept retransmissions of reassociation requests. This is
because the reassociation response of the AP may be lost due to
background noise, making the client send a new request.
Figure 9 shows the resulting key reinstallation attack against the
FT handshake. Note that we do not require a man-in-the-middle
position. Instead, being able to eavesdrop and inject frames is sufficient. In the first stage of the attack, we let the client and AP execute
a normal FT handshake. We then wait until the AP has transmitted
one or more encrypted data frames. At this point, we replay the
reassociation request to the AP. Because it does not contain a replay counter, and has a valid MIC, the AP will accept and process
the replayed frame. As a result, the AP will reinstall the PTK in
stage 3 of the attack, thereby resetting the associated nonce and
replay counter. Finally, the next data frame sent by the AP will be
encrypted using an already used nonce. Similar to our previous key
Session F3: Crypto Pitfalls CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1322
Key Reinstallation Attacks: Forcing Nonce Reuse in WPA2 CCS’17, October 30–November 3, 2017, Dallas, TX, USA.
Supplicant (client) Adversary Authenticator (victim)
AuthReq(SNonce)
AuthResp(ANonce, SNonce)
Install PTK ? Install PTK ?
ReassoReq(ANonce, SNonce, MIC)
ReassoResp(ANonce, SNonce, MIC; GTK)
Install PTK & GTK Install PTK
○1
Enc1
ptk{ Data(. . .) } ○2
ReassoResp(A/Snonce, MIC; GTK)
ReassoResp(ANonce, SNonce, MIC; GTK)
Reinstall PTK
○3
next transmitted frame(s) will reuse nonces
Enc1
ptk{ Data(. . .) } ○4
Figure 9: Key reinstallation attack against the Fast BSS Transition (FT) handshake. Note that a MitM position is not required, only the ability to eavesdrop and replay frames.
reinstallation attacks, this also enables an attacker to replay old
data frames sent by the client to the AP. We remark that our attack
is particularly devastating against the FT handshake because its
messages do not contain replay counters. This enables an adversary to replay the reassociation request continuously, each time
resetting both the nonce and replay counter used by the AP.
We tested this attack against all our three APs supporting 802.11r.
The first is the open source hostapd implementation, the second is
MediaTek’s implementation for home routers running on a Linksys
RE7000, and the third is a professional Aerohive AP. All three were
vulnerable to the above key reinstallation attack.
Note that if the reassociation response is lost due to background
noise, the client will retransmit the reassociation request spontaneously, causing the AP to reinstall the key. That is, without an
adversary being present, APs may already be reusing nonces.
Note that messages in the FT handshake never undergo (additional) protection using a data-confidentiality protocol. In particular,
Management Frame Protection (MFP) does not protect authentication and reassociation frames [1, §12.6.19]. Hence, key reinstallation
attacks against the FT handshake are trivial even if MFP is enabled.
5.3 Abusing BSS Transition Requests
An FT handshake is only performed when a station roams from one
AP to another. This limits when an attack can take place. However,
we can force a victim to perform an FT handshake as follows. First,
assume a client is connected to an AP of a network that supports
802.11r. Then, if no other AP of this network is within range of
the client, we clone a real AP of this network next to the client
using a wormhole attack [41]. This makes the client think another
AP of the targeted network is nearby. Finally, we send a BSS Transition Management Request to the client. This frame is used for
load balancing [1, 11.24.7] and commands the client to roam to
another AP. It is an unauthenticated management frame, and hence
can be forged by an adversary. Consequently, the client accepts this
frame, and roams to the (wormholed) AP using an FT handshake.
We tested this against clients supporting 802.11r. This confirmed
that wpa_supplicant, iOS [8], and Windows 10 [52] accept the
transition request, and roam to another AP using an FT handshake.
6 EVALUATION AND DISCUSSION
In this section we evaluate the impact of nonce reuse for the dataconfidentiality protocols of 802.11, present example attack scenarios, discuss implementation specific vulnerabilities, explain why
security proofs missed our attacks, and present countermeasures.
6.1 Impact of Nonce Reuse in 802.11
The precise impact of nonce reuse caused by our attacks depends on
the data-confidentiality protocol being used. Recall that this can be
either TKIP, CCMP, or GCMP. All three protocol use a stream cipher
to encrypt frames. Therefore, reuse of a nonce always implies reuse
of the keystream. This can be used to decrypt packets. We remark
that in our attack the replay counter of the victim is also reseted.
Therefore, all three protocols are also vulnerable to replay attacks.
When TKIP is used, we can also recover the MIC key as follows.
First, we abuse nonce reuse to decrypt a full TKIP packet, including
its MIC field. Then we attack the weak Michael algorithm: given
the plaintext frame and its decrypted MIC value, we can recover
the MIC key [66]. Because TKIP uses a different MIC key for each
communication direction (recall Section 2.4), this allows us to forge
frames in one specific direction. The origin of this direction is the
device targeted by the key reinstallation attack. Table 3 summarizes
this under the rows mentioning TKIP.
When CCMP is used, practical attacks are restricted to replay and
decryption of packets. Although there is some work that discusses
message forging attacks when nonces are repeated, the attacks are
theoretic and cannot be used to forge arbitrary messages [31].
When GCMP is used, the impact is catastrophic. First, it is possible to replay and decrypt packets. Additionally, it is possible to
recover the authentication key [43], which in GCMP is used to protect both communication directions (recall Section 2.4). Therefore,
unlike with TKIP, an adversary can forge packets in both directions.
Given that GCMP is expected to be adopted at a high rate in the next
few years under the WiGig name [58], this is a worrying situation.
In general an adversary can always replay, decrypt, or forge packets in a specific communication direction. The concrete direction
depends on the handshake being attacked. For example, because
the 4-way handshake attacks the client, it can be used to: (1) replay
unicast and broadcast/multicast frames towards the client; (2) decrypt frames sent by the client to the AP; and (3) forge frames from
the client to the AP. However, against the FT handshake we attack
the AP instead of the client, meaning we can replay, decrypt, and/or
Session F3: Crypto Pitfalls CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1323
CCS’17, October 30–November 3, 2017, Dallas, TX, USA. Mathy Vanhoef and Frank Piessens
Table 3: Impact of our key reinstallation attack against the
4-way, FT, and group key handshake, in function of the dataconfidentiality protocol used. Each cell shows in which direction frames can be replayed, decrypted, or forged.
Replay c Decrypt a Forge
4-way impact
TKIP AP → client client→ AP client→ AP b
CCMP AP → client client→ AP
GCMP AP → client client→ AP client↔ AP b
FT impact
TKIP client→ AP AP → client AP → client
CCMP client→ AP AP → client
GCMP client→ AP AP → client AP ↔ client b
Group impact
any AP → client c
a With this ability, we can hijack TCP connections to/from an
Internet endpoint and inject data into them.
b With this ability, we can use the AP as a gateway to inject packets
towards any device connected to the network.
c This denotes in which direction we can replay unicast and groupaddressed frames. For the group key handshake, only groupaddressed frames can be replayed.
forge packets in the reverse directions. Table 3 in the Appendix
summarizes this, taking into account the handshake being attacked.
Finally, in various cases we can forge messages from the client
towards the AP (see Table 3). Interestingly, the AP is generally not
the final destination of a frame, and instead will forward the frame
to its real destination. This means we can forge packets towards
any device connected to the network. Depending on the AP, it is
even possible to send a frame that is reflected back to the client.
6.2 Example Attack Scenarios
Among other things, our key reinstallation attacks allow an adversary to decrypt a TCP packet, learn the sequence number, and
hijack the TCP stream to inject arbitrary data [37]. This enables
one of the most common attacks over Wi-Fi networks: injecting
malicious data into an unencrypted HTTP connection.
The ability to replay broadcast and multicast frames, i.e., group
frames, is also a clear security violation. To illustrate how this could
impact real systems, consider the Network Time Protocol (NTP)
operating in broadcast mode. In this mode, the client first goes
through an initialization process, and then synchronizes its clock
by listening to authenticated broadcast NTP packets [53]. Malhotra and Goldberg have shown that if these broadcast frames are
replayed, victims get stuck at a particular time forever [48]. Using
our group key attack, we can replay these frames even if they are
sent over a protected Wi-Fi network. Note that manipulating the
time in this manner undermines the security of, for example, TLS
certificates [44, 54, 61], DNSSEC [47], Kerberos authentication [47],
and bitcoin [25]. Another example is the xAP and xPL home automation protocol. These generally use broadcast UDP packets to
send commands to devices [40]. We conjecture that our key reinstallation attack allows us to replay these commands. All combined,
these examples illustrate that the impact of replaying broadcast or
multicast frames should not be underestimated.
6.3 All-Zero Encryption Key Vulnerability
Our key reinstallation attack against the 4-way handshake uncovered special behavior in wpa_supplicant. First, version 2.3 and
lower are vulnerable to our attacks without unexpected side-effects.
However, we found that version 2.4 and 2.5 install an all-zero encryption key (TK) when receiving a retransmitted message 3. This
vulnerability appears to be caused by a remark in the 802.11 standard that indirectly suggests to clear the TK from memory once it
has been installed [1, §12.7.6.6]. Version 2.6 fixed this bug by only
installing the TK when receiving message 3 for the first time [50].
However, when patching this bug, only a benign scenario was considered where message 3 got retransmitted because message 4 was
lost due to background noise. They did not consider that an active
attacker can abuse this bug to force the installation of an all-zero
key. As a result, the patch was not treated as security critical, and
was not backported to older versions. Independent of this bug, all
versions of wpa_supplicant reinstall the group key when receiving a retransmitted message 3, and are also vulnerable to the group
key attack of Section 4.
Because Android internally uses a slightly modified version of
wpa_supplicant, it is also affected by these attacks. In particular, we inspected the official source code repository of Android’s
wpa_supplicant [32, 34], and found that all Android 6.0 releases
contain the all-zero encryption key vulnerability. Android Wear 2.0
also is vulnerable to this attack. Though third party manufacturers
might use a different wpa_supplicant version in their Android
builds, this is a strong indication that most Android 6.0 releases
are vulnerable. In other words, 31.2% of Android smartphones are
likely vulnerable to the all-zero encryption key vulnerability [33].
Finally, we also empirically confirmed that Chromium is vulnerable
to the all-zero encryption key vulnerability [68].
6.4 Limitations of the Security Proofs
Interestingly, our attacks do not violate the security properties
proven in formal analysis of the 4-way and group key handshake.
First, He et al. proved that the 4-way handshake provides key
secrecy and session authentication [39]. Key secrecy states that
only the authenticator and supplicant will posses the PTK. Since
we do not recover the PTK, this properly still holds. Session authentication was proven using the standard notion of matching
conversations [39]. Intuitively, this says a protocol is secure if the
only way that an adversary can get a party to complete the protocol is by faithfully relaying messages [12]. Our attacks, including
the channel-based MitM position we employ, do not violate this
property: we can only make endpoints complete the handshake by
forwarding (retransmitted) messages.
Second, He et al. proved key ordering and key secrecy for the
group key handshake [39]. Key ordering assures that supplicants
do not install an old GTK. This remains true in our attack, since we
reinstall the current group key. Additionally, we do not learn the
group key, hence key secrecy is also not violated by our attacks.
Session F3: Crypto Pitfalls CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1324
Key Reinstallation Attacks: Forcing Nonce Reuse in WPA2 CCS’17, October 30–November 3, 2017, Dallas, TX, USA.
However, the proofs do not model key installation. Put differently,
they do not state when the key is installed for use by the dataconfidentiality protocol. In practice, this means the same key can
be installed multiple times, thereby resetting associated nonces
and/or replay counters used by the data-confidentiality protocol.
6.5 Countermeasures
Key reinstallation attacks can be mitigated at two layers. First, the
entity implementing the data-confidentiality protocol should check
whether an already-in-use key is being installed. If so, it should
not reset associated nonces and replay counters. This prevents our
attacks, at least if an adversary cannot temporarily trick an implementation into installing a different (old) key before reinstalling
the current one. In particular, when using this countermeasure it is
essential that the replay counter of received group key handshake
messages only increases. Otherwise, an adversary can use an old
group message 1 to make a victim temporarily install an old (different) key, to subsequently reinstall the current group key using a
more recent group message 1.
A second solution is to assure that a particular key is only installed once into the entity implementing the data-confidentiality
protocol during a handshake execution. For example, the generated
session key in a 4-way handshake should only be installed once.
When the client receives a retransmitted message 3, it should reply,
but not reinstall the session key. This can be accomplished by adding
a boolean variable to the state machine of Figure 3. It is initialized to
false, and set to true when generating a fresh PTK in PTK-START. If
the boolean is true when entering PTK-DONE, the PTK is installed
and the boolean is set to false. If the boolean is false when entering
PTK-DONE, installation of the PTK is skipped. Note that this is
precisely what version 2.6 and higher of wpa_supplicant is doing.
Proving the correctness of the above countermeasure is straightforward: we modeled the modified state machine in NuSMV [23],
and used this model to prove that two key installations are always
separated by the generation of a fresh PTK. This implies the same
key is never installed twice. Note that key secrecy and session
authentication was already proven in other works [39].
We are currently notifying vendors about the vulnerabilities we
discovered, such that they can implement these countermeasures.
A full list of vendors that are known to be affected by some variant
of our attacks will be made available at [22].
6.6 Discussion
There are some important lessons that can be learned from our
results. First, the specification of a protocol should be sufficiently
precise and explicit. For example, when attacking the 4-way handshake in Section 3.3, we observed that the 802.11 standard is ambiguous as to which replay counter values should be accepted. A
more precise or formal specification would avoid any such potential
incorrect interpretations.
Second, it is not because a protocol has been formally proven
secure, that implementations of it are also secure. In our case, the
model of the 4-way handshake used in formal proofs did not fully
reflect reality. This is because it did not define when the negotiated
session key should be installed. As a result, there was no guarantee
that a session key is installed just once. Only by reading real code
did we realize the formal model did not match reality, and that keys
may be reinstalled. In this regard, formal proofs may in fact be counterproductive: once a protocol is formally verified, the community
may become less interested in auditing actual implementations.
Interestingly, the observation that a model may be wrong, and
therefore does not accurately reflect reality, also applies to the proof
of our own countermeasure. Put differently, it is not because we
modeled the countermeasure in NuSMV, that all implementations
are now suddenly secure. In reality, our formal state machine may
not accurately reflect certain implementations, patches of vendors
may be flawed, or a vendor may be affected by as-of-yet unknown
variants of the attack. As a result, it is critical to keep auditing and
testing actual implementations.
Another lesson is that the data-confidentiality protocol should
provide some protection against nonce reuse. For example, with
GCMP the authentication key can be recovered in case of nonce
recuse, while this is not so for CCMP. More generally, a nonce
misuse-resistant encryption scheme should be used, examples being
AES-SIV, GCM-SIV, or HS1-SIV [16]. These reduce the impact of
nonce reuse, and hence also the impact of key reinstallation attacks.
7 RELATED WORK
In this section we explore the history of key reinstallation attacks,
and give an overview of other Wi-Fi and protocol security works.
7.1 Key Reinstallation Attacks
We are not aware of prior work on key reinstallation attacks. This
lack of prior work is likely one of the reasons why the cryptographic
Wi-Fi handshakes we investigated were still vulnerable to these
attacks. For example, only now did we discover that the 14-yearold 4-way handshake is vulnerable to key reinstallation attacks.
Moreover, this flaw is not just present in implementations, but in
the protocol specification (standard) itself.
One somewhat related scenario that also leads to nonce reuse
are power failures. Here, after a power failure, the key is restored
from non-violate memory on boot, but the nonce will be reset to
its initial value. Suggested solutions to this problem are given by
Zenner [76]. However, unlike key reinstallation attacks, triggering
power failures cannot be done remotely over a network. Instead,
this requires physical access to the device being attacked. Moreover,
power failures do not affect the security of the protocols we studied,
since these handshakes are precisely used to avoid maintaining
state between old and new connections.
In [16], Bock et al. discovered that some TLS servers were using
static nonces. This was caused by a faulty implementation of the TLS
record layer protocol. That is, it was not caused by a reinstallation
of an already-in-use key. Additionally, some servers used randomly
generated nonces, which means in practice nonce reuse is likely to
occur due to the birthday paradox. In contrast, key reinstallation
attacks allow an adversary to force nonce reuse on demand by
replaying handshake message(s), and are caused by flaws in the
specification (or implementation) of the handshake protocol.
McGrew wrote a survey of best practices for generating IVs
and nonces, and summarizes how they are generated and used in
several protocols [51]. However, in the discussion of security risks,
(variations of) key reinstallation attacks are not mentioned.
Session F3: Crypto Pitfalls CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1325
CCS’17, October 30–November 3, 2017, Dallas, TX, USA. Mathy Vanhoef and Frank Piessens
Another somewhat related work is that of Beurdouche et al. [14]
and that of de Ruiter and Poll [27]. They discovered that several
TLS implementations contained faulty state machines. In particular,
certain implementations wrongly allowed handshake messages to
be repeated. However, they were unable to come up with example
attacks that exploited the ability to repeat messages. We conjecture
that an adversary can repeat certain messages to trick an endpoint
into reinstalling the TLS session keys, i.e., a key reinstallation attack might be possible. We consider it interesting future work to
determine whether this leads to practical attacks.
Reuse of IVs is also an issue in the broken WEP protocol [17, 18].
In particular, Borisov et al. discovered that certain wireless network cards initialized the WEP IV to zero each time they were
(re)initialized. Consequently, keystreams corresponding to small
IVs are likely to be reused [18]. However, in contrast to key reinstallation attacks, these IV resets cannot be triggered remotely.
7.2 Wi-Fi and Network Protocol Security
In one of the first formal analysis of the 4-way handshake, He
and Mitchell discovered a denial-of-service vulnerability [38, 55].
This led to the standardization of a slightly improved 4-way handshake [1]. In 2005, He et al. presented a formal correctness proof
of both the 4-way handshake and the group key handshake [39].
However, they did not explicitly model cipher selection and downgrade protection. This enabled Vanhoef and Piessens to carry out a
downgrade attack against the 4-way handshake [72]. In their attack,
the AP is tricked into using RC4 to encrypt the group key when
it is transported in message 3. This attack is only possible if the
network supports WPA-TKIP, which was already known to be a
weak cipher [66, 69]. Additionally, the models employed in [39] do
not define when to install the negotiated session key or transported
group key. However, we showed this timing is in fact essential,
since otherwise key reinstallation attacks may be possible.
The FT handshake is based on the 4-way handshake [5], but there
are no formal security analysis of it. Instead, existing works focus
on the performance of the handshake, examples being [11, 46].
Several works study authentication mechanisms which negotiate
master keys (PMKs) [19, 21, 59, 75]. Some of these mechanisms rely
on first establishing a secure TLS session [9]. As a result, recent
attacks on TLS also affect these mechanisms, examples being [10, 14,
15, 27, 62]. In this paper we did not study mechanisms that negotiate
master keys, but instead focused on handshakes that derive fresh
session keys from such a negotiated or pre-shared master key.
Regarding data-confidentiality protocols, the first practical attack
on WPA-TKIP was found by Beck and Tews [66]. They showed
how to decrypt a small TKIP packet, recovered the MIC key, and
subsequently forged packets. Their attack was further improved
in several works [36, 67, 69, 70]. Researchers also attacked the
weak per-packet key construction of TKIP by exploiting biases in
RC4 [6, 57, 71]. Nowadays TKIP is deprecated by the Wi-Fi Alliance
due to its security issues [74].
Although CCMP received some criticism [60], it has been proven
to provide security guarantees similar to modes such as OCB [42].
In [31], Fouque et al. discusses theoretic message forging attacks
when nonces are repeated in CCMP.
The GCM cipher is known to be weak when short authentication
tags are used [29], and when nonces are reused [43]. Böck et al. empirically investigate nonce reuse when GCM is used in TLS [16], and
discovered several servers that reuse nonces. Our attack on GCMP
in 802.11 is unique because we can control when an endpoint reuses
a nonce, and because GCMP uses the same (authentication) key in
both communication directions. Several cryptographers recently
referred to GCM as fragile [35, 56].
Finally, other works highlighted security issues in either Wi-Fi
implementations or surrounding technologies. For example, design
flaws were discovered in Wi-Fi Protected Setup (WPS) [73], vulnerabilities were found in drivers [13, 20], routers were found to be
using predictable pre-shared keys [45], and and so on.
8 CONCLUSION
Despite the security proof of both the 4-way and group key handshake, we showed that they are vulnerable to key reinstallation
attacks. These attacks do not violate the security properties of the
formal proofs, but highlight limitations of the models employed by
them. In particular, the models do not specify when a key should be
installed for usage by the data-confidentiality protocol. Additionally, we showed that the PeerKey and fast BSS transition handshake
are vulnerable to key reinstallation attacks.
All Wi-Fi clients we tested were vulnerable to our attack against
the group key handshake. This enables an adversary to replay
broadcast and multicast frames. When the 4-way or fast BSS transition handshake is attacked, the precise impact depends on the
data-confidentiality protocol being used. In all cases though, it is
possible to decrypt frames and thus hijack TCP connections. This
enables the injection of data into unencrypted HTTP connections.
Moreover, against Android 6.0 our attack triggered the installation
of an all-zero key, completely voiding any security guarantees.
Rather worryingly, our key reinstallation attack even occurs
spontaneously if certain handshake messages are lost due to background noise. This means that under certain conditions, implementations are reusing nonces without an adversary being present.
An interesting future research direction is to determine whether
other protocol implementations are also vulnerable to key reinstallation attacks. Protocols that appear particularly vulnerable are
those that must take into account that messages may be lost. After
all, these protocols are explicitly designed to process retransmitted
frames, and are possibly reinstalling keys while doing so.

