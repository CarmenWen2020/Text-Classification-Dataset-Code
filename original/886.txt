Private information retrieval (PIR) is a fundamental tool for preserving query privacy when accessing outsourced data. All previous PIR
constructions have significant costs preventing widespread use. In
this work, we present private stateful information retrieval (PSIR),
an extension of PIR, allowing clients to be stateful and maintain
information between multiple queries. Our design of the PSIR primitive maintains three important properties of PIR: multiple clients
may simultaneously query without complex concurrency primitives, query privacy should be maintained if the server colludes
with other clients, and new clients should be able to enroll into the
system by exclusively interacting with the server.
We present a PSIR framework that reduces an online query to
performing one single-server PIR on a sub-linear number of database records. All other operations beyond the single-server PIR
consist of cryptographic hashes or plaintext operations. In practice,
the dominating costs of resources occur due to the public-key operations involved with PIR. By reducing the input database to PIR,
we are able to limit expensive computation and avoid transmitting
large ciphertexts. We show that various instantiations of PSIR reduce server CPU by up to 10x and online network costs by up to
10x over the previous best PIR construction.
CCS CONCEPTS
• Security and privacy → Privacy-preserving protocols;
KEYWORDS
Private information retrieval; Cloud storage; Cryptography
1 INTRODUCTION
Private Information Retrieval (PIR) [18, 36] is a very important
privacy-preserving primitive for accessing data held by untrusted
servers. PIR enables clients to retrieve a record stored in a database
hosted by an untrusted server without revealing the record’s identity to the server and it has been used as a critical component in several systems such as friend discovery [11], publish-subscribe [17]
advertisement [25] and media consumption [27]. In this work, we
are interested in single-server PIR with computational security as
first considered by Kushilevitz and Ostrovsky [36].
Previous works on single-server PIRs considered stateless clients
as well as a stateless server that do not maintain information between queries and this implies the following three important properties.
• Parallel Access: The same PIR server can be simultaneously
used by several independent clients.
• Dynamic User Sets: The set of clients does not need to be
chosen ahead of time. New clients can be added to the system
without the intervention of existing clients and clients that
crash can easily recover and continue to use the system.
• Privacy Against Other Clients: Privacy for record retrieval
is guaranteed when the adversarial honest but curious server
is colluding with (possibly all) other clients.
Despite its wide applicability, PIR has not been used in applications because of its high costs. In a PIR protocol, the server is
required to perform at least one operation for each database record.
If a record is not involved in the computation of the reply, then
it is certainly not the one sought by the client. In practice, things
are even worse as, in most implementations of single-server PIR,
the server performs a linear number of expensive public-key operations.
In this paper, we introduce the concept of a Private Stateful Information Retrieval (PSIR), that extends the concept of a PIR without
losing any of the three desirable properties of PIR described above.
We give implementations of PSIR that drastically reduce communication and the server’s computational overhead compared to PIR.
Our main modification of PIR and PSIR lies in the fact that clients
are stateful. That is, a client may store information between queries.
The server of PSIR is stateless except for the database like in PIR.
Despite having a state, clients of PSIR execute retrieval operations
independently. Each retrieval only affects the state of the client
performing the retrieval and does not impact other clients in any
way. Together with the fact that the server is stateless, PSIR supports parallel access for multiple client without the need to deal
with concurrency issues. Furthermore, the initial state of a client is
obtained by the client by interacting solely with the server. Therefore, new clients (as well as crashed clients that lose their state) can
enter a PSIR scheme at any time without affecting existing clients.
For security, we wish to provide privacy for the client against both
the server as well as other possibly adversarial clients. Formally,
PSIR ensures that the identity of any records retrieved by any honest client remains private from the adversary even if the server is
colluding with all other clients. Overall, PSIR maintains the three
desirable properties of PIR while the availability of a client state in
PSIR will significantly improve the efficiency of private retrievals
as our constructions will show.
Session 5D: Encrypted Search & Computation 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 1002
1.1 Our Contributions
We show that PSIR is more efficient than PIR constructions by
giving a general construction for computationally secure PSIR with
practical instantiations. More precisely, let n be the number of
records in the database, let k be an adjustable parameter, 0 < k < n,
and suppose the client has memory to store c records. Our main
technical contribution consists in a reduction of a query in PSIR to
an online phase consisting of one blackbox PIR query on a database
of n/k records and the transfer of k seeds and k integers from client
to server. Both the client and server perform an additionalO(n) hash
evaluations and other simple operations. The reduction assumes
that the client has already performed an offline initialization phase
with O(n) communication that can be amortized overc queries thus
giving O(n/c) amortized communication.
As we have already pointed out, the dominating costs in practical
PIR constructions is constituted by public-key operations executed
by the server, usually over homomorphic ciphertexts. Previous PIR
constructions all required the server to execute at least n publickey operations per query. Our PSIR scheme replaces most of these
expensive public-key operations with simple, efficient operations.
We stress that our reduction does not add any other public-key
operation on top of the ones needed to execute PIR on a sub-linear
sized database. We note that our server still performs O(n) computation as otherwise our construction would not guarantee security.
As an example, we can concretely instantiate our construction by
setting k =
√
n which means only O(
√
n) public-key operations
are required. We construct PSIR using XPIR [5] as well as a PIR
construction built from the Paillier cryptosystem [43]. In addition,
we estimate costs for PSIR with SealPIR [7] using their reported
results.
Our concrete results are two-fold. We present a construction of
PSIR that outperforms the previous, best PIR construction in important resource costs for databases with 100K to 1M 288 byte records
(a standard database size experiment used in previous works [7]).
Specifically, we show that PSIR with Paillier outperforms SealPIR
by giving up to 4x speedup in server CPU, a 5-10x reduction in
online bandwidth and a 1.3-4x decrease in amortized total bandwidth. Furthermore, more than 50% of the total bandwidth can
be performed offline during cheaper, non-busy hours. We remark
though that PSIR with Paillier increases client CPU usage compared to SealPIR. In our opinion, these trade-offs are beneficial in
concrete terms. For 1M items, total client CPU increases to only 660
milliseconds while server CPU decreases by more than 4.5 seconds.
To achieve these benefits, the client uses up to 525 KB of state. We
note that 525 KB is less than 1/12 the network costs of generic XPIR
and is less than twice the network costs of generic SealPIR. On the
other hand, SealPIR requires the server to store 2.9 MB of auxiliary
cryptographic material for each client whereas PSIR with Paillier
does not require any extra storage beyond database.
In addition, we show that PSIR variants using XPIR and SealPIR
reduce resource costs compared to generic XPIR and SealPIR. In
terms of concrete savings, PSIR with XPIR results in a 12-28x
speedup in server CPU, up to 20x less online network costs and
17x less amortized network costs compared to generic XPIR. Our
estimates for PSIR with SealPIR result in an up to 10x speedup in
server CPU, but a slight increase in online network costs and an up
to 50% increase in amortized network costs compared to generic
SealPIR. Additionally, PSIR introduces an increase in client CPU of
at most 660 milliseconds in both cases. We still view the trade-offs
as excellent since, in concrete numbers, server CPU is decreased
by at least 4 seconds in both cases for 1M items. For network costs,
the benefits are clear for PSIR with XPIR. While network costs for
PSIR with SealPIR increase, the majority of the extra network costs
can be performed offline during off-peak periods. PSIR requires up
to 525 KB of state in all cases.
1.2 Relation to Other Privacy-Preserving
Storage Primitives
In the previous section, we presented PSIR as an extension of PIR.
Many other privacy-preserving storage and retrieval primitives
have been considered in previous works, We compare PSIR with
ORAM as well as extensions of PIR and ORAM and present a summary in Table 1.
ORAM. Oblivious RAM (ORAM) [23, 24] guarantees also privacy
of the blocks in addition to privacy of the access pattern. This implies that the client state contains the secret key used to decrypt the
block and, if any client were corrupted by the server then full privacy would be lost. The secret key enables ORAM to use sublinear
computation and bandwidth (the current, best ORAM construction
usesO(logn ·log logn) bandwidth and computation [44]). However,
since the server does not have the secret key, enrollment of new
clients would involve existing clients. In addition, in most ORAM
construction the client also has a location map mapping logical block
identity to physical server locations which dynamically changes as
physical blocks are accessed by the client. The presence of a location map would make parallel access very inefficient as performing
queries in parallel requires complex algorithms using expensive
concurrency primitives to enable access to shared resources.
Several previous works have considered extending the ORAM
scheme to enable access to a large group of clients [34, 38, 39, 50].
One way to extend ORAMs to multiple clients is to store a separate
ORAM scheme for each client. Each client is given the secret key
corresponding to their own ORAM scheme. As a result, a client may
only access their own ORAM and an adversarial server colluding
with other clients will not compromise privacy for honest clients.
New clients may also be added by constructing new ORAM schemes.
However, this scheme requires large storage since the database is
replicated once for each client unlike PSIR that stores the database
exactly once.
Another way to enable access to multiple clients is splitting
the ORAM (as well as the secret key) into shares and distributing
the shares to several non-colluding servers. To retrieve/overwrite
a record, the client performs a protocol with all non-colluding
servers to generate an access to the shared ORAM scheme. While
these schemes are efficient, they require the strong assumption
of multiple, non-colluding servers whereas PSIR focuses on the
single-server setting. ORAM and its multiple client extensions do
not provide practical solutions for enabling access to large groups
of clients efficiently and privately compared to PSIR.
Doubly Efficient PIR. Doubly Efficient PIR (DEPIR) refers to an
extension of PIR that allows a setup phase which preprocesses the
Session 5D: Encrypted Search & Computation 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 1003
Primitive Multiple Client
Access
Linear Server
Storage
Add New Clients/
Recover from Crash
Stateful
Server
Stateful
Client(s)
PIR [5, 7, 36] ✓ ✓ ✓
PSIR (This Paper) ✓ ✓ ✓ ✓
ORAM [23, 24, 44] ✓ ✓ ✓
Multiple Client ORAM [34, 38, 39, 50] ✓ ✓ ✓ ✓
Symmetric-Key DEPIR [12, 15] ✓
Public-Key DEPIR [12] ✓ ✓
PANDA [28] ✓ ✓ ✓
Table 1: This table compares single-server privacy-preserving storage systems. Multiple client access refers to systems that enable accessibility to large groups of clients while providing privacy against subsets of colluding clients. Add new clients/recover
from crash refers to servers with the capability to enroll stateless clients into the system.
database before any retrieval requests. Beyond the preprocessed
database, the server will be stateless. DEPIR schemes are categorized
into symmetric-key and public-key variants. In the symmetric-key
variant, each client must use a secret key to access the encoded
database. On the other hand, the public-key variant is accessible by
all clients. The first public-key DEPIR construction was presented
by Beimel et al. [9] in the multiple, non-colluding server setting that
is information-theoretically secure. More recently, Boyle et al. [12]
and Canetti et al. [15] present symmetric-key DEPIR schemes in
the single-server setting using locally decodable codes built from
Reed-Muller codes [42, 46]. In addition, Boyle et al. [12] present a
public-key DEPIR scheme using a variant of obfuscation. All above
DEPIR schemes ensure that both the client and server perform
a sub-linear number of operations compared to the database per
retrieval.
Both symmetric-key DEPIR and ORAM share the same problems
involving the secret key that must be shared by all clients that
require access to the database. Any extensions to multiple clients
will suffer the same problems as multiple client ORAM. On the
other hand, public-key DEPIR provides many useful properties
that are offered by PSIR. However, all public-key constructions
are built using very strong assumptions. The scheme of Beimel et
al. [9] requires multiple non-colluding servers while the scheme
of Boyle et al. [12] relies on non-standard assumptions involving
obfuscation while, also, requiring server storage super-linear in
the database size. Therefore, DEPIR schemes are not a practical
solution for privacy-preserving data access due to their reliance on
strong assumptions.
Private Anonymous Data Access. Hamlin et al. [28] have recently
introduced the Private Anonymous Data Access (PANDA) primitive.
PANDA is an extension of symmetric-key DEPIR where the server
is stateful and maintains information between multiple retrievals.
In addition, PANDA requires anonymity. That is, the adversary
cannot learn the identity of the querying clients which can be enforced by requiring clients to use anonymous mix networks [16].
Anonymity is an extra privacy feature of PANDA that is not provided by PSIR. Using leveled fully homomorphic encryption [13]
and Reed-Muller codes [42, 46], Hamlin et al. [28] present both a
read-only and public-write PANDA scheme. Public-writes are an
operation that are beyond the scope of PSIR, so we focus on the
read-only variant. Their PANDA scheme must be built using a collusion parameter that determines the maximum size of the subset
of colluding clients before privacy becomes compromised. Both
client and server operations as well as server storage grow linearly
in the collusion parameter. On the other hand, the client and server
operations for a private retrieval scale poly-logarithmically in the
database size.
In relation to PSIR that simply stores the database in plaintext,
their PANDA scheme requires server storage super-linear in the
size of the database even when providing no protection against
colluding clients. If we wish the PANDA scheme to be secure in the
setting that the server colludes with all clients except one, the server
would require storage larger than simply replicating the database
for each client. In comparison, our construction of PSIR outlined in
Section 1 guarantees privacy even when the server colludes with
all clients except one without sacrificing computational or storage
efficiency. Also, PANDA does not allow enrolling stateless clients
into the system by only interacting with the server unlike PSIR. As
a consequence, PANDA does not provide a practical solution.
2 TECHNICAL OVERVIEW
Our construction is inspired by the construction of PIR with side
information of Kadhe et al. [33] that considers the following hypothetical scenario. Suppose the client has obliviously obtained
some side information consisting of k − 1 records (thus the server
is unaware of which records are known to the client). Can the
client leverage on this side information to privately access other
records more efficiently? Kadhe et al. [33] show that the client can
randomly partition the database of n records into n/k parts of size
k such that the desired query record and all k − 1 records of side
information are in the same parts. The server will add all records
(that are represented as elements in a field) within the same parts
and return the n/k record sums to the client. The client discards all
sums except the sum of the desired record and the side information.
By subtracting the side information, the client successfully retrieves
the desired record. However, Kadhe et al. do not provide concrete
algorithms to privately obtain side information. Furthermore, the
network costs of communicating the partition and downloading all
n/k sums are significant.
In this paper, we present a construction of PSIR which addresses
these issues. Our PSIR relies on two main building blocks that
are of independent interest outside of PSIR: oblivious constrained
partitions and private batched sum retrieval. In addition, PSIR also
uses a single-server PIR scheme.
Session 5D: Encrypted Search & Computation 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 1004
• Oblivious Constrained Partitions (OCP). A OCP consists of
two algorithms: the construction algorithm and the expansion
algorithm. Given a constraintsubset S ⊆ [n] of size k, the construction algorithm OCP.GenerateSeed of an OCP returns
a succinct representation of a partition of [n], (P1, . . . , Pm),
into m = n/k parts, each of size k, such that one of the
m parts is equal to the constraint subset S. The obliviousness property guarantees that an adversary cannot correctly
guess whether the input constraint subset S contains a given
q ∈ [n] better than guessing at random. The expansion algorithm OCP.ExtractPartition, given a succinct description of
a partition, produces the actual partition. We give a construction algorithm that outputs a description of a partition consisting of k seeds of length equal to the security parameter λ
and k integers in [n]. Both the constructing and expanding
the description require O(n) PRF evaluations.
• Private Batched Sum Retrieval (PBSR). Given c subsets S1,
. . . , Sc ⊆ [n], the client wishes to privately retrieve c sums
corresponding to the sum of all records in each subset. That
is, for a database D = (B1, . . . , Bn), the client wishes to
retrieve the c sums: O1 =
Í
i ∈S1
Bi
, . . . ,Oc =
Í
i ∈Sc
Bi
.
This is an extension of private batched retrieval [30] where
only records, instead of sums of records, are retrieved. For
privacy, the adversary should not learn the c input subsets.
PSIR composes these primitives as follows. Assume the records
are elements of some finite fields and that the client has storage sufficient for containing c records. At the initialization phase, the client
and the server execute the private batched sum retrieval protocol
so that the client privately retrieves c sums of records, s1, . . . ,sc ,
where sum si
is over the set Si of k − 1 randomly chosen records
from the database. Now, suppose the client wishes to retrieve record
q and let Si be the next unused set that does not contain q. Using the
construction algorithm of an OCP with S = Si ∪ {q} as constraint
set, the client constructs an ordered partition P = (P1, . . . , Pm) and
let j be such that Pj = S. The client sends the succinct description of
P to the server. Upon receiving the description of the partition, the
server expands it and constructs a database where, for l = 1, . . . ,m,
the l-th record is the sum pl of all the records with index in part
Pl
. The client in addition constructs a query, using the underlying single-server PIR, to retrieve pj and sends the query to the
server. Then, the server executes the PIR query using (p1, . . . ,pm)
as the database and returns the PIR response to the client. Finally,
the client decrypts the PIR response to retrieve pj and obtains the
sought record by computing pj − si
. Once the client runs out of Si
,
the client will execute the private batched sum retrieval protocol
to gain new side information. Additionally, a client without state
(such as a new client or a crashed client that lost state) may execute
a private batched sum retrieval protocol with the server to start
performing retrievals.
Let us now give informal descriptions of our constructions for
OCP and PBSR.
Oblivious Constrained Partitions. Sampling a random partition
of [n] into m parts each of size k is equivalent to creating a random
assignment of the integers of [n] to the n cells of an m × k matrix
M, with each row corresponding to a part. The partition can be
succinctly described by the random seed to a PRF that is to be
96 55 ...
21 41 ...
35 2 17 ... 28
... ... ... ... ...
70 62 ...
P1
P2
P3
...
Pn/k
K1
,v1 K2
,v2
Figure 1: The constraint subset is embedded into the third
row. The pairs (K1,v1) and (K2,v2) succinctly represent the
first two ordered column subsets. The remaining columns
have not been generated yet.
used to generate the randomness of an agreed upon procedure for
sampling a random permutation, like, for example, Fisher-Yates [21].
The randomly sampled permutation is then used to assign integers
to the cells of the m × k matrix. However, we have two additional
goals. The first is of having a particular row be constrained to given
k values from the constraint set S. This could be easily achieved
by using Fisher-Yates to generate a permutation of n − k values
and then explicitly add the k constrains values to the seed of the
PRF used for Fisher-Yates. However, this method does not satisfy
our privacy requirement that the description of the partition be
oblivious to the constraints.
Let us consider the following warm-up construction based on
a family P of pseudorandom permutations. The construction algorithm randomly selects the constraint row 1 ≤ r ≤ m that will
contain the k elements {s1, . . . ,sk
} of the constraint set S and generates a pseudorandom permutation key for each column. For the first
column, a random key k1 is selected and the algorithm computes
ρ1 := P
−1
(k1,s1). The construction algorithm then evaluates P(k1, ·)
at values ρ1−1, ρ1−2, . . . ,so to obtain values M[r−1, 1], . . . , M[1, 1].
We let σ1 be the value such that M[1, 1] = P(k1, σ1); clearly, for column 1, we have σ1 = ρ1−(r−1). In addition, the algorithm evaluates
P(k1, ·) at values ρ1 +1, ρ1 +2, . . . to obtain M[r +1, 1], . . . , M[m, 1].
Once the first column T1 = M[⋆, 1] has been computed, the construction algorithm checks that it does not contain values from
the constrained row other than s1 and, if it does, a new key k1 is
randomly selected and the process is repeated until successful. The
first column T1 is succinctly specified by the key k1 and by the
integer σ1. The expansion algorithm reconstructs the column by
evaluating P(k1, x) for x = σ1, . . . , σ1 + (m − 1). For the second
column, the construction algorithm randomly selects key k2 and
does the same: that is, it sets ρ2 := P
−1
(k2,s2) and then evaluates
the PRP from ρ2 going back until the value M[1, 2] in row 1 is computed and forward until the value M[m, 2] is computed. As before,
the algorithm makes sure none of the remaining constrained row
values are used. If a value from the constrained row appears, then
a new key k2 is randomly selected and the selection of column
Session 5D: Encrypted Search & Computation 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 1005
2 starts again. Furthermore, it may be the case that a generated
value for column 2 appears in column 1. In this case, another key
k2 is generated randomly and the algorithm repeats. The expansion
algorithm, once column 1 has been reconstructed, obtains column
2 by repeatedly applying F(k2, ·) starting from σ2; if during the
reconstruction a value from column 1 appears, it is ignored and the
process continues until m values distinct from those appearing in
column 1 are obtained. The process continues until all k columns
have been specified.
There are two problems with this scheme: firstly, in the later
columns, we will have several collisions with values from previous
columns and this will require extra invocations of the PRP. We can
avoid this by using an indirection. Rather than treating the outputs
of the PRP as permuted values themselves, we will treat them as
pointers in a table T of unused values. Initially, T has all n unused
values and is ordered from 1 to n. For column 1, all PRP evaluations
are pointers to values in T . For example, if the evaluation at row 5
results in 11 then the actual value for row 5 is read from table as
T [11] which, for column 1, happens to be 11 also since all values are
unused. For the second column, we first remove all the values from
T that were used for column 1 and now have a modifiedT with n−m
ordered values. The domain of the PRP for the second column will
be 1, . . . ,n−m. This way we can avoid generating new permutation
keys by colliding with values from previous columns and we only
need to check that values from the constrained row values are not
used. The client continues this process for all k columns.
The second problem with PRP is that instantiating them securely
is quite expensive: in practice one would use PRP based on block
ciphers on small domains that can be constructed from secure
block ciphers at the cost of multiple evaluations (see, for example,
[41, 47]). Hence, we provide our main construction below that only
uses PRFs and is very efficient. Briefly, for each column, the PRF
F will generate m different values that are treated as a pointer to
get unused values from table T . This can be done by repeatedly
evaluating the F in increasing index until m different values appear.
For convenience, we will assume the first m invocations of F are
unique. As a result, F(K,i) will actually be the i-th unique value
appearing when evaluating F in increasing index. As the table size
or domain size changes column to column, the PRF output can be
simply mod-ed by the new domain size to get appropriate values,
as long as the original output of the PRF was large enough to keep
the biases negligible. However, we still have to guarantee that the
element in the constrained row of each column is an element from
the constrained set S. Unlike a PRP, we cannot invert the PRF and
find the correct index to start evaluating. Instead, the algorithm
will use an augmented description for the columns that consists
of the key k along with a displacement v. The displacement v is
computed to ensure that the r-th unique value produced by each
column PRF results in a specified index of T corresponding to a
value from the constrained set S. Thus, the expansion algorithm
will set the element in row 1 of a column described by (K,v) as
the one in position F(K, 1) + v of table T (with wrap-around if
necessary). The algorithm chooses v so that F(K,r) + v is the
current index in T of the constraint set S that is destined for row
r of the column being computed. The reconstruction algorithm is
straightforward: the partition is created column by column, using
the key to instantiate the PRP and encrypt forward to create pointers
to which the displacement v is added to get index for the table T .
After each column, the server removes the used values from the
table and the PRF works on a smaller domain for the next column.
The algorithm described above requires maintaining an ordered
table of the unused elements, that is the elements that have not
been assigned to a part yet, and this would require linear storage.
However, we observe that only the ranks of the unused elements of
the constraint set need to be maintained. For each element si from
the constraint set, the algorithm maintains the number of unused
elements that are smaller than si
. Indeed, after generating a column,
the algorithm only needs to check that the column contains the
rank of exactly one unused constraint subset element. Therefore,
we only explicitly store the rank of all constraint subset elements
that are used. Once a new column is obtained, the algorithm updates the ranks of the remaining unused items. As a consequence,
this algorithm requires O(k) storage to maintain the ranks and an
additional O(m) storage to explicitly store the generated column.
Private Batched Sum Retrieval. We present several different private batched sum retrieval protocols with both practical and theoretical interest. Recall as input, the protocol receives c subsets
S1, . . . , Sc ⊆ [n]. The protocol with the best performance on practical database sizes is also the simplest scheme, which simply downloads the entire database using n records of communication.
A more complex algorithm makes use of a private batched retrieval (PBR) scheme [7, 22, 26, 30]. The client constructs the set of
records used in the c sums, S = S1 ∪. . . ∪Sc . Additional records are
added to S until S has |S1 |+. . .+|Sc | records. Afterwards, the client
simply executes a PBR scheme to retrieve all records in S and adds
the records locally. This scheme requires only O(|S | · poly log(n))
records of communication andO(n) CPU computation. This scheme
makes sense for scenarios where network costs are significantly
higher than computation costs. In Appendix E, we present more
protocols of theoretical interest that use only O(c · poly log(n))
records of communication.
Paper Organization. In Section 3, we present the definitions of
oblivious partitioning, private batched sum retrieval and private
stateful information retrieval. We present our OCP, PBSR and PSIR
constructions in Sections 4, 5 and 6 respectively. Details of our
implementations are described in Section 7. The results of our
experiments are shown in Section 8.
3 DEFINITIONS
We suppose the database D contains n records denoted B1, . . . , Bn.
We will interchangeably use the terms records and blocks. We use
[n] to denote the set {1, . . . ,n}. For a two-party protocol Prot, the
writing (y1,y2) ← Prot(x1, x2) denotes that when the protocol is
played by party 1 with input x1 and party 2 with input x2 then
party 1 receives y1 as output whereas party 2 receives y2.
For an algorithm A that interacts with the server, we denote the
transcript by Trans[y ← A(x)] as all the information revealed to
the server by executing A to compute output y on input x. The
transcript includes all data uploaded to the server as well as the
sequence of data accesses performed when executing A.
Session 5D: Encrypted Search & Computation 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 1006
3.1 Private Stateful Information Retrieval
In this section, we define the notion of Private Stateful Information
Retrieval (PSIR). Roughly speaking, PSIR is an extension of the classical notion of a single-server PIR [36] in which the client keeps a
state between queries. Before any query can be issued, the client
initializes its state by executing the Init protocol with the server.
As in PIR, the query process of a PSIR consists of a single clientto-server message followed by a single server-to-client message.
The client will use the server’s response and their current state to
recover the record desired. For the sake of clarity, we split this last
step into two distinct parts: an Extract algorithm executed by the
client to extract the record queried from the server’s reply, and an
UpdateState algorithm jointly executed by the client and server to
update the client’s state. In our construction, the UpdateState protocol consumes part of the client’s state and, if needed, re-executes
the Init protocol. We stress that the server of a PSIR does not have
a state just like in the original notion of a single-server PIR.
Definition 1 (PSIR). A Stateful Information Retrieval PSIR =
(PSIR.Init, PSIR.Query, PSIR.Reply, PSIR.Extract, PSIR.UpdateState)
consists of the following components
• (st, ⊥) ← PSIR.Init((1
λ
, 1
c
), (1
λ
,D = (B1, . . . , Bn))): a protocol executed by a client and the server. The client takes as
input the security parameter λ and the parameter c that describes the number of records that can be stored by the client.
The server takes as input the security parameter λ and the
database D = (B1, . . . , Bn). The client’s output is its initial
state st and the server receives no output. Protocol Init is run
when a client enrolls into the system or when a new state is
needed by a client because the state has been lost for a crash.
• (st′
,Query) ← PSIR.Query(q,st): an algorithm executed by
the client that takes as input index q ∈ [n] and its current state
st and outputs Query to be sent to the server. In addition, the
client’s state is updated to st′
.
• Reply ← PSIR.Reply(Query,D = (B1, . . . , Bn)): an algorithm executed by the server that takes as input Query computed by a client and the database and returns Reply.
• B ← PSIR.Extract(Reply,st): an algorithm executed by the
client to extract a record from the server’s Reply to the query.
Note that the client’s state is not updated.
• (st, ⊥) ← PSIR.UpdateState((st), (D)): a protocol executed
by a client and the server that updates the client’s state.
such that the following Correctness condition is satisfied.
Correctness. For all λ, for all n ≤ poly(λ), for all c ≤ poly(λ),
for any set H of honest players, for any database D = (B1, . . . , Bn)
of size n and for any sequence Q = ((q1,u1), . . . ,(ql
,ul
)) of length
l = poly(λ) we have
Pr h
ExptPSIR
Correctness(λ,c, H,D, Q) , 1
i
≤ negl(λ)
where the experiment ExptPSIR
Correctness is defined as follows
ExptPSIR
Correctness(λ, c, H, D, Q);
For all u ∈ H
(stu, ⊥) ← PSIR.Init((1
λ
, 1
c
), (1
λ
, D));
For i ← 1, . . . , l:
(stui
, Queryi
) ← PSIR.Query(qi
, stui
);
Replyi ← PSIR.Reply(Queryi
, D);
Ri ← PSIR.Extract(Replyi
, stui
);
(stui
, ⊥) ← PSIR.UpdateState((stui
), (D)];
Output 1 iff for all i ∈ [l] Ri = Bqi
;
To properly define the notion of security for a a stateful information retrieval we need the concept of sequences compatible with
respect to a set of corrupted players.
Definition 2. Two sequences Q
0 = ((q
0
1
,u
0
1
), . . . ,(q
0
l
,u
0
l
)) and
Q
1 = ((q
0
1
,u
1
1
), . . . ,(q
0
l
,u
1
l
)) are compatible with respect to set C of
users if
(1) u
0
i
= u
1
i
, for all i = 1, . . . ,l;
(2) q
0
i
= q
1
i
, for all i such that u
0
i
= u
1
i
∈ C.
We are now ready to present our static notion of security.
Definition 3. A Stateful Information Retrieval is a Private Stateful Information Retrieval (PSIR) if for all λ, for all n ≤ poly(λ), for
all c ≤ poly(λ), for any sets H of honest players and C of corrupted
players, for any database D = (B1, . . . , Bn) of size n, and for any
two compatible sequences, Q
0 and Q
1 with respect to C of length
l = poly(λ) and for all PPT adversary A, we have that

Pr[ExptPSIR
A (λ,C, H,D, Q
0
) = 1]
− Pr[ExptPSIR
A (λ,C, H,D, Q
1
) = 1]

 < negl(λ),
where experiment ExptPSIR
A
is defined as follows
ExptPSIR
A
(λ, c, H, C, D, Q);
View ←
Ð
u∈H∪C Trans[(stu, ⊥) ← PSIR.Init((1
λ
, 1
c
), (1
λ
, D))];
View ← View ∪ (
Ð
u∈C stu );
Parse Q as Q = ((q1, u1), . . . , (ql
, ul
));
For i ← 1, . . . , l:
(stui
, Queryi
) ← PSIR.Query(qi
, stui
);
View ← View ∪ {Queryi
};
Replyi ← PSIR.Reply(Queryi
, D);
Bqi ← PSIR.Extract(Replyi
, stui
);
View ← View ∪ Trans[(stui
, ⊥) ← PSIR.UpdateState((stui
), (D)];
If ui ∈ C then View ← View ∪ {stui
};
Output A(View);
If we enforce the restriction that each user’s state is empty and
that both Init and UpdateState are empty functions, we attain a
security definition for PIR where the server may non-adaptively
corrupt a set of users.
Adaptive corruption. In the security definition above, the set of
corrupted users C is fixed at the beginning. We can also present
a security definition against adaptive corruption by means of the
following game between an A and a challenger CH. The games
starts with CH executing PSIR.Init for all users u and by picking a
random bit η. Then at each step i, A can decide to corrupt a new
player u. The initial state of stu of u is then given to A along with
all the random coin tosses of u, and all the replies received by u from
CH. In addition, A may issue a query on behalf of user ui
, in which
case A outputs (q
0
i
,q
1
i
,ui) and CH executes query q
η
i
for user ui
and gives A the view of the server and, if ui ∈ C, the updated state
Session 5D: Encrypted Search & Computation 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 1007
stui
of ui
. At the end of the game, A outputs its guess η
′
for η. We
say that A wins if η = η
′
and sequences Q
0 = ((q
0
1
,u1), . . . ,(q
0
l
,ul
))
and Q
1 = ((q
1
1
,u1), . . . ,(q
1
l
,ul
)) are compatible with respect the set
of corrupted players C at the end of the game. A PSIR scheme is
an adaptively private stateful information retrieval if for any PPT
adversary A the probability that A wins is negligibly in λ close to
1/2.
It can be shown that our main construction presented in Section 6
is also adaptively private.
3.2 Oblivious Constrained Partitions
In this section, we define the concept of a Oblivious Constrained Partition OCP. An OCP consists of two algorithms(OCP.GenerateSeed,
OCP.ExtractPartition). Algorithm OCP.GenerateSeed takes integers n, k and the constraint subset S ⊆ [n] of size k and returns the
pair (K,r) such that K is the description of a partition (P1, . . . , Pm)
of [n] intom := n/k ordered parts of size k and r is such that Sr = S.
Algorithm OCP.ExtractPartition takes K and expands it into the
partition (P1, . . . , Pm). We require that the construction hides the
constraint subset S used to sample (P1, . . . , Pm), in the sense that an
adversary that sees the description of a partition has no information
on which of the parts of the partition was used as constraint subset
in the generation of the partition. In particular, an adversary given
the seed K cannot determine whether an element q belongs to the
constraint subset or not.
Definition 4 (Constrained Partition). A Constrained Partition OCP = (OCP.GenerateSeed, OCP.ExtractPartition) consists
of the following two PPT algorithms:
• (K,r) ← OCP.GenerateSeed(1
λ
, 1
n
, S): an algorithm that
takes as input security parameter λ, integers n and constraint
subset S ⊆ [n] of size k, such that k divides n, and outputs a
seed K and an integer r.
• (P1, . . . , Pm) ← OCP.ExtractPartition(K): an algorithm that
takes as input a seed K and outputs subsets (P1, . . . , Pm), with
m = n/k.
that satisfy the following two properties:
• Correctness. For every n, k, λ and for every S ⊆ [n] of size k, if
(K,r) ← OCP.GenerateSeed(1
λ
, 1
n
, k, S) and (P1, . . . , Pm) ←
OCP.ExtractPartition(K) then (P1, . . . , Pm) is a partition of
[n] into m parts each of size k and Pr = S.
• Obliviousness. For all λ, all n = poly(λ) and k such that k
divides n, for any two elements q
0
,q
1 ∈ [n] and for any PPT
adversary A,

Pr[ExptOCP
A (λ,n, k,q
0
) = 1]
− Pr[ExptOCP
A (λ,n, k,q
1
) = 1]

 < negl(λ),
where ExptOCP
A
is defined as follows
ExptOCP
A
(λ, n, k, q);
Randomly choose S
′ ⊆ [n] of size k − 1;
Set S = S
′ ∪ {q };
(K, r) ← OCP.GenerateSeed(1
λ
, 1
n, S);
Output A(K);
3.3 Private Batched Sum Retrieval
A private batched sum retrieval is an algorithm that computes the
sums of c subsets S1, . . . , Sc of n elements from a field F stored
by a potentially adversarial server. In such a scheme, the server
should not learn the subsets for which the algorithm is computing
the partial sums. In Section 5, we present several different batched
sum retrieval schemes with various bandwidth and computational
overheads. To analyze communication, we count the number of field
elements that are transferred by the algorithm. For computational
costs, we count the number of field operations performed.
Definition 5. (Batched Sum Retrieval) A batched sum retrieval
scheme PBSR is an algorithm that takes as inputc subsets, S1, . . . , Sc ⊆
[n] and accesses n field elements D = (B1 . . . , Bn) ∈ F
n
stored on a
server and outputs c sums, O1, . . . ,Oc , where Oi =
Í
j ∈Si
Bj for all
i = 1, . . . ,c.
A batched sum retrieval scheme is private if for all λ, for all n =
poly(λ), for any c = poly(λ) and for any pair of sequences of subsets
(S1, . . . , Sc ) and (S
′
1
, . . . , S
′
c
) such that |Si
| = |S
′
i
| for all i ∈ [c] and
for any PPT adversary A,

Pr[ExptPBSR
A (λ,n, S1, . . . , Sc ) = 1]
− Pr[ExptPBSR
A (λ,n, S
′
1
, . . . , S
′
c
) = 1]

 < negl(λ),
where ExptPBSR
A
is defined as follows
ExptPBSR
A
(λ, n, S1, . . . , Sc );
χ ← Trans[(O1, . . . , Oc ) ← PBSR(S1, . . . , Sc, D)];
Output A(χ );
4 OBLIVIOUS CONSTRAINED PARTITIONS
In this section, we give a construction for OCP. We refer the
reader to Section 2, for an informal description of the algorithm.
Our construction uses a family of pseudorandom functions, F =
{F(K, ·)}K ∈ {0,1}⋆ . For a λ-bit key K, F(K, ·) is a function from
{0, 1}
λ
to {0, 1}
λ
. We assume F is a random oracle for security.
We start by describing two subroutines that will be useful in
our construction. Subroutine ExtractSubset takes as input integers u and m and seed K and outputs a sequence T consisting of
m distinct values in [u]. The subsets T is obtained by evaluating
F(K, ·) starting from 0 until m distinct elements are obtained. Subroutine ExtractSubset is also used in our construction of PSIR of
Section 6. Subroutine ExtractCondSubset instead outputs a succinct
description of a sequence T of m distinct elements of [u] subject
to the constrain that the r-th element is equal to a given element
x. ExtractSubset and ExtractCondSubset are described in Figure 2.
We also use procedure FisherYates(1
m, Kk
) that samples a random
permutation of [m] using the Fisher-Yates algorithm and using
F(Kk
, ·) as the source of randomness. We omit a description of this
standard algorithm.
We are now ready for a formal description of our construction
OCP.
Construction 6 (OCP). We describe an oblivious constrained
partition scheme OCP = (OCP.GenerateSeed, OCP.ExtractPartition).
Our construction OCP uses FisherYates and ExtractCondSubset as
subroutines.
Session 5D: Encrypted Search & Computation 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 1008
T ← ExtractSubset(K,u, 1
m)
1. Initialize T to be an array of size m.
2. Initialize seen to be an empty set.
3. Initialize next ← 0.
4. While seen.size < m:
ℓ ← F (K, next) mod u.
If ℓ < seen:
Insert ℓ into seen.
Append ℓ to T .
Increment next by one.
5. return T .
(T, K,v) ← ExtractCondSubset(1
λ
,u, 1
m,r, x)
1. Generate random seed K ← {0, 1}
λ
.
2. Execute T ← ExtractSubset(K,u, 1
m).
3. Compute v ← T [r] − x mod u.
4. Set T [l] ← T [l] −v mod u.
4. Return (T, (K,v)).
Figure 2: Description of ExtractSubset and ExtractCondSubset.
OCP.GenerateSeed. This algorithm outputs a compact description of a partition P = (P1, . . . , Pm) of [n] intom := n/k parts of size
k such that one of the parts is the constraint subset S received in input.
The algorithm sees the partition as a matrix withm rows, one for each
of the m parts of the partition, and k columns . Columns T1, . . . ,Tk
are constructed one at a time and the j-th partition Pj will consist
of the j-th element of each column. At the start of the algorithm, all
elements of [n] are unused and elements become used as they are
assigned to a part by the algorithm when columns are constructed.
As we have explained in the informal description of the algorithm in
Section 2, a column is not directly specified by its element but only by
an index to a table of sorted unused elements.
((K1,v1) . . . , (Kk
,vk
)) ← OCP.GenerateSeed(1
λ
, 1
n
, S)
(1) Set k = |S | and write S as S = (s1, . . . ,sk
) with s1 < s2 <
· · · < sk
.
Pick random r ∈ [m] and a random permutation τ of [k].
The algorithm will guarantee that the r-th element of each
column will be an element of S. Specifically, sτ (ℓ) of S will
appear as the r-th element of column Tℓ
, for ℓ = 1, . . . , k.
(2) Allocate array unused of k Boolean values and initialize unused[i] =
True, for i = 1, . . . , k.
The algorithm maintains the invariant that unused[i] =
True if and only ifsi
, the i-th smallest element of S, is unused.
Clearly, when the algorithm starts no element of S, actually
no element of [n], has been assigned to a part yet. Note that
the algorithm only needs to keep track of which elements of
S are unused.
(3) Allocate array rank of k integers and initialize rank[ℓ] = sℓ
,
for ℓ = 1, . . . , k.
The algorithm maintains the invariant that rank[ℓ] is equal
to the number of unused elements of [n] that are smaller
than or equal to sℓ
. Since at the beginning all elements of
[n] are unused, rank[ℓ] is initialized to be sℓ
.
(4) For each ℓ ← 1, . . . , k − 1:
The algorithm constructs the first k − 1 columns. For efficiency reasons, the last column, Tk
, is constructed using an
ad-hoc procedure.
(a) Set (Tℓ
, (K,v)) ← ExtractCondSubset(1
λ
,u := n−m· (ℓ−
1), 1
m,r, x := rank[τ (ℓ)]).
Column Tℓ does not contain explicitly specifies the m elements but only their current ranks with respect to the
u := n − m · (ℓ − 1) still unused elements. Procedure
ExtractCondSubset also guarantees that the r-th element
of the column is equal to sτ (ℓ) by enforcing Tℓ
[r] to be
equal to the current rank x of sτ (ℓ)
.
Next the algorithm updates the ranks of the unused elements of S and checks ifTℓ as returned by ExtractCondSubset
contains unused elements of S other than sτ (ℓ).
(b) Initialize newRank to store the updated ranks as if Tℓ were
to be the ℓ-th column.
(c) For all elements si ∈ S such that unused[i] = True:
(i) Let j be the largest integer such that rank[i] ≥ Tℓ
[j].
(ii) If rank[i] = Tℓ
[j] and i , ℓ then go to Step 4a.
In this case,Tℓ
[j] is equal to the current rank, rank[i], of
si and which means that the column contains an unused
element of S other than ℓ. The algorithm thus restart
by selecting another candidate column for Tℓ
.
(iii) Set newRank[i] ← rank[i] − (j − 1).
Note that j − 1 elements of Tℓ
that are smaller than
rank[i] will be used and thus the rank of si
is adjusted
accordingly.
(d) Set Kℓ ← K and vℓ ← v, set unused[τ (ℓ)] = False and
update rank ← newRank.
Tℓ can be used as the ℓ-th column subset.
(5) Randomly select Kk ← {0, 1}
λ
, Tk ← FisherYates(1
m, Kk
)
and set vk ← Tk
[r] − rank[τ (k)].
(6) Output ((K1,v1) . . . , (Kk
,vk
)).
OCP.ExtractPartition. This algorithm takes the succinct representation, ((K1,v1), . . . ,(Kk
,vk
)) of a partition of [n] into m parts of
size k and outputs the explicit partition.
(P1, . . . , Pm) ← OCP.ExtractPartition(n, (K1,v1), . . . ,(Kk
,vk
))
(1) Initialize P1, . . . , Pm to be empty arrays.
(2) Initialize T ← [n] as an ordered set.
(3) For i ← 1, . . . , k − 1:
(a) Execute Ti ← ExtractSubset(|T |,m, Ki).
(b) For each j ← 1, . . . ,m:
Append the (Ti[j] −vi)-th smallest item in T to Pj
.
Session 5D: Encrypted Search & Computation 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 1009
(c) For each j ← 1, . . . ,m:
Remove (Ti[j] −vi)-th smallest item from T .
(4) Execute Tk ← FisherYates(n/k, Kk
).
(5) For each j ← 1, . . . ,m:
Retrieve the (Tk
[j]−vk
)-th smallest item inT and append
it to Pj
.
(6) Output (P1, . . . , Pm).
We now prove the efficiency and security of our OCP construction. Our proofs will use the Chernoff Bounds that are reviewed in
Appendix B.
Lemma 7. For m = ω(logn), an invocation of ExtractSubset by
OCP.GenerateSeed performsO(m) PRF evaluations except with probability negligible in n.
Proof. At each iteration of the loop for ℓ that starts at Step 4,
there are exactly u = n − m · (ℓ − 1) unused elements and this
value is passed to ExtractCondSubset at Step 4a and, eventually, to
ExtractSubset to generate a subset of size m.
Note that u ≥ 2m in all invocations and therefore each F evaluations has probability at least 1/2 of being distinct from all previous evaluations. We consider p := 2(1 + 2ϵ) · m independent
evaluations of F, X1, . . . ,Xp such that Xi = 1 if and only if the
i-th evaluation is distinct from all previous evaluations. We set
X = X1 + . . . + Xp as the total number of successes and observe that µ = E[X] ≥ p/2 = (1 + 2ϵ) · m. Note ExtractSubset
only requires m successes to terminate and thus the probability
that ExtractSubset performs more than p evaluations is at most
Pr[X ≤ m] ≤ Pr[X ≤ (1 − ϵ)µ]. Assuming that ϵ is small enough
so that (1 + 2ϵ)(1 −ϵ) ≥ 1 and by using Chernoff bounds, we obtain
that this probability is negl(n). □
Lemma 8. A subset output by ExtractCondSubset intersects the
constraint subset at exactly one element witg probability at least 1/e.
Proof. Fix any ℓ ∈ [k−1] for which we are focusing our analysis.
After fixing the r-th element of Tℓ
in Step 4a, we can view the
remaining m − 1 elements as being randomly drawn from the set of
the remaining u − 1 unused elements. The sampling is considered
successful if we avoid the remaining k −ℓ elements of the constraint
subset S. As a result, the probability that Tℓ
intersects only at the
r-th element is

1 −
k − ℓ
u − 1

·

1 −
k − ℓ
u − 2

· . . . ·

1 −
k − ℓ
u − (m − 1)

≥

1 −
k − ℓ
u − m
m
≥

1 −
k − ℓ
m(k − ℓ)
m
≈
1
e
.
□
Theorem 9. OCP.GenerateSeed requires O(n) PRF evaluations
except with negligible probability in n when m, k = ω(logn) as well
as storage of O(m + k) integers.
Proof. OCP.GenerateSeed requires storage of the ranks of the
k elements of the constraint subset as well as the m elements of Tℓ
at each loop iteration.
By Lemma 8, a subset output by ExtractCondSubset has probability 1/e of passing the test of the loop starting at Step 4.c. We consider
p := e(1 + 3ϵ) · k independent invocations of ExtractCondSubset
we would expect µ = (1 + 3ϵ)k invocations to be successful. Therefore, by Chernoff bounds, the probability that OCP.GenerateSeed
performs more than (1 − ϵ)µ ≥ (1 + ϵ)k invocations is negligible, provided that ϵ is small enough so that (1 + 3ϵ)(1 − ϵ) ≥
(1 + ϵ). The Theorem follows since, by Lemma 7, each invocation
of ExtractCondSubset requires O(m) PRF evaluations except with
negligible probability, □
Theorem 10. Construction 6 is an oblivious constrained partition
according to Definition 4 when function F is modeled as a random
oracle.
Proof. The theorem follows from the fact that the constraint
set, as all the other subsets of the partition, is randomly selected
and thus cannot be distinguished from the others. □
In Appendix D, a more complex OCP scheme requiring O(k)
client storage for OCP.GenerateSeed is presented.
5 PRIVATE BATCHED SUM RETRIEVAL
In this section, we present StreamPBSR, a simple batch sum retrieval scheme that downloads all the field elements. While requiring O(n) bandwidth and computation, StreamPBSR can be used to
construct a single-server multiple user PIR with sublinear encrypted
operations later. The idea is very simple: each record is downloaded
and added to the appropriate partial sums. Before streaming, the
server could compress the database to reduce network costs.
Construction 11. (O1, . . . ,Oc ) ← StreamPBSR(S1, . . . , Sc )
(1) Initialize O1 ← 0, . . . ,Oc ← 0.
(2) For i = 1, . . . ,n:
(a) For all j ∈ [c] such that i ∈ Sj
:
(i) Oj ← Oj + Bi
(3) Output (O1, . . . ,Oc ).
Theorem 12. StreamPBSR is a private batched sum retrieval
scheme according to Definition 5. In addition, the algorithm uses
O(n) bandwidth, O(
Í
i
|Si
|) additions, and O(c) memory.
Proof. The algorithm accesses all the field elements in order
independent of the input subsets. □
In Appendix D, we present several more communication efficient
algorithms of more theoretical interest.
6 PRIVATE STATEFUL INFORMATION
RETRIEVAL
In this section, we present our construction of PSIR that uses as
subprotocols an oblivious constrained partition scheme OCP, a
private batched sum scheme PBSR, and a single-server PIR PIR. Our
construction is parametrized by two integers (c, k). For a choice
(c, k) of the parameters, PSIR has the following performance in
terms of client memory required and bandwidth:
• Client memory: the client memory must be large enough to
contain c records;
• Bandwidth per query amortized over c queries: k integers in
the range [n], k seeds of λ bits, and n/c + PIR(n/k) blocks,
where PIR(N) is the bandwidth of the underlying singleserver PIR PIR for a database of N records.
Session 5D: Encrypted Search & Computation 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 1010
Except for the PIR operations, the server and client only need to
perform plaintext operations or pseudorandom function evaluations.
A client initializes their state by executing PBSR to download
c sums where each sum is over a random subset of k − 1 records,
which will be the client’s side information. To retrieve a record, the
client iterates through its stored record sums or side information
until finding a sum that does not include the desired query record as
an addend. If all unused side information contains the desired query
record, then our PSIR scheme will fail. However, we show that at
least (1 − ϵ)c queries will succeed for all constant 0 < ϵ < 1 and
k ≤ n/2. After exactly (1 − ϵ)c queries, all clients will re-initialize
the state (and side information) by running another PBSR protocol.
After finding side information that does not include the query
record, the client executes OCP with the side information and
the query record as the constraint subset. In addition, the client
executes PIR to construct a PIR request corresponding to retrieving
the constraint subset. The request from PIR and seed from OCP are
sent to the server. The server reconstructs the partition and adds all
records with each of the m := n/k parts. The server executes PIR
on the m record sums and returns the result to the client. The client
simply decrypts the sum of side information and the query record
and subtracts the side information to retrieve the query record. The
formal description of PSIR is below.
Construction 13 (PSIR). We describe the algorithms that constitute PSIR that uses an adjustable parameter k and a constant
0 < ϵ < 1.
PSIR.Init. This protocol is jointly executed by the client and server
to compute the client’s initial state st. The database D is provided as
input to the server. Algorithm ExtractSubset is described in Section 4.
(st, ⊥) ← PSIR.Init((1
λ
, 1
c
), (1
λ
,D = (B1, . . . , Bn)))
(1) Client randomly selects K1, . . . , Kc ← {0, 1}
λ and sets
• S1 ← ExtractSubset(K1,n, 1
k−1
)
• . . .
• Sc ← ExtractSubset(Kc ,n, 1
k−1
).
(2) Client and Server jointly set (O1, . . . ,Oc ) ← PBSR(S1, . . . , Sc ).
(3) Client sets count ← 1 and next ← 1.
(4) Output st = (count, next,O1, . . . ,Oc , K1, . . . , Kc ).
PSIR.Query. This algorithm is executed by the client to retrieve
the q-th record of the database. It takes as input the state st and the
index q and returns an updated state st and a Query that is sent to
the server.
(st,Query) ← PSIR.Query(q,st)
(1) Write st as st = (count, next,O1, . . . ,Oc , K1, . . . , Kc ).
(2) Let p be the smallest integer p ≥ next such that q < Sp and
set next = p + 1 and count = count + 1. If no such integer p
exists, then abort.
(3) Set S ← Sp ∪ {q}.
(4) Execute (K,r) ← OCP.GenerateSeed(1
λ
, 1
n
, S).
(5) Execute (PIRQuery, PIRKey) ← PIR.Query(r).
(6) Update st = (count, next,O1, . . . ,Oc , K1, . . . , Kc , ((K,r),
PIRKey)).
(7) Output Query = (K, PIRQuery).
PSIR.Reply. This algorithm is executed by the server to compute
Response to the client’s Query.
Reply ← PSIR.Reply(Query,D = (B1, . . . , Bn))
(1) Write Query as Query = (K, PIRQuery) and set m = n/k.
(2) Set (P1, . . . , Pm) ← OCP.ExtractPartition(n, K).
(3) Compute Ti ←
Í
j ∈Pi
Bj for i = 1, . . . ,m.
(4) Output Response = PIR.Reply(PIRQuery,T1, . . . ,Tm).
PSIR.Extract. This algorithm is executed by the client to recover
the q-th block from Response obtained from server and theQueryKey
associated with the Query sent to the server.
Bq ← PSIR.Extract(Response,st)
(1) Parse st as
(count, next,O1, . . . ,Oc , K1, . . . , Kc , ((K,r), PIRKey)).
(2) Execute Bq ← PIR.Extract(Response, PIRKey) − Or .
(3) Output Bq.
PSIR.UpdateState. This protocol is executed by the client, possibly interacting with the server, to update the client’s state. This
can be executed offline by the client by itself unless it requires the
server’s help to re-instate an initial state.
(st, ⊥) ← PSIR.UpdateState((st), (D))
(1) Parse st as
(count, next,O1, . . . ,Oc , K1, . . . , Kc , ((K,r), PIRKey)).
(2) Set st as st = (count, next,O1, . . . ,Oc , K1, . . . , Kc ).
(3) If count > (1 − ϵ)c/2 then
Execute protocol (st, ⊥) ← PSIR.Init((1
λ
, 1
c
), (1
λ
,D)).
(4) Output st.
We next prove that if a client has local storage large enough to
hold c blocks then, except with negligible probability, the initial
state can be used for Ω(c) queries. We use the following lemma
on the tail of the sum of geometric distributions (for a proof, see
Theorem 2.1 of [32]).
Lemma 14. Let X1, . . . ,Xn be n geometrically distributed random
variables with success probability p1, . . . ,pn and define X to be X := Ín
i=1
Xi
. Then, for every ϵ > 0,
Pr[X ≥ (1 + ϵ)µ] ≤ e
−p⋆
µ(ϵ−ln(1+ϵ))
,
where µ = E[X] =
Í
i 1/pi and p⋆ = mini pi
.
Lemma 15. Algorithm PSIR.Query fails with probability negligible in n whenever c = ω(logn) and k ≤ n/2.
Proof. PSIR.Query fails only if all c subsets are consumed by
fewer than (1 − ϵ)c/2 queries. By PSIR.Init, each Sp is a randomly
chosen subset of [n] of cardinality k − 1 and thus, for any fixed
q ∈ [n], the probability that q < Sp is (n − (k − 1))/n, which is at
least 1/2 since k ≤ n/2. Therefore the number of subsets consumed
by each invocation of PSIR.Query is geometrically distributed with
probability of success at least 1/2. The lemma follows by applying
the bound given by Lemma 14. □
Theorem 16. Construction 13 reduces private record retrieval to
a single PIR execution on a database of n/k records while all other
operations are strictly plaintext or cryptographic hashes as well as
communicating k seeds and k integers. In addition, the client must
download (offline) O(n/c) records amortized over Ω(c) queries.
Session 5D: Encrypted Search & Computation 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 1011
Proof. The cost of communicating k seeds and k integers derive from the seeds derived from OCP.GenerateSeed. Besides the
operations of PIR, all other client or server operations are cryptographic hash evaluations and adding or moving blocks around
(plaintext). For amortized communication costs, the client streams
n records to construct side information which is used over O(c)
queries. Therefore, a total of O(n/c) amortized offline communication is required. □
Theorem 17. Construction 13 is a private stateful information
retrieval scheme according to Definition 1.
Proof. We note that PSIR.Init and PSIR.UpdateState are independent of the input subsets by the security of the underlying
PBSR scheme. As a result, the adversary’s view is independent
of each honest client’s state. PSIR.Query outputs Query which is
viewed by the adversary. PSIR.Query uses only the input q and
the client’s state. Query consists of PIRQuery and the seed generated by OCP. By the security of the underlying PIR, PIRQuery
is generated independently from the input q. Similarly, K generated by OCP.GenerateSeed is independent from the input q. As a
result, Query is independent from q. As a result, the execution of
PSIR.Reply as well its transcript is independent from q as it only
takes Query and the database as input. Therefore, the adversary’s
view is independent of the query sequence for all honest clients. □
In Appendix C, we present several techniques to amortize the
costs of PSIR.UpdateState.
6.1 Discussion
In this section, we will discuss various parts of our PSIR construction.
Online to Offline. A major contribution of our PSIR scheme is
moving online costs to an offline phase. Not all computation and
network costs are identical. A charging phone downloading at
night connected to WiFi is almost free in comparison to a phone
downloading during the day over cellular networks. PIR expenses
all bandwidth at query time whereas our PSIR scheme moves costs
to cheaper offline costs overcoming a significant practical obstacle.
Use of StreamPBSR.. At first look, StreamPBSR might seem really
inefficient to download the entire database to construct the client’s
state. However, it turns out that StreamPBSR is very efficient in
terms of private retrieval storage schemes that must handle many
queries. For existing single-server PIR constructions, a couple hundreds of PIR queries requires communication more than streaming
an entire database.
In practice, StreamPBSR is competitive when compared to asymptotically more efficient methods that use homomorphic encryption
and batch codes in an attempt to decrease communication costs (see
Appendix D). These techniques require significant computation so
that the amortized computations costs become similar or worse than
existing single-server PIR constructions even though they have better asymptotic performance. On the other hand, StreamPBSR uses
linear communication costs with very smaller hidden constants
giving much better practical efficiency.
Initializing State. Another issue that arises is that initializing a
client’s state before performing query requires streaming the entire
database. Many clients may wish to perform queries immediately
after joining the protocol. In this case, there are several options
that the client may use. First, the client may just perform standard
PIR queries while waiting for client state to finish initializing. On
the other hand, the client may use another private batched sum
retrieval schemes described in Appendix E.1 to initialize state for
a small number of queries. The client may use this smaller state
for immediate queries while waiting for the large client state to be
initialized. The first small number of queries for each client will
be slow as the client waits for its state initialization to complete
(analogous to a cache warming up).
7 IMPLEMENTATION
We implement PSIR in C++ on top of the APIs provided by the open
sourced XPIR [2] implementation. In addition, we build a library
that implements PIR using Paillier [43] and implement PSIR on top
of the Paillier PIR library. The client and server implementations of
PSIR are built using the gRPC [4] library. We will use StreamPBSR
as our PBSR scheme.
Oblivious Constrained Partition. We implement our construction of OCP in Section 4 using the OpenSSL implementation of
SHA256 as the basis of our function F . All seeds are 16 bytes long.
OCP.ExtractPartition requires an ordered set implementation that
requires efficient querying for the i-th smallest element. We implement a red-black tree that maintains the number of elements in
each node’s left and right subtree to efficiently query for the i-th
smallest element in logarithmic time.
Optimizations to Paillier. The Paillier cryptosystem [43] is a partially homomorphic encryption system. Paillier has two important
properties which enable its use for PIR: homomorphic plaintext
absorption and homomorphic addition. Homomorphic plaintext
absorption is the property that given an encryption, Enc(K,m), and
a plaintext, p, then Enc(K,m)
p = Enc(K,mp). Homomorphic addition is the property that for any two ciphertexts, Enc(K,m1) and
Enc(K,m2), then Enc(K,m1)Enc(K,m2) = Enc(K,m1 + m2). Paillier can be used to perform PIR requests. For a database, p1, . . . ,pn,
of n items of b bits, the client uploads Enc(K,m1), . . . , Enc(K,mn)
where only one mi = 1 corresponding to retrieving the i-th item.
The server needs to compute the value Î
j ∈[n] Enc(K,mj)
pj
. The
trivial way to compute a product of powers is to perform n exponentiations and n multiplications. Bernstein [10] surveys several techniques that improve the computational efficiency of this
problem. We implement Straus’s algorithm [49] as a faster way
to compute the product of powers. For parameter ρ, we only require (n/ρ) · (2
ρ + b) multiplications and (n/ρ) · b squarings. For a
description of Straus’s algorithm, see Algorithm 14.88 in [35].
In addition, we perform all modular multiplications using the
Montgomery representation [40] of multiplicands described in
OpenSSL. The Montgomery form of integers is advantageous when
performing many modular multiplications since the cost of converting the Montgomery form is expensive. In Paillier, the algorithm for
performing the product of powers requires thousands of modular
multiplications making Montgomery form useful.
Session 5D: Encrypted Search & Computation 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 1012
SealPIR SealPSIR PaillierPSIR
Database Size (n) 65,536 262,144 1,048,576 65,536 262,144 1,048,576 65,536 262,144 1,048,576
Client State (KB) N/A N/A N/A 129 258 524 129 258 524
Client CPU (sec)
SealPIR/PaillierPIR query < 0.01 < 0.01 < 0.01 < 0.01* < 0.01* < 0.01* 0.01 0.02 0.04
SealPIR/PaillierPIR extract < 0.01 < 0.01 < 0.01 < 0.01* < 0.01* < 0.01* 0.11 0.11 0.11
OCP.GenerateSeed N/A N/A N/A 0.04 0.12 0.51 0.04 0.12 0.51
total < 0.01 < 0.01 < 0.01 < 0.05* < 0.13* < 0.52* 0.16 0.25 0.66
Server CPU (sec)
SealPIR/PaillierPIR 0.41 1.20 6.50 0.05* 0.10* 0.20* 0.74 0.91 1.24
OCP.ExtractPartition N/A N/A N/A 0.02 0.11 0.51 0.02 0.11 0.51
total 0.41 1.20 6.50 0.07* 0.21* 0.71* 0.76 1.02 1.75
Network (KB)
SealPIR/PaillierPIR query 64 64 64 64 64 64 2 4 8
SealPIR/PaillierPIR answer 256 256 256 256 256 256 18 18 18
OCP seed N/A N/A N/A 10 20 40 10 20 40
online total 320 320 320 330 340 360 30 42 66
amortized StreamPBSR N/A N/A N/A 47 92 178 47 92 178
amortized total 320 320 320 377 432 538 77 134 244
Table 2: Microbenchmarks for network and CPU costs. The left column results are reported from [7]. The middle column is
extrapolated estimates from [7] with asterisks indicating estimates. The right column are reported experimental results.
8 EXPERIMENTAL EVALUATION
Using experiments, we attempt to answer three important questions.
First, can we construct an PSIR scheme with less concrete costs
than the current best PIR construction, SealPIR [7]? Second, what
are the benefits of an PSIR with XPIR and SealPIR compared to
generic XPIR and SealPIR? Finally, what is the latency of our PSIR
schemes in several different settings?
Setup. Our experiments are conducted using two identical machines, one for the client and one for the server. The machines are
Ubuntu PCs with 12 core, 3.5 GHz Intel Xeon E5-1650 and 32 GB of
RAM. All reported results (except the estimate costs for SealPIR)
have standard deviations less than 10% of the means. The cost of
network resources are determined at the application layer.
Database. Our experimental database contains n = 2
16
, 2
18
, 2
20
records of 288 bytes and to match the experiments of previous
works [7, 8]. Each database record will be chosen uniformly at
random. This is a pessimistic choice for our StreamPBSR scheme
since the database cannot be compressed. For real-world databases,
compression could save up to 75% of network costs especially for
large databases. Even with this pessimism, our PSIR scheme is more
efficient than previous PIR schemes.
PIR Parameters. We choose the parameters for Ring-LWE based
FHE schemes used by XPIR based on the analysis by Albrecht
et al. [6]. Similar parameters are used in previous instantiations
of XPIR [5] and SealPIR [7]. For XPIR, we use 2048 degree polynomials and 60 bit coefficient modulus. In particular, we use the
recommended modulus of the form 2
61 − i · 2
14 + 1 for different i.
We will pack α = 14 records to be downloaded and fit α records
into a single ciphertext. Therefore, XPIR will view the database as
n/α records of 288 · α bytes.
For Paillier [43], we set n to be 2048 bits as the product of two
1024 bit safe primes and the modulus n
2
to be 4096 bits. Each
ciphertext can only store 256 plaintext bytes. So, a single record
will need to be spread over two ciphertexts but only uses 32 bytes
in the second ciphertext. We will pack multiple records to share
ciphertext space. In particular, l records can be packed into ⌈
288·l
256 ⌉
Paillier ciphertexts. In particular, we will pack l = 32 records into
36 ciphertexts. Paillier will view the database as n/l records each of
288 ·l bytes. Additionally, we choose to fix the parameter of Straus’s
algorithm, ρ, to be 4, 8 and 8 respectively for databases of size 2
16
,
2
18 and 2
20 respectively. Our Paillier PIR uses no recursion.
PSIR Parameters. For our constructions, we fix k = 2
√
n where
n is the number of records. We choose the client to store approximately 125, 250 and 500 KB of state for database with 2
16
, 2
18 and
2
20 records respectively. In our experiments, the client will store
slightly more than the above chosen values. With records of 288
bytes, we choose the client to hold c ∈ {425, 850, 1725} records of
side information for each respective record size. We note our client
state size assumptions are reasonable since they are significantly
smaller than the network costs of XPIR and similar to the network
costs of SealPIR. The cost of adding plaintext records within parts
for our PSIR schemes is reported with the underlying PIR protocol.
8.1 PSIR Parameters
In this section, we perform experimental evaluation to determine
the correct number of queries our PSIR schemes will service before
running PSIR.Init to re-initialize client state. We consider database
sizes of n ∈ {2
16
, 2
18
, 2
20} with the parameters k = 2
√
n. In our experiments, we pick c random subsets of k − 1 records as the client’s
side information. We consider arbitrary query sequences and determine the maximum number of queries that may be serviced by the c
Session 5D: Encrypted Search & Computation 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 1013
XPIR (d = 2) XPIR (d = 3) XPSIR
Database Size (n) 65,536 262,144 1,048,576 65,536 262,144 1,048,576 65,536 262,144 1,048,576
Client State (KB) N/A N/A N/A N/A N/A N/A 129 258 524
Client CPU (sec)
XPIR query 0.04 0.08 0.15 0.01 0.02 0.04 < 0.01 < 0.01 0.01
XPIR extract < 0.01 < 0.01 < 0.01 0.02 0.02 0.02 < 0.01 < 0.01 < 0.01
OCP.GenerateSeed N/A N/A N/A N/A N/A N/A 0.04 0.12 0.51
total < 0.05 < 0.09 < 0.16 0.03 0.04 0.06 < 0.05 < 0.13 < 0.53
Server CPU (sec)
XPIR 0.35 1.37 5.08 0.55 2.02 6.47 0.01 0.01 0.01
OCP.ExtractPartition N/A N/A N/A N/A N/A N/A 0.01 0.11 0.51
total 0.35 1.37 5.08 0.55 2.02 6.47 0.02 0.12 0.52
Network (KB)
XPIR query 4,456 8,913 17,891 1,638 2,556 4,129 295 393 557
XPIR answer 262 590 590 1,998 2,097 2,097 262 262 262
OCP seed N/A N/A N/A N/A N/A N/A 10 20 40
online total 4,718 9,503 18,481 3,636 4,653 6,226 567 675 895
amortized StreamPBSR N/A N/A N/A N/A N/A N/A 47 92 178
amortized total 4,718 9,503 18,481 3,636 4,653 6,226 614 767 1,073
Table 3: Microbenchmarks for network and CPU costs for XPIR with d ∈ {2, 3} levels of recursion and PSIR using XPIR (d = 2).
blocks of side information. We run the above experiment 1,000,000
times and report on the average and minimum queries serviced.
Database Size (n) 65,536 262,144 1,048,576
Parameter (c) 425 850 1725
Average Queries Serviced 421.97 846.57 1722.52
Minimum Queries Serviced 420 844 1719
We see that, on average, less than 5 blocks of side information are
wasted. Furthermore, the minimum encountered over all 1,000,000
experiments is greater than c − 6 in all three scenarios. Therefore,
we empirically choose thatc −25 number of queries will be serviced
by our PSIR scheme before running PSIR.Init to re-initialize client
state.
8.2 Cost of Ring-LWE based PSIR
We construct PSIR using the XPIR scheme with d = 2 levels of
recursion, which we denote XPSIR. In addition, we estimate costs of
PSIR with SealPIR (SealPSIR) using previously reported results [7].
We note our experimental setup is worse than the one chosen
in [7] in terms of number of cores, RAM size and CPU version. The
means of 10 experiment runs are reported for XPSIR in Table 3.
Our estimated costs for SealPSIR are shown in Table 2. The costs
of OCP are shown in Appendix A.
XPSIR. The results for XPSIR show up to 12x reductions in server
CPU, 7x reductions in online network costs and 6x reductions in
total amortized network costs compared to XPIR. For the 1M items
case, XPSIR introduces up a half second increase in client CPU, but
offsets the gain by decreasing server by at least 4.5 seconds.
SealPSIR. Our estimates for SealPSIR indicate up to 10x reduction in server CPU costs since the PSIR framework reduces the
client database to √
n/2 records. In exchange, SealPSIR introduces
a 13% increase in online network costs, a 68% increase in total
amortized network costs and a significant increase in client CPU.
However, the client CPU increase is half a second while 6 seconds
are saved in server CPU. Furthermore, 80% of the extra network
costs can be performed offline at cheaper, non-busy times.
8.3 Cost of PaillierPSIR
In the previous section, we show that our estimates for SealPSIR
indicate decreases in server CPU and online network costs but
increases in total amortized network costs. Is it possible to construct
a PSIR scheme that can decrease the total amortized network while
reducing server CPU and online network costs significantly? We
answer in the affirmative.
We construct a library that constructs PIR based on the Paillier
cryptosystem [43] and build a PSIR scheme on top of the Paillier
PIR library. We denote this PSIR scheme as PaillierPSIR. Traditionally, PIR schemes built from Paillier enjoy the advantages of small
network costs but suffer from extremely large server CPU costs.
However, PaillierPSIR reduces the online PIR request to a small
database where the Paillier-built PIR is feasible. We study the time
needed by the client to generate queries and extract responses as
well as the time needed by the server to generates responses from
queries. In addition, we examine network costs. The results can be
seen in the right column of Table 2 and compared to SealPIR (the
best, previous construction) seen in the left column of Table 2.
Network costs. PaillierPSIR benefits from significant reductions
in online network costs as well as a modest reduction in total amortized network costs. PaillierPSIR uses 4.8-10.5x less online network
costs and 1.3-4.5x less total amortized network costs compared to
SealPIR. The main gains derive from replacing RLWE-based PIR
schemes with the Paillier PIR scheme. Furthermore, the majority of
amortized network costs may be performed offline.
CPU costs. For 1M items, PaillierPSIR reduces server CPU costs
by more than 3.7x compared to SealPIR. However, PaillierPSIR
Session 5D: Encrypted Search & Computation 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 1014
(a) Inter-Datacenter. (b) Home Network. (c) Mobile Network.
Figure 3: The amortized latency for queries under different settings.
introduces an increase in client CPU costs which we believe is a
worthwhile tradeoff. In concrete terms, client CPU increases by 660
milliseconds while server CPU decreases by more than 4 seconds.
8.4 Latency
To understand the total time required to perform a private retrieval,
we measure the latency of retrieving one 288 byte element from
databases of n ∈ {2
16
, 2
18
, 2
20} records. We set up our client and
server machines on the same LAN network and utilize the Linux
Traffic Control [1] to configure the bandwidth on both machines.
We consider the following three scenarios also used in [7]: querying between two datacenters, using a home network and using a
mobile network. We configure our machines to maintain 800 Mbps
for queries between data centers. For the home and mobile network, we choose 18.7 Mbps and 10 Mbps for each setting based
on Akamai’s latest reports [3]. The results are reported in Figure 3. Amortized latency refers to online latency and the latency of
PSIR.Init and PSIR.UpdateState spread over queries. PaillierPSIR
and XPSIR have smaller latency than XPIR.
9 CONCLUSIONS
In this paper, we present PSIR, an extension of PIR, that is able to
utilize the large amounts of storage available to applications on
client devices. Unlike other stateful primitives, we design PSIR such
that several important practical properties of PIR are maintained.
In particular, PSIR ensures that simultaneous querying capability
to large groups of independent clients, query privacy for a server
colluding with clients and the ability for stateless clients to enroll
in the system using only interaction with the server. By using
client state, PSIR reduces the number of public-key operations that
dominate practical costs to be sub-linear in the database size.
For concrete gains, we show that PaillierPSIR scheme (PSIR using PaillierPIR) is able to significantly reduce server CPU, online
and amortized total network costs compared to SealPIR (the current best PIR construction). In addition, we show that instantiating
PSIR with XPIR and SealPIR can also significantly reduce server
CPU. For PSIR with XPIR, significant network cost are also enjoyed
while PSIR with SealPIR increases network costs. Due to our PSIR
scheme, the majority of network costs may be moved to offline
processing.