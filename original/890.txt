We present a novel Proof-of-Stake (PoS) protocol, Ouroboros Genesis, that enables parties to safely join (or rejoin) the protocol execution using only the genesis block information. Prior to our work,
PoS protocols either required parties to obtain a trusted “checkpoint” block upon joining and, furthermore, to be frequently online
or required an accurate estimate of the number of online parties
to be hardcoded into the protocol logic. This ability of new parties to “bootstrap from genesis” was a hallmark property of the
Bitcoin blockchain and was considered an important advantage
of PoW-based blockchains over PoS-based blockchains since it facilitates robust operation in a setting with dynamic availability,
i.e., the natural setting—without external trusted objects such as
checkpoint blocks—where parties come and go arbitrarily, may join
at any moment, or remain offline for prolonged periods of time. We
prove the security of Ouroboros Genesis against a fully adaptive
adversary controlling less than half of the total stake in a partially
synchronous network with unknown message delay and unknown,
varying levels of party availability. Our security proof is in the
Universally Composable setting assuming the most natural abstraction of a hash function, known as the strict Global Random Oracle
(ACM-CCS 2014); this highlights an important advantage of PoS
blockchains over their PoW counterparts in terms of composability
with respect to the hash function formalisation: rather than a strict
GRO, PoW-based protocol security requires a “local” random oracle.
Finally, proving the security of our construction against an adaptive
adversary requires a novel martingale technique that may be of
independent interest in the analysis of blockchain protocols.
CCS CONCEPTS
• Security and privacy → Distributed systems security; Cryptography; Formal security models;
KEYWORDS
Distributed ledgers, Blockchain, Proof-of-Stake

1 INTRODUCTION
The primary real-world use of blockchains, thus far, has been to
offer a platform for decentralized cryptocurrencies with various
capabilities [7, 32]. A unique feature of blockchain protocols (in
contrast to, say, classical consensus protocols) is the fact that the
parties running the protocol may engage only in passing with the
protocol and need not identify themselves to other protocol participants. In fact, the Bitcoin blockchain protocol remains robust
in the presence of a Byzantine adversary even if parties arbitrarily
desynchronise, join at any moment of the execution or go offline
for arbitrary periods of time, as long as a majority of hashing power
is always following the protocol. We refer to this desirable set
of execution features as dynamic availability. Motivated by this
novel setting, several applications have recently emerged that use
blockchains (or the cryptocurrencies that build on top of them) as enablers for cryptographic protocols. For example, a number of recent
works [1, 2, 6, 27, 28] describe how blockchain-based cryptocurrencies can be used to obtain a natural notion of fairness in multi-party
computation against dishonest majorities; or to allow parties to
play games of chance—e.g., card games like poker—without the
need of a trusted third party [15, 29]; or how to use blockchains as
bulletin boards in electronic voting [30]. Such developments—in
conjunction with the direct applicability to cryptocurrencies—have
motivated general, formal security analysis of the functionality that
blockchain protocols provide, undertaken in steps of successive
refinement in [4, 18, 19, 33].
However, blockchain protocols such as Bitcoin and Ethereum
have led to concerns regarding their extraordinary energy demands
as they rely on proof-of-work (in short, PoW), a cryptographic
puzzle-solving procedure that increases in difficulty as more parties
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 913
join the system.1 The desire for more efficient blockchain solutions gave rise to an exciting recent line of work that proposes
to use alternative resources to achieve consensus and maintain a
robust ledger. A popular such resource is stake in the system itself [5, 13, 26]. Informally, instead of requiring a party to invest
computing power in order to be allowed to extend the blockchain,
parties are given the chance to do so according to their stake in
the system, e.g., the number of coins they own. This paradigm,
referred to as proof-of-stake (in short, PoS), has yielded a number of proposals for PoS-based blockchains, including several supported by formal analysis: Algorand [21], Snow White [14], and
Ouroboros/Ouroboros Praos [16, 25], which is implemented as part
of the Cardano blockchain.2 Additionally, Ethereum—a noted PoW
scheme—aims to transition to PoS in the future [8].
Despite the clear advantages of PoS blockchains in terms of energy efficiency, their suitability as PoW blockchain replacements
has been uncertain; see, e.g., [35]. Notably, such protocols restrict
the dynamic availability of participants: for instance, Casper [8],
Snow White [14], and Ouroboros/Ouroboros Praos [16, 25] require
parties to maintain a “moving checkpoint”—specifically, new parties must receive trusted “advice” when they join and otherwise be
frequently online—while Algorand [21] requires that a good estimate of the number of online parties is hardcoded in the protocol;
in case the estimate becomes incorrect, due to some parties going
offline, the protocol will halt, even when an active honest majority
is present (while protocols like [14, 16] will merely slow down).
All the above point to the following open, and fundamental,
question: Is it possible for PoS-blockchains to provide the same
functionality guarantees as PoW-blockchains in the setting of full
dynamic availability without access to any information beyond a
trusted initialisation string (the “genesis block”)?
Our Contributions. We propose a new protocol which features a
novel chain selection rule that enables joining parties to “bootstrap
from genesis”, i.e., to safely join an operating blockchain protocol
without any information other than the genesis block. In particular, this provides the joining party a blockchain possessing all
the favorable properties (e.g., a large common prefix with other
honest parties) that would be guaranteed if the party had fully participated during the entire history of the protocol. We then prove
that the protocol implements the natural ledger functionality proposed in [4]—the very same functionality shown to be possessed
by Bitcoin—under the assumption of standard cryptographic primitives. Our formalisation captures explicitly the setting of dynamic
availability: parties are allowed to join and leave the system at will,
as well as lose their network and/or clock synchronisation. We
describe these contributions in more detail below.
Our primary contribution is the construction and analysis of a
new protocol, Ouroboros Genesis, which builds on a recent PoS
protocol, Ouroboros Praos [16]; the main novelty of the new protocol is a (significantly) differing chain selection rule—instantiating
the so-called maxvalid procedure in [4, 16, 18, 25]—which allows
parties to identify a chain that shares a large common prefix with
1Currently each single Bitcoin block requires more than 2
72 operations to be performed,
cf. https://en.bitcoin.it/wiki/Difficulty.
2Cardano, https://whycardano.com, is currently the largest pure PoS cryptocurrency
according to market capitalisation, cf. https://coinmarketcap.com.
a recent honest chain, using only knowledge of the genesis block.
The protocol is organized around epochs, periods of the execution
during which the stake distribution is treated as constant by the
protocol. We prove that Ouroboros Genesis realizes the ledger functionality originally proposed in [4] to model the Bitcoin protocol
under an appropriate honest stake majority assumption: specifically, the majority of stake in each epoch—as defined by the stake
distribution in a recent previous epoch—favors the honest parties
in a precise sense that reflects the dynamic availability setting. In
order to express this guarantee formally, we refine the model of
[4] to include the following events: (i) parties may be spawned
and join the network at any time, (ii) parties may lose or regain
their network connection at any time, and (iii) parties may lose or
regain access to the random oracle (that in [4] models the hashing operation of the party) and/or clock functionality at any time.
The honest parties that retain their network connection, clock and
random oracle access for a sufficient amount of time—linear in the
network delay—are called alert, while the set of alert and adversarial parties are called active. On the other hand, the parties that
have lost synchronisation with the clock or are not connected to
the random oracle are called stalled; such parties still have an active
network connection and when they regain access to the clock and
the random oracle are guaranteed to receive all pending messages.
The set of stalled parties is a refinement of the concept of sleepy
parties that appeared in [14, 34].
Using this fine grained formalisation of party behavior, we can
express explicitly the dynamic availability guarantees under which
Ouroboros Genesis is shown secure: (i) The ratio α of the stake of
alert parties to that of the active parties is above 1/2; the difference
is by a constant that is sufficiently large to appropriately absorb the
partial synchrony delay parameter ∆. In particular (and similarly
to the Bitcoin blockchain [18, 33]) the protocol will use a “active
slots coefficient” f and provide meaningful security guarantees for
a range of ∆ below 1/f . (ii) The ratio β of the stake of the active
parties to the stake of all parties is bounded below by some arbitrary
constant that is unknown to the protocol participants.
The constraints above are arguably optimal (that is, necessary)
in the dynamic availability setting. First, if the alert to active stake
ratio α drops below 1/2, it indicates that (despite a possible honest
majority), the effective participating honest parties form a stake minority once we account for the honest players that are either offline
or have so recently joined that they are not yet fully synchronised
with the rest of the honest parties (due to message delays). Second,
if the active to total stake ratio β approaches 0, this indicates that
while there might be honest stake majority, almost all honest parties are stalled and thus the protocol cannot support “liveness”, i.e.,
the guaranteed processing of newly submitted transactions.
Our analysis is in the (partial) synchronous model of universally
composable (UC) functionalities [9, 11, 22] that was also used in [4]
to analyze the bitcoin protocol. A significant improvement in our
analysis, which highlights the higher composability potential of PoS
protocols over their PoW counterparts, is that we are able to prove
security in the strict global random oracle (sGRO or simply GRO)
setting [12], which is the most natural random oracle abstraction of
hash functions; this contrasts with the hash function formalisation
of [4] that restricts access to the hash function in each protocol
session. This latter limitation appears to be an inherent barrier
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 914
of the PoW setting since universal composition of a PoW-based
blockchain would require that computational effort expended in
the environment is inherently independent of the current session,
something known to be untrue (for instance, merged mining, cf.
[23], exploits exactly the transfer of computational effort across
protocol sessions).
On the necessity of novel techniques. The formal security arguments supporting Ouroboros Genesis—as with other rigorously
analysed blockchain protocols—ultimately rely on definition and
analysis of a stochastic process that abstracts the underlying dynamics of block creation and dissemination. The Ouroboros Genesis stochastic process is given by a coupled pair of discrete random walks,
very like the underlying process associated with the Ouroboros
Proas protocol. However, the Ouroboros Genesis analysis must
contend with a significant new analytic challenge: the “steps” of
the random walk are not simply given by independent random
variables (as in previous analyses), but may be correlated by the
adaptive behavior of the adversary. The stake constraints, fortunately, provide limits on the worst-case correlation of these random
variables, and our analyses shows that this can be advantageously
expressed as a martingale to which powerful classical concentration results apply. This permits us to dovetail our development
with the “forkable strings” analysis of [36] which, fortunately, can
also be cast in a martingale setting. These techniques may have
independent interest, as they can apply to quite general blockchain
dynamics and thus may prove useful for analyzing other PoS-based
blockchains.
Related Work. A number of recent works have studied—in a rigorous cryptographic manner—the security of several blockchain
protocols adopting both PoW-based (e.g, [4, 18, 33]) and PoS-based
(e.g., [14, 16, 21, 25, 34]) consensus mechanisms. In the PoW-based
setting, [4] describes and proves the composable security guarantees of the most representative protocol, namely Bitcoin; furthermore, the security proof tolerates an adaptive adversary and
achieves optimal resilience—the adversary can control any percentage less than 50% of the network’s total computing power. In
contrast, in the PoS-based setting, no simulation-based (UC) proof
existed, and various proposed schemes tolerate different types of
adversaries in terms of adaptivity. For example, Ouroboros [25]
achieves only “semi-adaptive” security (corruptions with delay),
whereas among the adaptively secure ones, Algorand [21] requires
less than 1/3 of the stake of the system to be held by malicious parties; Show White [14] and Ouroboros Praos [16] achieve the optimal
1/2 bound, at the cost of needing a checkpointing functionality to
accommodate joining parties.
The idea of parties that are muted for some time but do receive
their messages was first proposed in [34] where those parties were
referred to as sleepers. Our modeling of such parties differs from
that of [34] in various ways: first, instead of describing them by
means of whether they are paused or not, we characterize them by
means of the availability of their resources, making clear how those
parties enter this state. Furthermore, our notion only affects the PoS
session that is being executed and thus, in our composable setting,
such parties are not restricted as to how they should behave within
other protocols that they concurrently participate in. To emphasize
this distinction and the fact that they may be continuing to operate
in other protocol sessions we use the term “stalled” for these parties. In addition to the modeling distinctions, our model allows us
to obtain more general statements regarding the adaptivity of the
adversary. Concretely, we can tolerate fully adaptive adversaries
and worst-case registration/deregistration scheduling. In contrast,
[14] tolerates semi-adaptive adversaries, whose corruption only
takes effect after a certain number of rounds. Interestingly, there is
no need for distinguishing a class of parties called deep-sleepers
in [14] (i.e., those that are in sleepy mode for a prolonged time) that
required a safe initialisation string in [14]. Taking advantage our
bootstrapping from genesis chain selection rule, all parties that are
stalling, even for prolonged periods of time, can safely resynchronise without the assistance of a trusted initialisation exactly as in
the case of PoW-based protocols.
Outline of the remainder of the paper. In Section 2 we provide a formal description of our model of computation, including
our real and ideal world functionalities and setups. In Section 3
we describe Ouroboros Genesis as a (G)UC protocol. The security
analysis of the protocol, i.e., the proof that it UC-securely realizes
the ledger functionality, is given in Section 4. The proof begins by
considering the interaction of the old chain selection procedure
from [16] (this rule is called maxvalid-mc here; the protocol using it is dubbed Ouroboros-Praos) with online and stalled parties
only (Section 4.2); then the proof gradually incorporates the new
maxvalid-bg procedure which allows the protocol to bootstrap from
the genesis block (Section 4.3), and establishes that this procedure
is sufficient to provide all appropriate guarantees to newly joining
and temporarily offline parties (Section 4.4). Finally, the results are
transformed into the full UC statement in Section 4.5.
2 THE DYNAMIC-AVAILABILITY MODEL
This section presents the main components of the security model.
We work in the universal composability (UC) framework [9] and assume some basic familiarity with the core concepts. The full version
of this paper [3] includes a more detailed introduction. Following a
modular approach, we make use of a number of functionalities in
our descriptions and explain their behavior whenever needed to
follow this exposition.
UC defines security via the simulation paradigm: the protocol
execution in the real world is compared to an ideal execution, where
the parties have access to an ideal functionality F which abstracts
the goals of the protocol. In the ideal world, honest parties act as
simply relayers between their environment Z and the functionality
F (i.e., they run the so called dummy protocol [9]). Informally,
security requires that the attack of any adversary A against the
(real-world) protocol can be simulated in the ideal world.
Typically, a protocol is given access to so-called hybrid functionalities, which capture the resources that parties have available, e.g.,
their communication network or shared randomness. Our results
are in the GUC setting which allows parties access to Global setups
that capture settings where different protocols might share a common state, e.g., a common hash-function [10]. On a more technical
note, in order to preserve full UC composability in our statements,
as in [4] we capture assumptions/restrictions on the UC adversary
and environment as functionality wrappers that explicitly restrict
their access to certain functionalities.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 915
A significant extension in the model of computation in our work
is the high-resolution treatment of the protocol participant’s availability, which we term (full) dynamic availability. Concretely, as
in [4] all functionalities, protocols, and global setups have a dynamic
party set: they all include special instructions allowing parties—and
in case of global setups also ideal functionalities—to register, deregister, and allow the adversary to learn the current set of registered
parties. These registration commands are part of the specification
of all (hybrid and ideal) functionalities and setups considered in
this work. For simplicity, we will not write them explicitly in the
pseudo-code of the functionalities.
Dynamic availability requires special care in the blockchain
setting. For example, in [4] it is observed that due to network delays
newly joining Bitcoin miners might be temporarily desynchronized,
i.e., be tricked into working on a fake (adversarial) chain in the
first time period after joining the network. As discussed in the
end of this section (cf. Figure 1) our work goes one step further in
modeling fine-grained, i.e., full, dynamic availability patterns of
parties and capturing their respective security guarantees in the
blockchain setting.
It is important to point out that a fine-grained availability model
offers the capability to precisely model a wide range of real-world
concerns. For example, it allows to reason about a protocol’s resilience against networks failures or arbitrary message delays. The
reason is that such scenarios can be reflected by a particular pattern
of stalled and/or disconnected parties for an adversarially chosen
amount of time.
The remainder of this section describes, in the dynamic availability model, the real-world resources that Ouroboros Genesis requires
and describes the ideal-world functionality that is achieved by the
protocol.
2.1 The Real World Execution
Protocol participants are represented as parties in a multi-party
computation. The main aspects of this computation are as follows:
Communication. The parties communicate over a network of
eventual delivery unicast channels [4]—informally, every party
Up has an open incoming-connections interface where he might
receive messages from other parties. This captures the joining procedure of real-world blockchains where new parties find a point
of contact and use it to communicate with other parties by means
of gossiping. As shown in [4], assuming the honest parties are
strongly connected, this setup can realize the multicast network
with eventual delivery [18, 25, 33]. The abstraction of this network
as a (local)3 UC functionality is given in the full version [3]. For the
remainder of this work we will assume parties have direct access
to such a multicast network, denoted F
∆
N-MC, with an upper bound
∆ in the delay that the adversary can incur on the delivery of any
message. Note that our protocol is oblivious of ∆ and this bound
in only used in the security statement. Hence from the protocol’s
point of view the network is no better than that of an eventual
delivery network (without a concrete bound on delivery time).
3
It is natural to capture network functionalities as local UC functionalities, since
networks are often ad-hoc tailored to a specific task.
Synchrony. Known PoS-based blockchains, including Ouroboros
Genesis, are (partially) synchronous, i.e., they proceed in synchronized rounds with either a known (or an unknown, in the case of
partial synchrony) message delay. We model synchronous computation using the synchronous-UC paradigm introduced in [24] and
adapted to GUC in [4]. Concretely, the parties are assumed access
to a global clock setup, denoted as Gclock which roughly works as
follows: Each registered party can signal the clock that it is done
with the current round, and once all honest registered parties (and
functionalities) in this session have done so, the clock advances its
time counter. In addition, every party can query the clock to read
the (logical) time.
As observed in [4], to obtain UC realization in such a globally
synchronized setting, the target ideal functionality must keep track
of the number of activations that an honest party gets—it can then
enforce consistent clock “pace” in the ideal world and real world.
This can be achieved by describing the protocol so that it has a
predictable pattern of activations before it sends the clock an update
command. The precise definition is given in [3] since the exact
details are not needed to follow the rest of this paper.
Hash functions as global random oracles. Ouroboros Genesis assumes that parties can query a hash function. As typical in
cryptographic proofs, the queries to hash function are modeled as
queries to a random oracle (functionality): Upon receiving a query
(eval,sid, x) from a registered party, if x has not been queried
before a value y is chosen uniformly at random from {0, 1}
κ
(for
security parameter κ) and returned to the party (and the mapping
(x,y) is internally stored). If x has been queried before, the corresponding y is returned.
The common abstraction of random oracles as UC functionalities
raises issues with respect to its accuracy for capturing reality [12]. In
this work, we adopt the more faithful abstraction given by a global
random oracle (GRO) GRO. The fact that Ouroboros Genesis can be
proved secure under such an assumption serves as an indication of
the augmented composability that PoS can bring to the blockchain
ecosystem. As mentioned before, Bitcoin cannot be proved secure
in the GRO model.
The genesis block generation and distribution. Agreement
on the first, so-called genesis block, is a necessary condition in all
common blockchains for the parties to achieve eventual consensus.
In Ouroboros Genesis, this block includes the keys and initial stake
distribution of the parties that are present at the beginning of the
protocol. This assumption—i.e., that the genesis block is properly
created, reliably distributed to the initial parties, and that it is properly communicated to anyone who joins later—is captured in [16]
by assuming access to a (local) functionality FINIT. For each stakeholder registered at the beginning of the protocol, FINIT records his
key in the genesis block; this block is distributed to anyone who
requests it in any future round. To simplify the protocol description,
we will assume throughout the paper that the first round—i.e., the
genesis round—of the protocol occurs when the global time is τ = 0.
This is w.l.o.g., as the actual genesis-round index is written on the
genesis block and all parties have access to the global clock.
Hybrids used (only) in the security proof. Ouroboros Genesis
requires as setup only the above local and global functionalities
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 916
F
∆
N-MC, FINIT, Gclock, and GRO. However, for the sake of a clean
modular treatment, we also assume hybrid access to two more
functionalities from [16], capturing verifiable random functions
(VRF) FVRF and key-evolving signature schemes (KES) FKES. These
functionalities (which we recall in Appendix A) are UC-realizable
by cryptographic constructions [16]; therefore, they can be safely
replaced by virtue of the UC composition theorem.
2.2 The Ideal World Execution
We next turn to the functionalities available in the ideal-world.
In this world, the parties execute the so-called dummy protocol.
Since the clock and the random oracle are modeled as global setups,
they are available also in the ideal world. However, the Ouroboros
Genesis protocol (and the corresponding network and initialization
functionality) are replaced by the ideal functionality that abstracts
the protocol’s goals. We call this functionality the (ideal) ledger and
specify it below.
Overview. The ledger that Ouroboros Genesis realizes is almost
identical to the one proposed in [4] and shown to be implemented
by (the UC adaptation of) Bitcoin. Concretely, the ledger of [4] is
parameterizable by a collection of four algorithms, and the ledger
implemented by Ouroboros Genesis is effectively derived by appropriately instantiating these algorithms. This similarity can be seen
as a confirmation of the ledger abstraction, and as an affirmation
that Ouroboros Genesis meets strong composable security. We start
with a brief recap of the abstract ledger from [4] and then show
which ledger functionality Ouroboros Genesis realizes. The full
description of the ledger as pseudo-code is found in [3].
The ledger from [4] maintains a central and unique ledger state
denoted by state. Each registered party can request to see the state,
but is guaranteed to receive a only a sufficiently long prefix of it; the
size of each party’s view of the state is captured by (monotonically)
increasing pointers that define which part of the state each party can
read; the adversary has a limited control on these pointers. These
dynamics can be seen as a sliding window over the sequence of
state blocks, with width wSize and starting at the head of the state,
and each party’s pointer points to a location within this window
(the adversary can control the exact position). As is common in UC,
parties advance the ledger when they are activated with specific
maintain-ledger input by their environment Z. The ledger uses
these queries along with the function predict-time(·) to ensure that
the ideal world execution advances with the same pace (relatively
to the clock) as the protocol does.4
Ledger inputs and state update. Any party can input a transaction to the ledger once instructed by Z. The ledger first validates
transactions using a predicate Validate and if valid, these are added
to a buffer. Each new block of the state consists of transactions from
the buffer. To give protocols syntactic freedom of defining their
state block format, a vector of transactions, say N⃗
i
is mapped to
the ith state block via function Blockify(N⃗
i
). Validate and Blockify
are two of the ledger’s parametrization algorithms.
4Recall that the clock waits (also) for the ledger to check-in to advance its time/round
index.
One crucial property to specify a realistic ledger is the procedure
to define when/how to extend state, as one needs to find the balance between allowing the adversary certain influence (to reflect
real world impacts), and to enforce certain ideal policies/restrictions
regarding state updates. For example, our ledger enforces a minimum chain growth rate, a certain chain quality level, and liveness
of transactions. The procedure ExtendPolicy is responsible for enforcing such a policy. In nutshell, to enable adversarial influence,
ExtendPolicy takes as an input a proposal from the adversary for
extending the state, and can decide to follow this proposal if it satisfies its policy; if it does not, ExtendPolicy can ignore the proposal
and enforce a default extension.
Ledger Parameters. To specify the ledger achieved by Ouroboros
Genesis, we need to instantiate the relevant parameters and procedures from above. Blockify, Validate, and predict-time are chosen
to mimic the input/output format restrictions of the protocol; concretely, Blockify := blockifyOG, predict-time := predict-timeOG
(defined in the full version [3]), and
Validate(BTX, state, buffer) := ValidTxOG(tx, state),
where blockifyOG, predict-timeOG, and ValidTxOG are identical to
what the real protocol prescribes (cf. Section 3).
The procedure ExtendPolicy is trickier. It enforces the following
properties:
1. All blocks of state are semantically valid.
2. The state grows at a minimal rate of blocks over a time interval.
This is formalized by specifying a value maxTimewindow in which
at least wSize blocks have to be inserted into the ledger state.
3. A certain fraction of blocks in a sequence of wSize blocks have
to be honestly generated. This is enforced by requiring a limit
advBlckswindow of adversarial blocks in each window of wSize
blocks.
A detailed specification of the concrete ExtendPolicy is given in [3].
Guarantees for dynamic availability. The ideal guarantees
of [4] separates the active honest parties into two categories, called
synchronized and desynchronized. Desynchronized denotes those
parties that have registered with the protocol within the last Delay
rounds, where Delay (usually a multiple of the network delay) is a
parameter of the ledger that expresses how long a newly joining
party is not considered synchronized. Because we cannot guarantee
that these parties’ view is consistent with the rest of the honest
network, the ledger treats them as adversarial. However, as soon as
the interval of Delay rounds from registration passes, they become
synchronized and enjoy all guarantees for honest parties.
In this work, our goal is to achieve the highest granularity w.r.t.
capturing the security of parties depending on their availability
status. We go beyond the coarse-grained model of [4], where honest
parties are either offline or otherwise fall into two categories, and
separate honest parties into the following classes: offline parties
are honest parties that are deregistered from the network functionality. We further separate parties which are not offline into two
(sub-)categories, called (fully) online—parties which are registered
with all their setups and ideal resources—and (online but) stalled—
parties that are registered with their local network functionality,
but are unregistered with at least one of the global setups Gclock
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 917
Honest Parties
offline (have network)
(online, but) stalled
stalled
desynchronized
stalled
synchronized
(fully) online
online
desynchronized alert
Honest party “Synchronized”
state
Registered with
Gclock and GRO
Registered with
FN-MC
- alert ✓ ✓ ✓
- synchronized ✓ ? ✓
- online ? ✓ ✓
- stalled ? × ✓
- offline ? ? ×
Figure 1: Classification of honest parties. Based on access
to resources (clock Gclock, random oracle GRO, network
FN-MC) and presence in their current non-offline status for
more than Delay rounds (synchronized or desynchronized).
and GRO. Each of these (non-offline) subclasses is further split into
two subcategories along the lines of [4]: those that have been in
their current (non-offline) state for more that Delay rounds are
synchronized, whereas the remainder are desynchronized. This classification is illustrated in Figure 1. We will call a party active if it is
either online (and hence honest) or adversarial.
As in [4], the ledger keeps an updated track of registered parties
with all global setups and knows which category each party belongs
to. Desynchronized parties are treated as adversarial, whereas, offline and stalled parties remain silent (i.e., the ledger produces no
output for them). We note in passing that, although not included
in [4], this level of granularity is an interesting extension to the
existing Bitcoin analysis.
PoS vs. PoW Ledgers. There is one minor point where the
PoS ledger needs to deviate from the Bitcoin one. In Bitcoin the
contents of the genesis block are irrelevant (i.e., the ledger can
simply have this block hardwired). However, in PoS it is inherent that the initial stake distribution is reliably reflected (and
recall that parties associated to this setup register in the very
first round in the protocol execution). As we will see, to ensure
that the ledger execution is indistinguishable from the real-world
Ouroboros Genesis, we equip the ledger with an additional parameter, the initial stakeholders set and corresponding stake distribution
SinitStake := {(U1,s1), . . . , (Un,s1)}. If some honest stakeholder abstains from registering in the first round, the ledger stops execution.
For the formal specification of the concrete ledger that Ouroboros
Genesis realizes we refer to the full version [3].
3 OUROBOROS GENESIS AS A UC-PROTOCOL
The protocol Ouroboros-Genesis resembles the structure of its predecessor Ouroboros Praos [16], but differs drastically in its core,
as it invokes a novel chain selection rule. This allows, for the first
time in the PoS literature, parties to come and go (and loose and
regain access to their resources) at any point without the need
of external checkpointing. As already discussed, the protocol assumes access to the network functionalities and global setups, i.e.,
F
∆
N-MC, FINIT, Gclock, and GRO. Due to space limitation, we give a
detailed protocol overview in this section that is sufficient to follow
and evaluate the protocol and the results, and we refer to [3] for
the full specification.
Terminology and notation We start with some notation. We
use x ≺ y to indicate that the string x is a prefix of the string y.
Consider an arbitrary partitioning of the time axis into subsequent,
non-overlapping, equally long intervals called slots. For the purpose
of this section, a block is an arbitrary piece of data that contains an
identification of a time slot to which it belongs. A blockchain (or
chain, for short) is a sequence of blocks with increasing time slots,
starting with a special genesis block and with each subsequent block
containing a hash of the previous one. A more concrete description
of blocks and chains created by the Ouroboros Genesis protocol
will be given in Section 3.
We denote the length of a chain C (i.e., the number of its blocks)
by len(C). For a chain C and an interval of slots I ≜ [sli
, slj], we
denote by C[I] = C[sli
: slj] the sequence of blocks in C such that
their slot numbers fall into the interval I. We replace the brackets
in this notation with parentheses to denote intervals that do not
include endpoints; e.g., (sli
, slj] = {sli + 1, . . . , slj}. Finally, we
denote by #i:j
(C) ≜ #I
(C) ≜ |C[I]| the number of blocks in C[I].
Before giving the formal specification we introduce some necessary terminology and notation. Each party U stores a local
blockchain C
Up
loc —Up ’s local view of the blockchain.5 Such a local
blockchain is a sequence of blocks Bi
(i > 0) where each B ∈ Cloc
has the following format: B = (h, st, sl,crt, ρ, σ ). The first block
B0 is special and is referred to as the genesis block G. In each following block Bi
,i > 0, h is a hash of the previous block, st is the
encoded data of this block, and sl is the slot number this block
belongs to. The value crt = (Up,y, π ) certifies that the block was
indeed proposed by an eligible slot leader Up for slot sl by providing the output y of Up ’s VRF evaluation for this slot, along with
the corresponding VRF proof π. Additionally, ρ = (yρ , πρ ) is an
independent VRF output—along with its proof—that is also inserted
into the block by Up and is later used to derive the future epoch
randomness. Finally, σ is the signature by Up on the entire block
(using a key-evolving signature scheme).
If Cloc = B0 || · · · ||Bℓ
is a (local) chain, we define its associated
encoded state st⃗ as the sequence st0 || . . . ||stℓ
, where each sti—
referred to as the ith state block of the state—is the encoded data
stored in block Bi
. (The genesis data is defined to be st0 := ε.)
The exported state is then a specific prefix st⃗
⌈k
of this state (we
define this expression to be ε if k is larger than the size of the
chain). The exact format of the state blocks depends on the actual
implementation and is enforced by use of the function blockifyOG.
Concretely, each state block st is formed by applying this predicate
on a vector N of transactions to derive an appropriately formatted
version of the block. This parameterization allows flexibility in the
way the exported state is formatted.
5
For brevity, wherever clear from the context we omit the party ID from the local
chain notation, i.e., write Cloc instead of C
U
loc.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 918
To enable dynamic availability every party stores in a variable
ton (initially set to 1) the time/slot it was last online (and not stalled).
It also store in a variable twork (initially set to 0) the last time when
the staking procedure run to completion. Every protocol machine
also stores the current (local) state st⃗ encoded in the chain Cloc
and the local buffer buffer (corresponding to the transactions seen
so far on the network and not added on the blockchain); st⃗ , Cloc
and buffer are all initially empty.
For brevity, whenever in the protocol we say that a party uses
the clock to update, τ , ep, and sl we mean the following step:
Send (clock-read,sidC ) to Gclock; receive the current time
τ and update ep := ⌈τ /R⌉ and slot index sl = τ , accordingly.6
Handling interrupts in a UC protocol. A protocol command
might consists of a sequence of operations. In UC, certain operations, such as sending a message to another party or outputting
a message to the environment, result into the protocol machine
loosing the activation. Thus, one needs a mechanism for ensuring
that a party that looses the activation in the middle of such a multistep command is able to resume and complete this command. Such
a mechanism is implicitly described in [24]. This mechanism can
be made explicit by introducing an anchor a that stores a pointer
to the current operation; the protocol associates each anchor with
such a multiple command and an input I, so that when such an
input is received it directly jumps to the stored anchor, executes
the next operation(s) and updates (increases) the anchor before
releasing the activation. We refer to execution in such a manner as
I-interruptible.
For clarity we include an example of an interruptible execution.
Assume that the protocol mandates that upon receiving input I,
the party should run a command that consists of m steps Step 1,
Step 2, . . . , Step m, but some of these steps might result in the
executing party releasing its activation. Running this command
in an I-interruptible manner means executing the following code:
Upon receiving input I if a < m go to Step a and increase a = a + 1
before executing the first operation that releases the activation;
otherwise go to Step 1 and set a = 2 before executing any operation
that releases the activation.
Protocol overview. The protocol execution proceeds in disjoint,
consecutive time intervals called slots. Importantly, time is divided
in such a way that all parties know when a new slot starts—in
our specification, every slot is one round, hence the parties can
compute the current slot by comparing the round, i.e., clock value,
recorded on the genesis block with the current round. Without loss
of generality we will assume that the protocols starts when the
global time is τ = 0; in this case the current slot index will be τ .
In each slot sl, the parties execute a so-called staking procedure
to extend the blockchain. At a high level, the staking procedure
consists of the following steps: First, the parties execute an implicit
lottery to elect a slot leader from a distribution which, roughly, is
biased by the stake distribution—the more stake a party has in the
system, the more likely he is to be elected slot leader.
In any given slot, the elected slot leaders are in charge of extending the blockchain. Concretely, slot leaders are allowed to propose
6Recall that we assume for simplicity that the protocol starts when τ = 0 and that R
is a protocol parameter defining the duration of an epoch (in rounds).
an updated blockchain. To this end, the slot leader creates and signs
a block for the current slot. Each such block contains transactions
that may move stake among stakeholders. The slot leader then
multicasts the new, extended (by one block) chain to its peers. We
remark that, as in [16], in order to achieve adaptive security the
blocks are signed using a key-evolving signature scheme FKES instead of a standard signature, and honest parties are mandated to
update their private key in each slot.
A chain proposed by any party might be adopted only if it satisfies the following two conditions: (1) it is valid according to a well
defined validation procedure, and (2) the block corresponding to
each slot is signed by a corresponding certified slot leader.
To ensure the second property we need the implicit slot-leader
lottery to provide its winners (slot leaders) with a certificate/proof
of slot-leadership. For this reason, we implement the slot-leader
election as follows: Each party Up checks whether or not it is a slot
leader, by locally evaluating a verifiable random function (VRF, [17],
modeled by FVRF) using the secret key associated with its stake,
and providing as inputs to the VRF both the slot index sl and the
so-called epoch randomness η (we will discuss shortly where this
randomness comes from). If the VRF output y is below a certain
threshold Tp—which depends on Up ’s stake—then Up is an eligible
slot leader; furthermore, he can use the verifiability of the VRF to
generate a proof π of the function’s output, thereby certifying his
own eligibility to act as a slot leader. In particular, in addition to
transactions, each new block broadcast by a slot leader also contains
the VRF output y and a proof π of its validity to certify the party’s
eligibility to act as a slot leader.
Using the output of a VRF to identify the slot leaders as above not
only allows for certifying the winner, but it also ensures that slot
leaders are chosen from the appropriate distribution. In a nutshell,
this is achieved as follows: Multiple slots are collected into epochs,
each of which contains R ∈ N slots.7 The idea of having epochs
is that it allows to use stake reference points that are old enough
to be stable—with high probability—and are therefore appropriate
to be used in a universally verifiable proof. Concretely, during an
epoch ep, the stake distribution Sep that is used for deriving the
threshold T
ep
p
used for the slot-leader election corresponds to the
distribution recorded in the ledger up to the last block of epoch
ep − 2. Additionally, the epoch randomness ηep for sampling slot
leaders in epoch ep is derived as a hash of additional VRF-values
yρ that were included (together with their respective VRF-proofs
πρ ) into blocks from the first two thirds of epoch ep − 1 for this
purpose by the respective slot leaders. (To unify block structure,
our protocol includes these values into all blocks, but this would
not be necessary in practice.) The values Sep and ηep are updated
at the beginning of each epoch.
A delicate point of the above staking procedure is that there will
inevitably be some slots with zero or several slot leaders. This means
that the parties might receive valid chains from several certified
slot leaders. To determine which of these chains to adopt as the new
state of the blockchain, each party collects all valid broadcast chains
and applies a chain selection rule maxvalid-bg. In fact, the power of
the protocol Ouroboros-Genesis and its superiority over all existing
7Unlike [16], where R is fixed, in this work we treat R as a protocol parameter, which
will be bounded appropriately by our security statements.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 919
PoS-based blockchains stems from this new chain-selection rule
which we discuss in detail below.
The formal structure of the Ouroboros Genesis protocol is given
in Figure 2. For completeness, the description includes a block of
commands (in the bottom of the description) which specify what
parties do when they receive external, protocol-unrelated queries
to their setups, such as independent queries to the global random
oracle. Because the ideal-world (dummy) parties would forward
such queries to their setups, the protocol needs to do the same.
Registration/Deregistration (cf. Section 3.1):
Upon receiving input (register, R), where
R ∈ {Gledger, Gclock, GRO } execute protocol
Registration-Genesis(Up, sid, Reg, R).
Upon receiving input (de-register, R), where
R ∈ {Gledger, Gclock, GRO } execute protocol
Deregistration-Genesis(Up, sid, Reg, R).
Interacting with the Ledger (cf. Section 3.2):
Upon receiving a ledger-specific input
I ∈ {(submit, . . .), (read, . . .), (maintain-ledger, . . .)} verify first
that all resources are available. If not all resources are available, then
ignore the input; else execute one of the following steps depending on
the input I:
If I = (submit, sid, tx) then set buffer ← buffer| |tx, and
send (multicast, sid, tx) to F
∆
N-MC.
If I = (maintain-ledger, sid, minerID) then invoke protocol
LedgerMaintenance(Cloc, Up, sid, k, s, R, f ); if
LedgerMaintenance halts then halt the protocol execution (all
future input is ignored).
If I = (read, sid) then invoke protocol
ReadState(k, Cloc, Up, sid, R, f ).
Handling external (protocol-unrelated) calls to the clock and
the RO:
Upon receiving (clock-read, sidC ) forward it to Gclock and
output Gclock’s response.
Upon receiving (clock-update, sidC ), record that a clock-update
was received in the current round.
Upon receiving (eval, sidRO, x ) forward the query to GRO and
output GRO’s response.
Prot. Ouroboros-Genesisk (Up, sid; Gledger, Gclock, GRO, F
∆
N-MC)
Figure 2: The Ouroboros Genesis Protocol
3.1 Registration and Deregistration
The first thing a party needs to do in order to have any role in
the protocol is register with its resources. Registration (and deregistration) is dictated to the (honest) parties by the environment.
This captures the fact that resource availability is not something
controlled by the protocol itself. For example, a crash of the timing or hashing process of the party’s computer is captured by the
environment instructing the party to deregister from the clock or
the GRO, respectively. To capture our high-resolution (dynamic)
availability, the environment is allowed to register and deregister
parties from any of the resources at will.
In the following we describe the protocol that the parties execute upon receiving a registration/deregistration request. For clarity, we assume that every party keeps a local registry, denoted
by Reg, that includes a registration-flag for each of the functionalities (local and global) the party is connected to; whenever the
party registers or deregisters with some functionality/setup the
corresponding flag is updated accordingly. Since the registration
and deregistration commands are addressed to setups or to the
ledger, they only affect the real-world protocol if they are addressed
to one of the functionalities/setups that are present, i.e., to some
G ∈ {Gclock, GRO, Gledger}. Any registration input with session
ID different than that of those three functionalities will be ignored
by the protocol. W.l.o.g., we do not write the session IDs of global
setups and refer to them simply with their name.
The registration with any of the global setups GRO and Gclock
is straightforward. However, registering with the ledger is a little
more complicated: Upon receiving a ledger-registration query from
the environment, the party first checks that it is registered with the
global functionalities GRO and Gclock. If not, then it ignores the
input (and is still considered offline). Otherwise, it registers with
each functionality—excluding the already registered-to global setup
functionalities GRO and Gclock. Moreover, once a party registers
with its network it also stores the current time in variable ton. (Recall
that ton stores the last time the party was online, i.e., connected to
all its resources.) The deregistration is performed analogously.
Note that the registration to and from the global functionalities
has to stay under the control of the environment. Only once this procedure is completed, the party becomes operational and otherwise
is considered de-registered and does not answer any ledger-specific
queries (i.e., it is offline). The activation after any (de)registration
goes back to the environment. The registration and deregistration processes Registration-Genesis and Deregistration-Genesis
are specified as pseudo-code in [3].
3.2 Interacting with the Ledger
At the core of the Ouroboros Genesis protocol is the process that
maintains the ledger. There are three types of processes that are
triggered by three different commands provided that the party is
already registered to all its local and global functionalities—if this
in not the case, the corresponding command is ignored.8
The command (submit,sid, tx) is used for sending a new
transaction to the ledger (to be included in one of the upcoming blocks). It results in the party storing the submitted
transaction in its local transaction buffer and multicasting it
to the network so that other parties also add it to their buffers.
The command (read,sid) is used for the environment to ask
for a read of the current ledger state. It results in the party
outputting a prefix st⃗
⌈k
of the state st⃗ extracted from its most
recently updated (local) blockchain. As we argue, any such
output will be a prefix of any output given by any other party
(this will follow from the common-prefix property).
8Recall that our ledger functionality ensures that a parties input is considered—not
ignored—only if this party is registered with all its global inputs.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 920
The command (maintain-ledger,sid, minerID) triggers the
main ledger update and maintenance procedure which is the
most involved part. A party receiving this command first
fetches from its network all information relevant for the current round, then it uses the received information to update
its local data—i.e., asks the clock for the current time τ , updates its epoch counter ep, its slot counter sl, and its (local
view of) stake distribution parameters, accordingly; and finally it invokes the staking procedure unless it has already
done so in the current round. If this is the first time that the
party processes a (maintain-ledger,sid, minerID) message
then before doing anything else, the party invokes an initialization protocol to receive the initial information it needs to
start executing the protocol—in particular, the genesis block.
Furthermore, in order accommodate stalled parties, if the party
is registered with the network but not with all other setups,
this stalled party remembers the time it was stalled and returns the activation back to the environment. Also, since a
stalled party remembers the last time it was online—thereby
also the time it became stalled—in variable ton, once such a
party gets reconnected—i.e., re-registers with the ledger in the
ideal world (resp. with the network, the VRF and the KES in
the real world)—then upon its next activation to maintain the
ledger, the party fetches all messages it has missed by comparing the current time τ to ton and querying the network the
corresponding number of times. The relevant sub-processes
involved in the handling of a maintain-ledger query are detailed in [3]. Here we provide a high-level description and
discussion of these protocols.
3.2.1. Party Initialization A party that has been registered with
all its resources and setups becomes operational by invoking the
initialization protocol Initialization-Genesis upon processing its
first maintain-ledger command (see Figure 3 for detailed description). As a first step the party receives its keys from FVRF and FKES.
Subsequently, protocol Initialization-Genesis proceeds in one of
the following two modes depending on whether or not the current
round is the genesis round. Concretely:
In the genesis mode, which is only executed during the genesis round τ = 0, the party interacts with the initialization
functionality FINIT to claim its stake.
In the non-genesis mode, i.e., when τ > 1, the protocol
Initialization-Genesis queries FINIT to receive the genesis
block and uses the received stake distribution to determine
the initial threshold T
ep
p
for each stakeholder Up . Additionally, in order for the party to receive transactions and chains
that were circulated over the network prior to this current
round, the party multicasts a special message hello upon
its first maintain-ledger activation (in addition to its normal
round messages). Looking ahead, any Up receiving this message will set a special welcome flag to 1 and will trigger (at
first chance) Up to multicast his local buffer and chain; receiving these messages will enable the newly joining party to get
up to speed. Recall that in order to ensure that the genesis
round has been completed (and all initial stakeholders have
claimed their stake) before the protocol starts advancing, the
functionality FINIT throws an exception (halts with an error) if
the environment does not allow all stakeholders to claim their
stake in the genesis round. If this occurs, the calling protocol
(i.e., Ouroboros Genesis) also halts (cf. Figure 2).
Independent of the round, the protocol concludes with the party
setting isInit ← true (to make sure that it is never re-initialized)
and ton ← τ to remember the last time it became online—which in
this case is also the first one.
The following steps are executed in an
(maintain-ledger, sid, minerID)-interruptible manner:
1: Send (KeyGen, s id, Up ) to FVRF and FKES; receiving
(VerificationKey, s id, v
vrf
p
) and (VerificationKey, s id, v
kes
p
),
respectively.
2: Use the clock to update τ, ep ← ⌈τ /R⌉, and sl ← τ .
// The following brunch in only executed if this is the genesis
round
3: if τ = 0 then execute the following steps in an
(maintain-ledger, sid, minerID)-interruptible manner:
4: Send (ver_keys, s id, Up, v
vrf
p
, v
kes
p
) to FINIT to claim stake
from the genesis block.
5: Send (clock-update, sidC ) to Gclock.
6: Use the clock to update τ, ep ← ⌈τ /R⌉, and sl ← τ . and give
up the activation.
7: while τ = 0 do
8: Use the clock to update τ, ep, and sl and give up the
activation.
end while
// The following executed if this is a non-genesis round
9: else
10: Send (genblock_req, s id, Up ) to FINIT. If FINIT signals an error then halt. Otherwise, receive from FINIT the response
(genblock, s id, G = (S1, η1)), where
S1 =

(U1, v
vrf
1
, v
kes
1
, s1), . . . , (Un, v
vrf
n , v
kes
n , sn )

.
11: Set Cloc ← (G).
12: Set T
ep
p ← 2
ℓVRFϕf
(α
ep
p
) as the threshold for stakeholder Up
for epoch ep, where α
ep
p
is the relative stake of stakeholder Up
in Sep and ℓVRF denotes the output length of FVRF.
13: Send (hello, sid, Up, v
vrf
p
, v
kes
p
) to F
new
N-MC.
end if
14: Set isInit ← true and ton ← τ .
Global variables: The protocol stores the list of variables
v
vrf
p
, v
kes
p
, τ, ep, sl, Cloc, T
ep
p
, isInit, ton to make each of them
accessible by all protocol parts.
Protocol Initialization-Genesis(Up, sid, R)
Figure 3: The initialization protocol of Ouroboros Genesis
(run only the first time a party joins).
3.2.2. Fetching Information from the Network The first thing
that an already initialized (and fully online) party does is to attempt
to read its incoming messages. Recall that in our network setting, a
party accesses its network interface by sending a fetch command
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 921
The following steps are executed in an (maintain-ledger, sid, minerID)-interruptible manner:
// Determine leader status
1: Send (EvalProve, sid, ηj ∥ sl ∥ NONCE) to FVRF, denote the response from FVRF by (Evaluated, sid, yρ, πρ ).
2: Send (EvalProve, sid, ηj ∥ sl ∥ TEST) to FVRF, denote the response from FVRF by (Evaluated, sid, y, π ).
3: if y < T
ep
p
then
// Generate a new block
4: Set buffer′ ← buffer, N⃗ ← txbase-tx
Up
, and st ← blockifyOG(N⃗ )
5: repeat
6: Parse buffer′
as sequence (tx1, . . . , txn )
7: for i = 1 to n do
8: if ValidTxOG(txi
, st⃗ | |st) = 1 then
9: N⃗ ← N⃗ | |txi
10: Remove tx from buffer′
11: Set st ← blockifyOG(N⃗ )
end if
end for
until N⃗ does not increase anymore
12: Set cr t = (Up, y, π ), ρ = (yρ, πρ ) and h ← H (head(Cloc )).
13: Send (USign, sid, Up, (h, st, sl, cr t, ρ), sl) to FKES; denote the response from FKES by (Signature, sid, (h, st, sl, cr t, ρ), sl, σ ).
14: Set B ← (h, st, sl, cr t, ρ, σ ) and update Cloc ← Cloc ∥ B.
// Multicast the extended chain and wait.
15: Send (multicast, sid, Cloc ) to F
bc
N-MC and proceed from here upon next activation of this procedure.
end if
16: while A (clock-update, sidC ) has not been received during the current round do
Give up activation. Upon next activation of this procedure, proceed from here.
end while
Protocol StakingProcedure(k, Up, ep, sl, buffer, Cloc )
Figure 4: The Ouroboros Genesis staking procedure. The value y is used to evaluate slot leadership: if y < T
ep
p
then the party is
a slot leader and continues by processing its current transaction buffer to form a new block B. Aside of this application data,
each block contains control information, for example the proof of leadership (y, π ) and the additional VRF-output (yρ , πρ )
that influences the future epoch-randomness.
to its network. A network latency of, say, ∆ rounds, in the delivery
of any given messages is then captured by the network withholding
this message until ∆ fetch commands are issued (cf. [24]). In order
to ensure that parties which have been stalled (but were not taken
offline) can catch up with the messages sent to them while they
where stalled, we use the following mechanism. The party first
gets the current time τ from the clock, and then sets a counter
fetchcount to τ −ton. (Since ton stores the last round that the party
was online, fetchcount will be the number of rounds this party was
stalled.) Subsequently the party issues fetchcount fetch-queries to
its network. Recall that a party that was offline and becomes online
is considered de-synchronized for (at least) as many rounds as it
needs for that party to receive all the relevant information and for
the chain-selection rule to bootstrap it9 —by detecting a chain that
is guaranteed to originate from an honest and synchronized party.
This party does not get to retroactively receive messages sent to
it while it was offline, which is is reflected in our protocol by the
fact that this party will execute the network-registration procedure
from scratch and will therefore set ton = τ .
9We give concrete bounds on the time it needs to become synchronized in Section 4.
3.2.3. The Staking Procedure The next part of the ledgermaintenance protocol is the staking procedure—denoted by
StakingProcedure and found in Figure 4—which is used for the
slot leader to compute and send the next block.
Recall that a party Up is an eligible slot leader for a particular
slot sl in an epoch ep if its VRF-output (for an input dependent on
sl) is smaller than a threshold value T
ep
p
. We next discuss how this
threshold is computed for the party’s current (local) blockchain,
where we use the following notation: ℓVRF denotes the VRF output
length in bits. The (local) stake distribution Sep at epoch ep corresponding to the (local) blockchain Cloc is a mapping from a party
(identified by its public keys) to its stake and can be derived solely
based on encoded transactions in Cloc (and the genesis block).10
The relative stake of Up in the stake distribution Sep, denoted as
α
ep
p
∈ [0, 1], is the fraction of stake that is associated with this party
(more precisely, its public key) in Sep out of all stake. The mapping
ϕf
(·) is defined as
ϕf
(α) ≜ 1 − (1 − f )
α
(1)
10The exact encoding is not of primary relevance. A possible, straightforward encoding
is given in [16].
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 922
and is parametrized by a quantity f ∈ (0, 1] called the active slots
coefficient [16], which is an important parameter of the protocol
Ouroboros-Genesis (and its predecessor).
Given the above, the threshold T
ep
p
is determined as
T
ep
p = 2
ℓVRFϕf
(α
ep
p
) . (2)
Note that by (2), a party with relative stake α ∈ (0, 1] becomes
a slot leader in a particular slot with probability ϕf
(α), independently of all other parties. We clearly have ϕf
(1) = f , hence f
is the probability that a hypothetical party controlling all 100%
of the stake would be elected leader for a particular slot. Furthermore, the function ϕ has an important property called “independent
aggregation” [16]:
1 − ϕ *
,
X
i
αi
+
-
=
Y
i
(1 − ϕ(αi
)) . (3)
In particular, when leadership is determined according to ϕf
, the
probability of a stakeholder becoming a slot leader in a particular
slot is independent of whether this stakeholder acts as a single party
in the protocol, or splits its stake among several “virtual” parties.
Therefore, we can conclude that under arbitrary stake distribution,
a particular slot has some slot leader with probability f (if everyone is participating), giving the active slots coefficient its intuitive
meaning.
Transaction Validity. Blockchain ledgers typically put restrictions on transactions that can be added to a block. For example,
Bitcoin only allows transactions that are properly signed and are
spending an unspent coin. Although this is not directly related to
the consistency guarantees, similarly to [4], our ledger also has such
a transaction filter in place (this makes it suitable for applications
like cryptocurrencies). This filter is implemented by means of a
predicate ValidTxOG. To decide which transactions can be included
in the state of a new block, the party checks for each transaction
contained in its buffer whether it is valid, according to ValidTxOG,
with respect to the current state of the chain. Note that to allow for
full generality we leave ValidTxOG as a protocol/ledger parameter
(the same for both); this will allow to use the same protocol and
ledger for different definitions of transaction validity.
The transaction validity predicate ValidTxOG induces a natural
transaction validity on blockchain-states. This is captured by the
predicate isvalidstate(st⃗ ) that decides whether a state consists of
valid transactions according to ValidTxOG. The predicate simply
checks that each transaction tx of any state-block sti
included in
the state st⃗ = st0 || . . . ||stℓ
includes transactions that are valid
with respect to the state st0 || . . . ||sti−1 ||st−tx
i
, where st−tx
i
is the
i-th state block sti with tx removed.
Remark 1 (Building a Cryptocurrency Ledger). Consistently
with the cryptographic literature on blockchains, we use the term
transaction to refer to input values tx given to the ledger protocol
(and the ledger functionality). It is important to recall that in order to
achieve the standard ledger functionality of this work, where weak
transaction liveness is enforced, transactions need not be signed (cf.
[4, 18]). 11 Using composition, a protection to amplify the liveness
11More technically speaking, whether transactions are signed or not is completely
orthogonal to the security proof in this paper. The reason is that the main honeststake-majority condition refers to the stake-distribution and hence is a property of the
of transactions can be applied as a next modular step, on top of our
ledger functionality. We note in passing that such an amplification
has been achieved assuming a signature scheme combined with an
explicit encoding of transactions to contain the source and destination
addresses of the involved parties that relate to their public keys and/or
identities; an honest protocol participant would consequently only
sign its transactions but no others, and signature verification would be
part of the validity check ValidTxOG. We refer to [4] for details on how
to build a UC cryptocurrency ledger on top of a generic transaction
ledger using the composability guarantees of the UC framework.
3.2.4. Chain Selection The most novel component of our protocol
is the way in which a party decides which chain to adopt given a
set of alternatives it (repeatedly) receives over the network. The
chain selection protocol is invoked once a party has collected all
chains from a given round—denote the set of all these chains by
N = {C1, . . . , CM }—and must decide whether to keep his current
local chain Cloc, or adopt one of the newly received chains in N .
As we prove, the power of the new rule lies in the fact that it allows
a desynchronized or even a newly joining party—whose Cloc is
empty—to eventually converge to a good chain. We refer to this
process as bootstrapping from genesis, and denote the new chain
selection algorithm as maxvalid-bg.
The chain selection process proceeds in three steps: First the
party Up uses the clock to make sure the time-relevant parameters, i.e., τ , ep, and sl, are up-to-date, and updates its local state
accordingly (see below). Second, Up filters all the received chains,
one-by-one, to keep only the ones that satisfy a syntactic validity
property. Informally, those are chains whose signatures are consistent with the genesis block, and their block-contents are consistent
with the keys recorded in KES, the VRF, and the global random
oracle. The filtering of any given chain C is done by an invocation
of protocol IsValidChain described in Figure 5. Finally, the party
applies our new chain selection rule maxvalid-bg on the filtered
list of chains to (possibly) update its local chain. The above three
steps are detailed in the following.
Step 1: Updating the local state. Every time a party fetches new
information from the network, it needs to refresh its local view,
and in particular to update the current epoch counter ep using
the current clock time, as well as its view of the state parameters:
the current epoch stake distribution Sep, the relative stake α
ep
p
,
and epoch randomness ηep, and the staking threshold T
ep
p
. This is
achieved by the protocol UpdateLocal (see Figure 6). The algorithm
used to update the stake parameters, in particular the threshold
T
ep
p
, was discussed in Section 3.2.
Step 2: Filtering out invalid chains. The protocol IsValidChain
which filters out invalid chains is the same as the corresponding
protocol from [16] (cf. [3] for the full specification.)
Step 3: The new chain selection rule. The chain selection rule
maxvalid from [16] (which, to avoid confusion, we hereafter refer
to as maxvalid-mc for “moving checkpoint”, cf. Section 4) prefers
longer chains, unless the new chain Ci forks more than k blocks
relative to the currently held chain Cmax (in which case the new
basic content of the blockchain (and the corruption state of the miners) and therefore
under the control of the environment providing the contents via inputs to the protocol.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 923
if C contains future blocks, empty epochs, starts with a block other
than G, or encodes an invalid state with isvalidstate(st⃗ ) = 0 then
return false
end if
for each epoch ep do
// Derive stake distribution and randomness for this epoch from
// chain C
Set S
C
ep to be the stakeholder distribution at the end of epoch
ep − 2 in C.
Set α
ep,C
p′
to be the relative stake of any party Up′ in S
C
ep and
T
ep,C
p′ ← 2
ℓVRFϕf
(α
ep,C
p′
).
Set η
C
ep ← H (η
C
ep−1
∥ ep ∥ v) where v is the concatenation of the
VRF outputs yρ from all blocks in C from the first 16k/f slots
of epoch ep − 1, and η
C
1 ≜ η1 from G.
for each block B in C from epoch ep do
Parse B as (h, st, sl, cr t, ρ, σ ).
// Check hash
Set badhash ← (h , H (B
−1
)), where B
−1
is the last block in
C before B.
// Check VRF values
Parse cr t as (Up′, y, π ) for some p
′
.
Send (Verify, s id, ηep ∥ sl ∥ TEST, y, π, v
vrf
p′
) to FVRF,
get response (Verified, s id, ηep ∥ sl ∥ TEST, y, π, b1).
Send (Verify, s id, ηep ∥ sl ∥ NONCE, yρ, πρ, v
vrf
p′
) to FVRF,
get response (Verified, s id, ηep ∥ sl ∥ NONCE, yρ, πρ, b2).
Set badvrf ←

b1 = 0 ∨ b2 = 0 ∨ y ≥ T
ep,C
Up
′

.
// Check signature
Send (Verify, s id, (h, st, sl, cr t, ρ), sl, σ, v
kes
p′
) to FKES,
get response (Verified, s id, (h, st, sl, cr t, ρ), sl, b3).
Set badsig ← (b3 = 0).
if (badhash ∨ badvrf ∨ badsig) then
return false
end if
end for
end for
return true
Protocol IsValidChain(Up, k, C, h, f , R)
Figure 5: The chain validation (filtering) protocol
chain would be discarded). This so-called moving checkpointing
is crucial for the security proof in [16]; indeed, maxvalid-mc only
guarantees satisfactory blockchain properties when coupled with
a checkpointing functionality that provides newly joining, or rejoining, parties with a recent trusted chain. In particular, such
checkpointing provides resilience against so-called “long-range
attacks” (see [20] for a detailed discussion).
Our new chain selection rule, formally specified as algorithm
maxvalid-bg(·) (see Figure 7), adapts maxvalid-mc by adding an additional condition (Condition B). When satisfied, the new condition
can lead to a party adopting a new chain Ci even if this chain did
fork more than k blocks relative to the currently held chain Cmax.
Specifically, the new chain would be preferred if it grows more
1: Use the clock to update τ, ep ← ⌈τ /R⌉, and sl ← τ .
2: Set Sep to be the stakeholder distribution at the end of epoch
ep − 2 in Cloc.
3: Set α
ep
p
to be the relative stake of Up in Sep and
T
ep
p ← 2
ℓVRFϕf
(α
ep
p
).
4: Set ηep ← H (ηep−1 ∥ ep ∥ v) where v is the concatenation of the
VRF outputs yρ from all blocks in Cloc from the first 2R/3 slots of
epoch ep − 1.
Output: The protocol outputs τ, ep, sl, Sep, α
ep
p
, T
ep
p
, and ηep to its
caller (but not to Z).
Protocol UpdateLocal(k, Up, R, f )
Figure 6: The protocol for updating the local stake distribution parameters.
quickly in the s slots following the slot associated with the last
block common to both Ci and Cmax (here s is a parameter of the
rule that we discuss in full detail in the proof). Roughly, this “local
chain growth”—appearing just after the chains diverge—serves as
an indication of the amount of participation in that interval. The
intuition behind this criterion is that in a time interval shortly after
the two chains diverge, they still agree on the leadership attribution for the upcoming slots, and out of the eligible slot leaders, the
(honest) majority has been mostly working on the chain that ended
up stabilizing.
// Compare Cmax to each Ci ∈ N
1: Set Cmax ← Cloc.
2: for i = 1 to M do
3: if (Ci forks from Cmax at most k blocks) then
4: if |Ci
| > |Cmax | then // Condition A
Set Cmax ← Ci
.
end if
5: else
6: Let
j ← max (
j
′ ≥ 0 | Cmax and Ci have the same block in slj
′
)
7: if 


Ci[0 : j + s]



>



Cmax[0 : j + s]



then // Condition B
Set Cmax ← Ci
.
end if
end if
end for
8: return Cmax.
Algorithm maxvalid-bg(Cloc, N = {C1, . . . , CM }, k, s, f )
Figure 7: The new chain selection rule.
Thus the new rule substitutes a “global” longest chain rule with a
“local” longest chain rule that prefers chains that demonstrate more
participation after forking from the currently held chain Cmax. As
proven in Section 4, this additional condition allows an honest party
that joins the network at an arbitrary point in time to bootstrap
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 924
based only on the genesis block (obtained from FINIT) and the
chains it observes by listening to the network for a sufficiently long
period of time. In prior work, a newly spawned party had to be
assumed to be bootstrapped by obtaining an honest chain from an
external, and fully trusted, mechanism (or, alternatively, be given a
list of trustworthy nodes from which to request an honest chain);
our solution does not rely on any such assumption. We refer to
this process/assumption as checkpointing; provably avoiding this
process by means of an updated chain selection rule is one of the
major contributions of our work.
The protocol executed by the parties to select a new chain, denoted as SelectChain, can be found in Figure 8.
// Step 1: Updating the local state
1: Invoke protocol UpdateLocal(k, Up, R, f ) and denote the output
as τ, ep, sl, Sep, α
ep
p
, T
ep
p
, and ηep.
// Step 2: Filter out invalid chains
2: Initialize Nvalid ← ∅
3: for i = 1 . . . M do
Invoke Protocol IsValidChain(Ci
); if it returns true then update
Nvalid ← Nvalid ∪ Ci
end for
// Step 3: Applying the chain selection rule.
4: Execute Algorithm
maxvalid-bg(Cloc, Nvalid = {C1, . . . , CM }, k, s, f ) and receive its
output Cmax.
Output: The protocol outputs Cmax to its caller (but not to Z).
Protocol SelectChain(Cloc, N = {C1, . . . , CM }, k, s, R, f )
Figure 8: The protocol for parties to adopt a (new) chain.
The main ledger-maintenance protocol LedgerMaintenance
which stitches together the previously introduced sub-processes
can be found in Figure 9.
3.2.5. Reading the State The last command related to the interaction with the ledger is the read command (read,sid) that is used to
read the current contents of the state. Note that in the ideal world,
the result of issuing such a command is for the ledger to output a
(long enough prefix) of the current state of the ledger. Analogously,
in the real world, the result is for the party receiving it to execute
protocol ReadState which works as follows: the party, first, gets
up to speed with time, and updates its local blockchain using the
blockchains that have been sent to it,12 and then it computes and
outputs the prefix of its local chain (chopping of k blocks.) The
protocol ReadState is detailed in Figure 10.
12Observe that a stalled party that returns to the alert status will fetch all messages
sent to it while it was stalled.
The following steps are executed in an
(maintain-ledger, sid, minerID)-interruptible manner:
1: if isInit is false then invoke Initialization-Genesis(Up, sid, R);
if Initialization-Genesis halts then halt (this will abort the
execution); otherwise, use the list of initialized variables
v
vrf
p
, v
kes
p
, τ, ep, sl, Cloc, T
ep
p
, isInit, ton for the ongoing
computations.
end if
2: Execute FetchInformation to receive the newest messages for this
round; denote the output by (C1, . . . , CM ), (tx1, . . . , txk ), and
read the flag welcome.
3: if welcome = 1 then
4: Send (multicast, sid, Cloc ) to F
bc
N-MC.
5: for each tx ∈ buffer do
Send (multicast, sid, tx) to F
tx
N-MC.
end for
end if
6: Use the clock to update τ, ep ← ⌈τ /R⌉, and sl ← τ .
7: Set buffer ← buffer| |(tx1, . . . , txk ), ton ← τ , N ← {C1, . . . ,
and CM }
8: Invoke Protocol
SelectChain(Cloc, N = {C1, . . . , CM }, k, s, R, f ).
9: if twork < τ then
10: Invoke protocol StakingProcedure(k, Up, ep, sl, buffer, Cloc )
(in a (maintain-ledger, sid, minerID)-interruptible manner).
11: Set twork ← τ and send (clock-update, sidC ) to Gclock.
end if
Protocol LedgerMaintenance(Cloc, Up, sid, k, s, R, f )
Figure 9: The main ledger maintenance protocol.
1: if isInit is false then invoke Initialization-Genesis(Up, sid, R);
if Initialization-Genesis halts then halt (this will abort the
execution); otherwise, use the list of initialized variables
v
vrf
p
, v
kes
p
, τ, ep, sl, Cloc, T
ep
p
, isInit, ton for the ongoing
computations.
end if
2: Execute FetchInformation to receive the newest messages for this
round; denote the output chains by (C1, . . . , CM ) (the list of
transactions (tx1, . . . , txk ) and the flag welcome can be
ignored).
3: Invoke protocol UpdateLocal(k, Up, R, f ) and denote the output
as τ, ep, sl, Sep, α
ep
p
, T
ep
p
, and ηep.
4: Use the clock to update τ, ep ← ⌈τ /R⌉, and sl ← τ .
5: Set ton ← τ , N ← {C1, . . . , CM }.
6: Invoke Protocol
SelectChain(Cloc, N = {C1, . . . , CM }, k, s, R, f ).
7: Extract the state st⃗ from the current local chain Cloc.
8: Output (read, sid, st⃗
⌈k
) (to Z). // st⃗
⌈k
denotes the prefix of st⃗
with the last k state blocks chopped off
Protocol ReadState(k, Cloc, Up, sid, R, f )
Figure 10: The protocol for parties to adopt a (new) chain.
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 925
4 SECURITY ANALYSIS
After introducing the main desiderata for blockchain protocols in
Section 4.1, the security analysis proceeds in four modular steps.
In Section 4.2, we present the results of analyzing the predecessor
protocol, namely Ouroboros Praos, in a setting where parties could
potentially be stalled dynamically. As outlined above, the analysis
of this setting requires fundamentally new techniques. For the same
setting, the analysis of Ouroboros Genesis follows in Section 4.3 by
adopting the new chain selection rule (which is the difference between Praos and Genesis) and analyzing the impact of this change.
In Section 4.4 we extend the analysis of Ouroboros Genesis to the
setting where new parties can join (and leave) the protocol execution at any time. Finally, in Section 4.5, we establish UC-security,
i.e., that Ouroboros Genesis realizes the ledger functionality in a
setting with dynamic availability.
4.1 Blockchain Security Properties
We first define the standard security properties of blockchain protocols: common prefix, chain growth and chain quality. While the
security guarantees we prove in this paper are formulated in the
UC setting, these standalone properties will turn out to be useful
tools for our analysis.
Common Prefix (CP); with parameters k ∈ N. The chains
C1, C2 possessed by two alert parties at the onset of the slots
sl1 < sl2 are such that C
⌈k
1
⪯ C2, where C
⌈k
1
denotes the
chain obtained by removing the last k blocks from C1, and
⪯ denotes the prefix relation.
Chain Growth (CG); with parameters τ ∈ (0, 1],s ∈ N. Consider a chain C possessed by an alert party at the onset of
a slot sl. Let sl1 and sl2 be two previous slots for which
sl1 + s ≤ sl2 ≤ sl, so sl2 is at least s slots ahead of sl1.
Then |C[sl1 : sl2]| ≥ τ · s. We call τ the speed coefficient.
Chain Quality (CQ); with parameters µ ∈ (0, 1] and k ∈ N.
Consider any portion of length at least k of the chain possessed by an alert party at the onset of a slot; the ratio of
blocks originating from the adversary is at most 1 − µ. We
call µ the chain quality coefficient.
Note that previous work identified and studied a stronger version
of chain growth (denoted below as CG2), which controls the relative
growth of chains held by potentially distinct honest parties.
(Strong) Chain Growth (CG2); with parameters τ ∈ (0, 1],s ∈
N. Consider the chains C1, C2 possessed by two alert parties
at the onset of two slots sl1, sl2 with sl2 at least s slots
ahead of sl1. Then it holds that len(C2) − len(C1) ≥ τ · s.
We remark that the notion of chain growth CG2 follows from CP
and CG (with some appropriate decay in parameters). However,
it appears that CG is a preferable formulation in our setting, as it
can be established with stronger parameters than CG2 and more
naturally dovetails with several aspects of the security proofs.
Finally, we will also consider a slight variant of chain quality
called existential chain quality:
Existential Chain Quality (∃CQ); with parameter s ∈ N. Consider a chain C possessed by an alert party at the onset of
a slot sl. Let sl1 and sl2 be two previous slots for which
sl1 + s ≤ sl2 ≤ sl. Then C[sl1 : sl2] contains at least one
honestly generated block.
As a side remark, the CG (resp. CQ) property follows from ∃CQ and
an additional property called honest-bounded chain growth HCG
(resp. honest-bounded chain quality, HCQ). We define HCG and
HCQ and establish these relationships as part of our full analysis
given in [3].
Note that typically these security properties for blockchain protocols are formulated so that they grant the above-described guarantees to all honest parties. However, in our more fine-grained
modeling of parties’ availability, a natural choice is to analyze these
properties for the alert parties only.
4.2 Security of Ouroboros Genesis with
maxvalid-mc
The original Ouroboros Praos protocol given in [16] differs from
Ouroboros Genesis in its chain selection rule, which we call
maxvalid-mc here and outline below. For the sake of better comparison, we show maxvalid-mc in Appendix B. The difference in
maxvalid-mc compared to maxvalid-bg is that if the considered
chain Ci forks from the current chain Cloc more than k blocks in
the past, it is immediately discarded, without evaluating Condition B as in maxvalid-bg. This can be seen as a “moving checkpoint”
k blocks behind the current tip of the chain, which is what the suffix
-mc stands for. To preserve clarity, we will use Ouroboros-Praos
to refer to the protocol that is identical to the one given in Section 3 except that is uses maxvalid-mc instead of maxvalid-bg as
its chain-selection rule.
Our first goal is to establish that the useful properties of common prefix, chain growth, and chain quality are achieved by
Ouroboros-Praos, when executed in a slightly restricted environment. Namely, we start by assuming that all parties participate in
the protocol run from the beginning and never get deregistered
from the network FN-MC (i.e., honest parties are either online or
stalled); we refer to this setting as the setting with static FN-MCregistration. We will drop this assumption later.
The desired statement for this limited environment is given in
Theorem 4.3, the rest of Section 4.2 will be dedicated to sketching
its proof, which is fully spelled out in [3]. First, we need to define
some relevant quantities.
Definition 4.1 (Classes of parties and their relative stake). Let P[t]
denote the set of all parties at time t, and let Ptype[t] for any type
of party described in Figure 1 (e.g. alert, active) denote the set of all
parties of the respective type in time t. For a set of parties Ptype[t],
let S(Ptype[t]) ∈ [0, 1] denote the relative stake of the parties in
Ptype[t] with respect to the stake distribution used for sampling
stake leaders in time t.
Definition 4.2 (Alert ratio, participating ratio). At any time t during the execution, we let: (1) the alert stake ratio be the fraction
S(Paler t[t])/S(Pact ive [t]) of the alert stake out of all active stake;
and (2) the participating stake ratio be the fraction S(Pact ive [t]) of
all active stake out of all stake. Note that in the setting with static
FN-MC-registration, the set of active parties consists only of alert
and adversarial parties, while in general it also contains honest
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 926
parties that are online but desynchronized (we will discuss these in
detail in Section 4.4).
Theorem 4.3. Consider the execution of Ouroboros-Praos with
adversary A and environment Z in the setting with static FN-MCregistration. Let f be the active-slot coefficient, let ∆ be the upper
bound on the network delay and let Q be an upper bound on the total
number of queries issued to GRO. Let α, β ∈ [0, 1] denote a lower
bound on the alert ratio and participating ratio throughout the whole
execution, respectively. Let R and L denote the epoch length and the
total lifetime of the system (in slots), If for some ϵ ∈ (0, 1) we have
α · (1 − f )
∆+1 ≥ (1 + ϵ )/2 , (4)
and R ≥ 36∆/ϵβ f then Ouroboros-Praos achieves the following guarantees:
Common prefix. The probability that Ouroboros-Praos violates the CP property with parameter k is no more than
ϵCP(k) ≜
19L
ϵ
4
exp(∆ − ϵ
4
k/18) + ϵlift ;
Chain growth. The probability that Ouroboros-Praos violates
the CG property with parameters s ≥ 48∆/(ϵβ f ) and τCG =
β f /16 is no more than
ϵCG(τCG,s) ≜
sL2
2
exp 
−(ϵβ f )
2
s/256
+ ϵlift ;
Existential chain quality. The probability that the protocol
Ouroboros-Praos violates the ∃CQ property with parameter
s ≥ 12∆/(ϵβ f ) is no more than
ϵ∃CQ (s) ≜ (s + 1)L
2
exp 
−(ϵβ f )
2
s/64
+ ϵlift ;
Chain quality. The probability that Ouroboros-Praos violates
the CQ property with parameters k ≥ 48∆/(ϵβ f ) and µ =
ϵβ f /16 is no more than
ϵCQ (µ, k) ≜
kL2
2
exp 
−(ϵβ f )
2
k/256
+ ϵlift ;
where ϵlift is a shorthand for the quantity
ϵlift ≜ QL ·
"
R
3
· exp
−
(ϵβ f )
2R
768 !
+
38R
ϵ
4
· exp
∆ −
ϵ
4
β f R
864 !#
.
Proof Overview. We give here a proof overview and refer to
the full version of this work [3] for the complete analysis. The proof
is inspired by the proof of property-based security of Ouroboros
Praos given in [16]; however, a major extension of the techniques
is necessary. To appreciate the need for this extension, let us first
recall in very broad terms how the proof in [16] proceeds:
1. First, the above security properties (or slight variations of them,
cf. Section 4.1) are proven for a single epoch. For this, the dynamics of the protocol execution is abstracted into combinatorial objects called forks, while the slot leader selection (assuming static corruption) is captured by sampling a so-called
characteristic string.
2. A recursive rule is given that identifies whether a characteristic string allows for “dangerous” forks, and a probabilistic
analysis shows that under static corruption, leader schedules
corresponding to such characteristic strings are extremely rare.
3. Given the rarity of such undesirable characteristic strings, the
CP, CG, and CQ properties are established for a single epoch
and a static-corruption adversary.
4. The analysis is generalized to fully adaptive corruption by
showing a static-corruption adversary that dominates any adaptive one.
5. The analysis is extended to an arbitrary number of epochs by
analyzing the subprotocol for generating new randomness to
be used in the following epoch to sample the leader schedule.
The main improvement of Theorem 4.3 over the analysis in [16] is
that it captures stalled parties (and making honest parties stalled
is a fully adaptive decision of the environment). Unfortunately,
this makes it impossible to start with a static analysis of the slotleader selection as done above in steps 1–3. Moreover, the argument
in step 4 completely breaks down as the static adversary given
in [16] no longer dominates any possible adaptive combination
of corruption and stalling. Therefore, our proof needs to revisit
the steps 1–4 and replace the analysis of a sequence of binomially
distributed random variables (representing the characteristic string)
by considering inter-slot dependence right from the beginning.
This is done via a martingale framework that is an important
contribution of this work since its generality might form the basis
of future analyses of blockchain protocols. We give all the details
of the approach in [3]. □
4.3 Adopting the New maxvalid-bg Rule
We now show that essentially the same guarantees as provided by
Theorem 4.3 still hold when we replace the chain selection rule
maxvalid-mc with maxvalid-bg, arriving at the protocol Ouroboros
Genesis. The proof of Theorem 4.4 is found in [3].
Theorem 4.4. Consider the protocol Ouroboros-Genesis using
maxvalid-bg as described in Section 3, executed in the setting with
static FN-MC-registration, under the same assumptions as in Theorem 4.3. If the maxvalid-bg parameters, k and s, satisfy
k > 192∆/(ϵβ) and R/6 ≥ s = k/(4f ) ≥ 48∆/(ϵβ f )
then the guarantees given in Theorem 4.3 for common prefix, chain
growth, chain quality, and existential chain quality are still valid
except for an additional error probability
exp (ln L − Ω(k))+ϵCG(β f /16, k/(4f ))+ϵ∃CQ (k/(4f ))+ϵCP(kβ/64) .
(5)
4.4 Newly Joining Parties
We next show that the above proven guarantees on common prefix,
chain growth and (existential) chain quality remain valid also when
new parties join the protocol later during its execution.
To capture this, we proceed as follows. For any new party U
that joins the protocol later during its execution (say at slot sljoin),
we consider a virtual party U˜ that holds no stake, but was participating in the protocol since the beginning and was alert all the
time. Moreover, we assume that starting from sljoin, U˜
is receiving
the same messages (in the same slots) as U . Clearly, the run of the
protocol up to sljoin would look the same with and without U˜
, as
U˜ would never be elected a slot leader, and would not affect α or
β. Therefore, the execution of the protocol up to the point when
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 927
the first party U tries to join is covered by the statements proven
in Section 4.3 (even when also considering the participation of U˜
).
To argue about the joining process of U , we consider the abovedescribed execution and look at the first chain that U˜ adopts as an
update to its state after sljoin. We call it the synchronizing chain
of U , denote it Csync. Since it is a rather intuitive notion, we omit a
formal definition here and refer to the full version [3]. The heart
of our argument is then captured in the following lemma, proven
in [3].
Lemma 4.5. In the same setting as Theorem 4.4 but with dynamic
FN-MC-registrations, any newly joining party will adopt its synchronizing chain, except with probability (5).
In the full version [3], we discuss and formally analyze the socalled synchronization time tsync it takes for the synchronizing chain
to appear after U joins the execution, for several variants of the
protocol. Our main observations are: (1) Using the default request
mechanism presented in Section 3 we have tsync = 2∆. (2) If alert
parties did multicast their local state every (constant) T rounds,
we have tsync := T + ∆ even without any active request by the
newly joining party. (3) The protocol also has a self-synchronization
property, in the sense that even without any active requests, the
party will receive a synchronizing chain eventually.
The analysis of the synchronization process that was outlined
above applies also to resynchronization of parties that have already
participated in the protocol, acquired some stake, and then been
deregistered from FN-MC and hence became offline. The only difference is that, since the joining party does not know which of
the messages it receives is actually its synchronizing message containing Csync, it starts participating in the protocol immediately
after rejoining. Hence, before it receives Csync its participation is
to some extent controlled by the adversary and hence its stake has
to be counted towards the adversarial stake even though the party
is not formally corrupted. This is already captured in the general
form of Definition 4.2, and hence we have established the following
corollary.
Corollary 4.6. Consider the protocol Ouroboros-Genesis as described in Section 3, executed in an environment with dynamic FN-MCregistrations and deregistrations. Then, under the assumptions of Theorem 4.4, the guarantees it gives for common prefix, chain growth,
and chain quality are valid also in this general setting.
4.5 Composable Guarantees
We conclude our analysis by showing how the property-focused
statement of Corollary 4.6 can be turned into a UC security statement. The statement is conditioned again on the honest majority
assumption introduced above. As explained in [4] for fully composable statements, it is desirable not to restrict the environment, but
rather model these restrictions as part of the setup. In [4], they put
forth a general methodology to model such restrictions as wrapper
functionalities that control the interaction between an adversary
and the assumed setup functionality to enforce the restrictions. For
completeness, we provide the corresponding wrapper in the full
version [3].
To prove composable security, the properties proven above for
the real-world UC-execution play a crucial role in realizing the
ledger Gledger functionality (implementing a certain policy): first,
the common-prefix property ensures that the ledger can maintain
a unique ledger-state (a chain of state-blocks). Second, the chain
quality ensures that the ledger can enforce a fraction of honestly
generated blocks. Third, chain growth ensures that the ledger can
enforce its state to grow. The remaining arguments are given in
the full proof in [3]. We now state the composable version of Corollary 4.6 (again for the default tsync = 2∆ case) as a theorem:
Theorem 4.7. Let k be the common-prefix parameter and let R
be the epoch-length parameter (restricted as in Theorem 4.4), let ∆
be the network delay, let τCG and µ be the speed and chain-quality
coefficients, respectively (both defined as in Theorem 4.3), and let α
and β refer to the respective bounds on the participation ratios (as
in Theorem 4.3). Let Gledger be the ledger functionality defined in
Section 2.2 and instantiate its parameters by
wSize = k and Delay = 2∆
maxTimewindow =
wSize
τCG
and advBlckswindow = (1 − µ)wSize.
The protocol Ouroboros-Genesis (with access to its specified hybrids) securely UC-realizes Gledger under the assumptions required
by Theorem 4.3. In addition, the corresponding simulation is perfect
except with negligible probability in the parameter k when setting
R ≥ ω(log k).
A HYBRID FUNCTIONALITIES IN
OUROBOROS GENESIS
Recall that we consider functionalities that handle a dynamic party
set. As introduced in [4], the employed mechanism roughly works
as follows: the functionalities include the instructions that allow
honest parties to join or leave the set P of players that the functionality interacts with, and inform the adversary about the current
set of registered parties. For sake of simplicity, we do not explicitly
state these commands in the descriptions below.
Key-Evolving Signatures. The key-evolving signature scheme is
employed for signing blocks and a specification is given in Figure 11.
Verifiable Random Function. The verifiable random function
functionality is employed during slot-leader election and a specification is given in Figure 11.
Both hybrid functionalities are shown to be implementable by
standard cryptographic constructions.
B THE CHAIN SELECTION RULE FROM [16]
To better compare the main step between Ouroboros Genesis and
its predecessor Ouroboros Praos, we depict the chain selection rule
of Ouroboros Praos in Figure 12.
C LIST OF SYMBOLS
We give here a reference on the symbols and their associated meanings that we used in the main body.
The communication model:
∆ maximum message delay in slots
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 928
FVRF interacts with parties called U1, . . . , Un as follows:
• Key Generation. Upon receiving a message (KeyGen, s id) from a
stakeholder Ui
, hand (KeyGen, s id, Ui
) to the adversary. Upon
receiving (VerificationKey, s id, Ui
, v) from the adversary, if Ui
is
honest, verify that v is unique, record the pair (Ui
, v) and return
(VerificationKey, s id, v) to Ui
. Initialize the table T (v, ·) to empty.
• Malicious Key Generation. Upon receiving a message
(KeyGen, s id, v) from S, verify that v has not being recorded before;
in this case initialize table T (v, ·) to empty and record the pair (S, v).
• VRF Evaluation. Upon receiving a message (Eval, s id, m) from Ui
,
verify that some pair (Ui
, v) is recorded. If not, then ignore the request.
Then, if the value T (v, m) is undefined, pick a random value y from
{0, 1}
ℓVRF and set T (v, m) = (y, ∅). Then output (Evaluated, s id, y)
to P, where y is such that T (v, m) = (y, S ) for some S.
• VRF Evaluation and Proof. Upon receiving a message
(EvalProve, s id, m) from Ui
, verify that some pair (Ui
, v) is recorded.
If not, then ignore the request. Else, send (EvalProve, s id, Ui
, m) to
the adversary. Upon receiving (Eval, s id, m, π ) from the adversary, if
value T (v, m) is undefined, verify that π is unique, pick a random
value y from {0, 1}
ℓVRF and set T (v, m) = (y, {π }). Else, if
T (v, m) = (y, S ), set T (v, m) = (y, S ∪ {π }). In any case, output
(Evaluated, s id, y, π ) to P.
• Malicious VRF Evaluation. Upon receiving a message
(Eval, s id, v, m) from S for some v, do the following. First, if (S, v)
is recorded and T (v, m) is undefined, then choose a random value y
from {0, 1}
ℓVRF and set T (v, m) = (y, ∅). Then, if T (v, m) = (y, S )
for some S , ∅, output (Evaluated, s id, y) to S, else ignore the
request.
• Verification. Upon receiving a message (Verify, s id, m, y, π, v
′
)
from some party P, send (Verify, s id, m, y, π, v
′
) to the adversary.
Upon receiving (Verified, s id, m, y, π, v
′
) from the adversary do:
(1) If v
′ = v for some (Ui
, v) and the entry T (Ui
, m) equals (y, S )
with π ∈ S, then set f = 1.
(2) Else, if v
′ = v for some (Ui
, v), but no entry T (Ui
, m) of the form
(y, {. . . , π, . . .}) is recorded, then set f = 0.
(3) Else, initialize the table T (v
′
, ·) to empty, and set f = 0.
Output (Verified, s id, m, y, π, f ) to P.
Functionality FVRF
FKES is parameterized by the total number of signature updates T ,
interacting with a signer US and stakeholders Ui as follows:
• Key Generation. Upon receiving a message (KeyGen, s id, US )
from a stakeholder US , send (KeyGen, s id, US ) to the adversary.
Upon receiving (VerificationKey, s id, US, v) from the adversary,
send (VerificationKey, s id, v) to US , record the triple (s id, US, v)
and set counter kctr = 1.
• Sign and Update. Upon receiving a message (USign, s id, US, m, j)
from US , verify that (s id, US, v) is recorded for some s id and that
kctr ≤ j ≤ T . If not, then ignore the request. Else, set kctr = j + 1 and
send (Sign, s id, US, m, j) to the adversary. Upon receiving
(Signature, s id, US, m, j, σ ) from the adversary, verify that no
entry (m, j, σ, v, 0) is recorded. If it is, then output an error message
to US and halt. Else, send (Signature, s id, m, j, σ ) to US , and record
the entry (m, j, σ, v, 1).
• Signature Verification. Upon receiving a message
(Verify, s id, m, j, σ, v
′
) from some stakeholder Ui do:
(1) If v
′ = v and the entry (m, j, σ, v, 1) is recorded, then set f = 1.
(This condition guarantees completeness: If the verification key
v
′
is the registered one and σ is a legitimately generated
signature for m, then the verification succeeds.)
(2) Else, if v
′ = v, the signer is not corrupted, and no entry
(m, j, σ
′
, v, 1) for any σ
′
is recorded, then set f = 0 and record
the entry (m, j, σ, v, 0). (This condition guarantees
unforgeability: If v
′
is the registered one, the signer is not
corrupted, and never signed m, then the verification fails.)
(3) Else, if there is an entry (m, j, σ, v
′
, f
′
) recorded, then let
f = f
′
. (This condition guarantees consistency: All verification
requests with identical parameters will result in the same
answer.)
(4) Else, if j < kctr, let f = 0 and record the entry (m, j, σ, v, 0).
Otherwise, if j = kctr, hand (Verify, s id, m, j, σ, v
′
) to the
adversary. Upon receiving (Verified, s id, m, j, ϕ) from the
adversary let f = ϕ and record the entry (m, j, σ, v
′
, ϕ). (This
condition guarantees that the adversary is only able to forge
signatures under keys belonging to corrupted parties for time
periods corresponding to the current or future slots.)
Output (Verified, s id, m, j, f ) to Ui
.
Functionality FKES
Figure 11: The VRF and the key-evolving signatures functionalities from [16].
Functionalities:
Gclock global clock
GRO global random oracle
F
bc,∆
N-MC ∆-delayed network for diffusing blockchains
F
tx,∆
N-MC ∆-delayed network for diffusing transactions
FINIT init functionality providing the genesis block
FVRF verifiable random function
FKES key-evolving signature scheme
Gledger the ledger functionality
Protocol Ouroboros-Genesis:
f active slots coefficient
ϕ(·) slot-leader probability function (Eq. (1))
R epoch length in slots
Sep stake distribution used to sample slot
leaders in epoch ep
α
ep
p
relative stake of party Up in Sep
ηep randomness used to sample slot leaders
in epoch ep
Analysis:
α alert stake ratio (Def. 4.2)
β participating stake ratio (Def. 4.2)
L total length of the execution (in slots)
Q total number of queries to the random
oracle
Session 5C: Blockchain 2 CCS’18, October 15-19, 2018, Toronto, ON, Canada 929
1: Set Cmax ← Cloc.
2: for i = 1 to ℓ do
3: if IsValidChain(Ci
) then
// Compare Cmax to Ci
4: if (Ci forks from Cmax at most k blocks) then
5: if |Ci
| > |Cmax | then // Condition A
Set Cmax ← Ci
.
end if
end if
end if
end for
6: return Cmax.
Protocol maxvalid-mc(Cloc, C1, . . . , Cℓ )
Figure 12: The chain selection rule of Ouroboros Praos