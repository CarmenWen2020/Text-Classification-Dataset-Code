Financial deposits are fundamental to the security of cryptoeconomic protocols as they serve as insurance against potential misbehaviour of agents. However, protocol designers and their agents
face a trade-off when choosing the deposit size. While substantial
deposits might increase the protocol security, for example by minimising the impact of adversarial behaviour or risks of currency
fluctuations, locked-up capital incurs opportunity costs. Moreover,
some protocols require over-collateralization in anticipation of future events and malicious intentions of agents. We present Balance,
an application-agnostic system that reduces over-collateralization
without compromising protocol security. In Balance, malicious
agents receive no additional utility for cheating once their deposits
are reduced. At the same time, honest and rational agents increase
their utilities for behaving honestly as their opportunity costs for
the locked-up deposits are reduced. Balance is a round-based
mechanism in which agents need to continuously perform desired
actions. Rather than treating agents’ incentives and behaviour as
ancillary, we explicitly model agents’ utility, proving the conditions
for incentive compatibility. Balance improves social welfare given
a distribution of honest, rational, and malicious agents. Further,
we integrate Balance with a cross-chain interoperability protocol,
XCLAIM, reducing deposits by 10% while maintaining the same
utility for behaving honestly. Our implementation allows any number of agents to be maintained for at most 55,287 gas (≈ USD 0.07)
to update all agents’ scores, and at a cost of 54,948 gas (≈ USD 0.07)
to update the assignment of all agents to layers.
CCS CONCEPTS
• Information systems → Reputation systems; • Security and
privacy → Trust frameworks; Distributed systems security; • Theory of computation → Algorithmic game theory.
KEYWORDS
deposits; cryptocurrency; reputation; mechanism design; cryptoeconomic protocols
1 INTRODUCTION
Capital deposits are a security measure to motivate economically
rational agents to behave honestly in cryptoeconomic protocols. Yet,
sources of uncertainty, such as exchange rate volatility, can lead to
over-collateralization, where more capital than necessary is lockedup as a buffer. Moreover, locked capital is expensive: being unable to
access funds, agents face an opportunity cost in the form of forgone
returns that they could have accrued in alternative investments.
Hence, cryptoeconomic protocol design plays an important role in
balancing security with locked capital costs.
Cryptoeconomic protocols (π) combine cryptographic primitives
and economic theory. In such protocols, a utility maximising agent
chooses which action to perform based on self-interest, ignoring
the impact of their action on other agents. However, cheating or
other malicious behaviour by self-interested agents may harm the
protocol as a whole. Therefore, protocols typically involve two types
of incentives, e.g. [5, 12, 24, 26–30, 33, 44, 48, 53–55]: (i) payouts
motivate agents to act in the best interest of the protocol, and
(ii) deposits prevent malicious actions by punishing misbehaving
agents. Yet, choosing the appropriate deposit is challenging due to
private information and event-dependency:
Definition 1 (Private information). A valuation vA(σ) encodes
the preference of an agent A for a specific outcome in a protocol
depending on an action σ
1
. We define this information as private,
i.e. only known to the agent2
.
Definition 2 (Event-dependency). Deposits paid in cryptocurrencies can be subject to external events. Event-dependency is caused
by events that occur outside of the underlying blockchain and affects the level of required deposits.
An agent A performing an action in a protocol can (i) be intrinsically motivated to harm the protocol or (ii) receive an external
payment to act maliciously due to e.g. bribing [36]. This preference
is encoded in vA and is unknown to the designer of π. Since such a
1
For brevity, we write vA(σ ) as vA in the rest of the paper.
2
See also Chapter 9.4.1 on games with incomplete information in [41].
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1485
valuation is private information, the required deposit for secure operation is ambiguous. Further, a deposit can be used as insurance for
tasks performed outside the underlying ledger, e.g. performing verifiable computations [20, 30, 48], cross-chain assets exchanges [53],
or exchanging digital goods [12]. For such usage, the protocol is
event-dependent, e.g. affected by exchange rate fluctuations. Private
information and event-dependency require protocol designers to
dynamically calculate the required deposit levels. However, this
leads to a dilemma: if the required deposit is too high, the agent is
likely to refuse to participate in the protocol. A requesting agent
fears that the providing agent has an incentive to cheat if the deposit is too low. In both cases, whether the deposit is set “too low”
and “too high” is subjective. Thus, our central research question
arises: how can deposits in over-collateralised protocols be dynamically adjusted when assuming that agents have private information
and there exists a dependency on external events?
We present Balance which provides dynamic adjustment of deposits in over-collateralized protocols, improving agents’ financial
welfare, without compromising security. Balance is applicable to
protocols that (i) are implemented on a decentralised ledger, (ii) use
a deposit to prevent economically rational agents from performing
undesired actions, (iii) require agents to over-collateralize due to at
least one of the two identified sources of uncertainty, and (iv) verify
interactions with agents through objective specifications ϕ. Suitable
examples for integrating Balance are FairSwap [12], TrueBit [48],
NOCUST [27], and XCLAIM [53].
Security intuition. Balance allows agents to reduce their capital deposits over a sequence of periodic rounds, while preventing
the addition of incentives to act maliciously. In fact, malicious
agents that aim to misbehave in a protocol obtain more utility if
they do early on, before their deposits are reduced. Conversely,
honest and rational agents receive a higher utility by consistently
acting in the interest of the protocol. Balance achieves this property for protocols which feature over-collateralization by reducing
deposits to a lower bound. Above the lower bound, the additional
utility gained from reducing the deposit is less than the opportunity
cost for locking-up the deposit. Hence, a malicious agent gains no
additional utility from cheating in a later round with a reduced
deposit. However, honest and rational agents gain additional utility
by reducing the opportunity cost of the locked deposit.
Contributions
• Introduction of Balance, a mechanism for deposit reduction: the mechanism maps agents to layers according
to their behaviour, where each layer is associated with a
different level of deposit. The higher the layer, the lower
the required deposit, mitigating over-collateralization. To
the best of our knowledge, this is the first mechanism allowing for the dynamic adjustment of cryptocurrency deposits
while maintaining the same level of security.
• A formal analysis of agents’ incentives: we explicitly
model agents’ utilities with and without Balance. For agents
committed to a protocol, we characterise the conditions on
incentive compatibility for Balance. Further, we show that
given a distribution of agents over honest, rational, and malicious agent types in a protocol, introducing Balance leads
to an increase in social welfare. We show that with a decrease
of the provided deposit, we can achieve a greater incentive
for economically rational agents to behave honestly.
• An integration with XCLAIM: we integrate Balance with
XCLAIM [53], a protocol that allows two cryptocurrencies to
be exchanged without trusted intermediaries, using Solidity3
.
The clear exhibition of event dependency and private information in XCLAIM makes it a highly suitable Balance use
case. We show that Balance reduces deposits by 10% while
maintaining the same level of payoff for complying with the
specification of the protocol. The implementation has linear
complexity for storing the score of agents depending on the
number of layers with a maximum cost of updating a score
of a single agent of 55,287 gas (≈ USD 0.07). Further, curating
the agents to layers during transition to the next round has
constant complexity with 54,948 gas (≈ USD 0.07).
Structure
In Section 2 we provide a definition for cryptoeconomic protocols
including contracts and utilities. We provide an overview of Balance and its security assumptions in Section 3. Next, we introduce
the design and functionality of Balance in Section 4. We define a
model to prove incentive compatibility and social welfare increase
in Section 5. Balance’s security is evaluated in Section 6. We apply
Balance to XCLAIM in Section 7. Finally, we present related work
in Section 8 and conclude in Section 9.
2 CRYPTOECONOMIC PROTOCOLS
Cryptoeconomic protocols combine cryptographic primitives and
economic theory to create applications on a decentralised ledger.
We define a cryptoeconomic protocol as follows.
Definition 3 (Cryptoeconomic protocol π). A cryptoeconomic
protocol implements agreements—containing publicly known specifications (i.e. the terms of the agreement), verified through cryptographic primitives in a decentralised ledger—between multiple
agents. An agreement encodes an incentive mechanism through
payments and deposits, seeking to promote honest behaviour.
The states of a protocol are as follows (cf. Appendix A).
(1) Committed: an agent A commits to perform an action σ
that fulfils a specification ϕ defined by an agreement. The
commitment requires payment of a deposit D.
(2) Executed: an agent A performs an action σ. This action either
complies with the specification or violates it4
.
(3) Concluded: if the action σ complies with the specification,
the deposit plus any payments is transferred to the agent.
Otherwise, the agent’s deposit is destroyed or transferred to
another agent that suffered from σ
5
.
In this work, we use notation as summarised in Appendix D.
3The implementation is available at https://github.com/nud3l/balance.
4There are protocols that implement more complex verification steps, e.g. over multiple
rounds with accusations. However, at a high-level, the principle remains the same: the
protocol implements a method to determine whether or not a specification ϕ holds.
5Once the protocol is concluded, agents are free to redeem their deposit (if it has not
been destroyed or sent to another agent).
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1486
2.1 Contracts and agreements
A cryptoeconomic protocol π is implemented through smart contracts. A contract includes agreements A in the form of (similar
to [46]):
A = ⟨ϕ,p, D⟩ (1)
ϕ represents a condition that needs to be fulfilled by an action
and can evaluate to either true or false, i.e. ϕ : σ → {0, 1}. For
example, the FairSwap protocol implements such a mechanism by
arithmetic circuits [12]. p are the payments made from a receiving
agent B to a performing agent A as stated in the agreement. Further,
agents need to provide deposits to commit to a protocol. D is a set of
deposits {D1, ..,Dn } paid by agents to participate in an agreement
implemented in a smart contract. The smart contract acts as an
escrow of the deposit. If an agent complies with the specification
in an agreement, i.e. ϕ(σ) = 1, the deposit is refunded. If an agent
performs an action ϕ(σ) = 0 (or no action), the smart contract will
not refund the deposit to the agent.
2.2 Action choices
Following Definition 3, an agent commits to a protocol and can
only then perform an action. The agent has two action choices.
(1) An agent A ∈ P performs a desired action σA ∈ Σd
, where Σd
is defined as the set of all actions that evaluate to true with
respect to the specification of an agreement, i.e. ϕ(Σd
) = 1.
(2) An agent A ∈ P performs an undesired action σA ∈ Σu ,
where Σu is the set of all actions that evaluate to false for the
specification of an agreement, i.e. ϕ(Σu ) = 0. This includes
also no action σA = ∅ as this results in ϕ(∅) = 0.
2.3 Utility parameters
Each of the two action choices results in a utility for the agent expressed by u(σ). The utility of an action depends on five parameters.
(1) Payment p: determines how much an agent B has to pay for
an action in an agreement A and how much the performing
agent A receives by fulfilling the specification in A.
(2) Cost c: captures all costs associated with performing an action. This includes, for example, transaction costs and costs
for executing an action σ in A.
(3) Deposit D: summarises the deposits by agents in A.
(4) Expected future return E[rD]: describes the opportunity cost
for locking deposit D within an agreement that could be used
in another protocol to earn an interest6
.
(5) Valuation v: encodes the private preference of an agent for
an outcome depending on an action σ.
The private valuation expresses that an agent A prefers performing
an action σ ∈ Σu . Reflecting our security focus, we focus on the
worst case, where agents only derive a valuation from performing
an undesired action. Assume A is given the task to perform a computation in a protocol like TrueBit [48] and provided a deposit D
in the agreement A to perform a computation that fulfils the specification ϕ. If A has a positive valuation for vA that does not fulfil
6We assume the future return rate is stochastic such that the opportunity cost is not
known with certainty. We therefore denote the return rate as the expected return rate,
E[r].
the specification and the provided deposit D is smaller than vA, the
agent prefers the undesired action. Note that this private valuation
is not limited to pecuniary value: it can include the non-pecuniary
value that an agent may derive from performing an undesired action. In practice, v might be hard to approximate. We reflect this by
introducing agent types depending on the relation between v and
the protocol incentives D and p (cf. Section 2.6).
2.4 Performing agent utilities
The following are the utilities an agent A ∈ P performing an action7
.
uA(σA) = (
p − cA − E[rDA], if σA ∈ Σd
vA − DA − cA − E[rDA], if σA ∈ Σu
(2)
The agent tries to maximise its utility by choosing an appropriate action. We note two observations from equation (2). First,
performing an undesired action becomes a rational choice if σA,i ∈
Σd
, σA,j ∈ Σu : u(σA,i
) < u(σA,j
). In a protocol π without Balance agents can enter or leave the game at any time and their
past actions are not considered. Hence, the game consists of single,
disconnected rounds, i.e. it is a single-shot game. Second, executing
a desired action depends on the publicly known payout p as well as
the agent specific costscA caused by performing the action and the
expected loss of interest E[rDA]. An agent will choose this action
if it yields higher utility than the other actions8
.
2.5 Receiving agent utilities
An agent B ∈ P receiving a certain action has a different utility
from the performing agent A. This agent has no influence on the
performance of the action of agent A if we assume that the payout
cannot be changed after commitments are made. We assume that
the agent that receives an action is reimbursed with the deposit
that is provided by the performing agent. The utilities depending
on A’s actions are calculated as in (3).
uB(σA) = (
vB − p − cB, if σA ∈ Σd
DA −vB − cB, if σA ∈ Σu
(3)
2.6 Agent types and adversaries
The performing agent A influences the utility for both performing
and receiving agents. Most importantly, the security of a cryptoeconomic protocol depends on a core assumption: adversaries are
economically rational and computationally bounded. Considering
Eq. (2), an agent A chooses to perform a desired action if the utility
of the desired action is higher than the utility of the undesired
action, i.e. p − cA − E[rDA] > vA − DA − cA − E[rDA]. Inspired by
the BAR model [1], this notation allows us to express three types
of agents, from which we can deduct the adversaries.
Definition 4 (Performing agent types). We categorise performing
agents into the following three types.
7We omit the valuation vA for the desired action σ ∈ Σd as we assume agents do
not have an intrinsic or external motivation to comply with the specifications of
agreements in π .
8This is a deterministic model where we assume that if an agents “cheats”, it loses its
deposit. However, one could extend the model to include a probability of the agent
being caught if the specification function ϕ includes non-determinism.
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1487
(1) Type Td
: this type will always perform a desired action as
its utility resulting from a desired action is larger than the
valuation of an undesired action, i.e. vA ≪ DA + p.
(2) Type Tu : this type will always perform an undesired action
as vA ≫ DA + p. By definition, the deposit is never large
enough to prevent an undesired action by A.
(3) Type Tr : this type is undecided in the single-shot game setting which decision to take as v ≈ DA + p.
By this definition, a cryptoeconomic protocol is only able to
ensure that economically rational adversaries, i.e. type Tr , and
honest participants perform desired actions. Malicious adversaries
as expressed by the type Tu cannot be economically motivated
to perform a desired action. These agent types will perform the
undesired action as their valuation for the undesired outcome (from
the perspective of the protocol designer) is much greater than the
economic damage due to the loss of their deposit.
Following Definition 4 the notion of security that we employ in
our construction.
Definition 5 (Security under rational agents). A cryptoeconomic
protocol is secure if a economically rational performing agent A
would not choose an undesired action because the utility of a desired
action is greater, i.e. u(Σd
) > u(Σu ).
2.7 Mechanism utilities
Social welfare describes the sum of all agent utilities in a mechanism [51]. If we combine equations (2) and (3), we can calculate
the sum of utilities for performing and receiving agents {A, B} ∈ P
by considering the actions of performing agents A. Assuming that
every A is matched with at least one B, we split P into two groups
corresponding to whether the performing agents perform desirable
or undesirable actions. P is therefore comprised of a group ΛD ,
for the pairs of agents containing performing agents who perform
desirable actions and ΛU for undesirable actions. Thus summing
for pair of agents x ∈ P, where there are X pairs, such that 2X = |P |:
u(σA) = (PX
x=1(vx,B − cx,B − cx,A − E[rDx,A]), if A ∈ ΛD
PX
x=1(vx,A − cx,A −vx,B − cx,B), if A ∈ ΛU
(4)
Hence, if we take all actions within a certain amount of time,
we can specify the utility for a protocol π. Notably, agents acting
individually rationally and truthfully after commitment does not
imply that the mechanism as a whole maximises social welfare.
3 SYSTEM OVERVIEW
We introduce a mechanism called Balance, a verifiable layered
curated registry. The idea is to use Balance as an extension to
an existing cryptoeconomic protocol, i.e πBalance, to control the
amount of deposit an agent has to provide to resolve the dilemma
of having “too high” or “too low” deposits. The general intuition of
the mechanism is displayed in Figure 1 and is as follows:
• Commitment: an agent A has to provide a deposit D1 to commit to a protocol encoded by a smart contract. For protocols
with private information and event-dependency, the deposit
is typically set relatively high9
. An agent is not trusted at
9
For example, in the Dai stable coin, users have to provide at least a 150% deposit to
issue Collateralized Debt Positions (CDPs).
any point in time. However, an agent can reduce its deposit
by executing actions that are desired by the protocol.
• Execution: agents are tracked by a decentralised registry that
stores a ranking of their contributions towards the protocol.
Agents are initially assigned to the lowest layer which results
in the highest required deposit. When performing desired
actions, the agent collects a score within a round.
• Curation: if the agent’s score is high enough by the end of a
round, it moves to the next layer (provided there is a higher
layer). The mechanism defines a factor for each layer that is
multiplied with the base deposit. This will affect the deposit
an agent has to provide. Further, after each round, the score
of an agent is reset to retain an incentive to act in the best
interest of the protocol. Thereby, this mechanism introduces
a sequential game.
When an agent is assigned to a lower layer, i.e. having to provide
a higher deposit, the agent must ensure that the deposit requirement
is met within the current round. Otherwise, agents will move down
a layer or be removed from the registry.
3.1 Actors
Balance includes three actors with the following roles.
(1) Performing agent A: an agent A is committed to πBalance
and chooses action σ ∈ {Σd
, Σu } evaluating to true or false
with respect to the specification ϕ of an agreement A.
(2) Receiving agent B: a receiving agent B requested the performance of an action σ ∈ Σd as expressed by the specification
ϕ in the agreement A. The execution of the action is left
with an agent A.
(3) Registry R: the registry is a smart contract implemented
on a ledger. The registry keeps a mapping of scores of performing agents in a round t, a mapping of agents to layers in
a round t, and updates the mapping of agents to scores and
layers during transition to the next round t + 1. The registry
has direct access to the result of a performing agent’s action
ϕ(σ) = {0, 1} to update the agent’s score.
Each actor is identified on the ledger using a private/public
key pair. We note that agents can take several identities on the
blockchain, i.e. Sybil identities are possible. The adjustment of
deposit and consequences of performing actions is bound to a public
key. An agent A that performs several desired actions to reduce its
deposit can have a Sybil identity A
′
. However, the identity A
′
is
in the view of the registry R a separate agent and hence will not
benefit from the reduced deposit of the desired action sequence by
identity A. Further, we show in Section 6.2, that agents in Balance
cannot profit from Sybil attacks.
3.2 System properties
Balance achieves the following properties.
(1) Auditability: performing and receiving agentsA and B have
public insight into the amount of deposit D and layer assignment of performing agents A → L (Section 3.3).
(2) Reduction of opportunity costs: Balance reduces the opportunity costs of locked-up deposits E[rDA] for performing
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1488
ScoreA ? 100
ScoreB ? 200
ScoreC ? 90
ScoreD ? 400
Period t1
Layer 1 ? {A,B}
Layer 2 ? {C}
Layer 3 ? {D}
A B C D
Agents
BALANCE Smart Contract
ScoreA ? 0
ScoreB ? 0
ScoreC ? 0
ScoreD ? 0
Layer 1 = {A,C}
Layer 2 = {B}
Layer 3 = {D}
(1) perform actions
(3) period end
(2) updatescores (5) reset scores
Period t0
Cryptoeconomic Protocol
(4) curate agents
?A ?B ?C ?D
BALANCE Smart Contract
s(A)=100 s(B)=200 s(C)=90 s(D)=400
A B C D
Agents
Cryptoeconomic Protocol
layer(B) = 2 layer(C)=1
(6) notify agentsof layer and deposit updates
Figure 1: Balance is implemented as a smart contract and integrated into an existing cryptoeconomic protocol. Agents A, B,
C, and D are assigned to layers in the registry representing their deposit level. In step (1) they are performing actions as part of
a cryptoeconomic protocol. By performing these actions, they obtain a score that is forwarded to the Balance smart contract.
Step (2), is triggered by an agent’s actions and updates its scores. Scores reflect a reputation within a round, where the higher
the score the better. In step (3), the current round ends. The next interaction of an agent with the cryptoeconomic protocol
triggers step (4), the curation of agents to layers. The score of each agent is used to update the mapping of agents to layers,
whereby agents can either stay at the same layer, get promoted or demoted by one, or get removed from the registry. Updating
the assignment of an agent to a layer is determined by the upper and lower bounds of the layer an agent is currently assigned
to. Within that update, step (5) resets the scores of the agent for the next round. Last, in step (6), agents that changed their
layer are notified (e.g. via events emitted from a smart contract).
agent A by reducing deposit depending on the layer assignment A → L (Section 4.1).
(3) Strategy-proofness: a performing agent A behaves truthfully with respect to its valuation of an outcome vA independent of its type T (Section 5.2, 5.4).
(4) Transparency: assuming performing agents A1 and A2 provided the same initial deposit D, but are now assigned to
different layers such that DA1
̸= DA2
, B does not need to
choose between A1 and A2 as Balance ensures that each
deposit provides the same utility for A1 and A2 to act in the
interest of B (Section 5.5).
(5) Social welfare increasing: the joint welfare of performing agent A and receiving agent B is increased with Balance (Section 5.6).
(6) Sybil resistance: a performing agent A cannot gain additional utility from Balance by creating Sybil identities A
′
(Section 6.2).
3.3 Blockchain model
Balance operates as part of π implemented on a blockchain. This
blockchain provides a ledger functionality as for example defined
in [3, 4, 9, 42]. We assume that the ledger has finality as in consensus protocols like [6, 38, 47]. Additionally, we assume given the
number of participants n in a consensus protocol, the number of
Byzantine faults is f < n/3. In cases where a consensus protocol
does not provide finality, like Nakamoto consensus [40], we assume
that a security parameter k is set such that with high probability the
transaction is securely included [18]. Apart from that, we assume
that less than 1/3 of miners are malicious [13]. Setting an appropriate parameter for k and having less than 1/3 miners malicious,
prevents the impact from selfish-mining attacks.
Aside from the ledger, we assume there is an execution environment and a scripting language available that supports the creation
of secure smart contracts to implement agreements A and the registry R, for example the Ethereum Virtual Machine [49, 50]. We
assume that the agreement A including its specification ϕ, payments p, and deposits D is implemented by a smart contract SC
such that SC ⇔ A. Further, we require the possibility of creating generic data structures to store the information about agents’
scores and layers as part the registry R and that such information is
readable by performing and receiving agents A and B. Moreover, we
assume that the cryptographic primitives in the ledger are securely
implemented.
We make no further assumptions regarding the blockchain. Miners and adversaries are able to re-order transactions, censor transactions, and read the information from transactions before and after
they are included in the blockchain.
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1489
Property 1 Auditability
The deposit D and mapping of performing agents to layers A → L
is publicly available within R.
3.4 Agent assumptions
We make the following assumptions. First, for clarity of exposition,
we make the simplification that if an agent performs a single desired
action at a certain time, they transition to the higher layer. This
is a simplification because in the full specification, agents would
need to perform a number of actions in order to change layer. This
assumptions strengthens the adversary, as the reduction of deposit
requires only a single action. Second, we assume that πBalance
unambiguously detects an undesired action, i.e. ϕ(σ) = 0. In this
case, the agent takes on a new identity in the protocol and is able
to continue to interact with the protocol starting again from the
lowest layer. Third, we assume that in the long run, the market for
a protocol π is perfectly competitive, in the sense that the price (or
payments) made in the system will be equal to the marginal cost
of each transaction. This assumption provides a higher incentive
to perform undesired actions as p = 0 reduces the utility of performing a desired action as described in Eq. (2). Fourth, we assume
that performing an undesired action is free of direct costs10
. This
assumption increases the utility for performing an undesired action
as we set cA = 0 on for the undesired action utility.
Overall, our assumptions are pessimistic: we assume agents gain
no payments from performing desired actions and can perform undesired actions free of direct cost. Hence, we ensure that incentive
compatibility holds even under these pessimistic assumptions (cf.
Section 5). In practice, we expect that these assumptions can be
modified to include positive payment vectors and costs for executing undesired actions. This would allow more aggressive deposit
reductions, however, calculating these are left as future work.
4 BALANCE
Extending π with Balance adds two properties. First, we introduce
the registry R consisting of layers as well as functions to update
the score of agents and to curate agents into layers.
Second, we include a score s into A such that:
A = ⟨ϕ,p,s, D⟩ (5)
s is added to the current agent’s score if the specification ϕ of
the agreement evaluates to true. All details of the agreement are
public knowledge.
4.1 Integrating layers
A layer is a set of agents that have to provide the same relative
deposit. We use Balance to assign agents to layers, making this
a verifiable layered curated registry as illustrated in Figure 2. Intuitively, the higher the score of an agent, the higher the layer an
agent is assigned to.
We formally define a finite order of layers {L1 ≺ ... ≺ Lω },
where each layer Lm ∈ L has a lower bound l, an upper bound
u and a deposit factor f ∈ R
+
. We explain the use of the bounds
in Section 4.3. The factors determine the ordering of layers. Each
10For example, an agent might go offline and not perform any action in A.
Layer 1 Layer 2 Layer 3 Score
1.50
1.25
1.75
2.00
Deposit factor
1.00
Figure 2: An intuition of Balance with three layers. The
more an agent contributes to the integrated protocol (measured by a score), the further it moves up the layers (from
1 to 3). The higher the layer, the lower the relative deposit
needed.
layer maps to a deposit level in order, L → D. For instance, L2
requires deposit D2.
Li = ⟨l,u, f ⟩ (6)
The set of agents are mapped to the layers, i.e. P → L. Each
agent is only mapped to a single layer at any point in time. The
layer function returns the layer an agent is currently assigned to.
We define the layer(A) as the current layer of an agentA, layer(A)+1
as the higher layer with a lower deposit factor, and layer(A) − 1 as
the lower layer with a higher deposit factor.
The layers are used to calculate the deposit an agent needs to
provide. We define a base deposit Dbase (for the lowest layer) and a
factor f that are used to calculate Dm, where m ∈ L. Further, the
deposit DA of an agent A is determined by the base deposit and the
factor of the layer the agent is currently assigned to.
Dm = Dbase fm (7)
DA = Dbase flayer(A)
(8)
Factors are ordered similarly to the layers. Formally, factors are
a finite order { fω < ... < f1} where the factor corresponding to
the highest layer Lω is the smallest.
Property 2 Reduction of opportunity costs
Balance reduces deposit lock-up.
4.2 Updating scores
An agent that just committed to an agreement starts at the lowest
layer with the highest deposit factor. An agent can move up or
down the layers in the registry depending on its score sA.
Agents can increase their score in any round by performing
actions. The score for an action is determined from the agreement,
as defined in (5). The update function takes an action by an agent
and updates the agent’s score.
update : σA → sA (9)
4.3 Curating agents
We define a function curate. This function takes as input all agents
in an agreement A and results in a new assignment of agents to
layers depending on their scores. If an agent’s score is higher than
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1490
the upper bound of its currently assigned layer, the agent progresses
to the higher layer. If an agent’s score is lower than the lower bound
of its currently assigned layer, the agent falls back to the lower layer.
curate(A) =



layer(A), if l
layer(A) ≤ sA ≤ ulayer(A)
layer(A) + 1, if ulayer(A) < sA
layer(A) − 1, if sA < l
layer(A)
(10)
As layers are a finite order, an agent cannot progress above the
highest layer or below the lowest layer. An agent can leave the
registry by de-registering. This detail is left open to the actual
underlying cryptoeconomic protocol. We note that most protocols
require the agent to perform the action they initially committed
to. If an agent leaves prematurely, i.e. before the concluded phase,
the agent’s deposit is usually destroyed. However, an agent can
certainly participate in multiple agreements in the same contract.
The scores of these multiple agreements are added to the overall
score of the agent. An agent already in the highest layer can in the
best case remain there. An agent that is currently in the lowest layer
and misses its lower bound is excluded from the registry. Further,
any agent that performs an undesired action in any agreement part
of a smart contract is immediately excluded from the registry and
the deposit is destroyed or refunded to another agent.
4.4 Time period
According to our blockchain assumptions, Balance requires a minimum number of blocks to consider transactions confirmed depending on the security parameter k [17]. Further, Balance requires a
common period t over all its agreements A. We can determine a
minimum time period by considering the agreement that requires
the longest time even in the case of multiple chains (e.g. XCLAIM as
in Section 7). However, the time between blocks ∆ is not constant
on all chains (e.g. [11]). In the case of a single chain it is sufficient to
express the time as a number of blocks, i.e. t depends solely on the
security parameter k and the number of transaction ntx to execute
an agreement such that t = kntx.
If Balance is used in the multi-chain case, we need to include a
buffer b∆ to account for deviations in ∆. The time period in seconds
for one chain is expressed by tchain = b∆(ntxk∆). We can then
calculate the total time by summing the time periods for all involved
chains within an agreement. Last, the time period can be expressed
as a number of blocks by dividing the total time by the average ∆
of the chain on which Balance is implemented.
However, we note that the time period also determines how
often agents need to perform desired actions to remain or progress
in the layers. Hence, protocol designers need to consider how often
agents execute actions within the cryptoeconomic protocol.
5 INCENTIVE COMPATIBILITY
The performing agent commits to the protocol by providing a
deposit Dm. The deposits required by each layer are such that
D1 > D2 > ... > Dω: Balance rewards the performance of desired
actions by letting agents move to the next layer, thereby decreasing
the amount of deposit they need to lock up. The utility that the
agent gets depends on their choice of action fromσA ∈ {Σd
, Σu, Σ∅}.
Given that the performing agent is committed to the protocol, a
utility maximising agent will never choose to do nothing (σA ∈ Σ∅)
as they would receive a positive utility from committing either a
desired or an undesired action (depending on their valuation, vA).
Figure 3 presents the payoffs that the receiving agent would
receive by deciding to perform either a desired or undesired action.
The performing agent receives a payoff after each move. If we
consider a single-shot game at each round, the agent has to decide
between the resulting utility of two actions, i.e. the desired and
undesired action.
5.1 Action choice
We can express the condition for choosing a desired action for an
agent A at layer m ∈ [1,ω] with the following Eq.s:
v − cA − E[rDm] − Dm < p − cA − E[rDm] (11)
This amounts to requiring that
v < Dm + p (12)
Theorem 1. Considering a single-shot game, if the decision to
perform a desired action holds true for the highest layer Lω then it
will also hold true for all previous layers.
Proof. If the agent in the highest layer decides to perform a
desired action, Eq. (12) holds true. As Dω < ... < D1, the utility of
the agent at layer Lω is higher than at the previous layers. Hence,
a rational agent deciding to perform a desired action at layer Lω
makes the same decision in the previous layers. This also allows it
to reach the highest layer. □
5.2 Incentive compatibility for types Td and Tu
We now extend the analysis to consider the intertemporal payoffs
resulting from the agents’ decisions. If an agent always does a
desired action, i.e. an agent of type Td
, they get a payoff of p −cA −
E[rD1] in the first period. In the second period, invoking a discount
factor 0 < δ < 1 and a real rate of interest r, agents receive a payoff
of (
δ
1+r
)(p −cA − E[rD2]) in today’s terms. The payoff is discounted
reflecting the fact that future payoffs are less valuable than present
ones, because a payoff today would receive a rate of return r. This
continues until the agent is in the highest layer, Lω. In the highest
layer, agents would receive a payoff of (
δ
1+r
)
ω−1
(p − cA − E[rDω])
in today’s terms. Thus summing to infinity yields the following
payoff u(σd
) for agents who always performs a desired action each
round:
(13)
u(σd
) =
ωX−1
t=0
(
δ
1 + r
)
t
(pA − cA − E[rDt+1])
+
X∞
t=ω
(
δ
1 + r
)
t
(pA − cA − E[rDω])
Where convergence of the latter term requires that |(
δ
1+r
)|< 1.
If we assume that an agent is of type Tu , the agent will indefinitely perform an undesired action: at the lowest layer L1, the utility
of the undesired action is higher than the utility of the desired action. Hence, this agent’s utility is as follows.
u(σu ) = (14) X∞
t=0
(
δ
1 + r
)
t
(v − cA − E[rD1] − D1)
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1491
layer(A) = L1 layer(A) = L2 layer(A) = L3
σd
p − cA − E[rD1]
σd
p − cA − E[rD2]
σd
p − cA − E[rD3]
σu
v − cA − E[rD2] − D2
σu
v − cA − E[rD3] − D3
σu
v − cA − E[rD1] − D1
Figure 3: Layer transitions for agent A in a simplified 3-layer system. The red dashed lines correspond to an undesirable
action(σu ); the black solid branches correspond to a desirable action (σd
). The agent starts in L1. If the agent chooses σd
they
are moved into layer L2, receiving payoff p−cA −E[rD1], thus reducing the agent’s deposit to D2. In contrast, if the agent chooses
σu in L1 they receive payoff v − cA − E[rD1] − D1 and are removed from the registry. Assuming agents can rejoin the protocol,
this is equivalent to being returned to L1. This process is repeated analogously in L2 and L3.
Assuming that |(
δ
1+r
)|< 1, such that the series of payoff converges, this can be expressed as:
u(σu ) = (15) (1 + r)(v − cA − E[rD1]) − D1)
1 + r − δ
Theorem 2. Agents of types Td and Tu in Balance act individually
rational and truthful to their valuation.
Proof. By Definition 4, agents that are committed to the protocol cannot increase their utility by hiding their true valuations:
the protocol is strategy-proof. The utility of each agent in an infinite time horizon is given by Eq.s (13) and (14), respectively. Thus,
Balance is incentive compatible for types Td and Tu . □
Property 3 Strategy-proofness
Balance offers strategy-proofness for types Td and Tu .
5.3 Decision boundary for type Tr
The rational agent of type Tr is indifferent between performing an
undesired or desired action in the highest layer L. Hence, consider
the following strategy Slayer−cycling for an agent:
Definition 6 (Layer-Cycling). The agent performs a desired action
in the first ω − 1 layers but commits an undesired action once in
layer ω.
We index these cycles with γ , such 0 ≤ γ ≤ ∞. For instance,
the first iteration of this strategy is denoted by γ = 0; the next
iteration by γ = 1. If we consider a one-shot game, whether the
agent optimally commits a desired or undesired action is determined
by (12). However, this does not consider the fact that once the
agent performs an undesired action they need to work back up
through the layers, with greater opportunity costs for their lockedup deposit, by performing ω −1 desired actions to reach the highest
layer again. Thus, we provide a framework which captures the
intertemporal trade-off that agents face in Balance in committing
an undesired action once in the highest layer.
For each cycle complete γ starting at t = 0, the payoff of such a
strategy can be expressed as
uA = v −cA − Dω − E[rDω] + (16)
ωX−1
t=1
(
δ
1 + r
)
t
{p −cA − E[rDt]}
where Dω denotes the deposit made in the highest layer Lω. The
corresponding expression for infinite cycles is provided in Eq. (27)
in Appendix B.1.
Now consider the stream of payoffs to an agent who always
commits a desired action once in the highest layer. We can group
the stream of payoffs into sections of size ω, to correspond to the
number of rounds required for a player playing Slayer−cycling to
complete one full cycle. Thus the equivalent utility for performing
desired actions for a single cycle γ is as follows:
uA = (17)
ωX−1
t=0
(
δ
1 + r
)
t
{p − cA − E[rDω]}
Similarly, the corresponding expression for infinite cycles is
provided in Eq. (25) in Appendix B.1. Lemma 2 in the same Appendix
shows that comparing the payoffs of a Eq. (17) and (16) over infinite
cycle repetitions γ → ∞ is the same as comparing those equations
for a single cycle. Thus, equating (27) and (25) provides us with an
expression for the value of v at the boundary.
v = p + Dω + (18)
ωX−1
t=1
(
δ
1 + r
)
t
(E[rDt] − E[rDω])
Eq. (18) captures several salient aspects of Balance. Firstly,
the boundary valuation depends on the levels of p and Dω. An
increase in the payment that the agent receives or an increase in
the deposit in the final layerserve to increase the value ofv required
such that the agent is indifferent between committing a desired or
undesired action. The minimum valuation v also depends on the
difference in opportunity costs (forgone returns) on deposits, with
the opportunity cost of funds in lower layers contributing more:
(
δ
1+r
)
t declines as t increases.
As detailed in Appendix B.2, explicitly invoking deposit ratios
between the layers, such that Dω = fωDbase and Dt = ftDbase, and
setting p = 0, enables (18) to be rewritten as
v = fωD (19) base +
ωX−1
t=1

δ
1 + r
t

E[rDbase(ft − fω)]
Note that on the assumption that an agent can advance a single
layer m per time period t, to make this relationship between layers
and time explicit we swap m for t. Rearranging this expression
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1492
for fω, and assuming a linear relationship between the smallest
factor fω and the other factors fm (see Appendix B.1) enables the
indifference boundary to be plotted - see Figure 4.
5.4 Incentive compatibility region for type Tr
We can characterise the incentive compatibility region for the rational agent as follows.
Theorem 3. Provided fω > fω¯ , performing σd at the highest layer
(and not Slayer−cycling) is incentive compatible for type Tr .
Proof. We set Dbase as a relative value where Dbase = 1. Assuming a linear relationship between the smallest factor fω and
the other factors ft
, as detailed in Appendix B.2 (35), enables us
to express the boundary condition for incentive compatibility for
agents of type Tr fω¯ as follows:
fω¯ =
vω −v −
Pω−1
t=1 
δ
1+r
t
E[r f1(ω − t)]
ω − 1 −
Pω−1
t=1 
δ
1+r
t
E[r(ω − t)]
(20)
Thus, provided fω > fω¯ , incentive compatibility holds for Tr .
□
Property 3 Strategy-proofness
Balance offers strategy-proofness for type Tr .
5.5 Transparency
Balance seeks to be transparent to receiving agents B. B does not
have to choose between performing agents A based on their layer
assignment, but selects A as without Balance.
Theorem 4. Given an initial deposit D1 for a performing agent A
of type Tr and Balance with ω layers, A cannot decrease its utility
for performing a desired action and does not have a higher utility
for an undesired action assuming fω > fω¯ .
Proof. If A → Lm at a point t = 0, we consider two cases: First,
A can consider an infinite horizon. By Theorem 3, we know that
if fω > fω¯ , the utility for performing a desired action is greater
than the undesired action for A starting at L1. By the infinite time
horizon the starting layer Lm becomes irrelevant. Hence, A has the
same utility for performing a desired action at layer Lm as at L1.
Second, by Theorem 1, if agent A performs a desired action at
the highest layer, A also performs desired action at previous layers.
Further, the utility at the lowest layer L1 is smaller than the utility
at the subsequent layers. If A only considers a single time step, and
A has performed a desired action at layer L1, A can only increase
its utility by performing a desired action in the next layer. □
Property 4 Transparency
Balance is transparent to a receiving agent B.
5.6 Comparison and social welfare
Next, we show that adding Balance increases social welfare for
agents who perform desired actions.
Theorem 5. For a distribution of agent types p(x), where x ∈
{Td
, Tu, Tr }, adding Balance increases social welfare.
Proof. As in (4), if performing agents perform desired actions,
the utility is equal to PX
x=1(vx,B − cx,B − cx,A − E[rDx,A]), where
x is a pair of agents in the set of pairs X. without Balance, each
pair is required to have deposit D1 each period. Over a cycle length
t = ω, the total utility for all pairs of agents over the cycle is given
by
(21)
ωX−1
t =0
X
X
x =1
(δ/(1 + r))t
((vx,B − cx,B − cx,A − E[rDx,1]))
In contrast, with Balance, total welfare is given by
(22)
ωX−1
t =0
X
X
x =1
(δ/(1 + r))t
((vx,B − cx,B − cx,A − E[rDx,t+1]))
For agents performing desired actions, Balance improves welfare
when (22) is greater than (21). Yet, since in all but t = 0, the opportunity cost term ([rDx,t+1]) is smaller in the latter equation,
with Balance permitting agents to post smaller deposits at higher
layers, (22) must be the larger. Therefore, Balance improves social
welfare for agents performing desired actions. For agents who always perform undesired actions, social welfare is the same with
Balance as without it. □
Property 5 Social welfare increasing
Balance is social welfare increasing.
5.7 Parameter behaviour
Balance has four main parameters that influences the boundary
fω¯ over which fω must be set to ensure that agents of type Tr
perform desired actions. Figure 4 demonstrates how fω, the factor corresponding to the highest layer boundary, changes as the
parameters f1, r, δ and ω vary. The purpose of this section is to
provide guidance on the behaviour of for a given implementation
when the parameter values are varied. The values of f1 and ω can
be configured by the designer of the protocol π, whereas δ and r
are external factors that require careful consideration.
• Figure 4 (a) shows that, all else equal, ∀t, opting for a higher
value of f1 results in a relatively higher value of fω than
lower values of f1. Starting with a higher layer factor f1
permits a greater reduction in fω over time relative to the
starting value of fω at t = 0, but results in a higher absolute
value of fω relative to lower values of f1.
• Figure 4 (b) shows that, all else equal, ∀t, an increase in r
results in a lower value of fω. To offset a higher interest
rate, fω has to fall more quickly since a higher interest rate
results in higher opportunity costs of deposits.
• Figure 4 (c) shows that, all else equal, ∀t, an increase in the
discount factor δ allows fω to be relatively lower. As the
discount factor increases, such that future utility is more
valuable today, the factor fω corresponding to the highest
layer can be reduced.
• Figure 4 (d) shows that, all else equal, ∀t, using more layers
ω permits a greater reduction in fw through time. However,
this increase is not linear. Using Eq. 20, we can show that if
ω → ∞, the reduction of deposit has a lower bound.
We note an interesting property for protocol designers when
choosing parameters for Balance. If the required deposit factor at
each layer are set to the boundary fω¯ , πBalance enjoys the same
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1493
0 5 10 15 20 25 30
t
1.0
1.2
1.4
1.6
1.8
2.0
fω
ω = 30, r = 0.05, δ=0.90
f1 = 1.00
f1 = 1.25
f1 = 1.50
f1 = 1.75
f1 = 2.00
(a) Boundary of fω for five different initial factors of f1.
0 5 10 15 20 25 30
t
1.4
1.6
1.8
2.0
fω
f1 = 2.00, ω = 30, δ=0.90
r = 0.000
r = 0.025
r = 0.050
r = 0.075
r = 0.100
(b) Boundary of fω for five different return rates r.
0 5 10 15 20 25 30
t
1.5
1.6
1.7
1.8
1.9
2.0
2.1
fω
f1 = 2.00, ω = 30, r=0.05
δ = 0.75
δ = 0.80
δ = 0.85
δ = 0.90
δ = 0.95
(c) Boundary of fω for five different discount factors δ .
0 5 10 15 20 25 30
t
1.7
1.8
1.9
2.0
2.1
fω
f1 = 2.00, ω = 30, r=0.05
ω = 5
ω = 10
ω = 15
ω = 20
ω = 25
ω = 30
(d) Boundary of fω for six different numbers of layers ω.
Figure 4: The boundary fω¯ depending on the parameters of f1, ω, r, and δ. If fω is chosen above fω¯ , an economically rational
agent has a higher utility to choose a desired action. Below fω¯ , the agent chooses an undesired action.
level of security. However, if a designer sets the deposit factors for
layers m such that f1 > fm > fω¯ , πBalance has a relatively higher
level of security with respect to economically rational agents and
increases social welfare.
6 SECURITY ARGUMENTS
We discuss a range of attack strategies against Balance and how
to mitigate them.
6.1 Single-shot attack
In single-shot attack strategy, Ssingle−shot, the only objective of
agent A is to attack B through committing an undesired action. A
would then consider how to execute such an attack with least cost.
In particular, A may be able to reduce the cost of attack by playing a
modification of Slayer−cycling where A progresses through the layers
and performs the undesired action at the highest layer. We show
that if fω is set above a bound fω¯ , A would not gain additional
utility by waiting until it is in the highest layer before performing
the attack.
Lemma 1. If A plays Ssingle−shot it cannot gain additional utility
given that the fω is set above fω¯ .
Proof. This strategy has two implications. First, A performs
ω − 1 desired actions that contribute to the social welfare of the
protocol. Second, A increases its utility at t = ω for the undesired
action with being punished with the smaller Dω instead of D1.
However, for each ω − 1 round, A has incurred an opportunity
cost. As shown in Lemma 2 in Appendix B.1, Ssingle−shot results in
the same utility expression and boundary for fω as Slayer−cycling.
Hence, if fω is set to be greater than fω¯ , A does not gain additional
utility from playing Ssingle−shot. A should commit the undesired
action at D1 if A intends to perform a undesired action. Otherwise,
A should perform the desired action. □
Balance provides in the single-shot attack the same security as
protocols without Balance, however, offers desired agent types to
reduce their deposit over time.
6.2 Reputation boosting
An agent A could create Sybil identities to request performance of
actions and fulfil them itself. This results in improving the agent’s
score and reducing its deposit. We denote this Sboosting, a common
attack vector in reputation like systems [23, 25].
Theorem 6. Reputation boosting Sboosting is not rational in Balance if the cost of this strategy, c(Sboosting), is higher than the
expected saving from the reduction of deposit.
Proof. We consider a scenario where A can take the role of a
receiving agent B. Further, we assume that the cost for requesting
a service within an agreement A by c(Sboosting) = cB. Without
loss of generality, we assume that an instance of Balance includes
two layers, L1 and L2. A performs a desired action by fulfilling its
own request (per role B). In the next step, A can either execute a
desired or an undesired action. In either case, the increase of utility
is determined by the reduction in opportunity cost at each layer,
i.e. (
δ
1+r
)E[rD2] − E[rD1]. A sufficient condition for Sboosting to not
be a rational strategy is:
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1494
cB > E[rD1] −

δ
1 + r

E[rD2] (23)
Therefore, we prevent Sboosting by limiting the maximum deposit
that can be provided by a single identity of A to Dmax. If A wants to
exceed Dmax, it needs to commit to an agreement with an additional
identity A
′
. □
The commit stage of cryptoeconomic protocols typically requires
an on-chain transaction which incurs a cost, e.g. [27, 44]. If requesting isfree in a protocol, boosting would be rational. Thus, to prevent
griefing by B, cryptoeconomic protocols typically require a small
amount of deposit [12] as friction. Since B also has an expected loss
of interest on this deposit, this incurs a cost expressed by E[rDB].
Property 6 Sybil resistance
Balance is resistant to the creation of Sybil identities.
6.3 Action delay
In strategy Sdelay, A, who has already performed sufficient desired
actions to move up a layer, delays a desired action from t until
t + 1. In the new round, with a reset score, the delayed action would
count towards the new score. If there are significantly more requesting agents B than performing agents A, a backlog of requests
would occur. We propose two remedies. First, A could be required
to perform the actions within a time-limit enforced by the cryptoeconomic protocol (e.g. HTLCs). Second, Balance could be modified
to use dynamic time rounds. Dynamic time could be based on the
number of active performing agents A and the number of requests
by receiving agents B. For instance, the next round could be started
after a certain fraction (or all) of the performing agents A could
have at least fulfilled one request by B.
6.4 Competition and cooperation
Performing agents compete to fulfil agreements, to receive payments and reduce their deposit requirements. However, it is possible that the number of requests is insufficient for A to maintain
its assignment to the high layers of Balance. In such cases, two
strategies for A are as follows.
First, A can be non-cooperative and play a strategy Scompete in
which A (i) tries to fulfil requests as fast as possible by e.g. detecting
request transaction early through memory pool sniffing and (ii)
actively prevent other performing agents from fulfilling requests
by e.g. executing eclipse attacks [19, 21].
Second, A can be cooperative, executing a strategy Scooperate to
collaborate with other agents. A could form groups with shared
interests through e.g. multi-signature wallets with other agents. A
set of agents can act as a single entity to reduce their pooled deposit
and fulfil agreements as a whole. This concept is similarly applied
to layer-one protocols as so called mining pools. Lewenberg et al.
formulate an analysis for cooperative games in the Bitcoin mining
network [31]. A cooperative game for cryptoeconomic protocols
would consider the number of performing agents A, their overall
deposit D, and a likelihood of having open requests by B.
In both cases, Balance does not change the possible strategies
in the cryptoeconomic protocol. Agents can play either strategies
with and without Balance being present.
7 APPLICATION
The objective of Balance is to reduce deposits up to the boundary
fω¯ . Integrating Balance is therefore an exercise in determining
external factors and choosing the parameters such that fω¯ can be
optimised. This process includes the following steps:
(1) Determining the return rate r includes finding an approximate value what agents could earn by participating in other
protocols than π.
(2) Determining the discount factor δ comprises of finding the
discount agents apply to future returns.
(3) Choosing the scoress in A needs careful consideration of the
agreement. Reducing depositsintroduces a positive incentive
for agents. Therefore, only agreements that already have a
positive incentive, e.g. payments, should be associated with
a positive score.
(4) Choosing a period length t depends on how often a protocol designer expects agents to interact with the protocol.
Since agents need to continuously perform desired actions,
agents should have the chance to do so by giving them a
long enough time period.
(5) Choosing the number of layers ω determines (i) the overall
reduction of deposit possible and (ii) how many time periods
it takes to reach the lowest deposit.
(6) Choosing the initial factor f1 is a trade-off between the
“buffer” of over-collateralization and the amount of deposit
reduction. The higher f1, the higher the reduction possible.
However, also the higher the absolute deposit.
We provide more detail on determining external factorsr and δ in
Appendix C.2. However, a thorough study of parametersspecifically
for decentralised ledgers is left as future work.
In the following we describe in detail the application of Balance
to the XCLAIM protocol. XCLAIM is a generalised protocol that
allows exchange of cryptocurrencies across different blockchains
without a trusted intermediary [53]. The protocol employsthird partiesthat provide a deposit to be eligible to participate in the protocol.
Further, XCLAIM reduces the cost of atomic cross-currency swaps
in comparison to atomic-swaps realised with hashed time-lock contracts (HTLC). We choose XCLAIM as an example of how to apply
Balance as it is subject to exchange rate risk (event-dependency)
and heterogeneous valuations of individual cryptocurrencies (private information).
7.1 XCLAIM protocol
XCLAIM is divided into three sub-protocols. First, the issue protocol
enables creation of cryptocurrency-based assets (CbAs) from a
backing chain onto an issuing chain. Second, in the swap protocol,
senders and receivers on the issuing chain can exchange the issued
CbAs. Finally, in the redeem protocol, a redeemer exchanges his
CbA for the original coin on the backing chain. For example, Alice
could issue Bitcoin-backed tokens on the Ethereum chain. Alice
could then send her Bitcoin-backed tokens to Bob on Ethereum
in exchange for Ether. Bob can take his Bitcoin-backed tokens to
receive the equivalent amount of Bitcoins on Bitcoin. XCLAIM
includes six roles.
(1) CbA Requester: creates a backed token i(b) on an issuing
chain from locking a coin b on the backing chain.
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1495
(2) CbA Sender: sends a backed token i(b) on the issuing chain.
(3) CbA Receiver: receives a backed token i(b) on the issuing
chain.
(4) CbA Redeemer: destroys the backed token i(b) on the issuing
chain to redeem the coin b on the backing chain.
(5) CbA Backing Vault (vault): a non-trusted third party enabling
the issue protocol and executing the redeem protocol. The
CbA Requester locks her coins b with the vault while the
CbA Redeemer upon destruction of i(b) redeems b from the
vault.
(6) Issuing Smart Contract (iSC): implements the sub-protocols
on the issuing chain.
The vault only becomes active during the redeem sub-protocol
as any actions in the issuing sub-protocol are executed by the CbA
Requester and the iSC. To ensure correct behaviour, the vault has to
provide a deposit on the issuing chain which allows the issuing and
redeeming of CbAs. The iSC serves as an escrow for the deposit of
the vault. The deposit is a promise by the vault to release the backing
tokens b when a valid redeem request is made by destroying i(b).
Under the assumption of an economically rational vault, the vault
releases b as otherwise its deposit is refunded to the CbA Redeemer.
Further, the iSC verifies correct execution of the issue and redeem
process by verifying transactions occurring in the backing chain
on the issuing chain via a chain relay.
7.2 Deposit dilemma for XCLAIM vaults
Vaults in XCLAIM provide a deposit in the currency of the issuing
chain to insure against a risk on the backing chain. Exchange rate
fluctuations are external events that affect the security assumption
of a vault fulfilling a redeem request. Sudden drops in the exchange
rate results in insecure protocol states where the provided deposit
is less than the value of the coin b on the backing chain. Hence,
rational vaults have an incentive to refuse redeem requests even
under the threat of having their deposit taken away. Further, vaults
have a private valuation for the outcome of the redeem protocol. If
a vault values the backing coin b higher than the required deposit,
the vault has an incentive to not fulfil the redeem request. XCLAIM
mitigates exchange rate fluctuations and, implicitly, the potential
detrimental effects of private information through staged deposits.
(1) In secure operation, a CbA Requester can issue new CbAs as
DA is greater than an the ideal deposit ⌈DA⌉.
(2) In the buffered deposit stage, DA < ⌈DA⌉ but DA is still above
a lower bound deposit ⌊DA⌋. In this stage, a CbA Requester
cannot issue new CbAs based on this vaults deposit. The
vault can provide additional deposit to increase its deposit
rate back to the ideal rate.
(3) In the liquidation stage, a vault’s deposit is automatically
liquidated if it falls below ⌊DA⌋. The deposit rate is dynamically adjusted using an oracle O importing the exchange
rate.
7.3 Application of Balance
We integrate Balance with XCLAIM by defining the agreements
of vaults. These include their specification, payments, and deposits
as well as the score. Further, we define the length of the time period
t in which an agent can perform actions. Last, we set the initial
deposit factor f1 and lower bound fω. Our definitions are described
in Figure 5. We leave the quantification of scores for actions and
determining lower and upper bounds of layers as future work.
We argue that Balance does not affect the security arguments of
XCLAIM in Appendix C.3.
Determining a minimum time. XCLAIM assumes a minimum
number of blocks to consider transactions confirmed depending
on the security parameter k [17]. As outlined in Section 4.4, we
determine the period by considering the agreement with the most
transactions. Agreements A1,3,4 depend on one issuing chain transactions while A2 depends on one backing chain and two issuing chain transactions. We use a buffer of 2 such that the time
t = 2(kb∆b + 2ki∆i
). For the case where Bitcoin is the backing and
Ethereum the issuing chain, we assume kETH = 12, ∆ETH = 15 s,
kBTC = 6, ∆BTC = 10 min. This results in t ≈ 132 min or t ≈ 528
blocks on Ethereum.
Determining scores. Within XCLAIM, the issue commitment A1
is equivalent to the commit stage. We choose s = 0 for A1 to prevent
agents from splitting up their deposit into smaller parts. Further,
we exclude a reward for A3 resolving DA < ⌊DA⌋ as ideally DA
should always be greater than ⌈DA⌉. We define a positive score for
the desired action in A2. Further, we argue that having a positive
score in A4 provides an additional incentive for A to re-balance its
deposit in case of exchange rate fluctuations. In turn, this improves
the chance of CbA Requesters being able to participate in the issue
sub-protocol.
Determining a number of layers. We determine the number of
layers ω by considering which time period a performing agent A
is accounting for in its decision to decide between Σd and Σu . We
assume that A considers a 24 hour time period. Next, we calculate
ω by dividing 24 hours by the time representation of t. Based on
t = 528 blocks, we set ω = 12.
Determining factors. XCLAIM suggests deposit stages of 2.0 for
⌈DA⌉ and 1.05 for ⌊DA⌋. We leave ⌊DA⌋ as suggested. We focus
on reducing ⌈DA⌉ for a concrete implementation of XCLAIM for
Bitcoin and Ethereum. To verify the suggested deposit ⌈DA⌉, we
perform an analysis of the daily exchange rate fluctuations and
private valuations by parsing order books of exchanges (cf. Appendix C) for Bitcoin and Ethereum. Based on our analysis, and
assuming r = 0.05 and δ = 0.9 as well as a linear relation between
layer factors, we set f1 = 2.06 and fω = 1.85. Thereby, we achieve
a reduction of 10% of the deposit.
7.4 Implementation
We implemented Balance for Ethereum in Solidity v0.5.011. The
implementation consists of around 170 lines of code. The core
functions of Balance are update and curate defined by (9) and (10).
The cost experiments are conducted under the assumption that
all agents in the current registry change their layer (i.e. maximum
updates in the smart contract)12. We conducted experiments with
up to ten layers. The update function amounts to 55,287 gas costing
11Implementation available at https://github.com/nud3l/layered-tcr.
12All USD conversions are made with an Ethereum exchange rate of USD 230 and a
gas price of 6 GWEI.
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1496
Vault agreements
Roles: A mapping from XCLAIM to Balance roles.
(1) Performing agent A: Vault
(2) Receiving agent B: CbA Requester and CbA Redeemer
(3) Registry R: Integrated in the iSC
Events: An update to the exchange rate at time t changes the required ideal deposit
⌈DA ⌉ and ⌊DA ⌋. The current deposit DA might fall below ⌈DA ⌉ or ⌊DA ⌋.
Private information: A might value a currency higher such that even if DA >
⌊DA ⌋, A behaves economically rational when performing an undesired action.
A1: Issue commitment
ϕ True, if A provides a deposit DA ≥ ⌈DA ⌉.
False, if DA < ⌈DA ⌉.
p If ϕ of A1,4 is true, A receives pA paid by B in its issue request.
D A’s deposit DA is refunded to A if ϕ of A1 is false.
A2: Redeem request (Precondition: ϕ of A1 is true.)
ϕ True, if A fulfils a valid redeem request by B within a time w.
False, if A fails to provide a proof of executing B’s request within w.
p If ϕ of A2 is true, A receives payment pA
a
.
D A’s deposit DA is transferred to B if ϕ of A2 is false.
A3: Liquidation (Precondition: ϕ of A1 is true.)
Trigger: Exchange rate update provided by oracle O.
ϕ True, if DA is above ⌊DA ⌋.
False, if DA is below ⌊DA ⌋.
p There are no payments for performing this action.
D A’s deposit DA is used to perform a redeem request as stated in A2.
A4: Buffered deposit (Precondition: ϕ of A1 is true.)
Trigger: Exchange rate update provided by oracle O.
ϕ True, if DA is above ⌈DA ⌉.
False, if DA is below ⌈DA ⌉.
p There are no payments for performing this action. A cannot participate
in the issue protocol while ϕ is false.
D There is no impact on the deposit.
a XCLAIM does not define how payments are made during redeem (cf. Section
VII-F [53]). We assume that a fee is already paid during issue.
Parameters of Balance
Assumptions:
r 0.05. A earns 5% of its deposit by participating in other protocols.
δ 0.9. A discounts future income by 10%.
Time constraints:
t 528 blocks (on Ethereum)
Actions: Actions depend on the agreements and have an associated score.
A1 Desired σd : A provides DA ≥ ⌈DA ⌉.
Undesired σu : A provides DA < ⌈DA ⌉.
Score s: 0. A should not receive a reduction of deposit for adding deposit
in small quantities to reduce its overall deposit. By setting s = 0 for A1 we
prevent such behaviour.
A2 Desired σd : A fulfils B’s redeem request within w.
Undesired σu : A fails to execute B’s redeem request within w.
Score s: > 0. A receives an additional incentive to execute redeem requests
and can in return reduce its deposit.
A3 Desired σd : If DA < ⌊DA ⌋, A adds additional deposit D
′
A
such that DA +
D
′
A
≥ ⌊DA ⌋.
Undesired σu : A does not add deposit new deposit or an insufficient amount
such that DA + D
′
A
< ⌊DA ⌋.
Score s: 0. A should not receive a reward for being temporary below the
liquidation bound.
A4 Desired σd : If DA < ⌈DA ⌉, A adds additional deposit D
′
A
such that DA +
D
′
A
≥ ⌈DA ⌉.
Undesired σu : A does not add deposit new deposit or an insufficient amount
such that DA + D
′
A
< ⌈DA ⌉.
Score s: > 0 should receive an incentive for staying above the ideal deposit,
however, this might result in purposely falling under the ideal deposit.
Layers: The layer factors express the boundary for ⌈DA ⌉. We leave ⌊DA ⌋ as suggested
by XCLAIM at 1.05.
ω 12. Based on considering a time window of 24 hours and the minimum time
of 528 blocks.
f1 2.06. Based on our analysis of exchange rate and order books.
fω 1.85. Based on applying f1 to (20) and considering the exchange rate and
order book analysis.
Figure 5: An overview of the agreements of a vault in XCLAIM and parameters for an integration of Balance into XCLAIM.
around USD 0.07. The execution of the curate function costs 54,948
gas which is equivalent to around USD 0.07. We reduce the linear
complexity of the curate function (10) to constant by executing
the assignment of agents for the next round in the update function.
The curate function updates the round counter and activates the
mapping for the next round.
8 RELATED WORK
To the best of our knowledge, Balance is the first reputation-based
system for the dynamic adjustment of cryptocurrency deposits.
There are three discernible strands of related literature.
The first strand relates to Token Curated Registries (TCRs) [37],
inspiring the layered aspects of Balance [34]. A TCR formally represents a set R in which elements n can be included in a set through
a token-based voting mechanism. A variety of different TCR types
have been proposed [10, 16, 34, 37, 45]. Notably, ranked TCRs RO
enable agentsto vote on the rank (i.e. position) of an element in a set
of elements such that ni ≺ ni+1. Further, layered TCRs are a set RL,
consisting of distinct subsets where ∪
n
i=1Ri ⊆ RL
V
∩
n
i=1Ri = ∅.
However, while Balance takes inspiration from a ranked and layered TCR construction, TCRs require voting by individuals with
tokens, adding significant and potentially unwarranted complexity [2].
The second strand concerns reputation aspects of Balance. Yu et
al. uses a notion of reputation to define a miner’s power in terms of
its work performed over the lifetime of a blockchain, as opposed to
instantaneous mining power, in order to mitigate the vulnerability
of blockchains to 51% attacks, where an adversary momentarily
possesses more than 50% of the total mining power [52]. Another
system for reputation management in decentralised systems, but
this time for users of the system as opposed to miners, is [32]. The
mechanism uses cryptocurrencies to measure trust: using deposits
between different agents, the authors construct a web-of-trust like
architecture. Balance is different, creating only direct trust relationships between agents and actions are directly evaluated through
the agreements in a smart contract. Taxonomies of reputation based
systems [22, 23, 43] indicate comparators for Balance and other
reputation based systems. Balance is a quantitative as opposed
to qualitative trust system, expressing a reputation in terms of a
deposit factor. Reputation itself is accrued by agents through direct
experience, i.e. direct interaction with a smart contract. In particular,
there is no transitive reputation between peers: the trust that others
place in an agent does not confer trust onto the agent 13
. Some
13One caveat is that in one sense trust is transitive across agreements, since an agent
may participate in multiple agreements within the same smart contract, retaining the
same deposit factor.
Session 7B: Blockchain III CCS ’19, November 11–15, 2019, London, United Kingdom 1497
systems such as Pisa [35] do allow for transitive trust, allowing a
reputation to be indirectly established.
A third strand of literature is pursued by [7]. Seeking to guard
against losses of users’ funds by centralised exchanges [39], the
work focuses on providing a privacy-preserving system for proving
the solvency of an exchange, i.e. that an exchange controls sufficient
reserves to settle the account of each user.
9 CONCLUSION
Balance is an application-agnostic system, intended as an extension to existing cryptoeconomic protocols, that allows for the reduction of cryptocurrency deposits without compromising security.
By explicitly modelling agents’ utilities, we show that it features
an incentive-compatible mechanism that rewards agents for the
performance of desired actions by reducing their required deposits,
and therefore the opportunity costs of those deposits. Moreover,
we show that the addition of Balance increases social welfare. We
also implement Balance, integrating it with XCLAIM.
The primary motivating force for agents in our construction is
the expected reduction in opportunity costs for the agent resulting
from forgone returns on deposits. If we modify the assumption of
perfect competition in Section 5, such that agents receive a positive
payment from performing a desired action, payments p could also
constitute a motivating force. For protocols where a reduction in
the deposit is not practical or not desired by the protocol designers,
the factor in each layer could be used to calculate the payment. In
this case, the factor would increase with every layer so that agents
in the lowest layer receive a payment of p f1, where e.g. f1 = 0.6.
To the best of our knowledge, this paper is the first to use a
curated registry to enable dynamic deposit requirements. One question that arises is that given v is private information, at what level
should deposits and factors be set such that the proportion of agents
who find it incentive compatible to perform desired actions is optimal for the protocol (or society) as a whole? In addition, we plan
to explore different parameter configurations such as overlapping
boundaries and restrict the number of agents per layers, as well as
extend the model to cover probabilistic formulations of the specification.
