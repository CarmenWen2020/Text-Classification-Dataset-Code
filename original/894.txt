We propose a new, constant-round protocol for multi-party computation of boolean circuits that is secure against an arbitrary number
of malicious corruptions. At a high level, we extend and generalize recent work of Wang et al. in the two-party setting. Namely,
we design an efficient preprocessing phase that allows the parties
to generate authenticated information; we then show how to use
this information to distributively construct a single “authenticated”
garbled circuit that is evaluated by one party.
Our resulting protocol improves upon the state-of-the-art both
asymptotically and concretely. We validate these claims via several
experiments demonstrating both the efficiency and scalability of
our protocol:
• Efficiency: For three-party computation over a LAN, our
protocol requires only 95 ms to evaluate AES. This is roughly
a 700× improvement over the best prior work, and only 2.5×
slower than the best known result in the two-party setting.
In general, for n-party computation our protocol improves
upon prior work (which was never implemented) by a factor of more than 230n, e.g., an improvement of 3 orders of
magnitude for 5-party computation.
• Scalability: We successfully executed our protocol with a
large number of parties located all over the world, computing (for example) AES with 128 parties across 5 continents
in under 3 minutes. Our work represents the largest-scale
demonstration of secure computation to date.
CCS CONCEPTS
• Theory of computation → Cryptographic protocols;
KEYWORDS
Multi-party Computation; Secure Computation; Garbled Circuit
1 INTRODUCTION
Secure multi-party computation (MPC) allows a set of parties to
jointly perform a distributed computation while ensuring correctness, privacy of the parties’ inputs, and more. MPC protocols can
be classified in various ways depending on the native computations
Table 1: Asymptotic complexity (per party) for n-party MPC
protocols for boolean circuits, secure against an arbitrary
number of malicious corruptions. Here, κ (resp., ρ) is the computational (resp., statistical) security parameter, |C| is the circuit
size, d is the depth of the circuit, and B = O(ρ/ log |C|).
they support and the class of adversarial behavior they tolerate.
With regard to the first of these, protocols are typically designed
to compute either boolean circuits or arithmetic circuits over a
large field. Although these models are equivalent in terms of their
expressive power, for many natural computational tasks (e.g., comparisons, divisions, bit-wise operations, etc.) an arithmetic circuits
can be much larger than the corresponding boolean circuit, as well
as more cumbersome to design.
With regard to security, some protocols tolerate only semi-honest
adversaries that are assumed to follow the prescribed protocol but
then try to learn additional information from the transcript of the
execution. In contrast, the stronger malicious model does not make
any assumptions about the behavior of the corrupted parties. Finally,
some protocols assume an honest majority (i.e., are secure only as
long as strictly fewer than 1/2 of the parties are corrupted), while
others are secure for any number of corruptions (i.e., even if only
of the parties is honest).
In this work we focus on MPC protocols tolerating any number of
malicious corruptions. Previous implementations of MPC protocols
in this model rely on some variant of the secret-sharing paradigm
introduced by Goldreich, Micali, and Wigderson [23]. At a high
level, this technique requires the parties to maintain the invariant
of holding a linear secret sharing of the values on the circuit wires,
along with some sort of authentication information on those shares.
Linear gates in the circuit (e.g., XOR, ADD) can be processed locally,
while non-linear operations (e.g., AND, MULT) are handled by
having the parties interact with each other to maintain the desired
invariant. The most notable example of a protocol in this framework
is perhaps SPDZ [18, 19, 28], which supports arithmetic circuits;
protocols for boolean circuits have also been designed [20, 30].
Although this approach can lead to protocols with reasonable
efficiency when run over a LAN, it suffers the inherent drawback
of leading to round complexity linear in the depth of the circuit
being evaluated. This can have a significant impact on the overall
efficiency when the parties running the protocol are geographically
Session A1: Multi-Party Computation 1 CCS’17, October 30-November 3, 2017, Dallas, TX, USA 39
Setting Setup Indep. Depen. Online Total
3PC-LAN 36 47 12 2 95
128PC-LAN 390 2727 11670 1870 16657
14PC-Worldwide 8711 9412 1947 250 20320
128PC-Worldwide 88056 30796 22659 2316 143827
Table 2: Selected performance results for our protocol. All
results are in milliseconds, based on a statistical security of 2
−40
.
We consider the following settings (see Section 6 for more details.):
(a) 3PC-LAN: three-party computation over a LAN;
(b) 128PC-LAN: 128-party computation over a LAN;
(c) 14PC-Worldwide: 14-party computation over a WAN, with
parties located in 14 different cities across five continents;
(d) 128PC-Worldwide: 128-party computation over a WAN, with
parties located in 8 different cities across five continents (each city
with 16 parties).
separated or when the number of parties is high, and the communication latency dominates the cost of the execution. For example,
the communication latency between parties located in the U.S. and
Europe is around 75 ms even with the dedicated network provided
by Amazon EC2. If such parties are evaluating, say, SHA-256 (which
has a circuit depth of about 4,000), then a linear-round protocol
requires 300, 000 ms just for the back-and-forth interaction between
those parties, not even counting the time required for performing
local cryptographic operations or transmitting any data.
Constant-round protocols tolerating any number of malicious
corruptions have also been designed. The basic approach here, first
proposed by Beaver, Micali, and Rogaway [3], is to have the parties run a linear-round secure-computation protocol to compute
a garbled circuit [38] for the function f of interest; the parties
can then evaluate that garbled circuit using a constant number
of additional rounds. Since the circuit for computing the garbling
of f has depth independent of f , the overall number of rounds
is constant. Although several recent papers have explored this
approach [14, 31, 32], these investigations have remained largely
theoretical since the overall cost of even the best protocol using this
approach is asymptotically worse than the nonconstant-round protocols mentioned above; see Table 1. In fact, prior implementations
of constant-round MPC consider only the semi-honest setting [5, 6].
1.1 Our Contributions
In this paper, we take a significant step towards practical MPC
tolerating an unbounded number of malicious corruptions. To this
end, we propose a new, constant-round protocol for multi-party
computation of boolean circuits secure in this setting. Our protocol
extends and generalizes the recent work of Wang et al. [37] in
the two-party setting. Specifically, we first design an optimized,
multi-party version of their TinyOT protocol so as to enable n
parties to generate certain authenticated information as part of a
preprocessing phase. Next, generalizing their main protocol, we
show how to use this information to distributively construct a single
“authenticated” garbled circuit that is evaluated by a single party.
An overview of our entire protocol appears in Section 3, with details
in the remainder of the paper.
Our protocol improves upon the state-of-the-art both asymptotically (cf. Table 1) and concretely (see Section 6.4), and in particular it
allows us to give the first implementation of a constant-round MPC
protocol with malicious security. Our experiments demonstrate
that our protocol is both efficient and scalable:
• Efficiency: For three-party computation over a LAN, our
protocol requires only 95 ms to securely evaluate AES. This
is roughly a 700× improvement over the best prior work, and
only 2.5× slower than the best known result in the two-party
setting [37]. In general, for n-party computation our protocol
improves upon the best prior work [31, 32] (which was not
implemented) by a factor of more than 200n.
• Scalability: We successfully executed our protocol with
many parties located all over the world, computing (for example) AES with 128 parties across 5 continents in under
3 minutes. To the best of our knowledge, our work represents the largest-scale demonstration of secure computation
to date, even considering weaker adversarial models.
Selected performance results for our protocol are reported in Table 2.
Following [34], we divide execution into different phases:
• Setup. Here, the parties generate information that can be
used for computation of multiple, possibly different functions. For example, base-OT can be performed in this phase.
• Function-independent preprocessing. Here, the parties
begin execution of the protocol for a particular computation.
At this point, the parties only need to know an upper bound
on the size of the circuit that will be computed.
• Function-dependent preprocessing. Here the parties know
the function being computed, but need not know their inputs.
• Online phase. The parties evaluate the function on their
inputs.
1.2 Related Work
Implementations of MPC protocols. The first implementations
of generic MPC assumed a semi-honest adversary corrupting a minority of the parties. Early work in this area includes FairplayMP [5]
for boolean circuits, and VIFF [15] and SEPIA [11] for arithmetic circuits. Implementations of protocols handling an arbitrary number
of corrupted parties, but still in the semi-honest setting, were shown
by Choi et al. [13] and Ben-Efraim et al. [6], the latter running in a
constant number of rounds.
There are fewer implementations of MPC protocols handling
malicious attackers. Jakobsen et al. [26] developed the first such
system. SPDZ and its subsequent improvements [18, 19, 28, 29]
greatly improved the efficiency. As noted earlier, all existing implementations of MPC tolerating malicious attackers have round
complexity linear in the depth of the circuit.
Another line of work has specifically targeted three-party computation. Implementations here include Sharemind [8, 9], the sugarbeet auction run by Bogetoft et al. [10], and the recent work of
Araki et al. [2]; these each tolerate only semi-honest behavior. Mohassel et al. [33] and Furukawa et al. [21] tolerate a malicious attacker corrupting only one party.
Constant-round MPC. Techniques for building constant-round
MPC protocols have been studied in various settings. As noted
Session A1: Multi-Party Computation 1 CCS’17, October 30-November 3, 2017, Dallas, TX, USA 40
above, FairplayMP [5] and Ben-Efraim et al. [6] implemented this
approach in the semi-honest setting. Other researchers have proposed approaches without providing an implementation, possibly
because an implementation would be too complex or because the
concrete efficiency of the resulting protocol would be uncompetitive with nonconstant-round protocols. As examples, Damgård
and Ishai [16] proposed a protocol making black-box use of the
underlying cryptographic primitives, and Choi et al. [14] looked
at the three-party setting with malicious corruption of two parties.
Lindell et al. [31, 32] considered optimizations of the BMR approach
in the malicious setting. We compare the efficiency of our protocol
with relevant prior work in Section 6.4.
Concurrent work. Independent of our work, Hazay et al. [25]
proposed and implemented a constant-round MPC protocol with
malicious security against any number of corruptions. The complexities of the online the function-dependent preprocessing phases of
their protocol are similar to ours, though the underlying technique
is very different. On the other hand, our function-independent
processing phase is more efficient than theirs both asymptotically
and concretely, and appears to be 3 × −5× faster in practice. See
Section 6.4 for a more detailed comparison.
2 NOTATION AND PRELIMINARIES
We use κ and ρ to denote the computational and statistical security
parameters, respectively. We use = to denote equality and := to
denote assignment.
A circuit is viewed as a list of gates of the form (α, β,γ ,T ), where
this represents a gate with input wires α and β, output wire γ , and
gate type T ∈ {⊕, ∧}. Parties are denoted by P1, . . . , Pn. We use Ii
to denote the set of input-wire indices for Pi
, W to denote the set
of output-wire indices for all AND gates, and O to denote the set of
output-wire indices of the circuit. (We assume all parties learn the
output.) M is used to denote the set of all corrupted parties, with
H = [n] \ M denoting the set of all honest parties.
Our protocol operates by having the parties distributively construct a garbled circuit that is evaluated by one of the parties; we
let P1 be the circuit evaluator.
Authenticated bits. Information-theoretic message authentication codes (IT-MACs) for authenticating bits were first used for efficient secure computation by Nielsen et al. [35] in the two-party setting. The idea can be extended to the multiparty setting as follows.
Each player Pi holds a global MAC key ∆i ∈ {0, 1}
κ
. When Pi holds
a bit x authenticated by Pj
, this means that Pj
is given a random key
Kj[x] ∈ {0, 1}
κ
and Pi
is given the MAC tag Mj[x] := Kj[x] ⊕ x∆j
.
We let [x]
i denote an authenticated bit where the value of x is
known to Pi
, and is authenticated to all other parties. In more detail, [x]
i means that (x, {Mk
[x]}k,i
) is given to Pi
, and Kj[x] is
given to Pj for j , i.
Note that [x]
i
is XOR-homomorphic: given two authenticated
bits [x]
i
,[y]
i known to the same party Pi
, it is possible to locally
compute the authenticated bit [z]
i with z = x ⊕ y as follows:
• Pi computes z := x ⊕ y, and (
Mj[z] := Mj[x] ⊕ Mj[y]
)
j,i
;
• Pj
(for j , i) computes Kj[z] := Kj[x] ⊕ Kj[y].
Parties can also locally negate [x]
i
, resulting in [z]
i with z = x¯:
• Pi computes z := x ⊕ 1 and (
Mj[z] := Mj[x]
)
j,i
;
• Pj
(for j , i) computes Kj[z] := Kj[x] ⊕ ∆j
.
We let F
n
aBit denote an ideal functionality that distributes authenticated bits to the parties.(For details, see Figure 4 in Section 5.1).
We also discuss an efficient instantiation of this functionality in
Section 5.1.
Note that the above representation assumes that Pi uses a single
global MAC key ∆i
. In cases where other keys are used, we explicitly add a subscript to the representation, i.e., we use Ki[x]Gi
and
Mi[x]Gi = Ki[x]Gi ⊕ xGi to denote the key and MAC tag in this
case.
Authenticated shares. In the above construction, x is known to
one party. To generate an authenticated shared bit x, where x is not
known to any party, we generate XOR-shares for x (i.e., shares {x
i
}
with L
i
x
i = x) and then distribute the authenticated bits {[x
i
]
i
}.
We let ⟨x⟩ denote the collection of these authenticated shares for x;
that is, ⟨x⟩ means that each party Pi holds 
x
i
, {Mj[x
i
], Ki[x
j
]}j,i

.
We let FaShare denote an ideal functionality that distributes authenticated shared bits to the parties (Details see Figure 6 in Section 5.2). We discuss an efficient instantiation of this functionality
in Section 5.2.
Definition of security. We use the standard notion of (standalone)
security against an unbounded number of malicious parties. As our
protocol is described, only PA receives output; however, it would
not be difficult to modify the protocol (using standard techniques)
to support arbitrary outputs for different parties. In that case our
protocol would achieve the notion of secure computation with
designated abort [22, 24].
3 OVERVIEW OF OUR MAIN PROTOCOL
Our main protocol is designed in the FPre-hybrid model (see Figure 1). At a high level, FPre generates authenticated shares on
random bits x,y, z such that z = x ∧y. (We refer to these as AND
triples.) Our main protocol then uses those authenticated shares to
distributively construct a single, “authenticated” garbled circuit that
is evaluated by one of the parties. In the remainder of this section,
we describe our main protocol; further details are in Section 4. In
Section 5 we then discuss how to efficiently realize FPre.
3.1 Two-Party Authenticated Garbling
Wang et al. [37] recently proposed a maliciously secure protocol for
two-party computation using a two-party version of FPre. Before
explaining how we extend it to the multiparty setting, we briefly
describe their protocol partially based on their presentation.
Their protocol is based on a standard garbled circuit, where each
wire α is associated with a random “mask” λα ∈ {0, 1} known to
PA. If the actual wire value when the circuit is evaluated is x, then
the masked value observed by the circuit evaluator (namely, PB)
will be xˆ = x ⊕ λα . Each wire α is also associated with two labels
Lα,0 and Lα,1 := Lα,0 ⊕ ∆ known to PA. PB also learns Lα,xˆ
for
that wire. Let H be a hash function modeled as a random oracle.
The garbled table for an AND gate (α, β,γ , ∧) is given by:
Session A1: Multi-Party Computation 1 CCS’17, October 30-November 3, 2017, Dallas, TX, USA 41
Functionality FPre
Honest parties:
1. Upon receiving init from all parties, sample {∆i ∈ {0, 1}
κ
}i∈[n] and send ∆i to Pi
.
2. Upon receiving random from all Pi
, sample a random bit r and a random authenticated share ⟨r⟩ = {(r
i
, {Mj[r
i
], Ki[r
j
]}j,i
)}i∈[n]
. For each
i ∈ [n], the box sends (r
i
, {Mj[r
i
], Ki[r
j
]}j,i
) to Pi
.
3. Upon receiving 
AND, (r
i
, {Mj[r
i
], Ki[r
j
]}j,i
), (s
i
, {Mj[s
i
], Ki[s
j
]}j,i

from Pi for all i ∈ [n], the box checks that all MACs are valid,
computes t :=
L
i∈[n]
r
i

∧
L
i∈[n]
s
i

and picks a random authenticated share ⟨t⟩ = {(t
i
, {Mj[t
i
], Ki[t
j
]}j,i
)}i∈[n]
. For each i ∈ [n],
the box sends (t
i
, {Mj[t
i
], Ki[t
j
]}j,i
) to Pi
.
Corrupted parties: Corrupted parties can choose randomness used to compute the value they receive from the functionality.
Global key queries: The adversary at any point can send some (p, ∆
′
) and will be told if ∆
′ = ∆p .
Figure 1: The multi-party preprocessing functionality.
xˆ yˆ truth table garbled table
0 0 zˆ00 = (λα ∧ λβ ) ⊕ λγ H (Lα,0, Lβ,0
, γ, 00) ⊕ (zˆ00, Lγ ,zˆ00 )
0 1 zˆ01 = (λα ∧ λβ ) ⊕ λγ H (Lα,0, Lβ,1
, γ, 01) ⊕ (zˆ01, Lγ ,zˆ01 )
1 0 zˆ10 = (λα ∧ λβ ) ⊕ λγ H (Lα,1, Lβ,0
, γ, 10) ⊕ (zˆ10, Lγ ,zˆ10 )
1 1 zˆ11 = (λα ∧ λβ ) ⊕ λγ H (Lα,1, Lβ,1
, γ, 11) ⊕ (zˆ11, Lγ ,zˆ11 )
PB, holding (xˆ, Lα,xˆ
) and (yˆ, Lβ,yˆ
), evaluates it by picking the (xˆ,yˆ)-
th row and decrypting using the garbled labels it holds, thus obtaining (zˆ, Lγ,zˆ
). This is not secure because a malicious party can
perform a selective failure attack to learn, e.g., xˆ. However, Wang et
al. observe that it can be prevented if two parties hold secret shares
of the garbled table: e.g., for the first row, PA knows (r00, L
A
γ,zˆ00
),
while PB knows (s00 = zˆ00 ⊕ r00, L
B
γ,zˆ00
), where Lγ,z = L
A
γ,z ⊕ L
B
γ,z
.
Once PA sends its shares of all the garbled gates, PB can XOR those
shares with its own and then evaluate the garbled circuit as before.
Informally, it ensures privacy against a malicious PA since the
results of any changes PA makes to the garbled circuit are independent of PB’s inputs. However, PA can still affect correctness by, e.g.,
flipping the masked value in a row. This is solved using informationtheoretic MACs on PA’s share of masked bits. The shares of the
garbled table now take the form as shown in the table below.
xˆ yˆ PA’s share of garbled table PB’s share of garbled table
0 0 H (Lα,0, Lβ,0
, γ, 00) ⊕ (r00, M[r00], L
A
γ ,zˆ00
) (s00 = zˆ00 ⊕ r00, K[r00], L
B
γ ,zˆ00
)
0 1 H (Lα,0, Lβ,1
, γ, 01) ⊕ (r01, M[r01], L
A
γ ,zˆ01
) (s01 = zˆ01 ⊕ r01, K[r01], L
B
γ ,zˆ01
)
1 0 H (Lα,1, Lβ,0
, γ, 10) ⊕ (r10, M[r10], L
A
γ ,zˆ10
) (s10 = zˆ10 ⊕ r10, K[r10], L
B
γ ,zˆ10
)
1 1 H (Lα,1, Lβ,1
, γ, 11) ⊕ (r11, M[r11], L
A
γ ,zˆ11
) (s11 = zˆ11 ⊕ r11, K[r11], L
B
γ ,zˆ11
)
PB will verify the MAC on PA’s share of each masked bit that it
learns. This limits PA to only being able to cause PB to abort, which
will occur independently of PB’s actual input.
Finally they observe that if setting ∆ = ∆A then Lγ,zˆ00 can be
efficiently secret-shared:
Lγ,zˆ00 = Lγ,0 ⊕ zˆ00∆A
= Lγ,0 ⊕ r00∆A ⊕ s00∆A
=

Lγ,0 ⊕ r00∆A ⊕ K[s00]

| {z }
L
A
γ ,zˆ00
⊕ (K[s00] ⊕ s00∆A)
| {z }
L
B
γ ,zˆ00
.
Recall that PA knows Lγ,0,r00 and ∆A. Their key insight is that ifs00
is an authenticated bit known to PB, then PA can locally compute
the share L
A
γ,zˆ00
:= Lγ,0 ⊕ r00∆A ⊕ K[s00] from the information it
has, and then the other share L
B
γ,zˆ00
:= K[s00] ⊕ s00∆A is just the
MAC on s00 that PB already holds. Table 3 shows the garbled table
based on this observation.
3.2 Extension to the Multiparty Setting
It is not trivial to extend the above protocol to the multiparty setting.
The main challenge is that even when n − 1 parties are corrupted,
we still need to make sure that the adversary cannot learn any
information about the honest party’s inputs.
Attempted ideas. One idea, adopted by Choi et al. [14] in the
three-party setting, is to let n − 1 parties jointly compute a garbled
circuit that the remaining party will evaluate. However, if the n − 1
garblers are corrupt, there is no guarantee about the correctness of
the garbled circuit they generate. For that reason, Choi et al. had to
use cut-and-choose to check correctness of a random subset of ρ
garbled circuits, which imposes a huge overhead.
To avoid this additional cut-and-choose, we would like all parties to be involved in the garbled-circuit generation, as in the BMR
protocol [3]. However, state-of-the-art protocols based on BMR that
are maliciously secure against corruption of n − 1 parties require either O(n) somewhat homomorphic encryptions [32] or O(n) SPDZ
multiplication subprotocols [31] per AND gate both of which are
relatively inefficient. We aim instead to use “simpler” TinyOT-like
functionalities as we explain next.
Multiparty TinyOT: BDOZ-style vs. SPDZ-style. We observe
that in the existing literature, there are mainly two flavors on how
authenticated shared are constructed.
• BDOZ-style [7]: For a secret bit x, each party holds a share
of x. For each ordered pair of parties (Pi
, Pj
), Pi authenticates
its own share (namely x
i
) to Pj
.
• SPDZ-style [19]: Each party holds a share of a global MAC
key. For a secret bit x, each party holds a share of x and a
share of the MAC on x.
Note that these protocols are constructed for arithmetic circuits,
but these representations also apply to binary circuits. Existing
papers prefer SPDZ-style shares to BDOZ-style shares, because
SPDZ-style shares are smaller and thus more efficient to operate on.
Indeed, existing papers that investigated protocols for multi-party
TinyOT are all based on SPDZ-style shares [12, 20, 30].
Session A1: Multi-Party Computation 1 CCS’17, October 30-November 3, 2017, Dallas, TX, USA 42
x ⊕ λα y ⊕ λβ PA’s share of garbled table PB’s share of garbled table
0 0 H (Lα,0, Lβ,0
, γ, 00) ⊕ (r00, M[r00], Lγ ,0 ⊕ r00∆A ⊕ K[s00]) (s00 = zˆ00 ⊕ r00, K[r00], M[s00])
0 1 H (Lα,0, Lβ,1
, γ, 01) ⊕ (r01, M[r01], Lγ ,0 ⊕ r01∆A ⊕ K[s01]) (s01 = zˆ01 ⊕ r01, K[r01], M[s01])
1 0 H (Lα,1, Lβ,0
, γ, 10) ⊕ (r10, M[r10], Lγ ,0 ⊕ r10∆A ⊕ K[s10]) (s10 = zˆ10 ⊕ r10, K[r10], M[s10])
1 1 H (Lα,1, Lβ,1
, γ, 11) ⊕ (r11, M[r11], Lγ ,0 ⊕ r11∆A ⊕ K[s11]) (s11 = zˆ11 ⊕ r11, K[r11], M[s11])
Table 3: Final construction of an authenticated garbled table for an AND gate.
Our key observation is that such SPDZ-style AND triple, although efficient for interactive MPC protocols, are not suitable for
our use to construct constant-round MPC protocols. In particular,
in the SPDZ-style shares, each parties knows ∆i as a share of the
global key ∆ =
L
i
∆i
. For each bit x, they holds shares of x∆.
Since ∆ is not known to any party, it is not directly related to any
garbled circuit. On the contrary, in the BDOZ-style protocols, each
party holds (x
i
, {Mj[x
i
], Ki[x
j
]}j,i
), as we have already described
in Section 2. In this case, they essentially hold shares of x∆i for all
i ∈ [n], because:
x∆i =
*
.
,
M
j
x
j +
/
-
∆i = x
i∆i ⊕
*
.
,
M
j,i
x
j∆i
+
/
-
= x
i∆i ⊕
*
.
,
M
j,i
Mi[x
j
] ⊕ Ki[x
j
]
+
/
-
=
*
.
,
x
i∆i ⊕
M
j,i
Ki[x
j
]
+
/
-
⊕
M
j,i
Mi[x
j
]
Here, Pi knows the first value, while each Pj with j , i knows
Mi[x
j
]. In other word, a BDOZ-style share of a bit x can be used to
construct shares of x∆i for each i. This can further be used to construct shares of garbled labels, if we use the same ∆i for authenticated
shares and the global difference used in free-XOR. Indeed, looking
ahead to the main protocol in Figure 2 step 4 (d), the content of the
garbled circuit can be viewed as some authentication information
plus shares of the garbled output labels for each garbler.
High level picture of the protocol. Given the above discussion,
we can now picture the high level idea of our protocol. Our idea,
from a high level view, is to let n − 1 parties be garblers, each
maintaining a set of garbled labels, and to let the remaining party
be the evaluator. Each garbler knows its own set of garbled labels.
However, for each gate and for each garbler, the permuted garbled
output labels are secretly shared to all parties, and thus no party
knows how these labels are permuted. For each garbler Pi and a
garbler row, Pi has shares of permuted garbled output labels for all
garblers. In the garbled table, Pi encrypts all these shares using its
own set of garbled input labels. Further, shares of the mask value
are authenticated similarly. The evaluator decrypts the same row of
garbled tables from all garblers in order to recompute the garbled
output labels for each garbler. Intuitively, this ensures that for any
set of n − 1 parties, they cannot garble or evaluate any gate.
4 THE MAIN SCHEME
Since we have discussed the main intuition of our protocol, we will
proceed to the details directly. The proof of the main protocol can
be found in Section A.1. In Figure 2 and Figure 3, we present the
complete MPC protocol in the FPre-hybrid model. The protocol can
be divided into five phases:
1. Circuit Pre-scan. (Step 1-3) In this phase, each party obtains their own private global MAC keys (∆i
) from FPre, and
generate authenticated shares on wire masks for all wires.
2. Circuit Garbling. In this phase, each party compute shares
of garbled tables for each garbler (Step 4 (a) - 4 (c)). Garblers
then compute the distributed garbled circuits based on these
shares (Step 4 (d)).
3. Circuit Input Processing. For each input wire that corresponds to Pi
’s input, all other parties reveal their share of
the wire mask to Pi
. Party[i] then broadcasts the masked
input values. All garblers, upon receiving this masked input
value, send the corresponding key to the evaluator.
4. Circuit Evaluation. The evaluator evaluate the circuit following the topological order. In detail, the garbled wire labels
from each garbler is used to obtain a set of shares of the wire
labels for the output of the gate. The wire labels can then be
constructed from the shares.
5. Circuit Output Processing.Now the evaluator holds masked
output. All garblers reveal their shares of the output wire
masks for the circuit to let evaluator unmask the value.
5 EFFICIENTLY REALIZING FPRE
In this section, we describe an efficient instantiation of FPre, which
is a multi-party version of TinyOT protocol. All previous related protocols [12, 20, 30] for multi-party TinyOT rely on cut-and-choose to
ensure correctness and another bucketing to ensure privacy, resulting in a communication/computation complexity at least Ω(B
2n
2
)
per AND triple, where bucket size B = ρ/ log |C| (See Table 1 for
more detail). Furthermore, these protocols output SPDZ-style shares
that are not compatible with our main protocol. Our new protocol
introduced in this section works with BDOZ-style shares; furthermore the complexity per AND triple is O(Bn2
) with a very small
constant. The new protocol features a new distributed AND triple
checking protocol that checks the correctness of an AND triple without cut-and-choose. The adversary is still able to perform selective
failure attacks on a triple with probability of being caught at least
one-half. Such leakage can be easily eliminated using bucketing.
In the following, we will build our protocol from the bottom
up. In Section 5.1 and Section 5.2, we discuss the multi-party authenticated bits and authenticated shares that we also introduced
in Section 2; in Section 5.4, we discuss an AND triple generation
protocol that allows an adversary to perform selective failure attacks; the final protocol that eliminates such an attack follows the
bucketing protocols used in previous works [35, 37], and is detailed
in Section 5.5.
Note that similar to the prior work [37], our protocol also relies
on two-party FaBit functionality, which has a random global key for
Session A1: Multi-Party Computation 1 CCS’17, October 30-November 3, 2017, Dallas, TX, USA 43
Protocol Πmpc
Inputs: In the function-independent phase, parties know |C | and |I |; in the function-dependent phase, parties get a circuit representing function
f : {0, 1}
|I1 | × ... × {0, 1}
|In | → {0, 1}
|O|; in the input-processing phase, Pi holds xi ∈ {0, 1}
|Ii
|
.
Function-independent phase:
1. Pi sends init to FPre, which sends ∆i to Pi
.
2. For each wire w ∈ I ∪ W, i ∈ [n], Pi sends random to FPre, which sends 
r
i
w,
(
Mj[r
i
w ], Ki[r
j
w ]
)
j,i

to Pi
, where L
i∈[n]
r
i
w = λw . For
each i , 1, Pi also picks a random κ-bit string L
i
w,0
.
Function-dependent phase:
3. For each gate G = (α, β, γ, ⊕), each i ∈ [n], Pi computes 
r
i
γ
,
(
Mj[r
i
γ
], Ki[r
j
γ ]
)
j,i

:=

r
i
α ⊕ r
i
β
,

Mj[r
i
α ] ⊕ Mj[r
i
β
], Ki[r
j
α ] ⊕ Ki[r
j
β
]

j,i
!
.
For each i , 1, Pi also computes L
i
γ ,0
:= L
i
α,0
⊕ L
i
β,0
.
4. For each gate G = (α, β, γ, ∧):
(a) For each i ∈ [n], Pi sends
and,

r
i
α,
(
Mj[r
i
α ], Ki[r
j
α ]
)
j,i

,

r
i
β
,

Mj[r
i
β
], Ki[r
j
β
]

j,i
! ! to FPre, which sends 
r
i
σ ,
(
Mj[r
i
σ ], Ki[r
j
σ ]
)
j,i

to Pi
, where L
i∈[n]
r
i
σ =
L
i∈[n]
r
i
α

∧
L
i∈[n]
r
i
β

.
(b) For each i , 1, Pi computes the following locally.

r
i
γ ,0
,
(
Mj[r
i
γ ,0
], Ki[r
j
γ ,0
]
)
j,i

:=

r
i
σ ⊕ r
i
γ
,

Mj[r
i
σ ] ⊕ Mj[r
i
γ
], Ki[r
j
σ ] ⊕ Ki[r
j
γ ]

j,i


r
i
γ ,1
,
(
Mj[r
i
γ ,1
], Ki[r
j
γ ,1
]
)
j,i

:=

r
i
γ ,0
⊕ r
i
α,

Mj[r
i
γ ,0
] ⊕ Mj[r
i
α ], Ki[r
j
γ ,0
] ⊕ Ki[r
j
α ]

j,i


r
i
γ ,2
,
(
Mj[r
i
γ ,2
], Ki[r
j
γ ,2
]
)
j,i

:=

r
i
γ ,0
⊕ r
i
β
,

Mj[r
i
γ ,0
] ⊕ Mj[r
i
β
], Ki[r
j
γ ,0
] ⊕ Ki[r
j
β
]

j,i


r
i
γ ,3
,
(
Mj[r
i
γ ,3
], Ki[r
j
γ ,3
]
)
j,i

:=

r
i
γ ,1
⊕ r
i
β
,

M1[r
i
γ ,1
] ⊕ M1[r
i
β
], Ki[r
1
γ ,1
] ⊕ Ki[r
1
β
] ⊕ ∆i

S

Mj[r
i
γ ,1
] ⊕ Mj[r
i
β
], Ki[r
j
γ ,1
] ⊕ Ki[r
j
β
]

j,i,1

(c) P1 computes the following locally.

r
1
γ ,0
,
(
Mj[r
1
γ ,0
], K1[r
j
γ ,0
]
)
j,i

:=

r
1
σ ⊕ r
1
γ
,

Mj[r
1
σ ] ⊕ Mj[r
1
γ
], K1[r
j
σ ] ⊕ K1[r
j
γ ]

j,i


r
1
γ ,1
,
(
Mj[r
1
γ ,1
], K1[r
j
γ ,1
]
)
j,i

:=

r
1
γ ,0
⊕ r
1
α,

Mj[r
1
γ ,0
] ⊕ Mj[r
1
α ], K1[r
j
γ ,0
] ⊕ K1[r
j
α ]

j,i


r
1
γ ,2
,
(
Mj[r
1
γ ,2
], K1[r
j
γ ,2
]
)
j,i

:=

r
1
γ ,0
⊕ r
1
β
,

Mj[r
1
γ ,0
] ⊕ Mj[r
1
β
], K1[r
j
γ ,0
] ⊕ K1[r
j
β
]

j,i


r
1
γ ,3
,
(
Mj[r
1
γ ,3
], K1[r
j
γ ,3
]
)
j,i

:=

r
1
γ ,1
⊕ r
1
β
⊕ 1,

Mj[r
1
γ ,1
] ⊕ Mj[r
1
β
], K1[r
j
γ ,1
] ⊕ K1[r
j
β
]

j,i

(d) For each i , 1, Pi computes L
i
α,1
:= L
i
α,0
⊕ ∆i and L
i
β,1
:= L
i
β,0
⊕ ∆i
, and sends the following to P1.
G
i
γ ,0
:= H

L
i
α,0
, L
i
β,0
, γ, 0

⊕

r
i
γ ,0
,
(
Mj[r
i
γ ,0
]
)
j,i
, L
i
γ ,0
⊕
L
j,i
Ki[r
j
γ ,0
]

⊕ r
i
γ ,0
∆i

G
i
γ ,1
:= H

L
i
α,0
, L
i
β,1
, γ, 1

⊕

r
i
γ ,1
,
(
Mj[r
i
γ ,1
]
)
j,i
, L
i
γ ,0
⊕
L
j,i
Ki[r
j
γ ,1
]

⊕ r
i
γ ,1
∆i

G
i
γ ,2
:= H

L
i
α,1
, L
i
β,0
, γ, 2

⊕

r
i
γ ,2
,
(
Mj[r
i
γ ,2
]
)
j,i
, L
i
γ ,0
⊕
L
j,i
Ki[r
j
γ ,2
]

⊕ r
i
γ ,2
∆i

G
i
γ ,3
:= H

L
i
α,1
, L
i
β,1
, γ, 3

⊕

r
i
γ ,3
,
(
Mj[r
i
γ ,3
]
)
j,i
, L
i
γ ,0
⊕
L
j,i
Ki[r
j
γ ,3
]

⊕ r
i
γ ,3
∆i

Figure 2: Our main protocol. Here ρ is set to κ for clarity, but this is not necessary.
each party preserved across all executions and allows an adversary
to make “global-key queries” to honest parties’ global keys. Both
these features are preserved in all our ideal functionalities, but we
suppress explicit mention of them in our descriptions. Global-key
queries have little effect on security, since the probability that the
attacker can correctly guess the honest party’s value of ∆ using
polynomially many queries is negligible.
5.1 Multi-Party Authenticated Bit
The first step of our protocol is to generate multi-party authenticated bit. The functionality F
n
aBit, also discussed in Section 2, is
shown in Figure 4. Notice that if we set n = 2, then F
2
aBit is the
original two-party authenticated bit functionality [35]. One naive
solution to realize F
n
aBit is to let Pi run the two-party authenticated bit protocol with every other party using the same bit x. This
solution is not secure, since a malicious Pi can potentially use inconsistent values when running F
2
aBit with other parties. In our
protocol, we use this general idea and we also perform additional
checks to ensure that Pi uses consistent values. The check is similar
to the recent malicious OT extension protocol by Keller et al. [27],
where parties perform checks based on random linear combination:
a malicious Pi who uses inconsistent values is able to pass ρ checks
with probability at most 2
−ρ
. Note that these checks also reveal
some linear relationship of x’s. To eliminate this leakage, a small
number of random authenticated bits are computed and checked
together. They are later discarded to break the linear relationships.
The protocol is described in Figure 5 with proof in Section A.2.
Session A1: Multi-Party Computation 1 CCS’17, October 30-November 3, 2017, Dallas, TX, USA 44
Protocol Πmpc, continued
Input Processing:
5. For each i , 1, w ∈ Ii
, for each j , i, Pj sends (r
j
w, Mi[r
j
w ]) to Pi
, who checks that (r
j
w, Mi[r
j
w ], Ki[r
j
w ]) is valid, and computes x
i
w ⊕ λw :=
x
i
w ⊕
L
i∈[n]
r
i
w

. Pi broadcasts the value x
i
w ⊕ λw . For each j , 1, Pj sends L
j
xi ⊕λw
to P1.
6. For each w ∈ I1, i , 1, Pi sends (r
i
w, M1[r
i
w ]) to P1, who checks that (r
i
w, M1[r
i
w ], K1[r
i
w ]) are valid, and computes x
1
w ⊕ λw := x
1
w ⊕
L
i∈[n]
r
i
w

. P1 sends x
1
w ⊕ λw to Pi
, who sends L
i
w,x
1
w ⊕λw
to P1.
Circuit Evaluation:
7. P1 evaluates the circuit following the topological order. For each gate G = (α, β, γ, T ), P1 holds 
zα ⊕ λα,
(
L
i
α,zα ⊕λα
)
i,1

and

zβ ⊕ λβ,

L
i
β,zβ ⊕λβ

i,1
!
, where zα, zβ are the underlying values of the wire.
(a) If T = ⊕, P1 computes zγ ⊕ λγ := (zα ⊕ λα ) ⊕ (zβ ⊕ λβ ) and 
L
i
γ ,zγ ⊕λγ
:= L
i
α,zα ⊕λα
⊕ L
i
β,zβ ⊕λβ

i,1
(b) If T = ∧, P1 computes ℓ := 2(zα ⊕ λα ) + (zβ ⊕ λβ ). For i , 1, P1 computes

r
i
γ , ℓ,
(
Mj[r
i
γ , ℓ ]
)
j,i
, L
i
γ

:= G
i
γ , ℓ ⊕ H

L
i
α,zα ⊕λα
, L
i
β,zβ ⊕λβ
, γ, ℓ
.
P1 checks that  r
i
γ , ℓ, M1[r
i
γ , ℓ ], K1[r
i
γ , ℓ ]

i,1
are valid and aborts if fails. P1 computes zγ ⊕ λγ :=
L
i∈[n]
r
i
γ , ℓ , and

L
i
γ ,zγ ⊕λγ
:= L
i
γ ⊕
L
j,i Mi[r
j
γ , ℓ ]

i,1
Output Processing:
8. For each w ∈ O, i , 1, Pi sends (r
i
w, M1[r
i
w ]) to P1, who checks that (r
i
w, M1[r
i
w ], K1[r
i
w ]) is valid. P1 computes zw := (λw ⊕ zw ) ⊕
L
i∈[n]
r
i
w

.
Figure 3: Our main protocol, continued. Here ρ is set to κ for clarity, but this is not necessary.
Functionality F
n
aBit
Honest Parties: The box receives (input, i, ℓ) from all parties and
picks random bit-string x ∈ {0, 1}
ℓ
. For each j ∈ [ℓ], k , i, the box
picks random Kk [xj], and computes {Mk [xj] := Kk [xj] ⊕xj∆k }k,i
,
and sends them to parties. That is, for each j ∈ [ℓ], it sends
{Mk [xj]}k,i
to Pi and sends Kk [xj] to Pk for each k , i.
Corrupted parties: Corrupted parties can choose their output from
the protocol.
Figure 4: Functionality for multi-party authenticated bit.
5.2 Multi-Party Authenticated Shares
In this section, we aim to construct a protocol that allows multiple
parties to obtain authenticated shares of a secret bit, as shown in
Figure 6. One straightforward idea is to call F
n
aBit n times, where in
the i-th execution, they compute [x
i
]
i
for some random x
i known
only to Pi
. However, the adversary is still able to perform an attack:
a malicious Pi can potentially use different global MAC keys (∆i
) in
different executions of F
n
aBit. The result is that [x
j
]
j
is authenticated
with a global MAC key ∆i
, while some other [x
k
]
k
is authenticated
with a different global MAC key ∆
′
i
. This attack does not happen in
the two-party setting, because each party is authenticated to only
one party.
Our key idea is based on the observation that the two-party
authenticated bit protocol already ensured that, when Pi and Pj
compute multiple authenticated bits, Pi uses the same ∆i across
different authenticated bits. Therefore, in the above insecure attempt, if one authenticated share has consistent global MAC keys,
Protocol Π
n
aBit
Protocol:
1. Set ℓ
′
:= ℓ + 2ρ. Pi picks random bit-string x ∈ {0, 1}
ℓ
′
.
2. For each k , i, Pi and Pk runs F
2
aBit, where Pi
sends {xj }j∈[ℓ
′
]
to F
2
aBit. From the functionality, Pi gets
{Mk [xj]}j∈[ℓ
′
]
, Pk gets {Kk [xj]}j∈[ℓ
′
]
.
3. For j ∈ [2ρ], all parties perform the following:
(a) All parties sample a random ℓ
′
-bit strings r.
(b) Pi computes Xj =
Lℓ
′
m=1
rmxm, and broadcast Xj
, and
computes 
Mk [Xj] =
Lℓ
′
m=1
rmMk [xm]

k,i
.
(c) Pk computes Kk [Xj] =
Lℓ
′
m=1
rmKk [xm].
(d) Pi sends Mk [Xj] to Pk who check the validity.
4. All parties return the first ℓ objects.
Figure 5: The protocol Π
n
aBit instantiating F
n
aBit.
then all authenticated shares have consistent global MAC keys, and
vice versa. In our secure construction, we first let all parties compute ℓ + ρ number of multi-party authenticated shares as described
above, which may not be secure. Then we partially open the last ρ
tuples to check the consistency of global MAC keys. A malicious
party who uses inconsistent ∆i
’s will get caught with probability
one-half for each partially opened shares.
In more detail, each player Pi will take the role of a prover once
to prove that he uses a consistent ∆i and the remaining players
will take the role of verifier for the given prover. The basic idea is
that if the prover used a consistent ∆i
, then these authenticated
bits across different parties are XOR homomorphic. Taking a threeparty setting as an example. Say P1 has K1[x], K2[y] with global
Session A1: Multi-Party Computation 1 CCS’17, October 30-November 3, 2017, Dallas, TX, USA 45
Functionality FaShare
Honest Parties: The box receives (input, ℓ) from all parties and picks
random bit-strings x ∈ {0, 1}
ℓ
and random authenticated shares
{⟨xj⟩ }j∈[ℓ]
, and sends them to parties.
In detail, the box picks random bit strings {x
i
}
i∈[n]
, each of length
ℓ bits. For each i ∈ [n], j ∈ [ℓ], The box picks random multi-party
authenticated bits [x
i
j
]
i
and sends them to parties. That is, for each
j ∈ [ℓ], it sends (x
i
j
, {Mk [x
i
j
], Ki[x
k
j
]}k,i
) to Pi
.
Corrupted parties: Corrupted parties can choose their output from
the protocol.
Figure 6: Functionality for multi-party authenticated share.
Protocol ΠaShare
Protocol:
1. Set ℓ
′
:= ℓ + ρ. For each i ∈ [n], Pi picks random bit-string
x
i ∈ {0, 1}
ℓ
′
.
2. For each i ∈ [n], all parties compute multi-party authenticated
bits by sending (i, ℓ′
) to F
n
aBit, which sends {[x
i
j
]
i
}j∈[ℓ
′
]
to
parties.
3. For r ∈ [ρ], all parties perform the following:
(a) For each i ∈ [n], Pi parses {[x
k
ℓ+r
]
k
}k∈[n] as
(x
i
ℓ+r
, {Mk [x
i
ℓ+r
], Ki[x
k
ℓ+r
]}k,i
). Each Pi computes
commitments (c
0
i
, d
0
i
) ← Com(
L
k,i
Ki[x
k
ℓ+r
]),
(c
1
i
, d
1
i
) ← Com(
L
k,i
Ki[x
k
ℓ+r
] ⊕ ∆i
), and
(c
M
i
, d
M
i
) ← Com(x
i
ℓ+r
, {Mk [x
i
ℓ+r
]}k,i
), and broadcast
(cm
i
, c
0
i
, c
1
i
).
(b) For each i ∈ [n], after receiving all commitments, Pi broadcasts dM
i
.
(c) For each i ∈ [n], Pi computes b
i
:=
L
k,i
x
k
ℓ+r
, and
broadcast d
b
i
i
.
(d) For each i ∈ [n], Pi performs the following to check the
consistency of ∆’s: For each j , i, Pi computes K
j ←
Open(cbj , dbj ) and check if it equals to L
k,j Mj[x
k
ℓ+r
].
If any check fails, the party aborts.
4. All parties return the first ℓ objects.
Figure 7: The protocol ΠaShare instantiating FaShare.
keys ∆
x
1
and ∆
y
1 which are potentially different; P2 has (x, M1[x]);
P3 has (y, M1[y]). In our checking protocol, we let P1 commit to
values K1[x] ⊕ K1[y] and K1[x] ⊕ K1[y] ⊕ ∆1. For an adversary who
uses inconsistent global keys, it needs to choose two values out of
the following four values to commit.
x = 0 y = 0 K1[x] ⊕ K2[y]
x = 0 y = 1 K1[x] ⊕ K2[y] ⊕ ∆
y
1
x = 1 y = 0 K1[x] ⊕ K2[y] ⊕ ∆
x
1
x = 1 y = 1 K1[x] ⊕ K2[y] ⊕ ∆
x
1
⊕ ∆
y
1
Later in the protocol, the adversary is asked to open the MAC for
x ⊕ y. If inconsistent global keys are used, this value can be any
of the four values each with one-fourth probability, therefore, the
adversary can win with probability at most 2/4 = 1/2. The details
of the protocol are shown in Figure 7 with proof in Section A.3.
Functionality FHaAND
Honest Parties:
1. The box picks random ⟨x⟩ and sends it to all parties.
2. Upon receiving (i, {y
i
j
}j,i
) from all Pi
, the box picks random
bits {v
i
}i∈[n] such that L
i
v
i
:=
L
i
L
j,i
x
iy
j
i
. The box
sends v
i
to Pi
.
Corrupted parties: Corrupted parties can choose their output from
the protocol.
Figure 8: The Half Authenticated AND Functionality
Protocol ΠHaAND
Protocol:
1. All parties call FaShare to obtain ⟨x⟩.
2. For each i, j ∈ [n], such that i , j,
(a) Pi picks a random bit s
j
, and computes H0 :=
Lsb(H (Ki[x
j
])) ⊕s
j
, H1 = Lsb(H (Ki[x
j
] ⊕∆i
)) ⊕s
j ⊕y
i
j
.
(b) Pi sends (H0, H1) to Pj
, who computes t
i
:= Hx j ⊕
Lsb(H (Mi[x
j
])).
3. For each i ∈ [n], Pi obtains v
i
:=
L
k,i
(t
k ⊕ s
k
).
Figure 9: Protocol ΠHaAND instantiating FHaAND.
5.3 Half-Authenticated AND Triple
Before introducing the protocol for leaky authenticated AND triples,
there is yet another tool that we need. As described in Figure 8, the
functionality FHaAND is introduced to compute cross terms in AND
triples. It takes unauthenticated and potentially inconsistent y’s and
outputs authenticated share ⟨x⟩ as well as unauthenticated shares
of cross product terms. Details about the protocol is in Figure 9
with proof included in Section A.3.
5.4 Multi-Party Leaky Authenticated AND
Triple
Now we are ready to discuss the protocol for leaky authenticated
AND triples. It can be divided into following steps:
1. Call FaShare to obtain some random ⟨y⟩ and ⟨r⟩.
2. Call FHaAND with y to obtain a random ⟨x⟩ and compute
shares {z
i
}, such that (
L
i
x
i
) ∧ (
L
i
y
i
) =
L
i
z
i
.
3. Reveal d = z ⊕ r and computes ⟨z⟩ := ⟨r⟩ ⊕ d.
4. Perform additional check to ensure the correctness of the
AND relationship.
In the above steps, the adversary is able to cheat by using inconsistent values of y and z between step 1 and 2. However, this only
allows the adversary to perform selective failure attack on x
i
’s. For
example, the AND relationship checked is
*
,
M
i
x
i +
-
∧ *
,
M
i
y
i +
-
= *
,
M
i
z
i +
-
.
The adversary can guess that the value of Lx
i = 0 and flip y
j
for
some j ∈ M. If the guess is correct, than the check will go through
Session A1: Multi-Party Computation 1 CCS’17, October 30-November 3, 2017, Dallas, TX, USA 46
Functionality FLaAND
Honest parties: For each i ∈ [n], the box picks random ⟨x⟩, ⟨y⟩, ⟨z⟩
such that (
Lx
i
) ∧ (
Ly
i
) =
Lz
i
.
Corrupted parties:
1. Corrupted parties can choose all their randomness.
2. An adversary can send (Q, {Ri }i∈[n]
), which are κ-bit strings,
to the box and perform a linear combination test. The box
checks
Q ⊕
M
i
x
iRi = 0
If the check is incorrect, the box outputs fail and terminates,
otherwise the box proceeds as normal.
3. An adversary can also send (q, {ri }i∈[n]
), which are all bits,
to the box and perform a linear combination test. The box
checks
q ⊕
M
i
x
i
ri = 0
If the check is incorrect, the box outputs fail and terminates,
otherwise the box proceeds as normal.
Figure 10: Functionality FLaAND for leaky AND triple.
and the protocol will proceed as normal. However, if the guess is
wrong, then the checking will abort and the adversary is caught.
One main challenge is what leakage we should aim for in this
functionality. We would like to limit the leakage to be possible only
on x
i
’s, otherwise we would need more bucketing for each possible
leakage, as also noted by Nielsen et al. [35]. On the other hand, the
adversary can do more attacks than the one mentioned above: it is
also possible to, for example, learn L
i ∈S
x
i
for some set S ⊂ [n].
We find that the best way to abstract such attack is to allow the
adversary to perform a linear check on the value of x
i
’s. As shown
in Figure 10, the adversary is allowed to send a list of coefficients
and check if the inner product between the coefficients and x values
is zero or not.
Our checking phase differs substantially from existing works. We
design an efficient checking protocol, that ensures the correctness
of the triple (if no party aborts) which allows malicious parties to
learn k bits of some specific information with probability at most
2
−k
. In the two-party protocol, one party constructs “checking
tables” and lets the other party to evaluate/check. In the multi-party
protocol here, we instead let all parties distributively construct the
“checking tables”. Interestingly, distributively constructing these
checks is inspired by the main protocol where parties distributively
construct garbled tables. As noted before, this protocol is vulnerable
to selective failure attacks. The full description of this protocol is
presented in Figure 11.
In the following, we will show the correctness and unforgeability of the protocol, which are crucial to the security proof of the
protocol.
5.4.1 Correctness of the protocol. We want to show that the
protocol will compute a correct triple and will not abort if all parties
are honest. Notice that the value we are checking can be written as:
Protocol ΠLaAND
Triple computation.
1. For each i ∈ [n] each party calls FaShare and obtains random
authenticated shares {⟨y⟩, ⟨r⟩ }. All parties also calls FHaAND
to obtain random authenticated share ⟨x⟩.
2. For each i ∈ [n], Pi sends (i, {y
i
}j,i
) to FHaAND and gets
back some v
i
.
3. For each i ∈ [n], Pi computes z
i
:= x
iy
i ⊕v
i
and e
i
:= z
i ⊕
r
i
. Pi broadcasts e
i
to all other parties. All parties computes
[z
i
]
i
:= [r
i
]
i ⊕ e
i
.
Triple checking.
4. For each i ∈ [n], Pi computes: Φi
:= y
i∆i ⊕
L
k,i
Ki[y
k
] ⊕ Mk [y
i
]

.
5. For every pair of i, j ∈ [n], such that i , j, Pi computes Ki[x
j
]Φi
:= H (Ki[x
j
]) and Ui,j
:= H (Ki[x
j
] ⊕
∆i
) ⊕ Ki[x
j
]Φi ⊕ Φi
, and sends Ui,j to Pj
. Pj computes
Mi[x
j
]Φi
:= x
jUi,j ⊕ H (Mi[x
j
]).
6. For i ∈ [n], Pi computes
Hi
:= x
iΦi ⊕
L
k,i
Ki[x
k
]Φi ⊕ Mk [x
i
]Φk

⊕ z
i∆i ⊕
L
k,i
Ki[z
k
] ⊕ Mk [z
i
]

.
All parties simultaneously broadcast Hi by first broadcasting the commitment of Hi and send the decommitment after
receiving commitments from all parties.
7. Each party check if L
i Hi = 0 and abort if not true.
Figure 11: The protocol ΠLaAND.
M
i
Hi
=
M
i
*
.
,
x
i Φi ⊕
*
.
,
M
k,i
Ki[x
k
]Φi
⊕ Mk [x
i
]Φk
+
/
-
⊕ z
i ∆i ⊕
*
.
,
M
k,i
Ki[z
k
] ⊕ Mk [z
i
]
+
/
-
+
/
-
=
M
i
*
.
,
x
i Φi ⊕
*
.
,
M
k,i
Ki[x
k
]Φi
⊕ Mk [x
i
]Φk
+
/
-
+
/
-
⊕
M
i
*
.
,
z
i ∆i ⊕
*
.
,
M
k,i
Ki[z
k
] ⊕ Mk [z
i
]
+
/
-
+
/
-
=
M
i
*
.
,
x
i Φi ⊕
*
.
,
M
k,i
Ki[x
k
]Φi
⊕ Mi[x
k
]Φk
+
/
-
+
/
-
⊕
M
i
*
.
,
z
i ∆i ⊕
*
.
,
M
k,i
Ki[z
k
] ⊕ Mi[z
k
]
+
/
-
+
/
-
=
M
i
*
.
,
x
i Φi ⊕
*
.
,
M
k,i
x
k Φi
+
/
-
+
/
-
⊕
M
i
*
.
,
z
i ∆i ⊕
*
.
,
M
k,i
z
k ∆i
+
/
-
+
/
-
= *
,
M
i
x
i +
-
·
*
,
M
i
Φi
+
-
⊕ *
,
M
i
z
i +
-
·
*
,
M
i
∆i
+
-
Notice further that
M
i
Φi =
M
i
*
.
,
y
i ∆i ⊕
*
.
,
M
k,i
Ki[y
k
] ⊕ Mk [y
i
]
+
/
-
+
/
-
= *
,
M
i
y
i +
-
·
*
,
M
i
∆i
+
-
Therefore we know that
M
i
Hi = *
,
M
i
x
i +
-
·
*
,
M
i
Φi
+
-
⊕ *
,
M
i
z
i +
-
·
*
,
M
i
∆i
+
-
= *
,
M
i
x
i +
-
·
*
,
M
i
y
i +
-
·
*
,
M
i
∆i
+
-
⊕ *
,
M
i
z
i +
-
·
*
,
M
i
∆i
+
-
= *
,
*
,
M
i
x
i +
-
·
*
,
M
i
y
i +
-
⊕ *
,
M
i
z
i +
-
+
-
·
*
,
M
i
∆i
+
-
Since L
i
∆i
is non-zero, L
i Hi = 0 if and only if the logic of this
AND is correct.
Session A1: Multi-Party Computation 1 CCS’17, October 30-November 3, 2017, Dallas, TX, USA 47
5.4.2 Unforgeability. Now we want to show that any incorrect
AND triple cannot pass the check.
Lemma 5.1. Define x
i
,y
i
from ⟨x⟩,⟨y⟩ which are outputs from
FaShare and FHaAND; define z
i
:= r
i ⊕ e
i
, where ⟨r⟩ is output from
FaShare, e
i
is the value broadcast from Pi
. If L
i
x
i

∧
L
i
y
i

,
Lz
i

then the protocol results in an abort except with negligible
probability.
We use U
∗
i,j
and H
∗
i
to denote the values that an honest party
would have computed, and define Qi,j = U
∗
i,j
⊕ Ui,j
, Qi = H
∗
i
⊕ Hi
.
In the following, we will assume that the logic of the AND does
not hold while at the same time that the check passes, and we will
derive a contradiction from it.
First note that if Pi uses some Qi,j
, then Pj will obtain Mi[x
j
]Φi
with an additive error of x
jQi,j
. Note that
M
i
H
∗
i
= *
,
*
,
M
i
x
i +
-
·
*
,
M
i
y
i +
-
⊕ *
,
M
i
z
i +
-
+
-
·
*
,
M
i
∆i
+
-
=
M
i
∆i
Therefore, we know that
M
i
Hi =
M
i∈M
Hi ⊕
M
i∈H
Hi
=
M
i∈M

H
∗
i
⊕ Qi

⊕
M
i∈H
*
.
,
H
∗
i
⊕
*
.
,
M
k,i
x
k Qk,i
+
/
-
+
/
-
=
M
i
H
∗
i
⊕
M
i∈M
Qi ⊕
M
i∈H
*
.
,
M
k,i
x
k Qk,i
+
/
-
=
M
i
∆i ⊕
M
i∈M
Qi ⊕
M
i∈H
*
.
,
M
k,i
x
k Qk,i
+
/
-
In order to makeL
i Hi to be 0, the adversary needs to find paddings
such that
M
i ∈M
Qi ⊕
M
i ∈H
*
.
,
M
k,i
x
kQk,i
+
/
-
=
M
i
∆i
The above happens with at most negligible probability.
Theorem 5.2. Assuming an adversary corrupting up to n − 1 parties, the protocol in Figure 11, where H is modeled as a random oracle,
securely instantiates FLaAND functionality in the (FaShare, FHaAND)-
hybrid model.
Note that since no party has private input, the simulation proof
is straightforward given the lemmas above. We provide full details
of the proof in Section A.5.
5.5 Multi-Party Authenticated AND Triple
Once we have a protocol for leaky authenticated AND triple, it is
straightforward to obtain a non-leaky authenticated AND triple,
using the combine protocol in [37]. We show the details of the
protocol in Figure 13.
6 EVALUATION
6.1 Implementation Details
We implemented our protocol in the EMP-toolkit [36] framework
and will be made publicly available as a part of it. To fully explore
performance characteristics of our protocol, we evaluate our implementation in three different settings:
Functionality FaAND
Honest parties: For each i ∈ [n], the box picks random ⟨x⟩, ⟨y⟩, ⟨z⟩
such that (
Lx
i
) ∧ (
Ly
i
) =
Lz
i
.
Corrupted parties: Corrupted parties get to choose all of their randomness.
Figure 12: Functionality FaAND for generating AND triples
Protocol ΠaAND
Protocol:
1. Pi call FLaAND ℓ
′ = ℓB times and obtains
{⟨xj⟩, ⟨yj⟩, ⟨zj⟩ }j∈[ℓ
′
]
.
2. All parties randomly partition all objects into ℓ buckets, each
with B objects.
3. For each bucket, parties combine B leaky ANDs into one
non-leaky AND. To combine two leaky ANDs, namely
(⟨x1⟩, ⟨y1⟩, ⟨z1⟩) and (⟨x2⟩, ⟨y2⟩, ⟨z2⟩) :
(a) Parties reveal d := y1 ⊕ y2 with its MACs checked.
(b) Each party Pi sets ⟨x⟩ := ⟨x1⟩ ⊕ ⟨x2⟩, ⟨y⟩ := ⟨y1⟩, ⟨z⟩ :=
⟨z1⟩ ⊕ ⟨z2⟩ ⊕ d⟨x2⟩.
Parties iterate all B leaky objects, by taking the resulted object
and combine with the next element.
Figure 13: Protocol ΠaAND instantiating FaAND.
Figure 14: Amazon EC2 regions used in the WAN experiment. Details see Table 9.
Circuit n1 n2 n3 |C|
AES 128 128 128 6800
SHA-128 256 256 160 37300
SHA-256 256 256 256 90825
Table 4: Circuits used in our evaluation.
• LAN setting. Machines are located in the same Amazon
EC2 region. Experiments are performed for up to 14 parties.
• WAN setting. Each Machine is located in a different Amazon
EC2 region (locations shown in Figure 14). For a k-party
computation experiment, a prefix subset of the machines in
Table 9 are selected. For example, parties in 3PC experiments
are located in North Virginia, Ohio, and North California
Session A1: Multi-Party Computation 1 CCS’17, October 30-November 3, 2017, Dallas, TX, USA 48
(a) LAN setting. (b) WAN setting.
Figure 15: Running time breakdown for evaluating AES. In the LAN setting, all parties are located in the same region; In the WAN
setting, all parties are located in different regions worldwide, for example, 2PC: within US-east; 5PC: within North America; 8PC: within
North America and Europe; 12PC: within North America, Europe and Asia; 13PC: further adds Sydney; 14PC: all parties in Figure 14.
respectively. Experiments are run for up to 14 parties, which
is the number of different Amazon EC2 regions available.
• Crowd setting. In the LAN case, we evaluate up to 128
parties all located in the same Amazon EC2 region. In the
global-scale case, we choose 8 different cities across 5 continents and open up to 16 parties in each city (totally 128
parties).
All machines are of type c4.8xlarge, with 36 cores and 60 GB
RAM. Network bandwidth within the same region is about 10Gbps.
The bandwidth across different regions depends on the location
of the machines. All experiments are based on ρ = 40,κ = 128.
We extend justGarble [4] to support garbling of longer tables in
a straightforward manner. In the implementation, we used the
“broadcast with abort” protocol by Goldwasser and Lindell [24] and
achieves the notion of secure computation with abort. We observe
small variance when running in the LAN setting and slightly higher
variance in the WAN setting. All numbers reported in LAN setting
are on average of 10 runs, ones in WAN setting are on average of
20 runs, and ones in the Crowd setting are on average of 5 runs due
to the lengthy experiments.
6.2 Performance on Basic Circuits
We evaluate commonly used benchmark circuits on our protocol, including AES, SHA-1, and SHA-256. Information about these circuits
can be found in Table 4.
We plot in Figure 15 the results for AES in different network
setting and performance breakdown as described above. Detailed
timings and more results for all three circuits can be found in Table 10 in the Appendix. First, the performance of three-party computation is extremely efficient: it takes 95 ms to evaluate a circuit
for AES, with 2 ms online time. We also find that in the LAN setting,
the slowdown from 2PC to 3PC is roughly 1.5×; the slowdown in
the WAN setting is larger. This is caused by the network latency:
the first two parties are both located in the U.S. east coast, while
the third party is located in the U.S. west coast with much higher
latency.
We also find that the cost of the one-time setup is almost independent of number of parties for small number of parties. This is
mainly due to the parallelization in the implementation that allows
all base-OT to run at the same time.
World-wide MPC experiment. We would like to emphasize that
in the case of WAN setting with 14 parties, it is a “world-wide” MPC
experiment over 5 continents. To the best of our knowledge, we are
the first to conduct MPC over such large range even considering
semi-honest MPC protocols.
We also notice a big “jump” in running time from 8 parties to
9 parties in the WAN setting. We believe this is because of the
network condition: for experiments up to 8 parties, it is within
the US/Europe area; the ninth party is located in asia, where the
communication to US/Europe is much slower. More details see
Figure 15b.
6.3 Evaluation in a Global Setting
In this section, we focus on the performance of our protocol with a
large number of parties. We summarize our results in Figure 5. We
notice that our protocol scales very well with increasing number
of parties. Even in a setting with 128 parties located in the same
LAN, where up to 127 of them can be corrupted, it takes less than
17 seconds end-to-end running time to compute AES. Note that the
performance of a 64-party computation on AES is comparable to
the performance of what used to be the state-of-the-art malicious
2-party computation three years ago [1], and we believe further
optimizations and improvements based on our work will flourish
too.
When comparing the running time of 128 parties to the one
of 8 parties, we find that the cost of function-dependent phase
increases much faster than the cost of function-independent phase.
This is because our function-independent phase is symmetric and
all communication loads are evenly distributed among all parties;
while in the function-dependent phase, n − 1 garblers send the
garbled circuit to the evaluator, and the bandwidth of the evaluator
becomes the bottleneck. Therefore in the case where there are a lot
Session A1: Multi-Party Computation 1 CCS’17, October 30-November 3, 2017, Dallas, TX, USA 49
LAN setting WAN setting
n Setup Indep. Depen. Online Total Setup Indep. Depen. Online Total
8 49.4 122.2 35.7 7.8 215.1 16736.0 30647.4 5905.2 783.3 54071.9
16 78.8 227.8 121.1 29.4 457.0 18708.1 21699.6 12243.5 598.8 53250.0
32 129.9 627.0 446.2 112.3 1315.5 35838.8 19038.4 8242.3 716.6 63836.1
64 212.9 1182.2 2630.1 476.5 4501.7 71913.8 25280.7 29416.6 1564.0 128175.2
128 383.0 2727.4 11669.6 1870.2 16650.2 88055.9 30795.9 22659.1 2316.2 143827.0
Table 5: Detailed experiment results for the crowd setting. Timings are measured in terms of milliseconds. In the LAN setting, all
parties are located in the same region. In the Worldwide setting. 8PC is performed with each party located in a different region; 16PC is
performed with 2 parties located in each region; others can be interpreted similarly.
of parties, when we double the number of parties, the running time
of the function-dependent phase almost doubles.
We also run the same experiment in the worldwide range. We
choose 8 most separate regions out of 14 and open up to 16 machines
in each region (thus totally 128 machines). The performance is also
shown in Table 5: it takes slightly more than a minute for 64 parties
to compute AES and about 2.5 minutes for 128 parties located all
around the world. We also observe that setup takes much more
time; we believe it is due to the high latency.
6.4 Comparison to Other Work
Malicious MPC on AES. Evaluating AES with malicious security
against n − 1 corruption was studied by Damgård et al. [17]. They
reported 240 ms online time for 3 parties and 340 ms online time
for 10 parties. The offline time for 3 and 10 parties are around
4200 seconds and 15000 seconds respectively. Our protocol takes
95 ms total time to evaluate AES for 3 parties with online time as
small as 2 ms; and 268 ms total time with online time 12 ms. The
improvement for online phase ranges from 28× to 120×; and the
improvement for total time ranges from 44000× to 56000×. This is
a huge improvement even considering hardware differences.
BMR-style protocols. Lindell et al. [31, 32] studied how to use
SPDZ and SHE to construct a BMR-style protocol. Since their protocol is not implemented, we compare the communication complexity.
After incorporating various optimizations, every AND gate still
need 3n + 1 SPDZ multiplication triples. Together with the most
recent advance in SPDZ triple generation by Keller et al. [28], generating one SPDZ triple with n parties requires communication about
180(n − 1) kilobits per party. Therefore the communication cost per
AND gate per party is about 540n(n − 1) kilobits. In our protocol,
each AND gate only needs one AND triple from FPre, which, using
our new protocol in Section 5, requires communication roughly
2.28(n − 1) kilobits per party. Therefore, the improvement of our
protocol compared to the best-optimized BMR protocol based on
Lindell et al. is about 237n× with n parties. For a three-party setting,
it is an improvement of 711×; for the 128-party computation that
we perform, the improvement is as high as 30, 000×!
Ben-Efraim et al. [6] presented a protocol secure in the semihonest model based on BMR. Surprisingly, given the fact that our
protocol is maliciously secure, while theirs only has a semi-honest
security, our implementation has roughly the same performance
as theirs. In Table 6, we compare the running time of our protocol
with the running time of theirs based on the same hardware. We
3 8 16 32
[6] Online 80 150 400 1500
Total 228 2000 5900 -
This work Online 24 95 370 1632
Total 618 1945 6711 18828
Table 6: Compare with Ben-Efraim et al. [6] Timings are in
terms of milliseconds. Their protocol works in the semi-honest
setting; ours is maliciously secure. Comparison based on SHA-256,
with the same hardware configuration.
ρ 3 8 16
[25] 40 14 49 105
80 55 193 413
This work 40 4.8 16.9 36.4
80 8.6 30 64.5
Table 7: Compare bandwidth consumption with Hazay et
al. [25]. All numbers are the maximum amount of data one party
needs to send in the function-independent phase, measured in terms
of megabytes (MB). Numbers for ρ = 80 are calculated based on
the complexity of both protocols.
notice that for both online time and total time, the performance of
the two protocols are roughly the same.
Malicious 3PC protocols with honest majority. Mohassel et
al. [33] proposed an efficient protocol for malicious 3PC with honest
majority. Their protocol requires only one garbled circuit to be sent
and therefore has a smaller communication complexity than us. We
estimate that our protocol requires about 14× more communication
than theirs. However interestingly we also find that the online time
of two protocols are roughly the same: their protocol requires 31
ms evaluation time, while ours needs 23.4 ms evaluation time. We
belive this is due to the fact that their protocol needs to check that
the garbled circuit received from two garblers are the same, while
it is not needed in our protocol.
Furukawa et al. [21] also presented a malicious 3PC protocol
with honest majority. Their protocol has a smaller communication
overhead compared to the protocol above by Mohassel et al. but
requires at least one round of communication per level of the circuit. In addition to a stronger security guarantee that we support
dishonest majority, our protocol has a better latency, especially for
deep circuit (e.g. SHA-256 has a depth of 4000), while their protocol
has a better throughput.
Session A1: Multi-Party Computation 1 CCS’17, October 30-November 3, 2017, Dallas, TX, USA 50
n Setup Indep. Depen. Online Total
AES
3 57.1 KB 4.8 MB 1.3 MB 4.5 KB 6.2 MB
4 85.7 KB 7.2 MB 1.8 MB 4.5 KB 9.1 MB
5 114.2 KB 9.7 MB 2.2 MB 4.5 KB 12.0 MB
6 142.8 KB 12.1 MB 2.7 MB 4.5 KB 14.9 MB
7 171.4 KB 14.5 MB 3.1 MB 4.5 KB 17.8 MB
8 199.9 KB 16.9 MB 3.5 MB 4.5 KB 20.7 MB
16 428.4 KB 36.4 MB 7.1 MB 4.5 KB 44.0 MB
SHA-256
3 57.1 KB 63.3 MB 17.4 MB 9.0 KB 80.8 MB
4 85.7 KB 95.0 MB 23.4 MB 9.0 KB 118.5 MB
5 114.2 KB 126.6 MB 29.4 MB 9.0 KB 156.2 MB
6 142.8 KB 158.3 MB 35.4 MB 9.0 KB 193.9 MB
7 171.4 KB 190.0 MB 41.4 MB 9.0 KB 231.6 MB
8 199.9 KB 221.7 MB 47.4 MB 9.0 KB 269.3 MB
16 428.4 KB 475.1 MB 95.4 MB 9.0 KB 570.9 MB
Table 8: Communication complexity of our protocol. Bandwidth are measured for evaluating AES and SHA-256. All numbers
are the maximum amount of data one party needs to send.
Compare with Hazay et al. [25]. We also compare with the concurrent work by Hazay et al.. As their protocol is benchmarked
on different hardware and network configurations, we only compare the bandwidth usage. We find that both protocols has similar
function-dependent cost and online cost. However, due to our improved preprocessing protocol, our function-independent cost is
much smaller than theirs. In Table 7, we compare the functionindependent cost of for AES evaluation with different value of ρ.
Our protocol uses 3× to 6.5× less communication compared to
theirs. Note that the cost of function-independent phase dominates
the overall cost, therefore the speed up here also translates to the
speed up to the whole computation.
6.5 Communication Complexity
In this section, we evaluate the communication complexity of our
protocol. All numbers reported here are the maximum amount of
data sent from one party. All numbers are obtained by running
our implementation, which are slightly higher than calculated values due to implementation details. In Table 8, we summarize the
bandwith use for AES and SHA-256 for up to 16 parties.
We can see from the figure that the communication required
per party grows linearly with the number of parties. In addition,
the communication cost of the Setup phase and the Online phase
are very small. The total communication cost is dominated by the
function-independent phase.