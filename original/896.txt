Using dynamic Searchable Symmetric Encryption, a user with limited storage resources can securely outsource a database to an untrusted server, in such a way that the database can still be searched
and updated efficiently. For these schemes, it would be desirable
that updates do not reveal any information a priori about the modifications they carry out, and that deleted results remain inaccessible
to the server a posteriori. If the first property, called forward privacy,
has been the main motivation of recent works, the second one,
backward privacy, has been overlooked.
In this paper, we study for the first time the notion of backward privacy for searchable encryption. After giving formal definitions for different flavors of backward privacy, we present several
schemes achieving both forward and backward privacy, with various efficiency trade-offs.
Our constructions crucially rely on primitives such as constrained
pseudo-random functions and puncturable encryption schemes.
Using these advanced cryptographic primitives allows for a finegrained control of the power of the adversary, preventing her
from evaluating functions on selected inputs, or decrypting specific ciphertexts. In turn, this high degree of control allows our
SSE constructions to achieve the stronger forms of privacy outlined above. As an example, we present a framework to construct
forward-private schemes from range-constrained pseudo-random
functions.
Finally, we provide experimental results for implementations of
our schemes, and study their practical efficiency.
CCS CONCEPTS
• Security and privacy→Privacy-preserving protocols; Security protocols; Management and querying of encrypted data;
KEYWORDS
Searchable Encryption; Constrained PRF; Puncturable Encryption;
Forward Privacy; Backward Privacy
1 INTRODUCTION
Symmetric Searchable Encryption (SSE) enables a client to outsource the storage of private data to an untrusted server, while retaining the ability to issue search queries over the outsourced
data. Dynamic SSE schemes add the ability for the client to update
the outsourced database, inserting and possibility deleting entries
remotely. All the while, the design of the scheme should ensure
that the server is able to infer as little as possible about the content
of the database, or even the content of the queries it processes.
At the core of SSE schemes are trade-offs between efficiency,
such as storage requirements, bandwidth or latency, and the degree
to which the scheme protects the content of the client’s data against
a curious (or malicious) server. The latter is captured by the notion
of leakage functions that restrict the type of information leaked to
the server while processing search or update queries.
Since the inception of searchable encryption, tremendous progress
has been made toward efficient solutions yielding high throughput,
low latency, and more expressive queries [CJJ+13, CJJ+14, MM17].
Amid a growing awareness of privacy concerns however, a different
line of work has uncovered devastating and fairly generic attacks
against many SSE schemes [CGPR15, ZKP16]. Such leakage-abuse
attacks do not contradict the security claims of the targeted SSE
schemes, but show how seemingly benign leakage functions can
be exploited to reveal a considerable amount of information in
practice.
Forward privacy (also known as forward security) is an important
property of searchable encryption schemes that mitigates these
attacks by ensuring that newly updated entries cannot be related to
previous search results. Notably, forward-private schemes prevent
the most powerful versions of the recent injection attacks by Zhang
et al. [ZKP16]. Another natural notion of privacy is that of backward
privacy: search queries should not leak matching entries after they
have been deleted. However, besides being mentioned by Stefanov
et al. [SPS14], it is almost not discussed in the literature.
Our contribution. In this work, we realize single-keyword SSE
constructions from constrained and puncturable primitives. By
leveraging the fine-grained control afforded by this type of primitives, we are able to build (1) a very efficient forward-secure scheme;
and (2) a scheme that achieves both forward privacy and a weak
form of backward privacy. For both schemes, we define and prove
a general framework to build forward-secure SSE from the abstract
SSE primitive; and then propose and study a concrete scheme by
instantiating the framework with a specific choice of the underlying
primitive. In the process, we also investigate the notion of backward
privacy, providing formal definitions and a generic construction.
Finally, we provide experimental results for implementations of our
schemes. In more detail, our contributions are as follows.
(1) We propose formal definitions for several forms of backward
privacy, which up to now had only been treated informally. We also
Session G1: Searchable Encryption CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1465
Table 1 – Comparison with prior work. N is the number of keyword/document pairs in the database, K the number of distinct
keywords, and D the number of documents. nw is the size of the search result set for keyword w, aw is the number of entries
matching w inserted in total, while dw is the number of deleted entries matching w (and nw = aw −dw ). The RT column stands
for the number of roundtrips in the search protocol. FP (resp. BP) stands for forward (resp. backward) privacy. We denote
different levels of backward privacy with I, II, and III, where I is the strongest level (see Section 4.2 for details). The notation
Oe hides polylog factors.
Scheme Computation Communication Client FP BP Search Update Search RT Update Storage
Π
dyn [CJJ+14] O(aw ) O(1) O(nw ) 1 O(1) O(1) ✗ -
SPS [SPS14] O

min{aw + log N,nw log3 N}

O(log2 N) O(nw + log N) 1 O(log N) O(N
α
) ✓ -
TWORAM [GMP16] Oe

nw log N + log3 N

Oe(log2 N) Oe(nw log N + log3 N) 2 Oe(log3 N) O(1) ✓ -
Σoϕoς [Bos16] O(aw ) O(1) O(nw ) 1 O(1) O(K logD) ✓ -
ARX [PBP16] O(aw ) O(log aw ) O(nw + log aw ) 1 O(1) O(K logD) ✓ -
Moneta § 4.3 Oe

aw log N + log3 N

Oe(log2 N) Oe(aw log N + log3 N) 3 Oe(log3 N) O(1) ✓ I
Fides § 4.4 O(aw ) O(1) O(aw ) 2 O(1) O(K logD) ✓ II
Diana § 5.2 O(aw ) O(log aw ) O(nw + log aw ) 1 O(1) O(K logD) ✓ -
Dianadel § 5.3 O(aw ) O(log aw ) O(nw + dw log aw ) 2 O(1) O(K logD) ✓ III
Janus § 6 O(nw · dw ) O(1) O(nw ) 1 O(1) O(K logD) ✓ III
describe a simple and generic way to achieve backward privacy from
any forward private SSE scheme at the cost of an extra roundtrip
per search query, and two instantiations, Moneta and Fides.
(2) We define the FS-RCPRF framework, which builds a singlekeyword forward-private SSE scheme from any constrained pseudorandom function (CPRF) compatible with range constraints. By
instantiating the CPRF with the classic construction by Goldreich, Goldwasser and Micali [GGM84], we obtain Diana, a forwardsecure SSE scheme with very low computational and bandwidth
overhead—on some data sets, Diana performs up to 10 times faster
than recent schemes from the literature achieving the same leakage.
Note that Diana is very similar to the ARX-EQ construction [PBP16].
We also show how we can modify Diana into a two-roundtrips
backward-private scheme Dianadel.
(3) Finally, we describe Janus, a framework for constructing
a forward-secure SSE scheme that also achieves a weak form of
backward privacy; namely, search queries do not leak entries that
match the query after the entry has been deleted. The Janus framework requires a puncturable encryption scheme with a particular
incremental update property, which can be instantiated by the
Green-Miers puncturable encryption scheme [GM15].
To the best of our knowledge, Fides, Dianadel and Janus are the
first schemes not based on oblivious RAM to achieve backward
(and forward) privacy. Moreover, Janus is the only existing singleroundtrip forward and backward-private scheme.
A comparison of our schemes with prior work is provided in
Table 1. Beside the schemes themselves, we believe this work draws
a new connection between constrained primitives and searchable
encryption, which from the perspective of SSE schemes means new
construction techniques, and from the perspective of constrained
or puncturable primitives, new applications.
2 RELATED WORK
Searchable Encryption. Song et al. [SWP00] first introduced SSE.
The modern security definitions were developed by Curtmola et
al. [CGKO06]. They introduced the idea of leakage, and designed
the first reversed-index-based SSE construction, achieving optimal
search complexity. Note that SSE is a particular case of structured
encryption, as defined by Chase and Kamara [CK10], focused on
multi-maps (a.k.a. T-Sets or reversed index).
Even though the dynamic setting had been studied earlier, Kamara and Papamanthou [KP13] designed the first sublinear dynamic
scheme. Cash et al. [CJJ+14] constructed a dynamic scheme optimized for large datasets.
Forward privacy was introduced by Stefanov et al. in [SPS14]. In
that paper, the authors present an ORAM-inspired forward-private
SSE construction. Their construction also deals with deletion in an
elegant way, as it allows the server to skip deleted entries. However,
this was only designed to improve the performance of the scheme,
rather than its security. In [Bos16], Bost formally defined forward
privacy and designed an insertion-only SSE scheme with optimal
search and update complexity, based on asymmetric cryptography (trapdoor permutations). The motivation for studying forward
security came from file injection attacks on SSE [ZKP16].
In order to achieve the highest security guarantees, SSE can be
constructed using Oblivious RAM components [GO96, GMP16].
Unfortunately the overhead of ORAM is too high for a practical
SSE scheme [Nav15].
Several results propose SSE schemes with expressive search
queries: Cash et al. [CJJ+13] considered conjunctive queries; Kamara and Moataz [KM17] built a scheme for disjunctive queries;
while graph encryption was studied by Chase and Kamara [CK10]
and Meng et al. [MKNK15].
Constrained cryptographic primitives. Constrained pseudorandom functions were concurrently introduced in [BW13, KPTZ13,
BGI14], and applied to broadcast encryption, identity-based keyexchange, or SNARGs. One application considered by Kiayias et
al. [KPTZ13] was actually searchable encryption, but only for performance reasons: the constrained PRF is used to batch queries.
Session G1: Searchable Encryption CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1466
Instead of transmitting to the server many pseudo-randomly generated trapdoors, the client would transmit a constrained key allowing
for the generation of the trapdoors by the server.
Since then, new constrained PRFs have been developed, with
the ability to support richer constraint spaces [HKW15, CC17].
Unfortunately, many of these new constructions rely on indistinguishability obfuscation or similar techniques, and hence are not
yet practical. In this work, we only require the existence of cryptographic pairings for puncturable encryption, and pseudo-random
functions.
Building on non-monotonic attribute-based encryption [OSW07],
Green and Miers [GM15] proposed puncturable encryption as a way
to achieve forward secrecy for instant messaging. Their scheme
modifies the secret key every time a message is received, so that
from then on the modified key can no longer decrypt that message.
Thus, in the event of a key compromise, old messages remain safe.
Secure deletion. In this paper, we will use puncturable encryption
to securely delete entries in an encrypted database. Indeed, Green
and Miers [GM15] mention secure deletion as another application
of their work.
Boneh and Lipton [BL96] were the first to suggest using cryptography to erase information. These cryptographic solutions were
implemented for filesystems on flash drives [RCB12]. Secure deletion and history independence properties were also considered in
oblivious RAM literature [RAC16].
3 BACKGROUND
In the paper, λ is the security parameter and negl(λ) denotes a
negligible function in the security parameter.
Unless specified explicitly, the symmetric keys are strings of λ
bits, and the key generation algorithm uniformly samples a key in
{0, 1}
λ
. We only consider (probabilistic) algorithms and protocols
running in time polynomial in the security parameter λ. In particular, adversaries are probabilistic polynomial-time (PPT) algorithms.
For a finite set X, x
$← X means that x is sampled uniformly
from X.
3.1 Constrained Pseudorandom Functions
The idea of constrained PRFs (CPRFs) has been introduced in concurrent work by Boneh and Waters, Boyle et al., and Kiayias et
al. [BW13, BGI14, KPTZ13]. A constrained PRF is associated with
a family of boolean circuits C. The holder of the master PRF key
is able to compute a constrained key KC corresponding to a circuit
C ∈ C; the constrained key KC allows evaluation of the PRF only
on inputs x for which C(x) = 1.
More formally, a constrained PRF F with respect to a circuit family
C is a mapping F : {0, 1}
λ ×X → Y (the PRF proper), together with
a pair of algorithms (F .Constrain, F .Eval), defined as follows.
• F .Constrain(K,C) is a PPT algorithm taking as input a key
K ∈ {0, 1}
λ
and a circuit C ∈ C. It outputs a constrained key
KC.
• F .Eval(KC, x) is a deterministic polynomial-time algorithm
taking as input a constrained key KC for circuitC, and x ∈ X.
It outputs y ∈ Y.
Wherever this does not result in ambiguity, we may leave out
Eval and write F .Eval(KC, x) as F (KC, x).
Correctness. A CPRF F is correct iff C(x) = 1 implies F (K, x) =
F .Eval(KC, x), where KC = F .Constrain(K,C), for all K, x, and
C ∈ C.
Security. The security game describing the security of a CPRF
has three phases.
Setup Phase The challenger randomly picks a key K
$← {0, 1}
λ
and a bit b
$← {0, 1}.
Query Phase The adversary can adaptively query the oracles:
Eval(x) The challenger returns F (K, x);
Constrain(C) The challenger returns F .Constrain(K,C);
Challenдe(x) If b = 0 the challenger outputs F (K, x), otherwise he returns a uniform element in Y.
Guess Phase The adversary outputs a guess b
′ of b.
Let E be the set of evaluation queries, Z the set of challenge queries,
L the set of constrained key queries. The adversary wins the game
if b = b
′
and E ∩ Z = ∅ and C(z) = 0 ∀C ∈ L and z ∈ Z.
3.2 Bilinear Maps
Let G and GT be two cyclic groups of prime order p, д be a generator
of G and e : G × G → GT be such that
• e is bilinear: for all x,y ∈ G, a,b ∈ Zp , e(x
a
,y
b
) = e(x,y)
ab ;
• e is non-degenerate: e(д,д) , 1.
We consider G, GT and e such that the group operations in G
and GT , and the bilinear map e are all efficiently computable. The
scheme presented in this work using pairings needs the Decisional
Bilinear Diffie-Hellman (DBDH) and Decisional Bilinear DiffieHellman Inversion (DBDHI) to hold (cf. [BB04]).
3.3 Symmetric Searchable Encryption
The database DB on which we wish to perform search queries is defined as: DB = {(indi
, Wi) : 1 ≤ i ≤ D}, with indi ∈ {0, 1}
ℓ
, Wi ⊆
{0, 1}
∗
, and where indi are distinct document indices, represented
by ℓ-bit strings, and Wi
is a set of keywords matching document
indi
, represented by binary strings of arbitrary length. Note that
we identify documents with their indices. In addition, let us define:
W = ∪
D
i=1Wi the set of keywords;
K = |W| the number of keywords;
D = |DB| the number of documents;
N =
ÍD
i=1
|Wi
| the number of document/keyword pairs.
Finally, let DB(w) denote the set of documents containing keyword
w, i.e. DB(w) = {indi
|w ∈ Wi }.
A dynamic searchable encryption scheme Σ is a triple (Setup,
Search,Update) consisting of one algorithm and two protocols
between a client and a server:
• Setup(DB) is a probabilistic algorithm that takes as input the
initial database DB. It outputs a triple (EDB,KΣ, σ), where
KΣ is the master secret key, EDB is an encrypted database,
and σ is the client’s state.
• Search(KΣ,q, σ; EDB) = (SearchC(KΣ,q, σ), SearchS (EDB))
is a protocol between the client whose input is the master secret key KΣ, the client’s internal state σ, and a search query
q; and the server whose input is the encrypted database EDB.
Session G1: Searchable Encryption CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1467
In this paper, we only consider search queries restricted to a
single keyword w.
• Update(KΣ, σ, op, in; EDB) = (UpdateC
(KΣ, σ, op, in),
UpdateS
(EDB)) is a protocol between the client whose input
is KΣ and σ as above, and an operation op with its input in,
where in is parsed as an index ind and a set W of keywords;
and the server with input EDB. The update operations are
taken from the set {add, del}, meaning, respectively, the
addition and the deletion of a document/keyword pair.
An SSE scheme is said to be correct if the search protocol returns
the correct result for every query, except with negligible probability.
We refer to [CJJ+14] for a formal definition of correctness.
Security. The security of an SSE scheme expresses the fact that
the server should learn as little as possible about the content of
the database and queries. More precisely, we do not want the adversary to learn anything beyond some explicit leakage. This is
typically captured using a real-world versus ideal-world formalization [CGKO06, KPR12, CJJ+14]. A leakage function is used to
express the information leaked to the adversary by each SSE operation. Formally, the model is parametrized by the (stateful) leakage
function L = (LStp
, LSrch
, LUpdt), whose components correspond
respectively to the Setup, Search, and Update operations. The security model expresses the fact that whenever the client triggers one
of these operations, the adversary learns no more than the output
of the corresponding leakage function.
Formally, the adversary’s task is to distinguish between a real
word SSEReal and an ideal world SSEIdeal. The adversary fully
controls the client, in the sense that she can trigger Setup, then
Search and Update queries at will, with parameters of her choosing.
She then observes the execution of the scheme from the point
of view of the server. That is, the adversary is able to observe
the full transcript of each operation, i.e. the full content of the
communication between client and server. In principle, she is also
able to see the server’s memory; however since the server does not
see anything more of the client’s queries than the adversary, the
ability to see the server’s memory does not reveal any information
about the client’s queries beyond what can already be inferred from
the transcript alone.
• In the SSEReal world, the SSE scheme is executed honestly.
The adversary observes the real transcript of each operation,
and outputs a bit b.
• In the SSEIdeal world, the adversary sees a simulated transcript in place of the real transcript of the protocol. The
simulated transcript is generated by a PPT algorithm S,
known as the simulator, that has access to the leakage functions. For example, on Setup(DB), S returns a transcript from
S(LStp(DB)); and likewise for the Search and Update calls.
The adversary eventually outputs a bit b.
These games are formally described in Appendix D. The scheme Σ
is secure if the two worlds are indistinguishable.
Definition 3.1 (Adaptive security of SSE schemes). An SSE scheme
Σ is L-adaptively-secure, with respect to a leakage function L, if
for any polynomial-time adversary A issuing a polynomial number
of queries q(λ), there exists a PPT simulator S such that:



P
h
SSERealΣ
A
(λ,q) = 1
i
− P

SSEIdealA,S, L(λ,q) = 1



 =
negl(λ).
3.4 Leakage Functions
In this section we define a few simple leakage functions. We begin
with a common leakage function: the search pattern [CGKO06].
Most SSE schemes leak the fact that two search queries pertain
to the same keyword. Indeed, unless some form of data-oblivious
memory is used, when two searched keywords are equal, the search
token will typically prompt the server to access the same sections
of the encrypted database to retrieve the (same) document indices.
Formally, search pattern leakage is defined as follows. In its
internal state, the leakage function records the listQ of every search
query, in the form (u,w), whereu is the timestamp (an index starting
at 0 and increasing with every query) andw is the searched keyword.
The search pattern is defined as a function N → P(N) with sp(w) =
{u : (u,w) ∈ Q}. Thus, sp leaks which search queries relate to the
same keyword.
We also define the history UpHist(w) of each keyword w, following Bost [Bos16]. The function UpHist(w) outputs the list of all
updates on keywordw: each element of the list is a tuple (u, op, ind)
where u is the timestamp of the update, op is the operation, and ind
is the updated index. For example, if there are two documents
Dind1
and Dind2 matching w, such that Dind1 was inserted at update 3, Dind2
at update 7, and then Dind2 was deleted at update 42,
UpHist(w) will be [(4, add, ind1), (7, add, ind2), (42, del, ind2)].
4 FORWARD AND BACKWARD PRIVACY
Forward and backward privacy capture information leaked by a
dynamic SSE scheme. At a high level, forward privacy considers
privacy of the database and earlier search queries during updates,
while backward privacy captures privacy of the database and updates to it during search queries. In this section, we formally define
these privacy properties and present a generic transformation that
meets these definitions, albeit at a cost. Our generic construction,
and its instantiations with TWORAM [GMP16] and Σoϕoς [Bos16],
can be seen as a baseline solution that transforms any forwardprivate SSE scheme to provide backward privacy, at the cost of an
additional roundtrip. We improve on the baseline solution in the
following sections.
4.1 Forward Privacy
An SSE scheme is forward-private (or forward-secure) if Update
queries do not leak which keywords are involved in the keyword/
document pairs that are being updated. Forward privacy was informally defined in [SPS14]. Here we borrow the formal definition of
[Bos16].
Definition 4.1 (Forward Privacy). A L-adaptively-secure SSE
scheme is forward-private iff the update leakage function LUpdt
can be written as:
L
Updt(op, in) = L
′
(op, {(indi
, µi)})
Session G1: Searchable Encryption CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1468  
where the set {(indi
, µi)} captures all updated documents as the
number of keywords µi modified in document indi
; and L′
is stateless.
If update queries are restricted to adding or deleting a single
keyword/document pair, the scheme is forward-private iff we have
LUpdt(op,w, ind) = L′
(op, ind). All forward-private schemes in
this paper satisfy LUpdt(op,w, ind) = op.
4.2 Backward Privacy
Backward privacy limits the information on the updates affecting
keyword w that the server can learn upon a search query on w. Informally, an SSE scheme is backward-private (or backward-secure)
if, whenever a keyword/document pair (w, ind) is added into the
database and then deleted, subsequent Search queries on w do not
reveal ind [SPS14]. Note that ind is revealed if a Search query is
issued after (w, ind) is added, and before it is deleted.
Hence, we could argue that backward-private schemes are those
whose search leakage is only a (stateless) function of DB(w), as this
would only reveal information about document currently in the
database (and not the deleted ones). However, this is not enough,
as, even though the search leakage is reduced to DB(w), the update leakage could reveal the modified document/keyword pairs.
A scheme with such leakage would reveal the indices of deleted
documents, as the attacker could keep track of all the updated pairs,
which is exactly what we want to prevent. As a consequence, in
the security definitions, we must explicitly rule out such update
leakage.
Moreover, obtaining a scheme with leakage that depends only
on DB(w) would require hiding the pattern of updates as well as
their number. Although hiding the former could be achieved, for
example, using ORAM, this would result in expensive schemes.
As a consequence, we define three flavors of backward privacy of
decreasing strength, depending on how much metadata leaks about
the inserted and deleted entries:
I. Backward privacy with insertion pattern:
leaks the documents currently matching w, when they were
inserted, and the total number of updates on w.
II. Backward privacy with update pattern:
leaks the documents currently matching w, when they were
inserted, and when all the updates on w happened (but not
their content).
III. Weak backward privacy:
leaks the documents currently matching w, when they were
inserted, when all the updates on w happened, and which
deletion update canceled which insertion update.
Let us demonstrate the differences between these notions with an
example. Consider the following sequence of updates, in the order
of arrival: (add, ind1, {w1,w2}), (add, ind2, {w1}), (del, ind1, {w1}),
(add, ind3, {w2}). Let us consider the leakage for each definition
after a search query on w1. The first notion reveals ind1 and that
this entry was added at time 1. It also reveals that there were a
total of 3 updates for w1. The second notion, additionally reveals
that updates on w1 happened at time 1, 2, and 3. Finally, the third
definition also reveals that the index that was added for w1 at time
1 was removed at time 3.
In order to capture these notions, we introduce new leakage
functions, starting with TimeDB. For a keyword w, TimeDB(w) is
the list of all documents matching w, excluding the deleted ones,
together with the timestamp of when they were inserted in the
database. Formally, TimeDB(w) can be constructed from the query
list Q as follows:
TimeDB(w) = {(u, ind) | (u, add, (w, ind)) ∈ Q and
∀u
′
, (u
′
, del, (w, ind)) < Q}.
In particular DB(w) = {ind|∃u s.t. (u, ind) ∈ TimeDB(w)}. Note
that TimeDB is completely oblivious to any document added to
DB(w) that was later removed, but retains all other information.
As such, TimeDB captures a strong notion of backward privacy
revealing only the time of the insertion of the documents currently
containing the search query w.
Then, we define Updates(w) which is the list of timestamps of
updates on w. Formally,
Updates(w) = {u | (u, add, (w, ind)) or (u, del, (w, ind)) ∈ Q}.
Updates captures the leakage of the update pattern.
Finally, in order to capture the weakest notion of backward
privacy, we use DelHist. The deletion history DelHist(w) of w is
the list of timestamps for all deletion operations, together with the
timestamp of the inserted entry it removes. Formally, DelHist(w)
is constructed as:
DelHist(w) =
n
(u
add
,u
del) | ∃ind s.t. (u
del
, del, (w, ind)) ∈ Q
and (u
add
, add, (w, ind)) ∈ Q
o
.
With these tools, we can formally define our three notions of
backward privacy.
Definition 4.2 (Backward Privacy). A L-adaptively-secure SSE
scheme is insertion pattern revealing backward-private iff the search
and update leakage functions LSrch
, LUpdt can be written as:
L
Updt(op,w, ind) = L
′
(op)
L
Srch(w) = L
′′(TimeDB(w), aw ),
where L′
and L′′ are stateless.
A L-adaptively-secure SSE scheme is update pattern revealing
backward-private iff the search and update leakage functions LSrch
,
LUpdt can be written as:
L
Updt(op,w, ind) = L
′
(op,w)
L
Srch(w) = L
′′(TimeDB(w),Updates(w)),
where L′
and L′′ are stateless.
A L-adaptively-secure SSE scheme is weakly backward-private
iff the search and update leakage functions LSrch
, LUpdt can be
written as:
L
Updt(op,w, ind) = L
′
(op,w)
L
Srch(w) = L
′′(TimeDB(w), DelHist(w)),
where L′
and L′′ are stateless.
We can clearly see that backward privacy with insertion pattern
implies update pattern revealing backward privacy, which itself
Session G1: Searchable Encryption CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1469
Algorithm 1 Generic backward-private scheme B(Σ) where Σ is
an arbitrary SSE scheme and F is a PRF.
Setup(DB) :
1: Σ.Setup(DB), KΣ
$← {0, 1}
λ
Search(KΣ,w, σ; EDB)
1: Client and Server run Σ.Search(w), the client gets the list of
results R.
Client:
2: Kw ← F (KΣ,w)
3: Decrypt R as (EKw
(ind1, op1
), . . . , EKw
(indn, opn
))
4: Return 
ind : ∃i, (indi
, opi
) = (ind, add)
∧∀j > i, (indj
, opj
) , (ind, del)
o
Update(KΣ, add,w, ind, σ; EDB)
1: Client: Kw ← F (KΣ,w)
2: Client and Server run Σ.Update(add,w, EKw
(ind, op))
implies weak backward privacy. Also observe that an insertion pattern revealing backward-private scheme has to be forward-private,
and that if a scheme is both forward-private and weakly backwardprivate, then the leakage of update queries cannot depend on either
the updated keyword (by definition of forward privacy) or the updated document index (by definition of weak backward privacy),
so the leakage must be limited to the nature of the operation. This
will indeed be the case for all schemes considered in this article.
4.3 A Generic Two-Roundtrip
Backward-Private Scheme
In this section, we show how to build a simple backward-private
SSE scheme B(Σ) starting from an arbitrary SSE scheme Σ. We start
with a basic solution for clarity, then improve on it.
We alter Σ as follows. Instead of storing a document index ind,
the client uploads a ciphertext EKw
(ind, op), where EKw
is a secretkey encryption scheme and op ∈ {add, del}. The key Kw is specific
to keyword w and is chosen by the client. The server sees only the
resulting ciphertexts as Kw ’s are never revealed to it. The scheme
Σ otherwise runs as normal. In particular, Search queries return
the set of matching encrypted document indices EKw
(ind, op). The
client can then decrypt this set, remove deleted indices, and obtain
the final set of document indices matching w.
A description of B(Σ) is provided in Algorithm 1. Letting I denote the set of document indices, we assume I × {add, del} embeds
into the plaintext space of EK , and we use the ciphertext space
of EK as the set of document indices for Σ. Note that Σ only needs
to support add queries. The scheme B(Σ) achieves update pattern
revealing backward privacy, as Σ can leak any information about
the modified keyword during updates, and some access pattern
information during search. However, if Σ does not reveal any information about the past updates (i.e., if Σ does not leak UpHist(w)
but only DB(w)), we can show that B(Σ) guarantees backwardprivacy with insertion pattern. Unfortunately, the only dynamic
schemes which do not reveal UpHist(w) are based on ORAM, such
as TWORAM [GMP16].
The B(Σ) scheme, as described so far, has two drawbacks. The
first drawback is that the server does not learn document indices in
Algorithm 2 Improved backward-private scheme B
′
(Σ).
Setup(DB) :
1: T[w] ← 0 for all w, KΣ
$← {0, 1}
λ
2: DB′ ← DB where keywords w are replaced by w||0
3: Σ.Setup(DB′
)
Search(KΣ,w, σ; EDB)
1: Client: Kw ← H(KΣ,w, T[w])
2: Client and Server run R ← Σ.Search(w||T[w]) ▷ Server can
erase all retrieved elements from memory
Client:
3: Decrypt R as (EKw
(ind1, op1
), . . . , EKw
(indn, opn
))
4: R
′ ←

ind : ∃i, (indi
, opi
) = (ind, add)
∧∀j > i, (indj
, opj
) , (ind, del)
o
5: Send R
′
to Server
6: T[w] ← T[w] + 1
7: for all ind ∈ R
′ do ▷ In parallel
8: Run Update(KΣ, add,w, ind, σ; EDB)
9: end for
Update(KΣ, add,w, ind, σ; EDB)
1: Client: Kw ← H(KΣ,w, T[w])
2: Client and Server run Σ.Update(add,w||T[w], EKw
(ind, op))
the clear and, hence, cannot return the matching documents. This
is fine for a result-hiding scheme. However, a common use case
of SSE schemes is to return actual documents, which are stored
separately in an encrypted form. B(Σ) can support this case with
an additional roundtrip as follows. After the client computes the
result of a search query, she sends document indices in the clear
to the server. The server is then able to send the documents to the
client. Hence, B(Σ) is two-roundtrip protocol, assuming Σ requires
a single roundtrip for its queries.
The second drawback of B(Σ) is that deleted elements are never
deleted on the server side. Moreover, since deleted elements are
returned to the client on each search query, this also affects the
communication cost and the amount of work necessary on the
client side. We notice that this overhead can be avoided in the
common scenario outlined above where the client sends cleartext
document indices back to the server. In particular, it suffices for
the client to send, together with the list of cleartext indices, an
encryption of the same indices with a new key. Recall, that this list
contains only the relevant indices with deleted elements removed
by the client. Hence, the server can delete the old encrypted entries
in the database and insert the updated ones. Essentially we are
piggybacking a cleanup procedure on top of the Search protocol.
We denote a generic solution based on the above idea as B
′
(Σ)
and describe it in Algorithm 2. In B
′
(Σ), the client keeps track of
the number of times each keyword w has been queried in table
T. Each time a search query is issued, results are re-encrypted
using a fresh key derived from w and T[w]. Keywords w in Σ are
replaced by w||T[w], where || denotes concatenation. In line 7 of
the algorithm, re-encrypted indices are sent as Update queries
for the sake of having a generic solution. However, typical SSE
schemes would allow all updates to be performed at once in a single
roundtrip. We also expect that concrete choices of Σ may allow
Session G1: Searchable Encryption CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1470
further optimisations. For example, directly using a result-hiding
scheme for Σ would avoid having to encrypt the (ind, op) pairs
before inserting them in Σ.
The scheme B
′
(Σ) is intuitively backward-private since the server
learns document indices only after the client has removed deleted
indices. Moreover, since document indices are re-encrypted after
each search, it achieves the notion of update pattern revealing
backward privacy in the sense of Definition 4.2. We note that B
′
(Σ)
may achieve a stronger definition if one makes further assumptions
on how updates are carried out in Σ. In particular, we name the
B
′
(TWORAM) instantiation Moneta. Moneta achieves backward
privacy with insertion pattern, but at a very high computational
and communicational cost due to the use of TWORAM.
4.4 Fides: A Baseline Forward and Backward
Private SSE Scheme
In this section, we briefly describe Fides, the instantiation of B
′
using Σoϕoς [Bos16] (recall that Σoϕoς is forward-private, but not
backward-private). Fides guarantees forward privacy and update
pattern revealing backward privacy. The former is due to the underlying SSE scheme, Σoϕoς, being forward-private, while the latter is
the result of the B
′
construction. The formal statement on Fides’
security is given by Theorem 4.3.
Theorem 4.3. Define LFides as:
L
Updt
Fides(op,w, ind) = ⊥
L
Srch
Fides(w) = (DB(w),Updates(w)).
Fides is LFides-adaptively-secure.
Let us analyze Fides’ performance. Recall that Σoϕoς is optimal
for search and updates in terms of computation and communication.
In contrast, Fides takes two rounds during search and has O(aw )
computation and communication complexity, where aw is the total
number of update entries matching w. The cost of O(aw ) is the
worst case scenario since this cost can be amortized over all search
queries for w. Similar to Σoϕoς, the updates in Fides are optimal
(constant communication and computation).
Fides can be seen as a baseline for forward- and backward-private
designs: it is simple to build, offers moderate computation overhead,
and achieves a good level of security. In the next sections, we will
propose schemes that avoid inefficiencies such as the additional
roundtrip and the high communication overhead at the cost of
being only weakly backward-private.
5 Diana: FORWARD-SECURE SSE WITH VERY
LOW OVERHEAD
In this section, we describe a generic way to construct forwardprivate searchable encryption from constrained PRFs on N with
respect to the range family of circuits C = {Cc |Cc (x) = 1 ⇔
0 ≤ x ≤ c}. We will see that Σoϕoς [Bos16] can be seen as an
instantiation of this scheme, and then provide a much more efficient
one based on the GGM PRF [GGM84], which we call Diana.
Algorithm 3 FS-RCPRF: Forward private SSE scheme from rangeconstrained PRF Fe. H1 and H2 are hash functions.
Setup()
1: KΣ
$← {0, 1}
λ
, W, EDB ← empty map
2: return (EDB,KΣ, W)
Search(KΣ,w, σ; EDB)
Client:
1: Kw ||K
′
w ← FKΣ
(w), c ← W[w] ▷ c = nw − 1
2: if c = ⊥ then return ∅
3: ST ← Fe.Constrain(Kw ,Cc ) ▷ Cc is the circuit evaluating to 1
on {0, . . . ,c}
4: Send (K
′
w , ST,c) to the server.
Server:
5: for i = c to 0 do
6: Ti ← Fe(ST,i)
7: UTi ← H1(K
′
w ,Ti)
8: e ← EDB[UTi]
9: ind ← e ⊕ H2(K
′
w ,Ti)
10: Output each ind
11: end for
Update(KΣ, add,w, ind, σ; EDB)
Client:
1: Kw ||K
′
w ← F (KΣ,w), c ← W[w]
2: if c = ⊥ then c ← −1
3: T
c+1
w ← Fe(Kw ,c + 1), W[w] ← c + 1
4: UTc+1 ← H1(K
′
w ,T
c+1
w ), e ← ind ⊕ H2(K
′
w ,T
c+1
w )
5: Send (UTc+1, e) to the server.
Server:
6: EDB[UTc+1] ← e
5.1 FS-RCPRF: Forward-Secure SSE from
Range Constrained PRFs
Let Fe : {0, 1}
λ × {0, . . . ,nmax} → {0, 1}
λ be a constrained PRF
with respect to the class of range circuits C defined above. Also,
let F be a 2λ-bit PRF. Algorithm 3 describes FS-RCPRF, a forwardsecure scheme based on the range-constrained PRF Fe. The simple
idea behind FS-RCPRF is that update tokens for entries matching
keyword w are generated using Fe in counter mode, where the
counter is incremented every time a new entry matching w is
inserted. Then, during search, the client gives to the server the
constrained key allowing only the evaluation of Feon {0, . . . ,nw }.
The resulting scheme can be seen as a generalization of the dynamic
scheme of Cash et al. [CJJ+14], where during the search the client
gives to the server the constrained key of w instead of the master
key Kw .
The intuition for the security of FS-RCPRF is simple: as the adversary only gets to see the CPRF keys during searches for ranges
corresponding to already inserted entries, she cannot predict the
evaluation of the PRF for inputs outside of these ranges, and in
particular for newly inserted entries. Hence updates leak no information. Theorem 5.1 states the formal security of FS-RCPRF. Its
proof is deferred to Appendix A.
Session G1: Searchable Encryption CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1471
Theorem 5.1 (Adaptive security of FS-RCPRF). Define LF S =
(LSrch
F S , L
Updt
F S ) as:
L
Srch
F S (w) = (sp(w),UpHist(w))
L
Updt
F S (add,w, ind) = ⊥.
FS-RCPRF is LF S -adaptively-secure.
The adaptive security of FS-RCPRF is shown in the random oracle
model (ROM), but the ROM is not needed for non-adaptive security.
Reinterpreting Σoϕoς with constrained PRFs. The Σoϕoς construction is based on the iteration of a trapdoor permutation (TDP) π
to generate the update tokens in a way that prevents the server
from predicting them. Σoϕoς can be reinterpreted using our framework by constructing a TDP-based range-constrained PRF FeΣ (in
the following paragraph, we re-use the notation of [Bos16], which
overrules our own).
The master key FeΣ is composed of an RSA key SK and an element ST0 ∈ ZN where each can be pseudo-randomly generated
from a random λ-bit key. Fe((SK, ST0),c) = π
−c
SK(ST0) where π
−c
is the c-fold iteration of π
−1
. The constrain algorithm will then
be the following (we identify the circuit constraining to the range
{0, . . . ,n} with the integer n):
Fe.Constrain((SK, ST0),n) = (PK,π
−n
SK (ST0),n) = (PK, STn,n).
Finally, the constrained evaluation function is
Fe.Eval((PK, STn,n),c) = π
n−c
PK (STc ).
We can easily reduce the constrained-PRF security of Feto the hardness of the RSA assumption, and directly deduce the security of
Σoϕoς from Theorem 5.1.
5.2 Diana, a GGM instantiation of FS-RCPRF
In this section we present a range-constrained PRF and then use it
to instantiate FS-RCPRF.
We can easily construct a simple and efficient range-constrained
PRF from the tree-based GGM PRF [GGM84]. This instantiation
has been described by Kiayias et al. [KPTZ13] and is called best
range cover (BRC).
Let G : {0, 1}
λ → {0, 1}
2λ be a pseudo-random generator (PRG),
G0(k) and G1(k) be the first and second half of G(k). The GGM PRF
on n-bit integers is defined as FK (x) = Gxn−1(. . . (Gx1
(Gx0
(K))))
where xn−1 . . . x0 is the binary representation of x. The leaves of the
tree are the output values of F , and they can be labeled according
to the corresponding input, and the partial evaluation of F (i.e. the
iterated evaluation of G, but only on the first ℓ < n bits) are the
inner nodes of the tree.
To constrain F to the input range [0,c−1], we generate the nodes
of the tree covering exactly the leaves with labels in [0,c − 1]. In
practice if the binary representation ofc iscn−1 . . .c0, the punctured
key would be 
G0(Gci−1
(. . . (Gc0
(K)))	
for i such that ci = 1.
We use the above range CPRF to instantiate FS-RCPRF and call
this instantiation Diana. Note that, Diana is almost identical to
the ARX-EQ scheme [PBP16]. However ARX-EQ was not formally
proven, and FS-RCPRF provides a more general framework on how
to construct forward-private SSE schemes.
Let us analyze the efficiency of Diana. Updates need O(lognmax)
computation, where nmax is the maximum number of entries matching a keyword: CPRF computes a tree’s leaf from its root. Similarly,
during search, the server has to compute all the leaves of the tree
within a given range. This can be done efficiently in O(nw ) calls to
the PRG, where nw is the number of matches on search keyword w:
there are O(nw ) tree nodes to compute in total and each node can
be generated using a single PRG call. In terms of communication
complexity, Diana is optimal for updates, and sends O(lognw ) tree
nodes during a search query.
In theory, this is worse than Σoϕoς’ optimal computational and
communication complexity, but, as we will see in Section 7.1, Diana
uses symmetric primitives that are much faster than Σoϕoς’ RSA.
Also, since nodes in the tree will be 128-bit keys, we can set nmax to
2
32 and still have search tokens only twice as big as Σoϕoς’ 2048-bit
tokens.
5.3 Dianadel: Backward-Secure SSE from
Range-Constrained and Puncturable PRFs
The FS-RCPRF construction, and its instantiation Diana, do not
support deletions. Schemes of this type can be extended to support deletions by letting the client and the server maintain two
instances of the construction, one for insertions and one for deletions. Then, during a search query, the server can compute the
difference between the two result sets to compute the list of documents matching the query (i.e., without the deleted entries). This
solution, however, is not backward-private as the server trivially
learns the deleted entries. To this end, we propose FS-RCPRFdel,
which also uses two SE instances but exploits constrained PRFs to
guarantee weak backward privacy.
The key idea behind FS-RCPRFdel is to extend the set of constraints supported by the underlying constrained PRF used in Section 5.1. In order to support backward privacy, we make use of
constrained PRF F˜ that is not only range-constrained (for forward
privacy) but is also punctured on the deleted entries (for backward
privacy). Hence, the constrained key of F˜ enforces the predicate
Cc,x1,...,xn
(x) = 1 iff x ∈ [0,c] and ∀i, x , xi
. The values x1, . . . , xn
correspond to deleted entries that the server should not learn. Unfortunately, a naive implementation of F˜ requires the client to store all
deleted entries x1, . . . , xn since the order of deletions and insertions
can be arbitrary. Our construction avoids this storage overhead on
the client’s side by letting the server store the deleted entries in an
encrypted form.
We now combine the above ideas and describe FS-RCPRFdel. The
client and the server maintain two forward-private SE instances:
one for insertions and one for deletions. Every time the client wants
to insert (w, ind) with the counterc, it proceeds as in FS-RCPRF and
inserts the pair in the first SE instance, as in Algorithm 3. In addition,
it also pushes the pair (F
′
(Kw , (w, ind)), EncK′(c)), where F
′
and
Enc are a PRF and a CPA encryption scheme, to the server who
stores these pairs in a map. In order to delete (w, ind), the client
inserts the entry (w, F
′
(Kw , (w, ind))) in the second SE instance.
Then, during search query for w, the client proceeds as follows. It
requests a search for w on the second SE instance (i.e., the one that
stores deleted entries). As a result, the server gets the associated
tags F
′
(Kw , (w, ind)) for the deleted entries, uses them to retrieve
Session G1: Searchable Encryption CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1472
encrypted xi
’s from the map, and sends them back to the client.
The client then constrains the PRF using xi
’s and uses it to run
a search on the first SE instance. Note that this solution assumes
that the same index ind is never reused: once the entry (w, ind) has
been deleted, it can no longer be re-added.
The above solution is not ideal as it requires an additional roundtrip with large communication from the server to the client. Also,
it can only guarantee weak backward privacy, as the server learns
when the deletions occurred.
Similar to FS-RCPRF, we instantiate FS-RCPRFdel with the GGM
PRF and call the resulting scheme Dianadel. The constrained key,
instead of consisting of the covering nodes of the full range as in
Section 5.2, will be constructed as the set of nodes covering the
ranges [0, x1 − 1], [x1 + 1, x2 − 1], . . . ,[xn + 1,c] (assuming that
xi
’s are in increasing order). This approach will result in large keys
when the number of deletions is large: the number of tree nodes to
be sent will be in the order of dw ·log(nw /dw ). (assuming uniformly
distributed deletions).
6 Janus: WEAK BACKWARD SECURITY FROM
PUNCTURABLE ENCRYPTION
The solutions presented in Section 5.3 suffer from high inefficiencies,
by requiring either client storage linear in the number of deletions,
or multiple roundtrips with high communication complexity. In
this section, we show how to achieve (weak) backward security in
a single roundtrip, using puncturable encryption with incremental
punctures.
6.1 Puncturable Encryption
A puncturable encryption (PE) scheme is a public-key encryption
scheme that allows to puncture the secret key to prevent the decryption of some messages. More precisely, for such schemes, the
plaintexts are encrypted and attached to a tag, and the secret key is
punctured on a set of tags so that decryption of ciphertexts attached
to those tags is impossible. Puncturable encryption has been introduced by Green and Miers as a way to achieve forward security
in an asynchronous setting [GM15]. We adopt the same formalism
and definitions, except we fix the number of tags per message to 1.
A puncturable encryption scheme PPKE with message space
M and tag space T is a triple of algorithms (KeyGen, Encrypt,
Puncture, Decrypt) with the following syntax:
• KeyGen(1
λ
) outputs a public key PK and an initial secret
key SK0.
• Encrypt(PK, M,t) outputs the encryption CT of M ∈ M
attached to the tag t ∈ T.
• Puncture(SKi
,t) outputs a new secret key SKi+1 able to decrypt any ciphertext SKi can decrypt, except for ciphertexts
encrypted with the tag t.
• Decrypt(SKi
,CT,t) outputs a plaintext M or ⊥ if the decryption fails.
Correctness is achieved if a plaintext M encrypted with tag t
decrypts back to M when using the secret key punctured on any
set of tags that does not contain t.
The IND-PUN-ATK security games – with ATK ∈ {CPA,CCA}
– capture the security of puncturable encryption. We recall the
IND-PUN-CPA game (we will not use CCA security in this work)
in a simplified version.
Definition 6.1 (Security of puncturable encryption). Let PPKE be a
puncturable encryption scheme. The game IND-PUN-CPAPPKE,A
with adversary A is defined using three phases as follows:
Setup Phase The challenger initializes two empty sets P,C,T , a
counter n to 0, and runs (PK, SK0) ← PPKE.KeyGen(1
λ
).
Finally, he randomly picks b
$← {0, 1}.
Query Phase The adversary can adaptively issue the following
queries:
Puncture(t) The challenger increments n, computes SKn ←
PPKE.Puncture(SKn−1,t) and adds t to P.
Corrupt() The first time the adversary issues this query, if
T ⊆ P, the challenger returns the most recent secret key
SKn, and sets C ← P. All subsequent queries return ⊥.
Challenдe(M0, M1,t) If the adversary previously issued a
Corrupt query and t < C, the challenger rejects the challenge. Otherwise, the challenger returns
CT ← PPKE.Encrypt(PK, Mb
,t) to the adversary and
adds t to T .
Guess Phase The adversary outputs a guess b
′ of b.
The game ensures that the adversary can get challenge ciphertexts
only for tags on which the secret key has been punctured.
We say that PPKE is IND-PUN-CPA secure if for all polynomialtime adversaries A:
Advpun−cpa
PPKE,A
(λ) =|P[IND-PUN-CPAPPKE,A(λ) = 1]
− P[IND-PUN-CPAPPKE,A(λ) = 0]|
≤ negl(λ).
In the Janus construction, described in Section 6.3, we will encrypt the document indices using puncturable encryption, with tags
that are pseudo-randomly generated from the document-keyword
pairs. There will be a different key for each keyword, and when we
want to delete an entry for a specific keyword, we will puncture the
associated key on the tag derived from the document-keyword pair.
Upon a search query, the client will give to the server the associated
punctured secret key, with which he will only be able to decrypt
non-deleted entries.
In this paper, we will use the Green-Miers puncturable encryption scheme [GM15], described in Appendix C.
6.2 Incremental Puncture
The punctured keys will (often) grow with the number of punctures
(or be very large), and it will be impractical to store them on the
client side. To avoid this issue, we use an additional feature of the
Green-Miers scheme, which we call incremental puncture.
In our setting, we will see that it is very handy to be able to express the Puncture algorithm as a function of a constant-sized fraction of the secret key. The secret key of the Green-Miers puncturable
encryption scheme is, after n punctures, SKn = (sk0,sk1, . . . ,skn),
and the puncture algorithm is such that
Puncture(SKn,t) = (sk′
0
,sk1, . . . ,skn,skn+1)
where (sk′
0
,skn+1) = IncPuncture(sk0,t).
Session G1: Searchable Encryption CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1473
By using this PE scheme, the client will only have to store the
sk0 part of the secret key, and outsource the rest to the server. The
client’s storage will stay linear in the number of keywords, and
most of the storage burden will still be born by the server.
6.3 The Janus Construction
Janus, similar to the constructions in Section 5.3, uses two forwardsecure searchable encryption instances: Σadd to store the newly
inserted indices encrypted with the puncturable encryption scheme
(the insertion instance), and Σdel to store the punctured key elements (the deletion instance). There is a different encryption key
for each keyword and the client stores the sk0 part of each key
locally. During the search for w, the client sends the associated
key part and runs the search protocol of the SE scheme for both
instances. As a result, the server obtains the encrypted indices from
the insertion instance and all the remaining key parts from the deletion instance. She will then be able to decrypt all the non-deleted
(i.e. not punctured) indices.
Still, there is an important problem to tackle: once the secret
key for w has been revealed to the server, it can no longer be used
by the client to encrypt the index of the documents matching w
that will be inserted in the future. As a consequence, we need to
change the encryption key after every search. Yet, we do not need
to re-encrypt the already revealed indices (a.k.a. the result indices)
with the new key: the adversary already learned them, and, as the
Σadd and Σdel schemes used in practice will leak the search pattern,
she can keep track of the results over repeating search queries.
So, in the first version of our construction, the server will explicitly keep the results in a cache. This cache is also interesting
from a performance point of view: each matching index will be
decrypted at most once, and all the results from previous searches
on a given keyword can be stored close to each other, increasing
storage locality.
Description of Janus. Janus is described in Algorithm 4. It uses
two response-revealing (insertion-only) dynamic SSE schemes Σadd
and Σdel. Σadd and Σdel might be different for efficiency or security
purposes, but in the proof, we will assume that they are forwardsecure. Janus also uses a PRF F and an incremental puncturable
encryption scheme PPKE.
The client stores locally a table containing for each keyword w
the initial key share sk0[w] of a PE (WLOG we can assume that this
key share contains the public key). To insert a new entry (w, ind),
the client encrypts it with the PE scheme with the key sk0[w], using a pseudo-random value F (w, ind) as a tag. He then inserts this
ciphertext as a new entry matching w in Σadd. To delete the entry
(w, ind), the client computes the tag t = F (w, ind) and (incrementally) punctures sk0[w] on this tag. He then updates the initial key
share of w and pushes the new key element skt to the server by
inserting the entry (w,skt ) in Σdel. Finally, to search, the client
runs a search on w for both Σadd and Σdel. The server now has
access to the ciphertexts encrypting the inserted indices and to the
key elements necessary to decrypt them. Note that she will only
be able to decrypt the ciphertexts for which the key has not been
punctured, i.e. the non deleted entries.
After a search query on w, the same encryption key cannot be
used to encrypt new entries matching w: the server can reuse the
Algorithm 4 Janus: weakly backward-secure SSE.
Setup()
1: (EDBadd,Kadd, σadd) ← Σadd.Setup()
2: (EDBdel,Kdel, σdel) ← Σdel.Setup()
3: Kt aд,KS ← {0, 1}
λ
, PSK, SC, EDBcache ← empty map
4: return ((EDBadd, EDBdel, EDBcache ),
(Kadd,Kdel,Kt aд,KS ), (σadd, σdel, PSK, SC))
Search(KΣ,w, σ; EDB)
Client:
1: i ← SC[w].
2: if i = ⊥ return ∅
3: Send sk0 = PSK[w] to the server.
4: PSK[w] ← PPKE.KeyGen(1
λ
), SC[w] ← i + 1.
5: Send tkn ← F (KS ,w) to the server.
Client (C) & Server (S):
6: C and S run Σadd.Search(Kadd,w||i, σadd; EDBadd). The server
gets a list ((ct1,t
add
1
), . . . ,(ctn,t
add
n
) of ciphertexts and tags.
7: C and S run Σdel.Search(Kdel,w||i, σdel; EDBdel). The server
gets a list ((sk1,t
del
1
), . . . ,(skm,t
del
m )) of key elements.
8: S decrypts the ciphertexts with SK = (sk0,sk1, . . . ,skm), and
obtains the list N ewInd = ((ind1,t1), . . . ,(indℓ
,tℓ
)).
Server:
9: OldInd ← EDBcache [tkn]
10: Remove from OldInd the indices whose tags are in {t
del
j
}.
11: Res ← OldInd ∪ N ewInd, EDBcache [tkn] ← Res
12: return Res
Update(KΣ, add,w, ind, σ; EDB)
1: t ← FKt aд
(w, ind)
2: sk0 ← PSK[w], i ← SC[w]
3: if sk0 = ⊥ then
4: sk0 ← PPKE.KeyGen(1
λ
), PSK[w] ← sk0
5: i ← 0, SC[w] ← i
6: end if
7: if op = add then
8: ct ← PPKE.Encrypt(sk0, ind,t)
9: Run Σadd.Update(Kadd, add,w||i, (ct,t), σadd; EDBadd)
10: else ▷ op = del
11: (sk′
0
,skt ) ← PPKE.IncPuncture(sk0,t)
12: Run Σdel.Update(Kdel, add,w||i, (skt
,t), σdel; EDBdel)
13: PSK[w] ← sk′
0
14: end if
old key to decrypt even the newly deleted entries since the key
would not have been punctured on the corresponding tags. Janus
avoids this by requiring the client to generate a new key for w after
a search and encrypt new entries of w using this key. As discussed
earlier, the server can keep the results of previous search queries
and retrieve them the next time w is searched. This does not affect
the security of the scheme since the server has already learnt earlier
search results on w.
Security of Janus. Janus is a forward-private and weakly backward-private SSE scheme. The former comes directly from the
forward security of Σadd and Σdel. Let us consider backward security. The server has access to the decryption key of w’s entries
only during the search query for w. Moreover, this key allows her
Session G1: Searchable Encryption CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1474
to decrypt only the entries that have been added since the last
search for w and have not yet been deleted. Hence, the deleted
indices remain hidden. Note that weak backward security is the
strongest definition we can achieve with Janus as the server can
determine which of the inserted queries were later deleted as well
as the timestamps of these events. Also note that Janus does not
allow re-insertion of document/keyword pairs that were previously
deleted.
The formal security claim is given in Theorem 6.2, and its proof
is postponed to Appendix B.
Theorem 6.2 (Adaptive Security of Janus). If Σadd and Σdel
are two LF S -adaptively-secure SSE schemes, PPKE is IND-PUN-CPA
secure, and F is a PRF, then Janus is LwBS -adaptively secure, with
LwBS = (LSrch
wBS , L
Updt
wBS ) defined as
L
Srch
wBS (w) = (sp(w), TimeDB(w), DelHist(w))
L
Updt
wBS (op,w, ind) = op.
Note that in this theorem, LF S specifically refers to the leakage
of a forward-secure scheme as defined in Theorem 5.1.
Efficiency. The computational and communication complexity of
Janus can easily be derived from Σadd and Σdel. In particular, it has
the same complexity for insertion (resp. deletion) updates as Σadd
(resp. Σdel). To analyze search queries, let Tadd(n) and Tdel(n) be
the computational complexities of the search protocols of Σadd and
Σdel, respectively, where n is the size of a result set. Then, Janus’
search complexity for a keywordw with aw insertions, dw deletions,
and nw = aw − dw non-deleted matching results, is Tadd(aw ) +
Tdel(dw ) + O(nw · dw ). The last term comes from the fact that a
decryption of the PE scheme has complexity linear in the number
of punctures. When instantiated with Diana or Σoϕoς, Janus thus
has search complexity O(aw + dw + nw · dw ) = O(nw · dw ).
In terms of communication for search queries, Janus also inherits
from the complexity of Σadd, and Σdel. Let Cadd(n) and Cdel(n)
be the communication complexities of search protocols of Σadd
and Σdel, respectively, for a keyword that was inserted n times.
Then, the communication complexityCJanus(aw ,dw ) for a keyword
that was inserted aw times and deleted dw times is Cadd(aw ) +
Cdel(dw ). Also, the number of roundtrips is the maximum number
of roundtrips between Σadd and Σdel. Hence, when instantiated
either with Σoϕoς or Diana, Janus has single-roundtrip search and
updates protocols. In the case of Σoϕoς, the search communication
complexity is optimal (constant), and for Diana, it is O(log(aw ) +
log(dw )).
6.4 Reducing Storage Overhead
In practice, the storage overhead of Janus is quite high: the client
needs to store 3 group elements (at least 256 bits each) for every
keyword, while each ciphertext on the server side consists of the
masked index, two group elements and the tag, and 3 group elements and a tag for each key share. To reduce the overhead at the
client, we use a trick similar to the one used in Σoϕoς : we pseudorandomly generate the encryption scheme’s parameters and key
elements ski from a master key and the number of punctures done
on the secret key. The client does not need to store the public key
as he can directly encrypt the plaintext indices from the scheme’s
parameters (and this will actually be faster). As a result, the client
has to store only the number of deleted entries for each w, which
he does already if Σdel is instantiated with Diana. This modification
is described in detail in Algorithm 11 (Appendix C).
A similar trick can be used to reduce the storage on the server
side. Indeed, one of the three group elements stored for each entry
is a random blinding element, which can be generated pseudorandomly using a PRF applied on the keyword/document pair
(w, ind) to be encrypted. As the blinding element is part of the
ciphertext, and as it is now a (deterministic) function of the pair
(w,ind), the tag is now redundant an can be omitted. This modification is also described in Algorithm 11.
6.5 Security of Janus Against Weaker
Adversaries
We showed that Janus protects against persistent adversaries (e.g.,
a malicious server) and guarantees both forward and backward
privacy. In this section, we analyze its resistance against weaker
adversaries. First, we consider a snapshot adversary who is able
to see the encrypted database at one (or more) instant – e.g. in
case of a disk theft or subpoena. Then, we consider the security of
Janus against a late-persistent adversary that obtains control over
the server sometime after the client has outsourced his data and,
possibly executed some queries — e.g. in case of malware.
Janus, as is, does not protect against a snapshot adversary since
the cached results are kept in plaintext on the server side. Beside trivially revealing the cached content, this can also lead to the recovery
of some of the queries. This, in turn, can be used for leakage-abuse
attacks in the manner of file injections attacks [ZKP16] adapted to
using a single (or multiple) snapshot of EDB (and in particular of
EDBcache ).
To fix this problem, we propose to encrypt EDBcache using
a key that is not permanently stored at the server and maintain
EDBcache in a history-independent (HI) data structure as follows.
In particular, the content of EDBcache relevant to w is encrypted
using a keyword-specific symmetric key Kw . To this end, we modify
line 5 of Algorithm 4 to tkn||Kw ← F (KS ,w) where the client also
sends Kw to the server. Then the server uses Kw to decrypt and reencrypt EDBcache as needed, using an IND-CPA-secure secret-key
encryption scheme EKw
. Once the Search query is processed, the
server discards Kw ; in particular it must not be stored in EDB.
Unfortunately, encryption alone is not sufficient as the implementation of EDBcache could leak additional information, such as
the time of insertion/modification of data, or the size of previous,
now discarded, values. To this end, we rely on history-independent
(HI) data structures [NT01] whose goal is to hide exactly this kind of
side-channel information. Note that if Σadd and Σdel are instantiated
with existing forward-secure schemes (SPS [SPS14], Σoϕoς [Bos16],
or Diana), history-independence is not an issue as the snapshot adversary learns at most the update leakage, reduced to the list (opi
)
with opi = add if the i-th update was an insertion, and opi = del
otherwise. Though HI data structures come with an additional
overhead, the state-of-the-art constructions are practical [BS13].
The security of the above approach relies on cooperation from
the server who is required to use encryption and HI structures
Session G1: Searchable Encryption CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1475
Table 2 – Size of the databases used in the evaluation, and
the amount of storage needed for W and EDB
K N W EDB
222 · 103
1.9 · 107
4.6 MB 615 MB
2.68 · 106
1.9 · 108
46 MB 6.3 GB
21.8 · 106
1.9 · 109
365 MB 47 GB
42.9 · 106
3.8 · 109
720 MB 95 GB
for EDBcache and erase Kw from memory once he finishes en/decrypting EDBcache . Note that snapshot attacks are essentially attacks against the server, more so than against the client: we are
protecting from the attacker information learned by the server.
Despite the assumptions we have just outlined, it is clear that
storing the cache in encrypted form is a vast improvement over
storing this information in cleartext. It is also a cheap solution:
symmetric encryption is extremely fast on modern processors, especially in the presence of specialized instructions such as AES-NI.
Encrypting EDBcache would not significantly impact performance,
relative to the decryption of punctured encryption schemes, or
running the two SSE schemes Σadd and Σdel.
Let us now consider Janus against late-persistent adversaries.
In this case, we strive to obtain the following backward privacy:
even if a deleted entry matched a search query processed before the
corruption, it should be infeasible for the adversary to recover the
associated document index. Symmetrically encrypting EDBcache ,
as in the case of the snapshot adversary, is no longer sufficient as the
encryption key Kw will eventually be revealed. Instead, we require
that the server encrypt results with the PE scheme, using the public
key for the newly generated secret key (line 4 in Algorithm 4).
7 PERFORMANCE EVALUATION
We implemented and evaluated some of the schemes presented
in this paper. The PRF has been instantiated with HMAC, and we
chose Blake2b as the underlying hash function. For the GGM rangeconstrained PRF Fe, we used AES in counter mode for the pseudorandom generator G. The keyed hash function H used in Diana is
the AES block cipher used in Matyas-Meyer-Oseas mode [PGV94].
The code was written in C/C++, with many of the symmetric
cryptography function implemented in assembly, in particular using
AES-NI for the AES-based primitives. The code is OpenSource and
freely accessible [Bos17].
We ran our experiments on a desktop computer with a single Intel Core i7 4790K 4.00GHz CPU (with 8 logical cores), 16GB of RAM,
and a 250 GB Samsung 850 EVO SSD dedicated to the experiment.
The key-value store is implemented with RocksDB [Fac].
7.1 Performance of Diana
Our evaluation of Diana uses 4 different, synthetically generated,
data sets, each of different size. A quick summary of the statistics
of the data sets, the size of the resulting encrypted databases, and
the size of the client stored tables W is given in Table 2.
The performance results of keyword searches are presented in
Figure 1, together with the ones of Σoϕoς (taken from [Bos16]). The
0.0001
0.001
0.01
0.1
10 100 1000 10000 100000 1 × 106
Search time per matching entry (ms)
Number of matching documents
Diana – N = 1.9e7
Diana – N = 1.9e8
Diana – N = 1.9e9
Diana – N = 3.8e9
Σoϕoς – N = 1.4e7
Σoϕoς – N = 1.4e8
Figure 1 – Diana and Σoϕoς search performance. log-log scale.
timings include only the server’s work, and focus on the core performance of the scheme, i.e. we do not time the deserialization of the
queries and serialization of the results, nor the RPC infrastructure.
We observe an important performance discrepancy between the
two smallest and two largest databases: searching is up to 200 times
slower on the larger ones. This is explained by the time difference
when retrieving data from different hierarchies of memory. The SE
version of each of the two smaller datasets fits entirely in RAM and
the operating system is able to put a very large part of it in cache.
This makes the storage accesses very fast, even when SE was not
optimized for locality. However, in general secure SE schemes with
reasonable storage overhead have bad storage locality: the entries
to be accessed need to be randomly scattered in the encrypted
database (see [CT14] for a lower bound on locality). This issue can
be circumvented using specialized caching (cf. [MM17]), but this
breaks forward security strictly speaking – it is unclear what kind
of attacks could arise because of this – and it only reduces the
locality by a constant factor.
It is also interesting to notice that, for small databases (i.e., the
ones held in RAM), Diana is ten times faster than Σoϕoς on datasets
of similar size. This is clearly due to the use of RSA in Σoϕoς,
while Diana uses (hardware accelerated) AES as its cryptographic
building block. On the other hand, for larger datasets, Σoϕoς would
encounter similar IO bottleneck, and would perform (almost) as
well as Diana on large inputs. Hence, for large datasets IO costs
outweigh the cost of cryptographic primitives, making the latter
“almost free”.
7.2 Performance of Janus
As Janus is a composition of any forward secure scheme and the
adapted Green-Miers puncturable encryption scheme, here we focus
Session G1: Searchable Encryption CCS’17, October 30-November 3, 2017, Dallas, TX, USA 1476
Table 3 – Performance of the puncturable encryption
scheme used in Janus. Means are taken over 400 iterations.
Encrypt IncPuncture SK0Gen Decrypt (d punctures)
1.699 ms 1.386 ms 1.396 ms (d + 1) × 2.345 ms
on the performance of this scheme once tweaked to reduce the
storage overhead.
For the bilinear maps, we used a Type-3 pairing (cf. [GPS06]) on
Barreto-Naehrig curves [BN06]. We modified Miers’ implementation of the Green-Miers PE scheme of libforwardsec [Mie], which
is itself based on the RELIC pairing library [AG], to fit our usage.
We end up having 74-byte ciphertexts (for 8-byte indices), and
200-byte key shares. The computational performance of the scheme
is given in Table 3. SK0Gen is the procedure used to generate the
first key share sk0 of the punctured secret key from the number
of punctures. Note that these are single-core timings. While encryption, puncture and first key share generation are fast enough
to yield a reasonably practical scheme, decryption does not scale
well as the number of punctures grows. In particular, Janus would
not support more than a few hundreds deletions per keyword in
practice, for both computational and storage overhead reasons.
Designing puncturable encryption with smaller keys or better
computational efficiency is an open problem, and Janus would
immediately benefit from any improvement in this area.