Emerging smart contract systems over decentralized cryptocurrencies allow mutually distrustful parties to transact safely without trusted third parties. In the event of contractual breaches or aborts, the decentralized blockchain ensures that honest parties obtain commensurate compensation. Existing systems, however, lack transactional privacy. All transactions, including flow of money between pseudonyms and amount transacted, are exposed on the blockchain. We present Hawk, a decentralized smart contract system that does not store financial transactions in the clear on the blockchain, thus retaining transactional privacy from the public's view. A Hawk programmer can write a private smart contract in an intuitive manner without having to implement cryptography, and our compiler automatically generates an efficient cryptographic protocol where contractual parties interact with the blockchain, using cryptographic primitives such as zero-knowledge proofs. To formally define and reason about the security of our protocols, we are the first to formalize the blockchain model of cryptography. The formal modeling is of independent interest. We advocate the community to adopt such a formal model when designing applications atop decentralized blockchains.

SECTION I.Introduction
Decentralized cryptocurrencies such as Bitcoin [48] and alt-coins [20] have rapidly gained popularity, and are often quoted as a glimpse into our future [5]. These emerging cryptocur-rency systems build atop a novel blockchain technology where miners run distributed consensus whose security is ensured if no adversary wields a large fraction of the computational (or other forms of) resource. The terms “blockchain” and “miners” are therefore often used interchangeably.

Blockchains like Bitcoin reach consensus not only on a stream of data but also on computations involving this data. In Bitcoin, specifically, the data include money transfer transaction proposed by users, and the computation involves transaction validation and updating a data structure called the unspent transaction output set which, imprecisely speaking, keeps track of users' account balances. Newly emerging cryptocurrency systems such as Ethereum [57] embrace the idea of running arbitrary user-defined programs on the blockchain, thus creating an expressive decentralized smart contract system.

In this paper, we consider smart contract protocols where parties interact with such a blockchain. Assuming that the decentralized concensus protocol is secure, the blockchain can be thought of as a conceptual party (in reality decentralized) that can be trusted for correctness and availability but not for privacy. Such a blockchain provides a powerful abstraction for the design of distributed protocols.

The blockchain's expressive power is further enhanced by the fact that blockchains naturally embody a discrete notion of time, i.e., a clock that increments whenever a new block is mined. The existence of such a trusted clock is crucial for attaining financial fairness in protocols. In particular, malicious contractual parties may prematurely abort from a protocol to avoid financial payment. However, with a trusted clock, timeouts can be employed to make such aborts evident, such that the blockchain can financially penalize aborting parties by redistributing their collateral deposits to honest, non-aborting parties. This makes the blockchain model of cryptography more powerful than the traditional model without a blockchain where fairness is long known to be impossible in general when the majority of parties can be corrupt [8], [17], [24]. In summary, blockchains allow parties mutually unbeknownst to transact securely without a centrally trusted intermediary, and avoiding high legal and transactional cost.

Despite the expressiveness and power of the blockchain and smart contracts, the present form of these technologies lacks transactional privacy. The entire sequence of actions taken in a smart contract are propagated across the network and/or recorded on the blockchain, and therefore are publicly visible. Even though parties can create new pseudonymous public keys to increase their anonymity, the values of all transactions and balances for each (pseudonymous) public key are publicly visible. Further, recent works have also demonstrated deanonymization attacks by analyzing the transactional graph structures of cryptocurrencies [42], [52].

We stress that lack of privacy is a major hindrance towards the broad adoption of decentralized smart contracts, since financial transactions (e.g., insurance contracts or stock trading) are considered by many individuals and organizations as being highly secret. Although there has been progress in designing privacy-preserving cryptocurrencies such as Zerocash [11] and several others [26], [43], [54], these systems forgo programmability, and it is unclear a priori how to enable programmability without exposing transactions and data in cleartext to miners.

A. Hawk Overview
We propose Hawk, a framework for building privacy-preserving smart contracts. With Hawk, a non-specialist programmer can easily write a Hawk program without having to implement any cryptography. Our Hawk compiler is in charge of compiling the program to a cryptographic protocol between the blockchain and the users. As shown in Figure 1, a Hawk program contains two parts:

A private portion denoted ϕpriv which takes in parties' input data (e.g., choices in a “rock, paper, scissors” game) as well as currency units (e.g., bids in an auction). ϕpriv performs computation to determine the payout distribution amongst the parties. For example, in an auction, winner's bid goes to the seller, and others' bids are refunded. The private Hawk program ϕpriv is meant to protect the participants' data and the exchange of money.

A public portion denoted ϕpub that does not touch private data or money.

Our compiler will compile the Hawk program into the following pieces which jointly define a cryptographic protocol between users, the manager, and the blockchain:

the blockchain's program which will be executed by all consensus nodes;

a program to be executed by the users; and

a program to be executed by a special facilitating party called the manager which will be explained shortly.

Security Guarantees
Hawk's security guarantees encompass two aspects:

On-chain privacy. On-chain privacy stipulates that transactional privacy be provided against the public (i.e., against any party not involved in the contract) - unless the contractual parties themselves voluntarily disclose information. Although in Hawk protocols, users exchange data with the blockchain, and rely on it to ensure fairness against aborts, the flow of money and amount transacted in the private Hawk program ϕpriv is cryptographically hidden from the public's view. Informally, this is achieved by sending “encrypted” information to the blockchain, and relying on zero-knowledge proofs to enforce the correctness of contract execution and money conservation.

Contractual security. While on-chain privacy protects contractual parties' privacy against the public (i.e., parties not involved in the financial contract), contractual security protects parties in the same contractual agreement from each other. Hawk assumes that contractual parties act selfishly to maximize their own financial interest. In particular, they can arbitrarily deviate from the prescribed protocol or even abort prematurely. Therefore, contractual security is a multi-faceted notion that encompasses not only cryptographic notions of confidentiality and authenticity, but also financial fairness in the presence of cheating and aborting behavior. The best way to understand contractual security is through a concrete example, and we refer the reader to Section I-B for a more detailed explanation.

Minimally Trusted Manager
The execution of Hawk contracts are facilitated by a special party called the manager. The manager can see the users' inputs and is trusted not to disclose users' private data. However, the manager is NOT to be equated with a trusted third party - even when the manager can deviate arbitrarily from the protocol or collude with the parties, the manager cannot affect the correct execution of the contract. In the event that a manager aborts the protocol, it can be financially penalized, and users obtain compensation accordingly.

Fig. 1. - Hawk overview.
Fig. 1.
Hawk overview.

Show All

The manager also need not be trusted to maintain the security or privacy of the underlying currency (e.g., it cannot double-spend, inflate the currency, or deanonymize users). Furthermore, if multiple contract instances run concurrently, each contract may specify a different manager and the effects of a corrupt manager are confined to that instance. Finally, the manager role may be instantiated with trusted computing hardware like Intel SGX, or replaced with a multiparty computation among the users themselves, as we describe in Section IV-C and Appendix A.

Terminology
In Ethereum [57], the blockchain's portion of the protocol is called an Ethereum contract. However, this paper refers to the entire protocol defined by the Hawk program as a contract; and the blockchain's program is a constituent of the bigger protocol. In the event that a manager aborts the protocol, it can be financially penalized, and users obtain compensation accordingly.

B. Example: Sealed Auction
Example Program
Figure 2 shows a Hawk program for implementing a sealed, second-price auction where the highest bidder wins, but pays the second highest price. Second-price auctions are known to incentivize truthful bidding under certain assumptions, [55] and it is important that bidders submit bids without knowing the bid of the other people. Our example auction program contains a private portion ϕpriv that determines the winning bidder and the price to be paid; and a public portion ϕpub that relies on public deposits to protect bidders from an aborting manager.

For the time being, we assume that the set of bidders are known a priori.

Contractual Security Requirements
Hawk will compile this auction program to a cryptographic protocol. As mentioned earlier, as long as the bidders and the manager do not voluntarily disclose information, transaction privacy is maintained against the public. Hawk also guarantees the following contractual security requirements for parties in the contract:


Fig. 2.
Hawk program for a second-price sealed auction. Code described in this paper is an approximation of our real implementation. In the public contract, the syntax “send $N to P ” corresponds to the following semantics in our cryptographic formalism: ledger[p]:=ledger[p]+$n - see Section II-B.

Show All

Input independent privacy. Each user does not see others' bids before committing to their own (even when they collude with a potentially malicious manager). This way, users bids are independent of others' bids.

Posterior privacy. As long as the manager does not disclose information, users' bids are kept private from each other (and from the public) even after the auction.

Financial fairness. Parties may attempt to prematurely abort from the protocol to avoid payment or affect the redistribution of wealth. If a party aborts or the auction manager aborts, the aborting party will be financially penalized while the remaining parties receive compensation. As is well-known in the cryptography literature, such fairness guarantees are not attainable in general by off-chain only protocols such as secure multi-party computation [7], [17]. As explained later, Hawk offers built-in mechanisms for enforcing refunds of private bids after certain timeouts. Hawk also allows the programmer to define additional rules, as part of the Hawk contract, that govern financial fairness.

Security against a dishonest manager. We ensure authenticity against a dishonest manager: besides aborting, a dishonest manager cannot affect the outcome of the auction and the redistribution of money, even when it colludes with a subset of the users. We stress that to ensure the above, input independent privacy against a faulty manager is a prerequisite. Moreover, if the manager aborts, it can be financially penalized, and the participants obtain corresponding remuneration.

An auction with the above security and privacy requirements cannot be trivially implemented atop existing cryptocurrency systems such as Ethereum [57] or Zerocash [11]. The former allows for programmability but does not guarantee transactional privacy, while the latter guarantees transactional privacy but at the price of even reduced programmability than Bitcoin.

Aborting and Timeouts
Aborting is dealt with using timeouts. A Hawk program such as Figure 2 declares timeout parameters using the HawkDeclareTimeouts special syntax. Three timeouts are declared where T1<T2<T3:

T1: The Hawk contract stops collecting bids after T1.

T2: All users should have opened their bids to the manager within T2; if a user submitted a bid but fails to open by T2, its input bid is treated as 0 (and any other potential input data treated as ⊥), such that the manager can continue.

T3: If the manager aborts, users can reclaim their private bids after time T3.

The public Hawk contract ϕpub can additionally implement incentive structures. Our sealed auction program redistributes the manager's public deposit if it aborts. Specifically, in our sealed auction program, ϕpub defines two functions, namely check and managerTimeOut. The check function will be invoked when the Hawk contract completes execution within T3, i.e., manager did not abort. Otherwise, if the Hawk contract does not complete execution within T3, the managerTimeOut function will be invoked. We remark that although not explicitly written in the code, all Hawk contracts have an implicit default entry point for accepting parties' deposits - these deposits are withheld by the contract till they are redistributed by the contract. Bidders should check that the manager has made a public deposit before submitting their bids.

Additional Applications
Besides the sealed auction example, Hawk supports various other applications. We give more sample programs in Section VI-B.

C. Contributions
To the best of our knowledge, Hawk is the first to simultaneously offer transactional privacy and programmability in a decentralized cryptocurrency system.

Formal Models for Decentralized Smart Contracts
We are among the first ones to initiate a formal, academic treatment of the blockchain model of cryptography. We present a formal, Universal Composability (UC) model for the blockchain model of cryptography - this formal model is of independent interest, and can be useful in general for defining and modeling the security of protocols in the blockchain model. Our formal model has also been adopted by the Gyges work [35] in designing criminal smart contracts.

In defining for formal blockchain model, we rely on a notion called wrappers to modularize our protocol design and to simplify presentation. Wrappers handle a set of common details such as timers, pseudonyms, global ledgers in a centralized place such that they need not be repeated in every protocol.

New Cryptography Suite
We implement a new cryptography suite that binds private transactions with programmable logic. Our protocol suite contains three essential primitives freeze, compute, and finalize. The freeze primitive allows parties to commit to not only normal data, but also coins. Committed coins are frozen in the contract, and the payout distribution will later be determined by the program ϕpriv. During compute, parties open their committed data and currency to the manager, such that the manager can compute the function ϕpriv. Based on the outcome of ϕpriv, the manager now constructs new private coins to be paid to each recipient. The manager then submits to the blockchain both the new private coins as well as zero-knowledge proofs of their well-formedness. At this moment, the previously frozen coins are now redistributed among the users. Our protocol suite strictly generalizes Zerocash since Zerocash implements only private money transfers between users without programmability.

We define the security of our primitives using ideal functionalities, and formally prove security of our constructions under a simulation-based paradigm.

Implementation and Evaluation
We built a Hawk prototype and evaluated its performance by implementing several example applications, including a sealed-bid auction, a “rock, paper, scissors” game, a crowdfunding application, and a swap financial instrument. We propose interesting protocol optimizations that gained us a factor of 10× in performance relative to a straightforward implementation. We show that for at about 100 parties (e.g., auction and crowdfunding), the manager's cryptographic computation (the most expensive part of the protocol) is under 2.85min using 4 cores, translating to under $0.14 of EC2 time. Further, all on-chain computation (performed by all miners) is very cheap, and under 20ms for all cases. We will open source our Hawk framework in the near future.

D. Background and Related Work
1) Background
The original Bitcoin offers limited programmability through a scripting language that is neither Turing-complete nor user friendly. Numerous previous endeavors at creating smart contract-like applications atop Bitcoin (e.g., lottery [7], [17], micropayments [4], verifiable computation [40]) have demonstrated the difficulty of in retrofitting Bitcoin's scripting language - this serves well to motivate a Turing-complete, user-friendly smart contract language.

Ethereum is the first Turing-complete decentralized smart contract system. With Ethereum's imminent launch, companies and hobbyists are already building numerous smart contract applications either atop Ethereum or by forking off Ethereum, such as prediction markets [3], supply chain provenance [6], crowd-based fundraising [1], and security and derivatives trading [28].

Security of the Blockchain
Like earlier works that design smart contract applications for cryptocurrencies, we rely on the underlying decentralized blockchain to be secure. Therefore, we assume the blockchain's consensus protocol attains security when an adversary does not wield a large fraction of the computational power. Existing cryptocurrencies are designed with heuristic security. On one hand, researchers have identified attacks on various aspects of the system [29], [34]; on the other, efforts to formally understand the security of blockchain consensus have begun [32], [45].

Minimizing On-Chain Costs
Since every miner will execute the smart contract programs while verifying each transaction, cryptocurrencies including Bitcoin and Ethereum collect transaction fees that roughly correlate with the cost of execution. While we do not explicitly model such fees, we design our protocols to minimize on-chain costs by performing most of the heavy-weight computation off-chain.

2) Additional Related Works
Leveraging blockchain for financial fairness. A few prior works have explored how to leverage the blockchain technology to achieve fairness in protocol design. For example, Bentov et al. [17], Andrychowicz et al. [7], Kumaresan et al. [40], Kiayias et al. [36], as well as Zyskind et al. [59], show how Bitcoin can be used to ensure fairness in secure multi-party computation protocols. These protocols also perform off-chain secure computation of various types, but do not guarantee transactional privacy (i.e., hiding the currency flows and amounts transacted). For example, it is not clear how to implement our sealed auction example using these earlier techniques. Second, these earlier works either do not offer system implementations or provide implementations only for specific applications (e.g., lottery). In comparison, Hawk provides a generic platform such that nonspecialist programmers can easily develop privacy-preserving smart contracts.

Smart Contracts
The conceptual idea of programmable electronic “smart contracts” dates back nearly twenty years [53]. Besides recent decentralized cryptocurrencies, which guarantee authenticity but not privacy, other smart contract implementations rely on trusted servers for security [46]. Our work therefore comes closest to realizing the original vision of parties interacting with a trustworthy “virtual computer” that executes programs involving money and data.

Programming Frameworks for Cryptography
Several works have developed programming frameworks that take in high-level programs as specifications and generate cryptographic implementations, including compilers for secure multi-party computation [19], [39], [41], [51], authenticated data structures [44], and (zero-knowledge) proofs [12], [30], [31], [49]. Zheng et al. show how to generate secure distributed protocols such as sealed auctions, battleship games, and banking applications [58]. These works support various notions of security, but none of them interact directly with money or leverage public blockchains for ensuring financial fairness. Thus our work is among the first to combine the “correct-by-construction” cryptography approach with smart contracts.

Concurrent Work
Our framework is the first to provide a full-fledged formal model for decentralized blockchains as embodied by Bitcoin, Ethereum, and many other popular decentralized cryptocurrencies. In concurrent and independent work, Kiayias et al. [36] also propose a blockchain model in the (Generalized) Universal Composability framework [23] and use it to derive results that are similar to what we describe in the online version [37], i.e., fair MPC with public deposits. However, the “programmability” of their formalism is limited to their specific application (i.e., fair MPC with public deposits). In comparison, our formalism is designed with much broader goals, i.e., to facilitate protocol designers to design a rich class of protocols in the blockchain model. In particular, both our real-world wrapper (Figure 11) and ideal-world wrapper (Figure 10) model the presence of arbitrary user defined contract programs, which interact with both parties and the ledger. Our formalism has also been adopted by the Gyges work [35] demonstrating its broad usefulness.

SECTION II.The Blockchain Model of Cryptography
A. The Blockchain Model
We begin by informally describing the trust model and assumptions. We then propose a formal framework for the “blockchain model of cryptography” for specifying and reasoning about the security of protocols.

In this paper, the blockchain refers to a decentralized set of miners who run a secure consensus protocol to agree upon the global state. We therefore will regard the blockchain as a conceptual trusted party who is trusted for correctness and availability, but not trusted for privacy. The blockchain not only maintains a global ledger that stores the balance for every pseudonym, but also executes user-defined programs. More specifically, we make the following assumptions:

Time. The blockchain is aware of a discrete clock that increments in rounds. We use the terms rounds and epochs interchangeably.

Public state. All parties can observe the state of the block-chain. This means that all parties can observe the public ledger on the blockchain, as well as the state of any user-blockchain program (part of a contract protocol).

Message delivery. Messages sent to the blockchain will arrive at the beginning of the next round. A network adversary may arbitrarily reorder messages that are sent to the blockchain within the same round. This means that the adversary may attempt a front-running attack (also referred to as the rushing adversary by cryptographers), e.g., upon observing that an honest user is trading a stock, the adversary preempts by sending a race transaction trading the same stock. Our protocols should be proven secure despite such adversarial message delivery schedules.

We assume that all parties have a reliable channel to the blockchain, and the adversary cannot drop messages a party sends to the blockchain. In reality, this means that the overlay network must have sufficient redundancy. However, an adversary can drop messages delivered between parties off the blockchain.

Pseudonyms. Users can make up an unbounded polynomial number of pseudonyms when communicating with the blockchain.

Correctness and availability. We assume that the blockchain will perform any prescribed computation correctly. We also assume that the blockchain is always available.

Advantages of a Generic Blockchain Model
We adopt a generic blockchain model where the blockchain can run arbitrary Turing-complete programs. In comparison, previous and concurrent works [7], [17], [40], [50] retrofit the artifacts of Bitcoin's limited and hard-to-use scripting language. In Section VII and the online version [37], we present additional theoretical results demonstrating that our generic blockchain model yields asymptotically more efficient cryptographic protocols.

B. Formally Modeling the Blockchain
Our paper adopts a carefully designed notational system such that readers may understand our constructions without understanding the precise details of our formal modeling.

We stress, however, that we give formal, precise specifications of both functionality and security, and our protocols are formally proven secure under the Universal Composability (UC) framework. In doing so, we make a separate contribution of independent interest: we are the first to propose a formal, UC-based framework for describing and proving the security of distributed protocols that interact with a blockchain - we refer to our formal model as “the blockchain model of cryptography”.

Programs, Wrappers, and Functionalities
In the remainder of the paper, we will describe ideal specifications, as well as pieces of the protocol executed by the blockchain, the users, and the manager respectively as programs written in pseudocode. We refer to them as the ideal program (denoted Ideal), the blockchain program (denoted B or Blockchain), and the user/manager program (denoted UserP) respectively.

All of our pseudo-code style programs have precise meanings in the UC framework. To “compile” a program to a UC-style functionality or protocol, we apply a wrapper to a program. Specifically, we define the following types of wrappers:

The ideal wrapper F(⋅) transforms an ideal program IdealP into a UC ideal functionality F (IdealP).

The blockchain wrapper G(⋅) transforms a blockchain program B to a blockchain functionality G(B). The blockchain functionality G(B) models the program executing on the blockchain.

The protocol wrapper Π(⋅) transforms a user/manager program UserP into a user-side or manager-side protocol Π(UserP).

One important reason for having wrappers is that wrappers implement a set of common features needed by every smart contract application, including time, public ledger, pseudonyms, and adversarial reordering of messages — in this way, we need not repeat this notation for every blockchain application.

We defer our formal UC modeling to Appendix B. This will not hinder the reader in understanding our protocols as long as the reader intuitively understands our blockchain model and assumptions described in Section II-A. Before we describe our protocols, we define some notational conventions for writing “programs”. Readers who are interested in the details of our formal model and proofs can refer to Appendix B.

C. Conventions for Writing Programs
Our wrapper-based system modularizes notation, and allows us to use a set of simple conventions for writing user-defined ideal programs, blockchain programs, and user protocols. We describe these conventions below.

Timer Activation Points
The ideal functionality wrapper F(⋅) and the blockchain wrapper G(⋅) implement a clock that advances in rounds. Every time the clock is advanced, the wrappers will invoke the Timer activation point. Therefore, by convention, we allow the ideal program or the blockchain program can define a Timer activation point. Timeout operations (e.g., refunding money after a certain timeout) can be implemented under the Timer activation point.

Delayed Processing in Ideal Programs
When writing the blockchain program, every message received by the blockchain program is already delayed by a round due to the G(⋅) wrapper.

When writing the ideal program, we introduce a simple convention to denote delayed computation. Program instructions that are written in gray background denote computation that does not take place immediately, but is deferred to the beginning of the next timer click. This is a convenient shorthand because in our real-world protocol, effectively any computation done by a blockchain functionality will be delayed. For example, in our IdealPcash ideal program (see Figure 3), whenever the ideal functionality receives a mint or pour message, the ideal adversary S is notified immediately; however, processing of the messages is deferred till the next timer click. Formally, delayed processing can be implemented simply by storing state and invoking the delayed program instructions on the next Timer click. By convention, we assume that the delayed instructions are invoked at the beginning of the Timer call. In other words, upon the next timer click, the delayed instructions are executed first.

Pseudonymity
All party identifiers that appear in ideal programs, blockchain programs, and user-side programs by default refer to pseudonyms. When we write “upon receiving message from some P ”, this accepts a message from any pseudonym. Whenever we write “upon receiving message from P ”, without the keyword some, this accepts a message from a fixed pseudonym P, and typically which pseudonym we refer to is clear from the context.

Whenever we write “send m to G(B) as nym P ” inside a user program, this sends an internal message (“send”, m, P) to the protocol wrapper Π. The protocol wrapper will then authenticate the message appropriately under pseudonym P.


Fig. 3.
Definition of IdealPcash. Notation: ledger denotes the public ledger, and coins denotes the private pool of coins. As mentioned in Section II-C, gray background denotes batched and delayed activation. All party names correspond to pseudonyms due to notations and conventions defined in Section II-B.

Show All

When the context is clear, we avoid writing “as nym P ”, and simply write “send m to G(B) ”. Our formal system also allows users to send messages anonymously to the blockchain - although this option will not be used in this paper.

Ledger and Money Transfers
A public ledger is denoted ledger in our ideal programs and blockchain programs. When a party sends amttoanidealprogramorablockchainprogram,thisrepresentsanordinarymessagetransmission.Moneytransfersonlytakeplacewhenidealprogramsorblockchainprogramsupdatethepublicledgerledger.Inotherwords,thesymbol is only adopted for readability (to distinguish variables associated with money and other variables), and does not have special meaning or significance. One can simply think of this variable as having the money type.

SECTION III.Cryptography Abstractions
We now describe our cryptography abstraction in the form of ideal programs. Ideal programs define the correctness and security requirements we wish to attain by writing a specification assuming the existence of a fully trusted party. We will later prove that our real-world protocols (based on smart contracts) securely emulate the ideal programs. As mentioned earlier, an ideal program must be combined with a wrapper F to be endowed with exact execution semantics.

Overview
Hawk realizes the following specifications:

Private ledger and currency transfer. Hawk relies on the existence of a private ledger that supports private currency transfers. We therefore first define an ideal functionality called IdealPcash that describes the requirements of a private ledger (see Figure 3). Informally speaking, earlier works such as Zerocash [11] are meant to realize (approximations of) this ideal functionality - although technically this ought to be interpreted with the caveat that these earlier works prove indistinguishability or game-based security instead DC-based simulation security.

Hawk-specific primitives. With a private ledger specified, we then define Hawk-specific primitives including freeze, compute, and finalize that are essential for enabling transactional privacy and programmability simultaneously.

A. Private Cash Specification IdealPcash
At a high-level, the IdealPcash specifies the requirements of a private ledger and currency transfer. We adopt the same “mint” and “pour” terminology from Zerocash [11].

Mint
The mint operation allows a user P to transfer money from the public ledger denoted ledger to the private pool denoted Coins [P]. With each transfer, a private coin for user P is created, and associated with a value val.

For correctness, the ideal program IdealPcash checks that the user P has sufficient funds in its public ledger ledger [P] before creating the private coin.

Pour
The pour operation allows a user P to spend money in its private bank privately. For simplicity, we define the simple case with two input coins and two output coins. This is sufficient for users to transfer any amount of money by “making change,” although it would be straightforward to support more efficient batch operations as well.

For correctness, the ideal program IdealPcash checks the following: 1) for the two input coins, party P indeed possesses private coins of the declared values; and 2) the two input coins sum up to equal value as the two output coins, i.e., coins neither get created or vanish.

Privacy
When an honest party P mints, the ideal-world adversary A learns the pair (P,val)-since minting is raising coins from the public pool to the private pool. Operations on the public pool are observable by A.

When an honest party P pours, however, the adversary A learns only the output pseudonyms P1 and P2. It does not learn which coin in the private pool Coins is being spent nor the name of the spender. Therefore, the spent coins are anonymous with respect to the private pool Coins. To get strong anonymity, new pseudonyms P1 and P2 can be generated on the fly to receive each pour. We stress that as long as pour hides the sender, this “breaks” the transaction graph, thus preventing linking analysis.

If a corrupted party is the recipient of a pour, the adversary additionally learns the value of the coin it receives.

Additional Subtleties
Later in our protocol, honest parties keep track of a wallet of coins. Whenever an honest party pours, it first checks if an appropriate coin exists in its local wallet - and if so it immediately removes the coin from the wallet (i.e., without delay). In this way, if an honest party makes multiple pour transactions in one round, it will always choose distinct coins for each pour transaction. Therefore, in our IdealPcash functionality, honest pourers' coins are immediately removed from Coins. Further, an honest party is not able to spend a coin paid to itself until the next round. By contrast, corrupted parties are allowed to spend coins paid to them in the same round - this is due to the fact that any message is routed immediately to the adversary, and the adversary can also choose a permutation for all messages received by the blockchain in the same round (see Section II and Appendix B).

Another subtlety in the IdealPcash functionality is while honest parties always pour to existing pseudonyms, the functionality allows the adversary to pour to non-existing pseudonyms denoted ⊥ - in this case, effectively the private coin goes into a blackhole and cannot be retrieved. This enables a performance optimization in our UserPcash and Blockchaincash protocol later - where we avoid including the cti′s in the NIZK of LPOUR (see Section IV). If a malicious pourer chooses to compute the wrong cti, it is as if the recipient Pi did not receive the pour, i.e., the pour is made to ⊥.

B. Hawk Specification IdealPhawk
To enable transactional privacy and programmability simultaneously, we now describe the specifications of new Hawk primitives, including freeze, compute, and finalize. The formal specification of the ideal program IdealPhawk is provided in Figure 4. Below, we provide some explanations. We also refer the reader to Section I-C for higher-level explanations.

Freeze
In freeze, a party tells IdealPhawk to remove one coin from the private coins pool Coins, and freeze it in the blockchain by adding it to FrozenCoins. The party's private input denoted in is also recorded in FrozenCoins. IdealPhawk checks that P has not called freeze earlier, and that a coin (P,val exists in Coins before proceeding with the freeze.

Compute
When a party P calls compute, its private input in and the value of its frozen coin val are disclosed to the manager PM.

Finalize
In finalize, the manager PM submits a public input i n M to IdealPhawk.IdealPhawk now computes the outcome of ϕpriv on all parties' inputs and frozen coin values, and redistributes the FrozenCoins based on the outcome of ϕpriv. To ensure money conservation, the ideal program IdealPhawk checks that the sum of frozen coins is equal to the sum of output coins.

Interaction with Public Contract
The IdealPhawk functionality is parameterized by a public Hawk contract ϕpub, which is included in IdealPhawk as a sub-module. During a finalize, IdealPhawk calls ϕpub. check. The public contract ϕpub typically serves the following purposes:

Check the well-formedness of the manager's input in M. For example, in our financial derivatives application (Section VI-B), the public contract ϕpub asserts that the input corresponds to the price of a stock as reported by the stock exchange's authentic data feed.

Redistribute public deposits. If parties or the manager have aborted, or if a party has provided invalid input (e.g., less than a minimum bet) the public contract ϕpub can now redistribute the parties' public deposits to ensure financial fairness. For example, in our “Rock, Paper, Scissors” example (see Section VI-B), the private contract ϕpriv checks if each party has frozen the minimal bet. If not, ϕpriv includes that information in out so that ϕpub pays that party's public deposit to others.


Fig. 4.
Definition of ideal Phawk. Notations: FrozenCoins denotes frozen coins owned by the contract; Coins denotes the global private coin pool defined by IdealPcash; and (ini,vali) denotes the input data and frozen coin value of party Pi.

Show All

Security and Privacy Requirements
The IdealPhawk specifies the following privacy guarantees. When an honest party P freezes money (e.g., a bid), the adversary should not observe the amount frozen. However, the adversary can observe the party's pseudonym P. We note that leaking the pseudonym P does not hurt privacy, since a party can simply create a new pseudonym P and pour to this new pseudonym immediately before the freeze.

When an honest party calls compute, the manager PM gets to observe its input and frozen coin's value. However, the public and other contractual parties do not observe anything (unless the manager voluntarily discloses information).

Finally, during a finalize operation, the output out is declassified to the public — note that out can be empty if we do not wish to declassify any information to the public.

It is not hard to see that our ideal program IdealPhawk satisfies input independent privacy and authenticity against a dishonest manager. Further, it satisfies posterior privacy as long as the manager does not voluntarily disclose information. Intuitive explanations of these security/privacy properties were provided in Section I-B.

Timing and Aborts
Our ideal program IdealPhawk requires that freeze operations be done by time T1, and that compute operations be done by time T2. If a user froze coins but did not open by time T2, our ideal program IdealPhawk treats (ini,vali):=(0,⊥), and the user Pi essentially forfeits its frozen coins. Managerial aborts is not handled inside IdealPhawk, but by the public portion of the contract.

Simplifying Assumptions
For clarity, our basic version of IdealPhawk is a stripped down version of our implementation. Specifically, our basic IdealPhawk and protocols do not realize refunds of frozen coins upon managerial abort. As mentioned in Section IV-C, it is not hard to extend our protocols to support such refunds.

Other simplifying assumptions we made include the following. Our basic IdealPhawk assumes that the set of pseudonyms participating in the contract as well as timeouts T1 and T2 are hard-coded in the program. This can also be easily relaxed as mentioned in Section IV-C.

SECTION IV.Cryptographic Protocols
Our protocols are broken down into two parts: 1) the private cash part that implements direct money transfers between users; and 2) the Hawk-specific part that binds transactional privacy with programmable logic. The formal protocol descriptions are given in Figures 5 and 6. Below we explain the high-level intuition.

A. Warmup: Private Cash and Money Transfers
Our construction adopts a Zerocash-like protocol for implementing private cash and private currency transfers. For completeness, we give a brief explanation below, and we mainly focus on the pour operation which is technically more interesting. The blockchain program Blockchaincash maintains a set Coins of private coins. Each private coin is of the format
(P,coin:=Comms($$val))
View Sourcewhere P denotes a party's pseudonym, and coin commits to the coin's value $val under randomness s.


Fig. 5.
UserPcash construction. A trusted setup phase generates the NIZK's common reference string crs. For notational convenience, we omit writing the crs explicitly in the construction. The merkle tree MT is stored on the blockchain and not computed on the fly - we omit stating this in the protocol for notational simplicity. The protocol wrapper Π(⋅) invokes gennym whenever a party creates a new pseudonym.

Show All

During a pour operation, the spender P chooses two coins in Coins to spend, denoted (P,coin1) and (P,coin2) where coini:=Commsi($vali) for i∈{1,2}. The pour operation pays val′1 and val′2 amount to two output pseudonyms denoted P1 and P2 respectively, such that val1+val2=val′1+val′2. The spender chooses new randomness s′i for i∈{1,2}, and computes the output coins as
(Pi,coini:=Comms′i($$val′i))
View Source

The spender gives the values s′i and val′i to the recipient Pi for Pi to be able to spend the coins later.

Now, the spender computes a zero-knowledge proof to show that the output coins are constructed appropriately, where correctness compasses the following aspects:

Existence of coins being spent. The coins being spent (P,coin1) and (P,coin2) are indeed part of the private pool Coins. We remark that here the zero-knowledge property allows the spender to hide which coins it is spending — this is the key idea behind transactional privacy.

To prove this efficiently, Blockchaincash maintains a Merkle tree MT over the private pool Coins. Membership in the set can be demonstrated by a Merkle branch consistent with the root hash, and this is done in zero-knowledge.

No double spending. Each coin (P,coin) has a cryptographically unique serial number sn that can be computed as a pseudorandom function of P's secret key and coin. To pour a coin, its serial number sn must be disclosed, and a zero-knowledge proof given to show the correctness of sn. Blockchaincash checks that no sn is used twice.

Money conservation. The zero-knowledge proof also attests to the fact that the input coins and the output coins have equal total value.

We make some remarks about the security of the scheme. Intuitively, when an honest party pours to an honest party, the adversary A does not learn the values of the output coins assuming that the commitment scheme Comm is hiding, and the NIZK scheme we employ is computational zero-knowledge. The adversary A can observe the nyms that receive the two output coins. However, as we remarked earlier, since these nyms can be one-time, leaking them to the adversary would be okay. Essentially we only need to break linkability at spend time to ensure transactional privacy.


Fig. 6.
Blockchainhawk and UserPhawk construction.

Show All

When a corrupted party P∗ pours to an honest party P, even though the adversary knows the opening of the coin, it cannot spend the coin (P,coin) once the transaction takes effect by the Blockchaincash, since P∗ cannot demonstrate knowledge of P's secret key. We stress that since the contract binds the owner's nym P to the coin, only the owner can spend it even when the opening of coin is disclosed.

Technical Subtleties
Our Blockchaincash uses a modified version of Zerocash to achieve stronger security in the simulation paradigm. In comparison, Zerocash adopts a strictly weaker, indistinguishability-based privacy notion called ledger indistinguishability. In multi-party protocols, indistinguishability-based security notions are strictly weaker than simulation security. Not only so, the particular ledger indistinguishability notion adopted by Zerocash [11] appears subtly questionable upon scrutiny, which we elaborate on in the online version [37]. This does not imply that the Zerocash construction is necessarily insecure — however, there is no obvious path to proving their scheme secure under a simulation based paradigm.

B. Binding Privacy and Programmable Logic
So far, Blockchaincash, similar to Zerocash [11], only supports direct money transfers between users. We allow transactional privacy and programmable logic simutaneously.

Freeze
We support a new operation called freeze, that does not spend directly to a user, but commits the money as well as an accompanying private input to a smart contract. This is done using a pour-like protocol:

The user P chooses a private coin (P,coin)∈Coins, where coin:=Comms($val). Using its secret key, P computes the serial number sn for coin - to be disclosed with the freeze operation to prevent double-spending.

The user P computes a commitment (val∥in∥k) to the contract where in denotes its input, and k is a symmetric encryption key that is introduced due to a practical optimization explained later in Section V.

The user P now makes a zero-knowledge proof attesting to similar statements as in a pour operation, i.e., that the spent coin exists in the pool Coins, the sn is correctly constructed, and that the val committed to the contract equals the value of the coin being spent. See LFREEZE in Figure 6 for details of the NP statement being proven.

Compute
Next, computation takes place off-chain to compute the payout distribution {val′i}i∈[n] and a proof of correctness. In Hawk, we rely on a minimally trusted manager PM to perform computation. All parties would open their inputs to the manager PM, and this is done by encrypting the opening to the manager's public key:
ct:=ENC(PM.epk,r,($$val∥in∥k∥s′))
View Source

The ciphertext ct is submitted to the smart contract along with appropriate zero-knowledge proofs of correctness. While the user can also directly send the opening to the manager off-chain, passing the ciphertext ct through the smart contract would make any aborts evident such that the contract can financially punish an aborting user.

After obtaining the openings, the manager now computes the payout distribution {val′i}i∈[n] and public output out by applying the private contract ϕpriv. The manager also constructs a zero-knowledge proof attesting to the outcomes.

Finalize
When the manager submits the outcome of ϕpriv and a zero-knowledge proof of correctness to Blockchainhawk,Blockchainhawk verifies the proof and redistributes the frozen money accordingly. Here Blockchainhawk also passes the manager's public input inM and public output out to the public Hawk contract ϕpub. The public contract ϕpub can be invoked to check the validity of the manager's input, as well as redistribute public collateral deposit.

Theorem 1
Assuming that the hash function in the Merkle tree is collision resistant, the commitment scheme Comm is perfectly binding and computationally hiding, the NIZK scheme is computationally zero-knowledge and simulation sound extractable, the encryption schemes ENC and SENC are perfectly correct and semantically secure, the PRF scheme PRF is secure, then, our protocols in Figures 5 and 6 securely emulates the ideal functionality F(IdealPhawk) against a malicious adversary in the static corruption model.

Proof
Deferred to our online version [37]. □

C. Extensions and Discussions
Refunding Frozen Coins to Users
In our implementation, we extend our basic scheme to allow the users to reclaim their frozen money after a timeout T3>T2. To achieve this, user P simply sends the contract a newly constructed coin (P,coin:=Comms($val)) and proves in zero-knowledge that its value $val is equal to that of the frozen coin. In this case, the user can identify the previously frozen coin in the clear, i.e., there is no need to compute a zero-knowledge proof of membership within the frozen pool as is needed in a pour transaction.

Instantiating the Manager with Trusted Hardware
In some applications, it may be a good idea to instantiate the manager using trusted hardware such as the emerging Intel SGX. In this case, the off-chain computation can take place in a secret SGX enclave that is not visible to any untrusted software or users. Alternatively, in principle, the manager role can also be split into two or more parties that jointly run a secure computation protocol — although this approach is likely to incur higher overhead.

We stress that our model is fundamentally different from placing full trust in any centralized node. Trusted hardware cannot serve as a replacement of the blockchain. Any off-chain only protocol that does not interact with the blockchain cannot offer financial fairness in the presence of aborts — even when trusted hardware is employed.

Furthermore, even the use of SGX does not obviate the need for our cryptographic protocol. If the SGX is trusted only by a subset of parties (e.g., just the parties to a particular private contact), rather than globally, then those users can benefit from the efficiency of an SGX-managed private contract, while still utilizing the more widely trusted underlying currency.

Pouring Anonymously to Long-Lived Pseudonyms
In our basic formalism of IdealPcash, the pour operation discloses the recipient's pseudonyms to the adversary. This means that IdealPcash only retains full privacy if the recipient generates a fresh, new pseudonym every time. In comparison, Zero-cash [11] provides an option of anonymously spending to a long-lived pseudonym (in other words, having IdealPcash not reveal recipients' pseudonyms to the adversary).

It would be straightforward to add this feature to Hawk as well (at the cost of a constant factor blowup in performance); however, in most applications (e.g., a payment made after receiving an invoice), the transfer is subsequent to some interaction between the recipient and sender.

Open Enrollment of Pseudonyms
In our current formalism, parties' pseudonyms are hardcoded and known a priori. We can easily relax this to allow open enrollment of any pseudonym that joins the contract (e.g., in an auction). Our implementation supports open enrollment. Due to SNARK's preprocessing, right now, each contract instance must declare an upperbound on the number of participants. An enrollment fee can potentially be adopted to prevent a DoS attack where the attacker joins the contract with many pseudonyms thus preventing legitimate users from joining. How to choose the correct fee amount to achieve incentive compatibility is left as an open research challenge. The a priori upper bound on the number of participants can be avoided if we adopt recursively composable SNARKs [18], [25] or alternative proofs that do not require circuit-dependent setup [16].

SECTION V.Adopting Snarks in UC Protocols and Practical Optimizations
A. Using Snarks in UC Protocols
Succinct Non-interactive ARguments of Knowledge [12], [33], [49] provide succinct proofs for general computation tasks, and have been implemented by several systems [12], [49], [56]. We would like to use SNARKs to instantiate the NIZK proofs in our protocols — unfortunately, SNARK's security is too weak to be directly employed in UC protocols. Specifically, SNARK's knowledge extractor is non-blackbox and cannot be used by the UC simulator to extract witnesses from statements sent by the adversary and environment — doing so would require that the extractor be aware of the environment's algorithm, which is inherently incompatible with UC security.

UC protocols often require the NIZKs to have simulation extractability. Although SNARKs do not satisfy simulation extractability, Kosba et al. show that it is possible to apply efficient SNARK-lifting transformations to construct simulation extractable proofs from SNARKs [38]. Our implementations thus adopt the efficient SNARK-lifting transformations proposed by Kosba et al. [38].

B. Practical Considerations
Efficient Snark Circuits
A SNARK prover's performance is mainly determined by the number of multiplication gates in the algebraic circuit to be proven [12], [49]. To achieve efficiency, we designed optimized circuits through two ways: 1) using cryptographic primitives that are SNARK-friendly, i.e. efficiently realizable as arithmetic circuits under a specific SNARK parametrization. 2) Building customized circuit generators to produce SNARK-friendly implementations instead of relying on compilers to translate higher level implementation.

The main cryptographic building blocks in our system are: collision-resistant hash function for the Merkle trees, pseudorandom function, commitment, and encryption. Our implementation supports both 80-bit and 112-bit security levels. To instantiate the CRH efficiently, we use an Ajtai-based SNARK-friendly collision-resistant hash function that is similar to the one used by Ben-Sasson et al. [14]. In our implementation, the modulus q is set to be the underlying SNARK implementation 254-bit field prime, and the dimension d is set to 3 for the 80-bit security level, and to 4 for the 112-bit security level based on the analysis in [38]. For PRFs and commitments, we use a hand-optimized implementation of SHA-256. Furthermore, we adopt the SNARK-friendly primitives for encryption used in the study by Kosba et al. [38], in which an efficient circuit for hybrid encryption in the case of 80-bit security level was proposed. The circuit performs the public key operations in a prime-order subgroup of the Galois field extension Fpμ, where μ=4,p is the underlying SNARK field prime (typically 254-bit prime, i.e. pμ is over 1000-bit), and the prime order of the subgroup used is 398-bit prime. This was originally inspired by Pinocchio coin [26]. The circuit then applies a lightweight cipher like Speck [10] or Chaskey-LTS [47] with a 128-bit key to perform symmetric encryption in the CBC mode, as using the standard AES-128 instead will result in a much higher cost [38]. For the 112-bit security, using the same method for public key operations requires intensive factorization to find suitable parameters, therefore we use a manually optimized RSA-OAEP encryption circuit with a 2048-bit key instead.

In the next section, we will illustrate how using SNARK-friendly implementations can lead to 2.0−3.7× savings in the size of the circuits at the 80-bit security level, compared to the case when naive straightforward implementation are used. We will also illustrate that the performance is also practical in the higher security level case.

Optimizations for Finalize
In addition to the SNARK-friendly optimizations, we focus on optimizing the O(N)-sized finalize circuit since this is our main performance bottleneck. All other SNARK proofs in our scheme are for O(1)-sized circuits. Two key observations allow us to greatly improve the performance of the proof generation during finalize.

Optimization 1: Minimize SSE-Secure Nizks
First, we observe that in our proof, the simulator need not extract any new witnesses when a corrupted manager submits proofs during a finalize operation. All witnesses necessary will have been learned or extracted by the simulator at this point. Therefore, we can employ an ordinary SNARK instead of a stronger simulation sound extractable NIZK during finalize. For freeze and compute, we still use the stronger NIZK. This optimization reduces our SNARK circuit sizes by 1.5× as can be inferred from Figure 9 of Section VI, after SNARK-friendly optimizations are applied.

Optimization 2: Minimize Public-Key Encryption in Snarks
Second, during finalize, the manager encrypts each party Pi′s output coins to Pi′s key, resulting in a ciphertext cti. The ciphertexts {cti}i∈[N] would then be submitted to the contract along with appropriate SNARK proofs of correctness. Here, if a public-key encryption is employed to generate the cti′s, it would result in relatively large SNARK circuit size. Instead, we rely on a symmetric-key encryption scheme denoted SENC in Figure 6. This requires that the manager and each Pi perform a key exchange to establish a symmetric key ki. During an compute, the user encrypts this ki to the manager's public key PM. epk and prove that the k encrypted is consistent with the k committed to earlier in cmi. The SNARK proof during finalize now only needs to include commitments and symmetric encryptions instead of public key encryptions in the circuit – the latter much more expensive.

This second optimization additionally gains us a factor of 1.9× as shown in Figure 9 of Section VI after applying the previous optimizations. Overall, all optimizations will lead to a gain of more than 10× in the finalize circuit.

Remarks About the Common Reference String
SNARK schemes require the generation of a common reference string (CRS) during a pre-processing step. This common reference string consists of an evaluation key for the prover, and a verification key for the verifier. Unless we employ recursively composed SNARKs [18], [25] whose costs are significantly higher, the evaluation key is circuit-dependent, and its size is proportional to the circuit's size. In comparison, the verification key is O(|in|+|out|) in size, i.e., depends on the total length of inputs and outputs, but independent of the circuit size. We stress that only the verification key portion of the CRS needs to be included in the public contract that lives on the blockchain.

We remark that the CRS for protocol UserPcash is shared globally, and can be generated in a one-time setup. In comparison, the CRS for each Hawk contract would depend on the Hawk contract, and therefore exists per instance of Hawk contract. To minimize the trust necessary in the CRS generation, one can employ either trusted hardware or use secure multi-party computation techniques as described by Ben-Sasson et al. [13].

Finally, in the future when new primitives become sufficiently fast, it is possible to drop-in and replace our SNARKs with other primtives that do not require per-circuit preprocessing. Examples include recursively composed SNARKs [18], [25] or other efficient PCP constructions [16]. The community's efforts at optimizing these constructions are underway.


Fig. 7.
Compiler overview. Circuit augmentation for finalize.

Show All

SECTION VI.Implementation and Evaluation
A. Compiler Implementation
Our compiler consists of several steps, which we illustrate in Figure 7 and describe below:

Preprocessing
First, the input Hawk program is split into its public contract and private contract components. The public contract is Serpent code, and can be executed directly atop an ordinary cryptocurrency platform such as Ethereum. The private contract is written in a subset of the C language, and is passed as input to the Pinocchio arithmetic circuit compiler [49]. Keywords such as HawkDeclareParties are implemented as C preprocessors macros, and serve to define the input (Inp) and output (Outp) datatypes. Currently, our private contract inherits the limitations of the Pinocchio compiler, e.g., cannot support dynamic-length loops. In the future, we can relax these limitations by employing recursively composition of SNARKs.

Circuit Augmentation
After compiling the preprocessed private contract code with Pinocchio, we have an arithmetic circuit representing the input/output relation ϕpriv. This becomes a subcomponent of a larger arithmetic circuit, which we assemble using a customized circuit assembly tool. This tool is parameterized by the number of parties and the input/output datatypes, and attaches cryptographic constraints, such as computing commitments and encryptions over each party's output value, and asserting that the input and output values satisfy the balance property.

Cryptographic Protocol
Finally, the augmented arithmetic circuit is used as input to a state-of-the-art zkSNARK library, Libsnark [15]. To avoid implementing SNARK verification in Ethereum's Serpent language, we must add a SNARK verification opcode to Ethereum's stack machine. We finally compile an executable program for the parties to compute the Libsnark proofs according to our protocol.

B. Additional Examples
Besides our running example of a sealed-bid auction (Figure 2), we implemented several other examples in Hawk, demonstrating various capabilities:

Crowdfunding
A Kickstarter-style crowdfunding campaign, (also known as an assurance contract in economics literature [9]) overcomes the “free-rider problem,” allowing a large number of parties to contribute funds towards some social good. If the minimum donation target is reached before the deadline, then the donations are transferred to a designated party (the entrepreneur); otherwise, the donations are refunded. Hawk preserves privacy in the following sense: a) the donations pledged are kept private until the deadline; and b) if the contract fails, only the manager learns the amount by which the donations were insufficient. These privacy properties may conceivably have a positive effect on the willingness of entrepreneurs to launch a crowdfund campaign and its likelihood of success.

Table I Performance of the zk-snark circuits for the user-side circuits: pour, freeze AND compute (same FOR ALL applications). MUL denotes multiple (4) cores, and ONE denotes a single core. The mint operation does not involve any snarks, and can be computed within tens of microseconds. The Proof includes any additional cryptographic material used for the SNARK-lifting transformation

Rock Paper Scissors
A two-player lottery game, and naturally generalized to an N-player version. Our Hawk implementation provides the same notion of financial fairness as in [7], [17] and provides stronger security/privacy guarantees. If any party (including the manager), cheats or aborts, the remaining honest parties receive the maximum amount they might have won otherwise. Furthermore, we go beyond prior works [7], [17] by concealing the players' moves and the pseudonym of the winner to everyone except the manager.

“Swap” Financial Instrument
An individual with a risky investment portfolio (e.g, one who owns a large number of Bitcoins) may hedge his risks by purchasing insurance (e.g., by effectively betting against the price of Bitcoin with another individual). Our example implements a simple swap instrument where the price of a stock at some future date (as reported by a trusted authority specified in the public contract) determines which of two parties receives a payout. The private contract ensures the privacy of both the details of the agreement (i.e., the price threshold) and the outcome.

The full Hawk programs for these examples are provided in our online version [37].

C. Performance Evaluation
We evaluated the performance for various examples, using an Amazon EC2 r3.8xlarge virtual machine. We assume a maximum of 264 leaves for the Merkle trees, and we present results for both 80-bit and 112-bit security levels. Our benchmarks actually consume at most 27GB of memory and 4 cores in the most expensive case. Tables I and II illustrate the results – we focus on evaluating the zk-SNARK performance since all other computation time is negligible in comparison. We highlight some important observations:


Fig. 8.
Gains of using SNARK-friendly implementation for the user-side circuits: pour, freeze and compute at 80-bit security.

Show All

Table II Performance of the zk-SNARK circuits for the manager circuit finalize for different applications. The manager circuits are the same for both security levels. MUL denotes multiple (4) cores, and ONE denotes a single core
Table II- Performance of the zk-SNARK circuits for the manager circuit finalize for different applications. The manager circuits are the same for both security levels. MUL denotes multiple (4) cores, and ONE denotes a single core
On-chain computation (dominated by zk-SNARK verification time) is very small in all cases, ranging from 9 to 20 milliseconds The running time of the verification algorithm is just linearly dependent on the size of the public statement, which is far smaller than the size of the computation, resulting into small verification time.

Fig. 9. - Gains after adding each optimization to the finalize auction circuit, with 25, 50 and 100 bidders. Opt 1 and opt 2 are two practical optimizations detailed in Section V.
Fig. 9.
Gains after adding each optimization to the finalize auction circuit, with 25, 50 and 100 bidders. Opt 1 and opt 2 are two practical optimizations detailed in Section V.

Show All

On-chain public parameters: As mentioned in Section IV-C, not the entire SNARK common reference string (CRS) need to be on the blockchain, but only the verification key part of the CRS needs to be on-chain. Our implementation suggests the following: the private cash protocol requires a verification key of 23KB to be stored on-chain - this verification key is globally shared and there is only a single instance. Besides the globally shared public parameters, each Hawk contract will additionally require 13–114 KB of verification key to be stored on-chain, for 10 to 100 users. This per-contract verification key is circuit-dependent, i.e., depends on the contract program. We refer the readers to Section IV-C for more discussions on techniques for performing trusted setup.

Manager computation: Running private auction or crowd-funding protocols with 100 participants requires under 6.5min proof time for the manager on a single core, and under 2.85min on 4 cores. This translates to under $0.14 of EC2 time [2].

User computation: Users' proof times for pour, freeze and compute are under one minute, and independent of the number of parties. Additionally, in the worst case, the peak memory usage of the user is less than 4 GB.

Savings from Protocol Optimizations
Figure 8 illustrates the performance gains attained by using a SNARK-friendly implementation for the user-side circuits, i.e. pour, freeze and compute w.r.t. the naive implementation at the 80-bit security level. We calculate the naive implementation cost using conservative estimates for the straightforward implementation of standard cryptographic primitives. The figure shows a gain of 2.0−2.6× compared to the naive implementation. Furthermore, Figure 9 illustrates the performance gains attained by our protocol optimizations described in Section V The figure considers the sealed-bid auction finalize circuit at different number of bidders. We show that the SNARK-friendly implementation along with our two optimizations combined significantly reduce the SNARK circuit sizes, and achieve a gain of 10× relative to a straightforward implementation. The figure also illustrates that the manager's cost is proportional to the number of participants. (By contrast, the user-side costs are independent of the number of participants).

SECTION VII.Additional Theoretical Results
Last but not the least, we present additional theoretical results to fruther illustrate the usefulness of our formal block-chain model. In the interest of space, we defer details to the online version [37], and only state the main findings here.

Fair MPC with Public Deposits in the Generic Blockchain Model
As is well-understood, fairness is in general impossible in plain models of multi-party computation when the majority can be corrupted. This was first observed by Cleve [24] and later extended in subsequent papers [8]. Assuming a blockchain trusted for correctness and availability (but not for privacy), an interesting notion of fairness which we refer to as “financial fairness” can be attained as shown by recent works [7], [17], [40]. In particular, the blockchain can financially penalize aborting parties by confiscating their deposits. Earlier works in this space [7], [17], [40], [50] focus on protocols that retrofit the artifacts of Bitcoin's limited scripting language. Specifically, a few works use Bitcoin's scripting language to construct intermediate abstractions such as “claim-or-refund” [17] or “multi-lock” [40], and build atop these abstractions to construct protocols. Table VII shows that by assuming a generic blockchain model where the blockchain can run Turing-complete programs, we can improve the efficiency of financially fair MPC protocols.

Table III Additional theoretical results for fair MPC with public deposits. The table assumes that FF parties wish to securely compute 1 bit of output that will be revealed to all parties at the end. For collateral, we assume that each aborting party must pay all honest parties 1 unit of currency. N

Fair MPC with Private Deposits
We further illustrate how to perform financially fair MPC using private deposits, i.e., where the amount of deposits cannot be observed by the public. The formal definitions, constructions, and proofs are supplied in the online version [37].


