Bit coin is the first digital currency to see widespread adoption. While payments are conducted between pseudonyms, Bit coin cannot offer strong privacy guarantees: payment transactions are recorded in a public decentralized ledger, from which much information can be deduced. Zero coin (Miers et al., IEEE S&P 2013) tackles some of these privacy issues by unlinking transactions from the payment's origin. Yet, it still reveals payments' destinations and amounts, and is limited in functionality. In this paper, we construct a full-fledged ledger-based digital currency with strong privacy guarantees. Our results leverage recent advances in zero-knowledge Succinct Non-interactive Arguments of Knowledge (zk-SNARKs). First, we formulate and construct decentralized anonymous payment schemes (DAP schemes). A DAP scheme enables users to directly pay each other privately: the corresponding transaction hides the payment's origin, destination, and transferred amount. We provide formal definitions and proofs of the construction's security. Second, we build Zero cash, a practical instantiation of our DAP scheme construction. In Zero cash, transactions are less than 1 kB and take under 6 ms to verify - orders of magnitude more efficient than the less-anonymous Zero coin and competitive with plain Bit coin.
SECTION I.Introduction
Bitcoin is the first digital currency to achieve widespread adoption. The currency owes its rise in part to the fact that, unlike traditional e-cash schemes [1]–[2][3], it requires no trusted parties. Instead of appointing a central bank, Bitcoin leverages a distributed ledger known as the block chain to store transactions made between users. Because the block chain is massively replicated by mutually-distrustful peers, the information it contains is public.

While users may employ many identities (or pseudonyms) to enhance their privacy, an increasing body of research shows that anyone can de-anonymize Bitcoin by using information in the block chain [4]–[5][6], such as the structure of the transaction graph as well as the value and dates of transactions. As a result, Bitcoin fails to offer even a modicum of the privacy provided by traditional payment systems, let alone the robust privacy of anonymous e-cash schemes.

While Bitcoin is not anonymous itself, those with sufficient motivation can obfuscate their transaction history with the help of mixes (also known as laundries or tumblers). A mix allows users to entrust a set of coins to a pool operated by a central party and then, after some interval, retrieve different coins (with the same total value) from the pool. Yet, mixes suffer from three limitations: (i) the delay to reclaim coins must be large to allow enough coins to be mixed in; (ii) the mix can trace coins; and (iii) the mix may steal coins.1For users with “something to hide,” these risks may be acceptable. But typical legitimate users (1) wish to keep their spending habits private from their peers, (2) are risk-averse and do not wish to expend continual effort in protecting their privacy, and (3) are often not sufficiently aware of their compromised privacy.

To protect their privacy, users thus need an instant, risk-free, and, most importantly, automatic guarantee that data revealing their spending habits and account balances is not publicly accessible by their neighbors, co-workers, and merchants. Anonymous transactions also guarantee that the market value of a coin is independent of its history, thus ensuring legitimate users' coins remain fungible. 2

Zerocoin: a Decentralized Mix
Miers et al. [8] proposed Zerocoin, which extends Bitcoin to provide strong anonymity guarantees. Like many e-cash protocols (e.g., [2]), Zerocoin employs zero-knowledge proofs to prevent transaction graph analyses. Unlike earlier practical e-cash protocols, however, Zerocoin does not rely on digital signatures to validate coins, nor does it require a central bank to prevent double spending. Instead, Zerocoin authenticates coins by proving, in zero- knowledge, that they belong to a public list of valid coins (which can be maintained on the block chain). Yet, rather than a full-fledged anonymous currency, Zerocoin is a decentralized mix, where users may periodically “wash” their bitcoins via the Zerocoin protocol. Routine day-to-day transactions must be conducted via Bitcoin, due to reasons that we now review.

The first reason is performance. Redeeming zerocoins requires double-discrete-logarithm proofs of knowledge, which have size that exceeds 45 kB and require 450 ms to verify (at the 128-bit security level).3 These proofs must be broadcast through the network, verified by every node, and permanently stored in the ledger. The entailed costs are higher, by orders of magnitude, than those in Bitcoin and can seriously tax a Bitcoin network operating at normal scale.

The second reason is functionality. While Zerocoin constitutes a basic e-cash scheme, it lacks critical features required of full-fledged anonymous payments. First, Zerocoin uses coins of fixed denomination: it does not support payments of exact values, nor does it provide a means to make change following a transaction (i.e., divide coins). Second, Zerocoin has no mechanism for one user to pay another one directly in “zerocoins.” And third, while Zerocoin provides anonymity by unlinking a payment transaction from its origin address, it does not hide the amount or other metadata about transactions occurring on the network.

Our Contribution
In this work we address the aforementioned issues via two main contributions.

We introduce the notion of a decentralized anonymous payment scheme, which formally captures the functionality and security guarantees of a full-fledged decentralized electronic currency with strong anonymity guarantees. We provide a construction of this primitive and prove its security under specific cryptographic assumptions. The construction leverages recent advances in the area of zero-knowledge proofs. Specifically, it uses zero-knowledge Succinct Non-interactive ARguments of Knowledge (zk-SNARKs) [9]–[10][11][12][13][14][15][16].

We achieve an implementation of the above primitive, via a system that we call Zerocash. Compared to Zerocoin, our system (at 128 bits of security):

Reduces the size of transactions spending a coin by 97.7%.

Reduces the spend-transaction verification time by 98.6%.

Allows for anonymous transactions of variable amounts.

Hides transaction amounts and the values of coins held by users.

Allows for payments to be made directly to a user's fixed address (without user interaction).

To validate our system, we measured its performance and established feasibility by conducting experiments in a test network of 1000 nodes (approximately 1/16 of the unique IPs in the Bitcoin network and 1/3 of the nodes reachable at any given time [17]). This inspires confidence that Zerocash can be deployed as a fork of Bitcoin and operate at the same scale. Thus, due to its significantly improved functionality and performance, Zerocash makes it possible to entirely replace traditional Bitcoin payments with anonymous alternatives.

Concurrent Work
The idea of using zk-SNARKs in the setting of Bitcoin was first presented by one of the authors at Bitcoin 2013 [18]. In concurrent work, Danezis et al. [19] suggest using zk-SNARKs to reduce proof size and verification time in Zerocoin; see Section IX for a comparison.

SECTION A.Zk-Snarks
We now sketch in more technical terms the definition of a zk-SNARK; see Section II for more details. A zk-SNARK is a non-interactive zero-knowledge proof of knowledge that is succinct, i.e., for which proofs are very short and easy to verify. More precisely, let L be an NP language, and let C be a nondeterministic decision circuit for L on a given instance size n. A zk-SNARK can be used to prove and verify membership in L, for instances of size n, as follows. After taking C as input, a trusted party conducts a one-time setup phase that results in two public keys: a proving key pk and a verification key vk. The proving key pk enables any (untrusted) prover to produce a proof π attesting to the fact that x∈L, for an instance x (of size n) of his choice. The non-interactive proof π is zero knowledge and a proof of knowledge. Anyone can use the verification key vk to verify the proof π; in particular zk-SNARK proofs are publicly verifiable: anyone can verify π, without ever having to interact with the prover that generated π. Succinctness requires that (for a given security level) π has constant size and can be verified in time that is linear in |x| (rather than linear in |C|).

SECTION B.Decentralized Anonymous Payment Schemes
We construct a decentralized anonymous payment (DAP) scheme, which is a decentralized e-cash scheme that allows direct anonymous payments of any amount. See Section III for a formal definition. Here, we outline our construction in six incremental steps; the construction details are in Section IV.

Our construction functions on top of any ledger-based base currency, such as Bitcoin. At any given time, a unique valid snapshot of the currency's ledger is available to all users. The ledger is a sequence of transactions and is append- only. Transactions include both the underlying currency's transactions, as well as new transactions introduced by our construction. For concreteness, we focus the discussion below on Bitcoin (though later definitions and constructions are stated abstractly). We assume familiarity with Bitcoin [20] and Zerocoin [8].

Step 1: User Anonymity with Fixed-Value Coins
We first describe a simplified construction, in which all coins have the same value of, e.g., 1 BTC. This construction, similar to the Zerocoin protocol, shows how to hide a payment's origin. In terms of tools, we make use of zk-SNARKs (recalled above) and a commitment scheme. Let COMM denote a statistically-hiding non-interactive commitment scheme (i.e., given randomness r and message m, the commitment is c:=COMMr(m); subsequently, c is opened by revealing r and m, and one can verify that COMMr(m) equals c).

In the simplified construction, a new coin c is minted as follows: a user u samples a random serial number sn and a trapdoor r, computes a coin commitment cm :=COMM7 (sn), and sets c (r, sn, cm). A corresponding mint transaction txMint, containing cm (but not sn or r), is sent to the ledger; txMnt| is appended to the ledger only if u has paid 1 BTC to a backing escrow pool (e.g., the 1 BTC may be paid via plaintext information encoded in t⟩⟨Mint). Mint transactions are thus certificates of deposit, deriving their value from the backing pool.

Subsequently, letting CM List denote the list of all coin commitments on the ledger, u may spend c by posting a spend transaction t×Spend that contains (i) the coin's serial number sn; and (ii) a zk-SNARK proof π of the NP statement I know r such that COMM7 (sn) appears in the list CMList of coin commitments. Assuming that sn does not already appear on the ledger (as part of a past spend transaction), u can redeem the deposited amount of 1 BTC, which u can either keep for himself, transfer to someone else, or immediately deposit into a new coin. (If sn does already appear on the ledger, this is considered double spending, and the transaction is discarded.)

User anonymity is achieved because the proof π is zero- knowledge: while sn is revealed, no information about r is, and finding which of the numerous commitments in CM List corresponds to a particular spend transaction txSpenc is equivalent to inverting f(x):=COMMx (sn), which is assumed to be infeasible. Thus, the origin of the payment is anonymous.

Step 2: Compressing the List of Coin Commitments
In the above N P statement, CM List is specified explicitly as a list of coin commitments. This naive representation severely limits scalability because the time and space complexity of most protocol algorithms (e.g., the proof verification algorithm) grows linearly with CMList. Moreover, coin commitments corresponding to already spent coins cannot be dropped from CM List to reduce costs, since they cannot be identified (due to the same zero-knowledge property that provides anonymity).

As in [3], we rely on a collision-resistant hash function CRH to avoid an explicit representation of CM List. We maintain an efficiently updatable append-only CRH-based Merkle tree Tree(CMList) over the (growing) list CMList. Letting rt denote the root of Tree(CMList), it is well-known that updating rt to account for insertion of new leaves can be done with time and space proportional to the tree depth. Hence, the time and space complexity is reduced from linear in the size of CM List to logarithmic. With this in mind, we modify the N P statement to the following one: ‘I know r such that COMMr (sn) appears as a leaf in a CRH-based Merkle tree whose root is rt. Compared with the naive data structure for CM List, this modification increases exponentially the size of CM List which a given zk-SNARK implementation can support (concretely, using trees of depth 64, Zerocash supports 264 coins).

Step 3: Extending Coins for Direct Anonymous Payments
So far, the coin commitment cm of a coin c is a commitment to the coin's serial number sn. However, this creates a problem when transferring c to another user. Indeed, suppose that a user uA created c, and uA sends c to another user u13. First, since uA knows sn, the spending of c by uE is both not anonymous (since uA sees when c is spent, by recognizing sn) and risky (since uA could still spend c first). Thus, uB must immediately spend c and mint a new coin c′ to protect himself. Second, if uA in fact wants to transfer to uB, e.g., 100 BTC, then doing so is both unwieldy (since it requires 100 transfers) and not anonymous (since the amount of the transfer is leaked). And third, transfers in amounts that are not multiples of 1 BTC (the fixed value of a coin) are not supported. Thus, the simplified construction described is inadequate as a payment scheme.

We address this by modifying the derivation of a coin commitment, and using pseudorandom functions to target payments and to derive serial numbers, as follows. We use three pseudorandom functions (derived from a single one). For a seed x these are denoted PRFaddrx(. ),PRFsnx(. ), and PRFpkx(⋅). We assume that PRFsn is moreover collision-resistant.

To provide targets for payments, we use addresses: each user u generates an address key pair (αpk,ask). The coins of u contain the value apk and can be spent only with knowledge of ask. A key pair (apk,ask) is sampled by selecting a random seed ask and setting apk:=PRfadd¯¯¯rask(0),. A user can generate and use any number of address key pairs.

Next, we re-design minting to allow for greater functionality. To mint a coin c of a desired value v, the user u first samples ρ, which is a secret value that determines the coin's serial number as sn :=PRFsnask(ρ). Then, u commits to the tuple (apk,v,ρ) in two phases: (a) u computes k:=COMMr(apk∥ρ) for a random r; and then (b) u computes cm:=COMMs(v∥k) for a random s. The minting results in a coin c:=(apk,v,ρ,r,s,cm) and a mint transaction t×Mint:=(v,k,s,cm). Crucially, due to the nested commitment, anyone can verify that cm in t×Mint is a coin commitment of a coin of value v (by checking that COMMs(v∥k) equals cm) but cannot discern the owner (by learning the address key apk) or serial number (derived from ρ) because these are hidden in k. As before, t×Mint is accepted by the ledger only if u deposits the correct amount, in this case v BTC.

Coins are spent using the pour operation, which takes a set of input coins, to be consumed, and “pours” their value into a set of fresh output coins - such that the total value of output coins equals the total value of the input coins. Suppose that u, with address key pair (a∘1dpk,a∘1dsk), wishes to consume his coin c∘1d=(a∘1dpk,v∘1d,pold,r∘1d,s∘1d,cm∘1d) and produce two new coins cnew1 and cnew2, with total value vnew1+vnew2=v∘1c, respectively targeted at address public keys αnewpk,1 and anewpk,2. (The addresses anewpk,1 and anewpk,2 may belong to u or to some other user.) The user u, for each i∈{1,2], proceeds as follows: (i) u samples serial number randomness newρi; (ii) u computes knewi:=COMMrnmi(anewpk,i∥ρnewi) for a random rnewx˙; and (iii) u computes ¬mnewi:=COMMsnewi(vnewi∥knewi) for a random snewi.

This yields the coins cmnew1) and cnew2:=(anewpk,2,vnew2,ρnew2,rnew2,snew2,cmnew2). Next, u produces a zk-SNARK proof πPOUR for the following NP statement, which we call POUR:


A resulting pour transaction txPour:= (rt, snO,cm∩ew1|d,cmnew2,πPOUR) is appended to the ledger. (As before, the transaction is rejected if the serial number sn appears in a previous transaction.)

Now suppose that u does not know, say, the address secret key anewsk,1 that is associated with the public key anewpk,1. Then, u cannot spend cnew1 because he cannot provide anewsk,1 as part of the witness of a subsequent pour operation. Furthermore, when a user that knows anewsk,1 does spend cnew1, the user u cannot track it, because he knows no information about its revealed serial number, which is snnew1:=PRFsnanewsk,1–(ρnew1).

Also observe that t×Pour reveals no information about how the value of the consumed coin was divided among the two new fresh coins, nor which coin commitment corresponds to the consumed coin, nor the address public keys to which the two new fresh coins are targeted. The payment was conducted in full anonymity.

More generally, a user may pour N∘1d≥0 coins into Nnew≥ 0 coins. For simplicity we consider the case Nold=Nnew=2, without loss of generality. Indeed, for Nold<2, the user can mint a coin with value 0 and then provide it as a “null” input, and for Nnew<2, the user can create (and discard) a new coin with value 0. For NO|d>2 or Nnew>2, the user can compose logN∘1d+logNnew of the 2-input/2-output pours.

Step 4: Sending Coins
Suppose that anewpk,1 is the address public key of u1. In order to allow u1 to actually spend the new coin cnew1 produced above, u must somehow send the secret values in cnew1 to ul. One way is for u to send u1 a private message, but the requisite private communication channel necessitates additional infrastructure or assumptions. We avoid this “out- of-band” channel and instead build this capability directly into our construction by leveraging the ledger as follows.

We modify the structure of an address key pair. Each user now has a key pair (addrpk,addrsk), where addrpk=(apk,pkenc) and addrsk=(ask,skenc). The values (apk,ask) are generated as before. In addition, (pkenc,skenc) is a key pair for a key-private encryption scheme [21].

Then, u computes the ciphertext C1 that is the encryption of the plaintext (vnew1,ρnew1,rnew1,snew1), under pknewenc,1 (which is part of ul 's address public key addrnewsk,1 ), and includes C1 in the pour transaction t×Pour The user u1 can then find and decrypt this message (using his sknewenc,1) by scanning the pour transactions on the public ledger. Again, note that adding C1 to txPour leaks neither paid amounts, nor target addresses due to the key-private property of the encryption scheme. (The user u does the same with cnew2 and includes a corresponding ciphertext C2 in txPour.)

Step 5: Public Outputs
The construction so far allows users to mint, merge, and split coins. But how can a user redeem one of his coins, i.e., convert it back to the base currency (Bitcoin)? For this, we modify the pour operation to include a public output. When spending a coin, the user u also specifies a nonnegative vpub and an arbitrary string info. The balance equation in the NP statement POUR is changed accordingly: v∩ew1+v∩ew2+vpub=vO|d. Thus, of the input value vO|c, a part vpub is publicly declared, and its target is specified, somehow, by the string info. The string info can be used to specify the destination of these redeemed funds (e.g., a Bitcoin wallet public key).4 Both vpub and info are now included in the resulting pour transaction t×Pour. (The public output is optional, as the user u can set vpub=0.)

Step 6: Non-Malleability
To prevent malleability attacks on a pour transaction t×Pour. (e.g., embezzlement by re-targeting the public output of the pour by modifying info), we further modify the NP statement POUR and use digital signatures. Specifically, during the pour operation, the user ui (i) samples a key pair (pksig,sksigS| for a one-time signature scheme; (ii) computes hSig:=CRH(pksig); (iii) computes the two values h1:=PRFpka∘1dsk1(hSig) and h2:=PRFpka∘1dsk2,(hSig|, which act as MACs to “tie” hSig to both address secret keys; (iv) modifies POUR to include the three values hSig,h1,h2 and prove that the latter two are computed correctly; and (v) uses skS1g to sign every value associated with the pour operation, thus obtaining a signature σ, which is included, along with pksig, in t⟩⟨Pour. Since the aoldsk,i are secret, and with high probability hSig changes for each pour transaction, the values h1,h2 are unpredictable. Moreover, the signature on the N P statement (and other values) binds all of these together.

This ends the outline of the construction, which is summarized in part in Figure 1. We conclude by noting that, due to the zk-SNARK, our construction requires a one-time trusted setup of public parameters. The trust affects soundness of the proofs, though anonymity continues to hold even if the setup is corrupted by a malicious party.

SECTION C.Zerocash
We outline Zerocash, a concrete implementation, at 128 bits of security, of our DAP scheme construction; see Section V for details. Zerocash entails carefully instantiating the cryptographic ingredients of the construction to ensure that the zk-SNARK, the “heaviest” component, is efficient enough in practice. In the construction, the zk-SNARK is used to prove/verify a specific NP statement: POUR. While zk-SNARKs are asymptotically efficient, their concrete efficiency depends on the arithmetic circuit C that is used to decide the NP statement. Thus, we seek instantiations for which we can design a relatively-small arithmetic circuit CPOUR for verifying the NP statement POUR.

Our approach is to instantiate all of the necessary cryptographic ingredients (commitment schemes, pseudorandom functions, and collision-resistant hashing) based on SHA256. We first design a hand-optimized circuit for verifying SHA256 computations (or, more precisely, its compression function, which suffices for our purposes). 5 Then, we use this circuit in constructing CPOUR, which verifies all the necessary checks for satisfying the NP statement CPOUR.

Fig. 1: - (a) Illustration of the CRH-based Merkle tree over the list CMList of coin commitments. (b) A coin $c$, (c)j Illustration of the structure of a coin commitment cm. (d) Illustration of the structure of a coin serial number sn.
Fig. 1:
(a) Illustration of the CRH-based Merkle tree over the list CMList of coin commitments. (b) A coin c, (c)j Illustration of the structure of a coin commitment cm. (d) Illustration of the structure of a coin serial number sn.

Show All

This, along with judicious parameter choices, and a state-of- the-art implementation of a zk-SNARK for arithmetic circuits [16] (see Section II-C), results in a zk-SNARK prover running time of few minutes and zk-SNARK verifier running time of few milliseconds. This allows the DAP scheme implementation to be practical for deployment, as our experiments show.

Zerocash can be integrated into Bitcoin or forks of it (commonly referred to as “altcoins”); we later describe how this is done.

SECTION D.Paper Organization
The remainder of this paper is organized as follows. Section II provides background on zk-SNARKs. We define DAP schemes in Section III, and our construction thereof in Section IV. Section V discusses the concrete instantiation in Zerocash. Section VI describes the integration of Zerocash into existing ledger-based currencies. Section VII provides microbenchmarks for our prototype implementation, as well as results based on full-network simulations. Section VIII describes optimizations. We discuss concurrent work in Section IX and summarize our contributions and future directions in Section X.

SECTION II.Background on Zk-Snarks
The main cryptographic primitive used in this paper is a special kind of Succinct Non-interactive ARgument of Knowledge (SNARK). Concretely, we use a publicly-verifiable preprocessing zero-knowledge SNARK, or zk-SNARK for short. In this section we provide basic background on zk-SNARKs, provide an informal definition, and recall known constructions and implementations.

A. Informal Definition
We informally define zk-SNARKs for arithmetic circuit satisfiability. We refer the reader to, e.g., [11] for a formal definition.

For a field F, an F-arithmetic circuit takes inputs that are elements in F, and its gates output elements in F. We naturally associate a circuit with the function it computes. To model nondeterminism we consider circuits that have an input x∈Fn and an auxiliary input α∈Fh, called a witness. The circuits we consider only have bilinear gates.6 Arithmetic circuit satisfiability is defined analogously to the boolean case, as follows.

Definition 11.1
The arithmetic circuit satisfiability problem of an F arithmetic circuit C:Fn×Fh→Fl is captured by the relation RC={(x,a)∈Fn×Fh:C(x,a)=0l}; its language is LC={x∈Fn : ∃a∈Fh s.t. C(x,a)=0l}.

Given a field F, a (publicly-verifiable preprocessing) zk-SNARK for F. arithmetic circuit satisfiability is a triple of polynomial-time algorithms (KeyGen, Prove, Verify):

KeyGen (1λ,C)→ (pk, vk). On input a security parameter λ (presented in unary) and an F -arithmetic circuit C, the key generator KeyGen probabilistically samples a proving key pk and a verification key vk. Both keys are published as public parameters and can be used, any number of times, to prove/verify membership in LC.

Prove ( pk, x,a)→π. On input a proving key pk and any (x,a)∈RC, the prover Prove outputs a non-interactive proof π for the statement x∈LC.

Verify(vk, x,π)→b. On input a verification key vk, an input x, and a proof π the verifier Verify outputs b=1 if he is convinced that x\in {\cal L}_{C}.

A zk-SNARK satisfies the following properties.

Completeness
For every security parameter \lambda, any {\BBF}- arithmetic circuit C, and any (x, a)\in {\cal R}_{C}, the honest prover can convince the verifier. Namely, b=1 with probability 1 - negl (\lambda) in the following experiment: (pk, vk) \leftarrow KeyGen (1^{\lambda}, C);\pi\leftarrow Prove ({\rm pk}, x, a);b\leftarrow Verify (vk, x, \pi).

Succinctness
An honestly-generated proof \pi has O_{\lambda}(1) hits and Verify ( vk, x, \pi) runs in time O_{\lambda}(\vert x\vert). (Here, O_{\lambda} hides a fixed polynomial factor in \lambda.)

Proof of knowledge(and soundness)
If the verifier accepts a proof output by a bounded prover, then the prover “knows” a witness for the given instance. (In particular, soundness holds against bounded provers.) Namely, for every POly (\lambda)- size adversary {\cal A}, there is a POly (\lambda) -size extractor {\cal E} such that Verify ( vk, x, \pi)=1 and (x, a)\not\in {\cal R}_{C} with probability negl (\lambda) in the following experiment: (pk, vk) \leftarrow KeyGen (1^{\lambda}, C); (x, \pi)\leftarrow {\cal A}({\rm pk}, vk ); a\leftarrow {\cal E}({\rm pk}, vk ).

Perfect Zero Knowledge
An honestly-generated proof is perfect zero knowledge.7 Namely, there is a POly (\lambda) -size simulator Sim such that for all stateful POly (\lambda) -size distinguishers D the following two probabilities are equal:

The probability that {\cal D}(\pi)=1 on an honest proof. {\rm Pr}\left[\matrix{(x,a)\epsilon {\cal R}_{C}&\vert &({\rm Pk},{Vk})\leftarrow {\rm KeyGen}({\rm C})\cr {\cal D}{\pi}=1&\vert &(x,a)\leftarrow {\cal D}({\rm Pk},{Vk})\cr &\vert &{\pi}\leftarrow{rm Prove}({\rm Pk},x,a)}\right]
View Source

The probability that D(\pi)=1 on a simulated proof. {\rm Pr}\left[\matrix{(x,a)\epsilon {\cal R}_{C}&\vert &({\rm Pk},{\ Vk},{\rm trap})\leftarrow {\rm Sim}({\rm C})\cr {\cal D}{\pi}=1&\vert &(x,a)\leftarrow {\cal D}({\rm Pk},{\ Vk})\cr &\vert &{\pi}\leftarrow{rm Sim}({\rm Pk},x,{\rm trap})}\right]
View SourceRight-click on figure for MathML and additional features.

B. Known Constructions and Security
There are many zk-SNARK constructions in the literature [9]–[10][11][12][13][14][15][16]. We are interested in zk-SNARKs for arithmetic circuit satisfiability, and the most efficient ones for this language are based on quadratic arithmetic programs [12], [11], [13], [14], [16]–; such constructions provide a linear-time KeyGen, quasilinear-time Prove, and linear-time Verify.

Security of zk-SNARKs is based on knowledge-of-exponent assumptions and variants of Diffie-Hellman assumptions in bilinear groups [9], [22], [23]. While knowledge-of-exponent assumptions are fairly strong, there is evidence that such assumptions may be inherent for constructing zk-SNARKs [24], [25].

C. Zk-Snark Implementations
There are three published implementations of zk-SNARKs: (i) Parno et al. [13] present an implementation of zk-SNARKs for programs having no data dependencies.8 (ii) Ben-Sasson et al. [14] present an implementation of zk-SNARKs for arbitrary programs (with data dependencies); and (iii) Ben- Sasson et al. [16] present an implementation of zk-SNARKs that supports programs that modify their own code (e.g., for runtime code generation); their implementation also reduces costs for programs of larger size and allows for universal key pairs.

Each of the works above also achieves zk-SNARKs for arithmetic circuit satisfiability as a stepping stone towards their respective higher-level efforts. In this paper we are only interested in a zk-SNARK for arithmetic circuit satisfiability, and we rely on the implementation of [16] for such a zk-SNARK.9 The implementation in [16] is itself based on the protocol of Parno et al. [13]. We thus refer the interested reader to [13] for details of the protocol, its intuition, and its proof of security; and to [16] for the implementation and its performance. In terms of concrete parameters, the implementation of [16] provides 128 bits of security, and the field {\BBF} is of a 256-bit prime order p.

SECTION III.Definition of a Decentralized Anonymous Payment Scheme
We introduce the notion of a decentralized anonymous payment scheme (DAP scheme), extending the notion of decentralized e-cash [8]. Later, in Section IV, we provide a construction.

A. Data Structures
We begin by describing, and giving intuition about, the data structures used by a DAP scheme. The algorithms that use and produce these data structures are introduced in Section III-B.

Basecoin Ledger
Our protocol is applied on top of a ledgerbased base currency such as Bitcoin; for generality we refer to this base currency as Basecoin. At any given time T, all users have access to L_{T}, the ledger at time T, which is a sequence of transactions. The ledger is append-only (i.e., T < T^{\prime} implies that L_{T} is a prefix of L_{T^{\prime}})^{10} The transactions in the ledger include both Basecoin transactions as well as two new transaction types described below.

Public Parameters
A list of public parameters pp is available to all users in the system. These are generated by a trusted party at the “start of time” and are used by the system's algorithms.

Addresses
Each user generates at least one address key pair ({\rm addr}_{{\rm pk}}, {\rm addr}_{{\rm sk}}). The public key {\rm addr}_{{\rm pk}} is published and enables others to direct payments to the user. The secret key {\rm addr}_{{\rm sk}} is used to receive payments sent to {\rm addr}_{{\rm pk}}. A user may generate any number of address key pairs.

Coins
A coin is a data object {\rm c}, to which we associate the following:

Acoin commitment, denoted cm (c): a string that appears on the ledger once {\rm c} is minted.

10

A coin value, denoted v({\rm c}): the denomination of {\bf c}, as measured in basecoins, as an integer between 0 and a maximum value v_{{\rm ma}\times} (which is a system parameter).

A coin serial number, denoted sn (c): a unique string associated with the {\bf c}, used to prevent double spending.

A coin address, denoted {\rm addr}_{{\rm pk}}({\rm c}): an address public key, representing who owns {\bf c}.

Any other quantities associated with a coin c (e.g., various trapdoors) are implementation details.

New Transactions
Besides Basecoin transactions, there are two new types of transactions.

Mint transactions. A mint transaction {\rm tx}_{{\rm Mint}} is a tuple (cm, v, \ast), where cm is a coin commitment, v is a coin value, and \ast denotes other (implementation-dependent) information. The transaction {\rm tx}_{{\rm Mint}} records that a coin c with coin commitment cm and value v has been minted.

Pour transactions. A pour transaction {\rm t}\times {\rm Pour} is a tuple (rt, {\rm sn}_{1}^{{\rm old}}, {\rm sn}_{2}^{{\rm old}}, {\rm cm}_{1}^{{\rm new}}, cm 2^{{\rm new}}, v_{{\rm pu}{\rm b}}, info, \ast), where rt is a root of a Merkle tree, {\rm sn}_{1}^{{\rm old}}, {\rm sn}_{2}^{{\rm old}} are two coin serial numbers, {\rm cm}_{1}^{{\rm ne}{\rm w}}, {\rm cm}_{2}^{{\rm ne}{\rm w}} are two coin commitments, v_{{\rm pu}{\rm b}} is a coin value, info is an arbitrary string, and \ast denotes other (implementation-dependent) information. The transaction {\rm tx}_{{\rm Po}{\rm ur}} records the pouring of two input (and now consumed) coins {\rm C}_{1}^{\circ 1{\rm d}}, {\rm C}_{2^{1{\rm d}}}^{{\rm O}}, with respective serial numbers {\rm sn}_{1}^{\circ 1{\rm d}}, {\rm sn}_{2^{1{\rm d}}}^{{\rm o}}, into two new output coins {\rm c}_{1}^{{\rm ne}{\rm w}}, {\rm c}_{2}^{{\rm ne}{\rm w}}, with respective coin commitments {\rm cm}_{1}^{{\rm ne}{\rm w}}, cm 2{\rm new}, as well as a public output v_{{\rm pu}{\rm b}} (which may be zero). Furthermore, {\rm t}\times {\rm Pour} also records an information string info (perhaps containing information on who is the recipient of v_{{\rm pu}{\rm b}} basecoins) and that, when this transaction was made, the root of the Merkle tree over coin commitments was rt (see below).

Commitments of Minted Coins and Serial Numbers of Spent Coins
For any given time T,

{\rm CM} {\rm List}_{T} denotes the list of all coin commitments appearing in mint and pour transactions in L_{T};

{\rm SN}{\rm List}_{T} denotes the list of all serial numbers appearing in pour transactions in L_{T}.

While both of these lists can be deduced from L_{T}, it will be convenient to think about them as separate (as, in practice, these may be separately maintained due to efficiency reasons).

Merkle Tree Over Commitments
For any given time T, {\rm Tree}_{T} denotes a Merkle tree over {\rm CM}{\rm List}_{T} and {\rm rt}_{{\cal I}} its root. Moreover, the function {\rm Path}_{T} (cm) gives the authentication path from a coin commitment cm appearing in {\rm CM} {\rm List}_{T} to the root of {\rm Tree}_{T}\ \ ^{11} For convenience, we assume that L_{T} also stores {\rm rt} T^{\prime} for all T^{\prime}\leq T (i.e., it stores all past Merkle tree roots).

B. Algorithms
A DAP scheme II is a tuple of polynomial-time algorithms (Setup, CreateAddress, Mint, Pour, Verify Transaction, Receive)11 with the following syntax and semantics.

System Setup
The algorithm Setup generates a list of public parameters:

Algorithm 
The algorithm Setup is executed by a trusted party. The resulting public parameters pp are published and made available to all parties (e.g., by embedding them into the protocol's implementation). The setup is done only once; afterwards, no trusted party is needed, and no global secrets or trapdoors are kept.

Creating Payment Addresses
The algorithm CreateAddress generates a new address key pair:

Algorithm 
Each user generates at least one address key pair ({\rm addr}_{{\rm pk}}, {\rm addr}_{{\rm sk}}) in order to receive coins. The public key {\rm addr}_{{\rm pk}} is published, while the secret key {\rm addr}_{{\rm sk}} is used to redeem coins sent to {\rm addr}_{{\rm pk}}. A user may generate any number of address key pairs; doing so does not require any interaction.

Minting Coins
The algorithm Mint generates a coin (of a given value) and a mint transaction:

Algorithm 
A system parameter, v_{\max}, caps the value of any single coin. The output coin c has value v and coin address {\rm addr}_{{\rm pk}}; the output mint transaction {\rm tx}_{{\rm Min} {\rm t}} equals (cm, v,\ast), where cm is the coin commitment of {\bf c}.

Pouring Coins
The Pour algorithm transfers value from input coins into new output coins, marking the input coins as consumed. Moreover, a fraction of the input value may be publicly revealed. Pouring allows users to subdivide coins into smaller denominations, merge coins, and transfer ownership of anonymous coins, or make public payments.12

Algorithm 
Thus, the Pour algorithm takes as input two distinct input coins {\rm c}_{1}^{{\rm old}}, {\rm c}_{2}^{{\rm old}}, along with corresponding address secret keys {\rm addr}_{{\rm sk},1}^{{\rm old}}, {\rm add}{\rm r}_{{\rm sk},2}^{{\rm old}} (required to redeem the two input coins). To ensure that {\rm c}_{1}^{\rm old},{\rm c}_{2}^{\rm old} have been previously minted, the Pour algorithm also takes as input the Merkle root rt (allegedly, equal to the root of Merkle tree over all coin commitments so far), along with two authentication paths path1, path2, for the two coin commitments cm ({\rm c}_{1}^{{\rm old}}), cm ({\rm c}_{2}^{{\rm old}}). Two input values v_{1}^{{\rm ne}{\rm w}}, v_{2}^{{\rm ne}{\rm w}} specify the values of two new anonymous coins {\rm c}_{1}^{{\rm ne}{\rm w}}, {\rm c}_{2}^{{\rm ne}{\rm w}} to be generated, and two input address public keys {\rm addr}_{{\rm pk},1}^{{\rm ne}{\rm w}}, {\rm addr}_{{\rm pk},2}^{{\rm ne}{\rm w}} specify the recipients of {\rm c}_{1}^{{\rm ne}{\rm w}}, {\rm c}_{2}^{{\rm ne}{\rm w}}. A third value, vpub, specifies the amount to be publicly spent (e.g., to redeem coins or pay transaction fees). The sum of output values v_{1}+v_{2}+v pub must be equal to the sum of the values of the input coins (and cannot exceed v_{{\rm ma}\times})’ Finally, the Pour algorithm also receives an arbitrary string info, which is bound into the output pour transaction {\rm t}\times {\rm Pour}.

The Pour algorithm outputs two new coins {\rm c}_{1}^{{\rm ne}{\rm w}}, {\rm c}_{2}^{{\rm ne}{\rm w}} and a pour transaction {\rm tx}_{{\rm Pour}}. The transaction {\rm t}\times_{{\rm Pour}} equals ( rt, {\rm sn}_{1}^{{\rm o}1{\rm d}}, {\rm sn}_{2}^{{\rm o}1{\rm d}}, {\rm cm}_{1}^{{\rm ne}{\rm w}}, cm 2{\rm new}, v_{{\rm pub}}, info, \ast), where {\rm cm}_{1}^{{\rm ne}{\rm w}}, cm 2{\rm new} are the two coin commitments of the two output coins, and \ast denotes other (implementation-dependent) information. Crucially, {\rm t}\timesPour reveals only one currency value, the public value vpub (which may be zero); it does not reveal the payment addresses or values of the old or new coins.

Verifying Transactions
The algorithm VerifyTransaction checks the validity of a transaction:


Both mint and pour transactions must be verified before being considered well-formed. In practice, transactions can be verified by the nodes in the distributed system maintaining the ledger, as well as by users who rely on these transactions.

Receiving Coins
The algorithm Receive scans the ledger and retrieves unspent coins paid to a particular user address:

Algorithm 
When a user with address key pair ({\rm addr}_{{\rm pk}}, {\rm addr}_{{\rm sk}}) wishes to receive payments sent to {\rm addr}_{{\rm pk}}, he uses the Receive algorithm to scan the ledger. For each payment to {\rm addr}_{{\rm pk}} appearing in the ledger, Receive outputs the corresponding coins whose serial numbers do not appear on the ledger L. Coins received in this way may be spent, just like minted coins, using the Pour algorithm. (We only require Receive to detect coins paid to {\rm addr}_{{\rm pk}} via the Pour algorithm and not also detect coins minted by the user himself.)

Next, we describe completeness (Section III-C) and security (Section III-D.

C. Completeness
Completeness of a DAP scheme requires that unspent coins can be spent. More precisely, consider a ledger sampler S outputting a ledger L. If {\rm c}_{1} and {\rm c}_{2} are two coins whose coin commitments appear in (valid) transactions on L, but their serial numbers do not appear in L, then {\rm c}_{1} and {\rm c}_{2} can be spent using Pour. Namely, running Pour results in a pour transaction {\rm tx}_{{\rm Po}{\rm ur}} that Verify Transaction accepts, and the new coins can be received by the intended recipients (by using Receive); moreover, {\rm tx}_{{\rm Po}{\rm ut}} correctly records the intended vpub and transaction string info. This property is formalized via an incompleteness experiment INCOMP.

Definition III.1
A DAP scheme \Pi=( Setup, Create/vddress, Mint, Pour, Verify Transaction, Receive) is complete if no polynomial-size ledger sampler S wins INCOMP with more than negligible probability.

D. Security
Security of a DAP scheme is characterized by three properties, which we call ledger indistinguishability, transaction non-malleability, and balance.

Definition III.2
A DAP scheme {{\Pi}=} (Setup, {\rm C} reateAddress, Mint, Pour, VerifyTransaction, Receive) is secure if it satisfies ledger indistinguishability, transaction non-malleability, and balance.

Below, we provide an informal overview of each property, and defer formal definitions to the extended version of this paper [26].

Each property is formalized as a game between an adversary {\cal A} and a challenger C. In each game, the behavior of honest parties is realized via a DAP scheme oracle {\cal O} DAP, which maintains a ledger L and provides an interface for executing CreateAddress, Mint, Pour and Receive algorithms for honest parties. To elicit behavior from honest parties, {\cal A} passes a query to C, which (after sanity checks) proxies the query to {\cal O}^{{\rm DAP}}. For each query that requests an honest party to perform an action, {\cal A} specifies identities of previous transactions and the input values, and learns the resulting transaction, but not any of the secrets or trapdoors involved in producing that transaction. The oracle {\cal O}^{{\rm DAP}} also provides an Insert query that allows {\cal A} to directly add aribtrary transactions to the ledger L.

Ledger Indistinguishability
This property captures the requirement that the ledger reveals no new information to the adversary beyond the publicly-revealed information (values of minted coins, public values, information strings, total number of transactions, etc.), even when the adversary can adaptively induce honest parties to perform DAP operations of his choice. That is, no bounded adversary {\cal A} can distinguish between two ledgers L_{0} and L_{1}, constructed by A using queries to two DAP scheme oracles, when the queries to the two oracles are publicly consistent: they have matching type and are identical in terms of publicly-revealed information and the information related to addresses controlled by A.

Ledger indistinguishability is formalized by an experiment L-IND that proceeds as follows. First, a challenger samples a random bit b and initializes two DAP scheme oracles {\cal O}_{0}^{{\rm DA}{\rm P}} and {\cal O}_{1}^{{\rm DA}{\rm P}}, maintaining ledgers L_{0} and L_{1}. Throughout, the challenger allows {\cal A} to issue queries to {\cal O}_{0}^{{\rm DA}{\rm P}} and {\cal O}_{1}^{{\rm DA}{\rm P}}, thus controlling the behavior of honest parties on L_{0} and L_{1}. The challenger provides the adversary with the view of both ledgers, but in randomized order: L_{{\rm Le}{\rm ft}}:=L_{b} and L_{{\rm Ri}} ght :=L_{1-b}. The adversary's goal is to distinguish whether the view he sees corresponds to (L_{{\rm Le}{\rm ft}}, L Right) =(L_{0}, L_{1}), i.e. b=0, or to (L_{{\rm Le}{\rm ft}}, L Right) =(L_{1}, L_{0}), i.e. b=1.

At each round of the experiment, the adversary issues queries in pairs Q, Q^{1} of matching query type. If the query type is CreateAddress, then the same address is generated at both oracles. If it is to Mint, Pour or Receive, then Q is forwarded to L_{0} and Q^{\prime} to L_{1}; for Insert queries, query Q is forwarded to L_{{\rm Le}{\rm ft}} and Q^{\prime} is forwarded to LRight. The adversary's queries are restricted in the sense that they must maintain the public consistency of the two ledgers. For example, the public values for Pour queries must be the same, as well as minted amounts for Mint queries.

At the conclusion of the experiment, A outputs a guess b^{\prime}, and wins when b=b^{\prime}. Ledger indistinguishability requires that {\cal A} wins L-IND with probability at most negligibly greater than 1/2.

Transaction Non-Malleability
This property requires that no bounded adversary {\cal A} can alter any of the data stored within a (valid) pour transaction {\rm tx}_{{\rm Pour}}. This transaction non- malleability prevents malicious attackers from modifying others' transactions before they are added to the ledger (e.g., by retargeting the Basecoin public output of a pour transaction).

Transaction non-malleability is formalized by an experiment TR-NM, in which {\cal A} adaptively interacts with a DAP scheme oracle {\cal O}^{{\rm DAP}} and then outputs a pour transaction tx*. Letting {\cal T} denote the set of pour transactions returned by {\cal O}^{{\rm DAP}}, and L denote the final ledger, {\cal A} wins the game if there exists tx \in {\cal T}, such that (i) {\rm t}\times^{\ast}\neq tx; (ii) tx* reveals a serial number contained in {\rm t}\times; and (iii) both tx and tx* are valid with respect to the ledger L^{\prime} containing all transactions preceding tx on L. In other words, {\cal A} wins the game if txt manages to modify some previous pour transaction to spend the same coin in a different way.

Transaction non-malleability requires that {\cal A} wins TR-NM with only negligible probability. (Note that {\cal A} can of course produce valid pour transactions that are unrelated to those in {\cal T}; the condition that {\rm t}\times^{\ast} reveals a serial number of a previously- spent coin captures non-malleability.)

Balance
This property requires that no bounded adversary {\cal A} can own more money than what he minted or received via payments from others.

Balance is formalized by an experiment BAL, in which {\cal A} adaptively interacts with a DAP scheme oracle {\cal O}^{\rm DAP} and then outputs a set of coins S_{{\rm co}{\rm in}}. Letting S_{{\rm ad}{\rm dr}} be set of addresses returned by CreateAddress queries (i.e., addresses of “honest” users), {\cal A} wins the game if the total value he can spend or has spent (either as coins or Basecoin public outputs) is greater than the value he has received or mined. That is, {\cal A} wins if v\cup nspent +v_{{\rm Ba}{\rm se}{\rm co}1{\rm n}}+v_{A\rightarrow {\rm AD}{\rm DR}}>v_{{\rm M}}\vert nt +v_{{\rm AD}{\rm DR}\rightarrow A} where: (i) v_{\cup} nspent is the total value of unspent coins in S_{{\rm co}{\rm in}}; (ii) v_{{\rm Basecoin}} is the total value of public outputs placed by {\cal A} on the ledger; (iii) v_{{\rm M}}\vert nt is the total value of {\cal A} 's mint transactions; (iv) v_{{\rm AD}{\rm DR}\rightarrow A} is the total value of payments received by A from addresses in S_{{\rm ad}{\rm dr}};({\rm v})v_{A\rightarrow {\rm AD}{\rm DR}} is the total value of payments sent by {\cal A} to addresses in S_{{\rm ad}{\rm dr}}.

Balance requires that A wins BAL with only negligible probability.

SECTION IV.Construction of a Decentralized Anonymous Payment Scheme
We show how to construct a DAP scheme (introduced in Section III) using zk-SNARKs and other building blocks. Later, in Section V, we give a concrete instantiation of this construction.

A. Cryptographic Building Blocks
We first introduce notation for the standard cryptographic building blocks that we use. We assume familiarity with the definitions of these building blocks; for more details, see, e.g., [27]. Throughout, \lambda denotes the security parameter.

Collision-Resistant Hashing
We use a collision-resistant hash function CRH: \{0,1\}^{\ast}\rightarrow\{0,1\}^{O(\lambda)}.

Pseudorandom Functions
We use a pseudorandom function family PRF = \{ PRF x:\{0,1\}^{\ast}\rightarrow\{0,1\}^{O(\lambda)}\}_{x} where x denotes the seed. From PRF x, we derive three “non-overlapping” pseudorandom functions, chosen arbitrarily as PRFxaddr {(z):= {\rm PRF}_{x}(00\Vert z), {\rm PRF}_{x}^{{\rm sn}}(z): = {\rm PRF}_{x}(01\Vert z) {\rm PRF}_{x}^{{\rm pk}}(z)-:=} PRF x(10\Vert z). Furthermore, we assume that PRFsnis also collision resistant, in the sense that it is infeasible to find (x, z)\neq(x^{\prime}, z^{\prime}) such that PR {{\rm F}_{x}^{{\rm sn}}(z)=} PR {\rm F}_{x}^{{\rm sn}}(z^{\prime}).

Statistically-Hiding Commitments
We use a commitment scheme COMM where the binding property holds computationally, while the hiding property holds statistically. It is denoted \{{\rm COMM}_{x}:\{0,1\}^{\ast}\rightarrow\{0,1\}^{O(\lambda)}\}_{x} where x denotes the commitment trapdoor. Namely, to reveal a commitment cm to a value z, it suffices to provide z and the trapdoor x; then one can check that cm ={\rm C} OMM x(z).

One-Time Strongly-Unforgeable Digital Signatures
We use a digital signature scheme Sig =({\cal G}_{{\rm si}{\rm gs}\vert }{\cal K}_{{\rm gs}\vert }S_{{\rm gs}\vert }{\cal V}_{{\rm g}}) that works as follows.

{\cal G}_{{\rm si}{\rm g}}(1^{\lambda})\rightarrow {\rm pp}_{{\rm S}1}{\rm g}. Given a security parameter \lambda (presented in unary), {\cal G}_{{\rm sig}} samples public parameters {\rm pp}_{{\rm en}{\rm c}} for the encryption scheme.

{\cal K}_{{\rm S}1}\cdot {\rm g}({\rm pp}_{{\rm si}{\rm g}})\rightarrow({\rm pk}_{{\rm si}{\rm g}}, {\rm sk}_{{\rm si}{\rm g}}). Given public parameters {\rm pp}_{{\rm s}1{\rm g}}, {\cal K}_{{\rm sig}} samples a public key and a secret key for a single user.

S_{{\rm si}{\rm g}}({\rm sk}_{{\rm sig}}, m)\rightarrow\sigma. Given a secret key {\rm sk}_{{\rm si}{\rm g}} and a message m, S_{{\rm si}{\rm g}} signs m to obtain a signature \sigma.

{\cal V}_{{\rm S}1}{\rm g}({\rm pk}_{{\rm si}{\rm g}}, m, \sigma)\rightarrow b. Given a public key {\rm pk}_{{\rm sig}}, message m, and signature \sigma, {\cal V}_{{\rm sig}} outputs b=1 if the signature \sigma is valid for message m; else it outputs b=0.

The signature scheme Sig satisfies the security property of one-time strong unforgeability against chosen-message attacks (SUF-1GMA security).

Key-Private Public-Key Encryption
We use a public-key encryption scheme Enc =({\cal G}_{{\rm en}{\rm c}}, {\cal K}_{{\rm en}{\rm c}}, {\cal E}_{{\rm en}{\rm c}}, {\cal D}_{{\rm en}{\rm c}}) that works as follows.

{\cal G}_{{\rm en}{\rm c}}(1^{\lambda})\rightarrow {\rm pp}_{{\rm en}{\rm c}}. Given a security parameter \lambda (presented in unary), {\cal G}_{{\rm en}{\Fraktur c}} samples public parameters {\rm pp}_{{\rm en}{\rm c}} for the encryption scheme.

• {\cal K}_{{\rm en}{\rm c}}({\rm pp}_{{\rm en}{\rm c}})\rightarrow({\rm pk}_{{\rm en}{\rm c}}, {\rm sk}_{{\rm en}{\rm c}}). Given public parameters {\rm pp}_{{\rm en}{\rm c}}, {\cal K}_{{\rm en}{\rm c}} samples a public key and a secret key for a single user.

{\cal E}_{{\rm en}{\rm c}}({\rm pk}_{{\rm en}{\rm c}}, m)\rightarrow c. Given a public key {\rm pk}_{{\rm en}{\rm c}} and a message m, {\cal E}_{{\rm en}{\rm c}} encrypts m to obtain a ciphertext c.

{\cal D}_{{\rm en}{\rm c}}({\rm sk}_{{\rm en}{\rm c}}, c)\rightarrow m. Given a secret key {\rm sk}_{{\rm en}{\rm c}} and a ciphertext c, D_{{\rm en}{\rm c}} decrypts c to produce a message m (or \perp if decryption fails).

The encryption scheme Enc satisfies two security properties: (i) ciphertext indistinguishability under chosen-ciphertext attack (IND-GGA security); and (ii) key indistinguishability under chosen-ciphertext attack (IK-CCA security). While the first property is standard, the second is less known; informally, IK-CCA requires that ciphertexts cannot be linked to the public key used to encrypt them, or to other ciphertexts encrypted with the same public key. For definitions, we refer the reader to [21].

B. Zk-Snarks for Pouring Coins
As outlined in Section 1-B, our construction invokes a zk-SNARK for a specific NP statement, POUR, which we now define. We first recall the context motivating POUR. When a user u pours “old” coins {\rm c}_{{1}}^{{\rm old}}, {\rm c}_{2}^{{\rm old}} into new coins {\rm c}_{1}^{{\rm ne}{\rm w}}, {\rm c}_{2}^{{\rm ne}{\rm w}}, a corresponding pour transaction{\rm t}\times {\rm p}_{{\rm ou}{\rm r}}=({\rm rt}, {\rm sn}_{1}^{01{\rm d}}, {\rm sn}_{2}^{01{\rm d}}, {\rm cm}_{1}^{{\rm ne}{\rm w}}, {\rm cm} 2{\rm new}, v_{{\rm pu}{\rm b}}, {\rm info}, \ast)
View SourceRight-click on figure for MathML and additional features.is generated. In our construction, we need to provide evidence in “*” that various conditions were respected by the pour operation. Concretely, {\rm tx}_{{\rm Pour}} should demonstrate that (i) u owns {\rm C}_{1}^{{\rm old}}, {\rm C}_{2}^{{\rm old}}; (ii) coin commitments for {\rm c}_{1}^{{\rm old}}, {\rm c}_{2}^{{\rm old}} appear somewhere on the ledger; (iii) the revealed serial numbers {\rm sn}_{1}^{{\rm old}}, {\rm sn}_{2}^{{\rm old}} are of {\rm C}_{1}^{\circ 1{\rm d}}, {\rm C}_{2}^{\circ 1{\rm d}}; (iv) the revealed coin commitments {\rm cm}_{1}^{{\rm ne}{\rm w}}, {\rm cm}_{2}^{{\rm ne}{\rm w}} are of {\rm c}_{1}^{{\rm ne}{\rm w}}, {\rm c}_{2}^{{\rm ne}{\rm w}};({\rm v}) balance is preserved. Our construction achieves this by including a zk-SNARK proof \pi_{{\rm POUR}} for the statement POUR which checks the above invariants (as well as others needed for non-malleability).

The Statement Pour
Concretely, the NP statement POUR is defined as follows.

Instances are of the form \vec{x}= (rt, {\rm sn}_{1^{1{\rm d}}}^{{\rm o}}, {\rm sn}_{2^{1{\rm d}}}^{{\rm o}}, {\rm cm}_{1}^{{\rm ne}{\rm w}}, cm 2{\rm new}, v_{{\rm pu}{\rm b}}, h_{{\rm Si}{\rm g}}, h_{1}, h_{2}). Thus, an instance \vec{x} specifies a root rt for a CRH- based Merkle tree (over the list of commitments so far), the two serial numbers of the consumed coins, two coin commitments for the two new coins, a public value, and fields h_{{\rm Si}{\rm g}}, h_{1}, h_{2} used for non-malleability.

Witnesses are of the form \vec{a}=({\rm path}_{1}, {\rm path}2, {\rm C}_{1}^{{\rm old}}, {\rm C}_{2}^{{\rm old}}, where, for each i\in\{1,2\}: \eqalignno{ &{\rm c}_{i}^{{\rm old}}= ({\rm add} {\rm r}_{{\rm pk},i}^{{\rm old}}, v_{i}^{{\rm old}}, \rho_{i}^{{\rm old}}, r_{i}^{{\rm old}}, s_{i}^{{\rm old}}, {\rm cm}_{i}^{{\rm old}})\cr &{\rm c}_{i}^{{\rm new}}= ({\rm addr}_{{\rm pk},i}^{{\rm new}}, v_{i}^{{\rm new}}, \rho_{i}^{{\rm new}}, r_{i}^{{\rm new}}, s_{i}^{{\rm new}}, {\rm cm}_{i}^{{\rm new}}) }
View SourceRight-click on figure for MathML and additional features.

for the same {\rm cm}_{i}^{{\rm ne}{\rm w}} as in \vec{x}, \eqalignno{ &{\rm addr}_{{\rm pk},i}^{{\rm old}} = (a_{{\rm pk},i}^{{\rm old}}, {\rm pk}_{{\rm enc},i}^{{\rm old}})\cr &{\rm addr}_{{\rm pk},i}^{{\rm ne}{\rm w}}=(a_{{\rm pk},i}^{{\rm ne}{\rm w}}, {\rm pk}_{{\rm en}{\rm c},i}^{{\rm ne}{\rm w}})\, \cr &{\rm addr} _{{\rm sk},i}^{{\rm old}}=(a_{{\rm sk},i}^{{\rm old}}, {\rm sk}_{{\rm enc},i}^{{\rm old}}) }
View SourceRight-click on figure for MathML and additional features.

Thus, a witness \vec{\alpha} specifies authentication paths for the two new coin commitments, the entirety of coin information about both the old and new coins, and address secret keys for the old coins.

Given a POUR instance \vec{x}. a witness \vec{a} is valid for \vec{x} if the following holds:

1) For Each i\in\{1, {\rm Z}\}
The coin commitment {\rm cm}_{i}^{{\rm old}} of {\rm C}_{i}^{\rm old} appears on the ledger, i.e., {\rm path}_{i} is a valid authentication path for leaf {\rm cm}_{i}^{{\rm old}} with respect to root rt, in a CRH-based Merkle tree.

b) The address secret key a_{{\rm sk},i}^{{\rm old}} matches the address public key of {\rm C}_{i}^{{\rm old}}, i.e., a_{{\rm pk},i}^{\circ 1{\rm d}}={\rm PRF}_{a_{{\rm sk}i}^{\circ 1{\rm d}}}^{{\rm ad}{\rm dr}}(0).

The serial number {\rm sn}_{i}^{{\rm old}} of {\rm c}_{i}^{{\rm old}} is computed correctly, i.e., {\rm sn}_{i}^{\circ 1{\rm d}}={\rm PRF}_{a_{{\rm sk}.i}^{\circ {\rm d}}}^{{\rm sn}}\vert (\rho_{i}^{\circ 1{\rm d}}).

d) The coin {\rm C}_{i}^{\rm old} is well-formed, i.e., {\rm cm}_{i}^{{\rm old}} COM {\rm M}_{s_{i}^{\circ 1{\rm d}}} (COM {\rm M}_{r_{i}^{\circ 1{\rm d}}}(a_{{\rm pk},i}^{01{\rm d}}\Vert\rho_{i}^{01{\rm d}})\Vert v_{i}^{01{\rm d}}).

The coin {\rm c}_{i}^{{\rm ne}{\rm w}} is well-formed, i.e., {\rm cm}_{i}^{{\rm ne}{\rm w}} = CO M {\rm M}_{s_{i}^{{\rm ne}{\rm w}}} ({\rm COM}\ {\rm M}_{r_{\dot{x}}^{{\rm ne}{\rm w}}}(a_{{\rm pk},i}^{{\rm ne}{\rm w}}\Vert\rho_{i}^{{\rm ne}{\rm w}})\Vert v_{i}^{{\rm ne}{\rm w}}).

The address secret key \dot{a}_{{\rm sk},i}^{{\rm O}}\vert {\rm d} ties h_{{\rm Si}{\rm g}} to h_{i}, i.e., h_{i}= {\rm PRF}_{a_{{\rm sk}i}^{\circ 1{\rm d}}}^{{\rm pk}}.(h_{{\rm Si}{\rm g}}).

v_{1}^{\circ 1{\rm d}}, v_{2}^{\circ 1{\rm d}}\geq 0 and v_{1}^{\circ 1{\rm d}}+v_{2}^{\circ 1{\rm d}}\leq v_{{\rm ma}\times}).

Recall that in this paper zk-SNARKs are relative to the language of arithmetic circuit satisfiability (see Section II); thus, we express the checks in POUR via an arithmetic circuit, denoted C_{{\rm PO}{\rm UR}}. In particular, the depth d_{{\rm tr}{\rm ee}} of the Merkle tree needs to be hardcoded in C_{{\rm POUR}}, and we thus make it a parameter of our construction (see below); the maximum number of supported coins is then 2 d_{{\rm t}\varpi}.

C. Algorithm Constructions
We proceed to describe the construction of the DAP scheme \Pi (Setup, CreateAddress, Mint, Pour, Verify Transaction, Receive) whose intuition was given in. Figure 2 gives the pseudocode for each one of the six algorithms in \Pi, in terms of the building blocks introduced in Section IV-A and Section IV-B. In the construction, we hardcode two quantities:

2) Balance is Preserved
v_{1}^{{\rm ne}{\rm w}}+v_{2}^{{\rm ne}{\rm w}}+v pub =v_{1}^{{\rm old}}+v_{2}^{{\rm old}} (with the maximum value of a coin, v_{\max}, and the depth of the Merkle tree, d_{{\rm tr}{\rm ee}}.

Fig. 2: - Construction of a DAP scheme using zk-snarks and other ingredients.
Fig. 2:
Construction of a DAP scheme using zk-snarks and other ingredients.

Show All

D. Completeness and Security
Our main theorem states that the above construction is indeed a DAP scheme.

Theorem IV.1
The tuple {\Pi=} (Setu {\rm p}, {\rm C} reate/id {\rm d} ress, Mint. Pour, Verify Transaction, Receive), as defined in Section IV-C, is a complete (cf. Definition III.1) and secure (cf. Definition III.2) DAP scheme.

We provide a proof of Theorem IV.1 in the extended version of this paper [26]. We note that our construction can be modified to yield statistical (i.e., everlasting) anonymity; see the discussion in the extension section of the full version of this paper.

Remark(trusted setup)
Security of ∏ relies on a trusted party running Setup to generate the public parameters (once and for all). This trust is needed for the transaction non-malleability and balance properties but not for ledger indistinguishability. Thus, even if a powerful espionage agency were to corrupt the setup, anonymity will still be maintained. Moreover, if one wishes to mitigate the trust requirements of this step, one can conduct the computation of Setup using secure multiparty computation techniques; we leave this to future work.

SECTION V.Zerocash
We describe a concrete instantiation of a DAP scheme; this instantiation forms the basis of Zerocash. Later, in Section VI, we discuss how Zerocash can be integrated with existing ledger- based currencies.

A. Instantiation of Building Blocks
We instantiate the DAP scheme construction from Section IV (see Figure 2), aiming at a level of security of 128 bits. Doing so requires concrete choices, described next.

Crh, Prf, Comm from sha256
Let {\cal H} be the SHA256 compression function, which maps a 512-bit input to a 256-bit output. We mostly rely on {\cal H}, rather than the “full” hash, since this suffices for our fixed-size single-block inputs, and it simplifies the construction of C_{{\rm PO}{\rm UR}} We instantiate CRH, P RF, COM M via {\cal H} (under suitable assumptions on {\cal H}).

First, we instantiate the collision-resistant hash function CRH as {\cal H}(z) for z\in\{0,1\}^{512}; this function compresses “two-to-one”, so it can be used to construct binary Merkle trees.13

Next, we instantiate the pseudorandom function PRF x(z) as {\cal H}(x\Vert z), with x\in\{0,1\}^{256} as the seed, and z\in\{0,1\}^{256} as the input.14 Thus, the derived functions are PRFxaddr (z):= {\cal H}(x\Vert\overline{0}0\Vert z), {\rm PRF}_{x}^{{\rm sn}}(z): ={\cal H}(x\Vert 01\Vert z) and {\rm PR}\overline{{\rm F}}_{x}^{{\rm pk}}(z):= {\cal H}(x\Vert 10\Vert z), with x\in\{0,1\}^{256} and z\in\{0,1\}^{254}.

As for the commitment scheme COMM, we only use it in the following pattern:\eqalignno{ &k: = {\rm COMM}r(a_{{\rm pk}}\Vert\rho)\cr &{\rm cm}\ : = {\rm COMM} s(v\Vert k) }
View Source

Due to our instantiation of PRF, a_{{\rm pk}} is 256 bits. So we can set \rho also to 256 bits and r to 256+128=384 bits; then we can compute {k:=} COM {\rm M}_{r}(a_{{\rm pk}}\Vert\rho) as {\cal H}(r\Vert[{\cal H}(a_{{\rm pk}}\Vert\rho)]_{128}). Above, [\cdot]_{128} denotes that we are truncating the 256-bit string to 128 bits (say, by dropping least-significant bits, as in our implementation). Heuristically, for any string x\in\{0,1\}^{128}, the distribution induced by {\cal H}(r\Vert x) is 2^{-128} -close to uniform, and this forms the basis of the statistically-hiding property. For computing cm, we set coin values to be 64-bit integers (so that, in particular, v_{{\rm ma}\times}=2^{64}-1 in our implementation), and then compute cm := COMM s(v\Vert k) as {\cal H}(k\Vert 0^{192}\Vert v). Noticeably, above we are ignoring the commitment randomness s. The reason is that we already know that k, being the output of a statistically-hiding commitment, can serve as randomness for the next commitment scheme.

Instantiating the Np Statement Pour
The above choices imply a concrete instantiation of the N P statement POUR (see Section IV-B). Specifically, in our implementation, POUR checks that the following holds, for each i\in\{1,2\}:

{\rm path}_{i} is an authentication path for leaf {\rm cm}_{i}^{{\rm old}} with respect to root rt, in a CRH-based Merkle tree;:

{\rm cm}_{i}^{\circ 1{\rm d}}={\cal H}({\cal H}(r_{i}^{\circ 1{\rm d}}\Vert[{\cal H}(a_{{\rm pk},i}^{\circ 1{\rm d}}\Vert\rho_{i}^{\circ 1{\rm d}})]_{128})\Vert 0^{192}\Vert v_{i}^{\circ 1{\rm d}});

Cminew ={\cal H}({\cal H}(r_{i}^{{\rm ne}{\rm w}}\Vert[{\cal H}(a_{{\rm pk},i}^{{\rm ne}{\rm w}}\Vert\rho_{i}^{{\rm ne}{\rm w}})]_{128})\Vert 0^{192}\Vert v_{i}^{{\rm ne}{\rm w}}); and

h_{i}={\cal H}(a_{{\rm sk},i}^{{\rm O}}\vert {\rm d}\Vert 10\Vert[h_{{\rm Sg}}\vert ]_{254}).

Moreover, POUR checks that v_{1}^{{\rm new}}+v_{2}^{{\rm new}}+v_{{\rm pub}}=v_{1}^{{\rm old}}+v_{2}^{{\rm old}}, with v_{1}^{{\rm old}}, v_{2}^{{\rm old}} \geq 0 and v_{1}^{\circ 1{\rm d}}+v_{2}^{\circ 1{\rm d}} < 2^{64}.

Finally, as mentioned, in order for C_{{\rm PO}{\rm UR}} to be well-defined, we need to fix a Merkle tree depth d_{{\rm tr}{\rm ee}}. In our implementation, we fix d_{{\rm tr}{\rm ee}}=64, and thus support up to 264 coins.

Instantiating Sig
For the signature scheme Sig, we use ECDSA to retain consistency and compatibility with the existing bitcoind source code. However, standard ECDSA is malleable: both (r, s) and (r, -s) verify as valid signatures. We use a non-malleable variant, where s is restricted to the “lower half” of field elements. While we are not aware of a formal SUF-CMA proof for this variant, its use is consistent with proposals to resolve Bitcoin transaction malleability [29].15

Instantiating Enc
For the encryption scheme Enc, we use the key-private Elliptic-Curve Integrated Encryption Scheme (ECIES) [30], [31]; it is one of the few standardized key-private encryption schemes with available implementations.

For further details about efficiently realizing these in the arithmetic circuit for POUR, see the full version of this paper.

SECTION VI.Integration with Existing Ledger-Based Currencies
Zerocash can be deployed atop any ledger (even one maintained by a central bank.) Here, we briefly detail integration with the Bitcoin protocol. Unless explicitly stated otherwise, in the following section when referring to Bitcoin, and its unit of account bitcoin (plural bitcoins), we mean the underlying protocol and software, not the currency system. (The discussion holds, with little or no modification, for many forks of Bitcoin, a.k.a. “altcoins”, such as Litecoin.)

By introducing new transaction types and payment semantics, Zerocash breaks compatibility with the Bitcoin network. While Zerocash could be integrated into Bitcoin (the actual currency and its supporting software) via a “flag day” where a super- majority of Bitcoin miners simultaneously adopt the new software, we neither expect nor advise such integration in the near future and suggest using Zerocash in a separate altcoin.

Integrating Zerocash into Bitcoin consists of adding a new transaction type, Zerocash transactions, and modifying the protocol and software to invoke Zerocash's DAP interface to create and verify these transactions. Two approaches to doing so are described next, followed by a discussion of anonymizing the network layer.

A. Integration by Replacing the Base Currency
One approach is to alter the underlying system so that all monetary transactions are done using Zerocash, i.e., by invoking the DAP interface and writing/reading the associated transactions in the distributed ledger.

As seen in Section III, this suffices to offer the core functionality of payments, minting, merging, splitting, etc., while assuring users that all transactions using this currency are anonymous. However, this has several drawbacks: all transactions incur the cost of generating a zk-SNARK proof; the scripting feature of Bitcoin is lost; and Bitcoin's ability to spend unconfirmed transactions is lost.

B. Integration by Hybrid Currency
A different approach is to extend Bitcoin with a parallel, anonymized currency of “zerocoins,” existing alongside bit- coins, using the same ledger, and with the ability to convert freely between the two. The behavior and functionality of regular bitcoins is unaltered; in particular, they may support functionality such as scripting.

In this approach, the Bitcoin ledger consists of Bitcoin-style transactions, containing inputs and outputs [20]. Each input is either a pointer to an output of a previous transaction (as in plain Bitcoin), or a Zerocash pour transaction (which contributes its public value, v_{{\rm pu}{\rm b}}. of bitcoins to this transaction). Outputs are eithers an amount and destination public address/script (as in plain Bitcoin), or a Zerocash mint transaction (which consumes the input bitcoins to produce zerocoins). The usual invariant over bitcoins is maintained and checked in plain view: the sum of bitcoin inputs (including pours' vpub) must be at least the sum of bitcoin outputs (including mints' v), and any difference is offered as a transaction fee. However, the accounting for zerocoins consumed and produced is done separately and implicitly by the DAP scheme.

C. Additional Anonymity Considerations
Zerocash only anonymizes the transaction ledger. Network traffic used to announce transactions, retrieve blocks, and contact merchants will still leak identifying information (e.g., IP addresses). Thus users need some anonymity network to safely use Zerocash. The most obvious way to do this is via Tor [32]. Given that Zerocash transactions are not low latency themselves, Mixnets (e.g., Mixminion [33]) are also a viable way to add anonymity (and one that is not as vulnerable to traffic analysis as Tor). Using mixnets that provide email-like functionality has the added benefit of providing an out-of-band notification mechanism as a replacement to Receive.

Additionally, although in theory all users have a single view of the block chain, a powerful attacker could potentially fabricate an additional block solely for a targeted user. Spending any coins with respect to the updated Merkle tree in this “poison-pill” block will uniquely identify the targeted user. To mitigate such attacks, users should check with trusted peers their view of the block chain and, for sensitive transactions, only spend coins relative to blocks further back in the ledger (since creating the illusion for multiple blocks is far harder).

SECTION VII.Experiments
To measure the performance of Zerocash, we ran several experiments. First, we benchmarked the performance of the zk-SNARK for the NP statement POUR (Section VII-A) and of the six DAP scheme algorithms (Section VII-B). Second, we studied the impact of a higher block verification time via a simulation of a Bitcoin network (Section VII-C).

A. Performance of Zk-Snarks for Pouring Coins
Our zk-SNARK for the NP statement POUR is obtained by constructing an arithmetic circuit C_{{\rm PO}{\rm UR}} for verifying POUR, and then invoking the generic implementation of zk-SNARK for arithmetic circuit satisfiability of [16] (see Section II-C). The arithmetic circuit C_{{\rm PO}{\rm UR}} is built from scratch and hand- optimized to exploit nondeterministic verification and the large field characteristic.

Figure 3 reports performance characteristics of the resulting zk-SNARK for POUR. This includes three settings: single- thread performance on a laptop machine; and single-thread and multi-thread performance on a desktop machine. (The time measurements are the average of 10 runs, with standard deviation under 2.5 %.)

B. Performance of Zerocash Algorithms
In Figure 4 we report performance characteristics for each of the six DAP scheme algorithms in our implementation. Note that these numbers do not include the costs of maintaining the Merkle tree because doing so is not the responsibility of these algorithms. Moreover, for Verify Transaction, we separately report the cost of verifying mint and pour transactions and, in the latter case, we exclude the cost of scanning L (as this cost depends on L). Finally, for the case of Receive, we report the cost to process a given pour transaction in L.

C. Large-Scale Network Simulation
Because Bitcoin mining typically takes place on dedicated GPUs or ASICs, the CPU resources to execute the DAP scheme algorithms are often of minimal consequence to network performance. There is one potential exception to this rule: the Verify Transaction algorithm must be run by all of the network nodes in the course of routine transaction validation. The time it takes to perform this verification can have significant impact on network performance.

In the Zerocash implementation (as in Bitcoin), every Zero- cash transaction is verified at each hop as it is forwarded though the network and, potentially, again when blocks containing the transaction are verified. Verifying a block consists of checking the proof of work and validating the contained transactions.


Fig. 3:
Performance of our zk-snark for the NP statement POUR. (N=10, \sigma\leq 2.5\%)

Show All

Thus Zerocash transactions may take longer to spread though the network and blocks containing Zerocash transactions may take longer to verify. While we are concerned with the first issue, the potential impact of the second issue is cause for greater concern. This is because Zerocash transactions cannot be spent until they make it onto the ledger.

Because blocks are also verified at each hop before they are forwarded through the network, delays in block verification slow down the propagation of new blocks through the network. This causes nodes to waste CPU-cycles mining on out-of-date blocks, reducing the computational power of the network and making it easier to mount a “51 % attack” (dishonest majority of miners) on the distributed ledger.

It is a priori unclear whether this potential issue is a real concern. Bitcoin caches transaction verifications, so a transaction that was already verified when it propagated through the network need not be verified again when it is seen in a block. The unknown is what percentage of transactions in a block are actually in any given node's cache. We thus conduct a simulation of the Bitcoin network to investigate both the time it takes Zerocash transactions to make it onto the ledger and establish the effects of Zerocash transactions on block verification and propagation. We find that Zerocash transactions can be spent reasonably quickly and that the effects of increased block validation time are minimal.

Simulation Design
Because Zerocash requires breaking changes to the Bitcoin protocol, we cannot test our protocol in the live Bitcoin network or even in the dedicated testnet. We must run our own private testnet. For efficiency and cost reasons, we would like to run as many Bitcoin nodes as possible on the least amount of hardware. This raises two issues. First, reducing the proof of work to practical levels while still preserving a realistic rate of new blocks is difficult (especially on virtualized hardware with variable performance). Second, the overhead of zk-SNARK verification prevents us from running many Bitcoin16 17 nodes on one virtualized server. The frequency of new blocks can be modeled as a Poisson process with a mean of \Lambda_{block} seconds. To generate blocks stochastically, we modify bitcoind to fix its block difficulty at a trivial level and run a Poisson process, on the simulation control server, which trivially mines a block on a randomly selected node. This preserves the distribution of blocks, without the computational overhead of a real proof of work. Another Poisson process triggering mechanism, with a different mean {\rm A}_{tx}, introduces new transactions at random network nodes.


Fig. 4:
Performance of Zerocash algorithms. (N=10, \sigma\leq 2.5\%^{17})

Show All

To differentiate which transactions represent normal Bitcoin expenditures vs. which contain Zerocash pour transactions, simulated Zerocash transactions pay a unique amount of bitcoins (we set this value arbitrarily at 7 BTC). If a transaction's output matches this preset value, and it is not in verification cache, then our modified Bitcoin client inserts a 10 ms delay simulating the runtime of Verify Transaction.18 Otherwise transactions are processed as specified by the Bitcoin protocol. We vary the amount of simulated Zerocash traffic by varying the number of transactions with this particular output amount. This minimizes code changes and estimates only the generic impact of verification delays and not of any specific implementation choice.

Methodology
Recent research [17] suggests that the Bitcoin network contains 16,000 distinct nodes though most are likely no longer participating: approximately 3,500 are reachable at any given time. Each node has an average of 32 open connections to randomly selected peers. As of November 2013, the peak observed transaction rate for Bitcoin is slightly under one transaction per second [34].

In our simulation, we use a 1000-node network in which each node has an average of 32 peers, transactions are generated with a mean of \Lambda_{tx}=1{\rm s}, a duration of 1 hour, and a variable percentage \epsilon of Zerocash traffic. To allow for faster experiments, instead of generating a block every 10 minutes as in Bitcoin, we create blocks at an average of every \Lambda_{block}=150{\rm s} (as in Litecoin, a popular altcoin).18

Fig. 5: - The average values of the three metrics we study, as a function of $\epsilon$, the percentage of transactions that are Zerocash transactions. Note that, ${\rm m}({\rm a})$, latency is undefined when $\epsilon=0$ and hence omitted.
Fig. 5:
The average values of the three metrics we study, as a function of \epsilon, the percentage of transactions that are Zerocash transactions. Note that, {\rm m}({\rm a}), latency is undefined when \epsilon=0 and hence omitted.

Show All

We run our simulation for different traffic mixes, where \epsilon indicates the percentage of Zerocash transactions and \epsilon\in {0%, 25%, 50%, 75%, 100%}. Each simulation is run on 200 Amazon EC2 general-purpose m1.medium instances, in one region on a 10.10./16 private network. On each instance, we deploy 5 instances of bitcoind.

Results
Transactions are triggered by a blocking function call on the simulation control node that must connect to a random node and wait for it to complete sending a transaction. Because the Poisson process modeling transactions generates delays between such calls and not between the exact points when the node actuals sends the transactions, the actual transaction rate is skewed. In our experiments the real transaction rate shifts away from our target of one per second to an average of one every 1.4 seconds.

In Figure 5 we plot three metrics for \epsilon\in\{0\%, 25%, 50%, 75%,100%}. Each is they average defined over the data from the entire run of the simulation for a given \epsilon (i.e., they include multiple transactions and blocksj.19Transaction latency is the interval between a transaction's creation and its inclusion in a block. Block propagation time comes in two flavors: 1) the average time for a new block to reach a node computed over the times for all nodes, and 2) the same average computed over only the last node to see the block.

Block verification time is the average time, over all nodes, required to verify a block. If verification caching was not effective, we would expect to see a marked increase in both block verification time and propagation time. Since blocks occur on average every 150 s, and we expect approximately one transaction each second, we should see {150 \times 10 ms =} 1500 ms of delay if all transactions were non-cached Zerocash transactions. Instead, we see worst case 80 ms and conclude caching is effective. This results in a negligible effect on block propagation (likely because network operations dominate).

The time needed for a transaction to be confirmed, and hence spendable, is roughly 190 s. For slower block generation rates (e.g., Bitcoin's block every 10 minutes) this should mean users must wait only one block before spending received transactions.

SECTION VIII.Optimizations and Extensions
See the extended version of this paper [26] for extensions on everlasting anonymity, batched Merkle tree updates, faster block propagation, and scaling to 264 serial numbers.

SECTION IX.Concurrent Work
Danezis et al. [19] suggest using zk-SNARKs to reduce proof size and verification time in Zerocoin. Our work differs from [19] in both supported functionality and scalability. First, [19]'s protocol, like Zerocoin, only supports fixed-value coins, and is best viewed as a decentralized mix. Instead, we define, construct, and implement a full-fledged decentralized electronic currency, which provides anonymous payments of any amount.

Second, in [19], the complexity of the zk-SNARK generator, prover, and verifier all scale superlinearly in the number of coins, because their arithmetic circuit computes, explicitly, a product over all coins. In particular, the number of coins “mixed together” for anonymity cannot be large. Instead, in our construction, the respective complexities are polylogarithmic, polylogarithmic, and constant in the number of coins; our approach supports a practically-unbounded number of coins.

SECTION X.Conclusion
Decentralized currencies should ensure a user's privacy from his peers when conducting legitimate financial transactions. Zerocash provides such privacy protection, by hiding user identities, transaction amounts, and account balances from public view. This, however, may be criticized for hampering accountability, regulation, and oversight. Yet, Zerocash need not be limited to enforcing the basic monetary invariants of a currency system. The underlying zk-SNARK cryptographic proof machinery is flexible enough to support a wide range of policies. It can, for example, let a user prove that he paid his due taxes on all transactions without revealing those transactions, their amounts, or even the amount of taxes paid. As long as the policy can be specified by efficient nondeterministic computation using NP statements, it can (in principle) be enforced using zk-SNARKs, and added to Zerocash. This can enable privacy-preserving verification and enforcement of a wide range of compliance and regulatory policies that would otherwise be invasive to check directly or might be bypassed by corrupt authorities. This raises research, policy, and engineering questions over what policies are desirable and practically realizable.

Another research question is what new functionality can be realized by augmenting the capabilities already present in Bitcoin's scripting language with zk-SNARKs that allow fast verification of expressive statements.