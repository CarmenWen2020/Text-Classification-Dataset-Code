Sidechains have long been heralded as the key enabler of blockchain scalability and interoperability. However, no modeling of the concept or a provably secure construction has so far been attempted. We provide the first formal definition of what a sidechain system is and how assets can be moved between sidechains securely. We put forth a security definition that augments the known transaction ledger properties of liveness and safety to hold across multiple ledgers and enhance them with a new “firewall” security property which safeguards each blockchain from its sidechains, limiting the impact of an otherwise catastrophic sidechain failure. We then provide a sidechain construction that is suitable for proof-of-stake (PoS) sidechain systems. As an exemplary concrete instantiation we present our construction for an epoch- based PoS system consistent with Ouroboros (Crypto 2017), the PoS blockchain protocol used in Cardano which is one of the largest pure PoS systems by market capitalisation, and we also comment how the construction can be adapted for other protocols such as Ouroboros Praos (Eurocrypt 2018), Ouroboros Genesis (CCS 2018), Snow White and Algorand. An important feature of our construction is merged-staking that prevents “goldfinger” attacks against a sidechain that is only carrying a small amount of stake. An important technique for pegging chains that we use in our construction is cross-chain certification which is facilitated by a novel cryptographic primitive we introduce called ad-hoc threshold multisignatures (ATMS) which may be of independent interest. We show how ATMS can be securely instantiated by regular and aggregate digital signatures as well as succinct arguments of knowledge such as STARKs and bulletproofs with varying degrees of storage efficiency.

SECTION I.Introduction
Blockchain protocols and their most prominent application so far, cryptocurrencies like Bitcoin [25], have been gaining increasing popularity and acceptance by a wider community. While enjoying wide adoption, there are several fundamental open questions remaining to be resolved that include (i) Interoperability: How can different blockchains interoperate and exchange assets or other data? (ii) Scalability: How can blockchain protocols scale, especially proportionally to the number of participating nodes? (iii) Upgradability: How can a deployed blockchain protocol codebase evolve to support a new functionality, or correct an implementation problem?

The main function of a blockchain protocol is to organise application data into blocks so that a set of nodes that evolves over time can arrive eventually to consensus about the sequence of events that took place. The consensus component can be achieved in a number of ways, the most popular is using proof-of-work [14] (cf. [15], [25]), while a promising alternative is to use proof-of-stake (cf. [4], [11], [18], [24]). Application data typically consists of transactions indicating some transfer of value as in the case of Bitcoin [25]. The transfer of value can be conditioned on arbitrary predicates called smart contracts such as, for example, in Ethereum [9], [29].

The conditions used to validate transactions depend on local blockchain events according to the view of each node and they typically cannot be dependent on other blockchain sessions. Being able to perform operations across blockchains, for instance from a main blockchain such as Bitcoin to a “sidechain” that has some enhanced functionality, has been frequently considered a fundamental technology enabler in the blockchain space.1

Sidechains, introduced in [1], are a way for multiple blockchains to communicate with each other and have one react to events in the other. Sidechains can exist in two forms. In the first case, they are simply a mechanism for two existing stand-alone blockchains to communicate, in which case any of the two blockchains can be the sidechain of the other and they are treated as equals. In the second case, the sidechain can be a “child” of an existing blockchain, the mainchain, in that its genesis block, the first block of the blockchain, is somehow seeded from the parent blockchain and the child blockchain is meant to depend on the parent blockchain, at least during an initial bootstrapping stage.

A sidechain system can choose to enable certain types of interactions between the participating blockchains. The most basic interaction is the transfer of assets from one blockchain to another. In this application, the nature of the asset transferred is retained in that it is not transformed into a different class of asset (this is in contrast to a related but different concept of atomic swaps). As such, it maintains its value and may also be transferred back. The ability to move assets back and forth between two chains is sometimes referred to as a 2way peg. Provided the two chains are both secure as individual blockchains, a secure sidechain protocol construction allows this security to be carried on to cross-chain transfers.

A secure sidechain system could be of a great value vis-à-vis all three of the pressing open questions in blockchain systems mentioned above. Specifically:

Interoperability. There are currently hundreds of cryptocurrencies deployed in production. Transferring assets between different chains requires transacting with intermediaries (such as exchanges). Furthermore, there is no way to securely interface with another blockchain to react to events occurring within it. Enabling sidechains allows blockchains of different nature to communicate, including interfacing with the legacy banking system which can be made available through the use of a private ledger.

Scalability. While sidechains were not originally proposed for scalability purposes, they can be used to off-load the load of a blockchain in terms of transactions processed. As long as 2-way pegs are enabled, a particular sidechain can offer specialization by, e.g., industry, in order to avoid requiring the mainchain to handle all the transactions occurring within a particular economic sector. This provides a straightforward way to “shard” blockchains, cf. [19], [23], [31].

Upgradability. A child sidechain can be created from a parent mainchain as a means of exploring a new feature, e.g., in the scripting language, or the consensus mechanism without requiring a soft, hard, or velvet fork [17], [32]. The sidechain does not need to maintain its own separate currency, as value can be moved between the sidechain and the mainchain at will. If the feature of the sidechain proves to be popular, the mainchain can eventually be abandoned by moving all assets to the sidechain, which can become the new mainchain.

Given the benefits listed above for distributed ledgers, there is a pressing need to address the question of sidechain security and feasibility, which so far, perhaps surprisingly, has not received any proper formal treatment.

Our contributions. First, we formalize the notion of sidechains by proposing a rigorous cryptographic definition, the first one to the best of our knowledge. The definition is abstract enough to be able to capture the security for blockchains based on proof-of-work, proof-of-stake, and other consensus mechanisms.

A critical security feature of a sidechain system that we formalise is the firewall property in which a catastrophic failure in one of the chains, such as a violation of its security assumptions, does not make the other chains vulnerable providing a sense of limited liability.2 The firewall property formalises and generalises the concept of a blockchain firewall which was described in high level in [1]. Informally the blockchain firewall suggests that no more money can ever return from the sidechain than the amount that was moved into it. Our general firewall property allows relying on an arbitrary definition of exactly how assets can correctly be moved back and forth between the two chains, we capture this by a so-called validity language. In case of failure, the firewall ensures that transfers from the sidechain into the mainchain are rejected unless there exists a (not necessarily unique) plausible history of events on the sidechain that could, in case the sidechain was still secure, cause the particular transfers to take place.

Second, we outline a concrete exemplary construction for sidechains for proof-of-stake blockchains. For conciseness our construction is described with respect to a generic PoS blockchain consistent with the Ouroboros protocol [18] that underlies the Cardano blockchain, which is currently one of the largest pure PoS blockchains by market capitalisation,3 nevertheless we also discuss how to modify our construction to operate for Ouroboros Praos [11], Ouroboros Genesis [2], Snow White [5] and Algorand [24].

We prove our construction secure using standard cryptographic assumptions. We show that our construction (i) supports safe cross-chain value transfers when the security assumptions of both chains are satisfied, namely that a majority of honest stake exists in both chains, and (ii) in case of a onesided failure, maintains the firewall property, thus containing the damage to the chains whose security conditions have been violated.

A critical consideration in a sidechain construction is safeguarding a new sidechain in its initial “bootstrapping” stage against a “goldfinger” type of attack [20]. Our construction features a mechanism we call merged-staking that allows mainchain stakeholders who have signalled sidechain awareness to create sidechain blocks even without moving stake to the sidechain. In this way, sidechain security can be maintained assuming honest stake majority among the entities that have signaled sidechain awareness that, especially in the bootstrapping stage, are expected to be a large superset of the set of stakeholders that maintain assets in the sidechain.

Our techniques can be used to facilitate various forms of 2way peggings between two chains. As an illustrative example we focus on a parrent-child mainchain-sidechain configuration where sidechain nodes follow also the mainchain (what we call direct observation) while mainchain nodes need to be able to receive cryptographically certified signals from the sidechain maintainers, taking advantage of the proof-of-stake nature of the underlying protocol. This is achieved by having mainchain nodes maintain sufficient information about the sidechain that allows them to authenticate a small subset of sidechain stakeholders that is sufficient to reliably represent the view of a stakeholder majority on the sidechain. This piece of information is updated in regular intervals to account for stake shifting on the sidechain. Exploiting this, each withdrawal transaction from the sidechain to the mainchain is signed by this small subset of sidechain stakeholders. To minimise overheads we batch this authentication information and all the withdrawal transactions from the sidechain in a single message that will be prepared once per “epoch.” We will refer to this signaling as cross-chain certification.

In greater detail, adopting some terminology from [18], the sidechain certificate is constructed by obtaining signatures from the set of so-called slot leaders of the last Θ(k) slots of the previous epoch, where k is the security parameter. Subsequently, these signatures will be combined together with all necessary information to convince the mainchain nodes (that do not have access to the sidechain) that the sidechain certificate is valid. We abstract the notion of this trust transition into a new cryptographic primitive called ad-hoc threshold multisignatures (ATMS) that we implement in three distinct ways. The first one simply concatenates signatures of elected slot leaders. While secure, the disadvantage of this implementation is that the size of the sidechain certificate is Θ(k) signatures. An improvement can be achieved by employing multisignatures and Merkle-tree hashing for verification key aggregation; using this we can drop the sidechain-certificate size to Θ(r) signatures where r slot leaders do not participate in its generation; in the optimistic case r≪k and thus this scheme can be a significant improvement in practice. Finally, we show that STARKs and bulletproofs [3], [8] can be used to bring down the size of the certificate to be optimally succinct in the random oracle model. We observe that in the case of an active sidechain (e.g., one that returns assets at least once per epoch) our construction with succinct sidechain certificates has optimal storage requirements in the mainchain.

Related work. Sidechains were first proposed as a high level concept in [1]. Notable proposed implementations of the concept are given in [21], [27]. In these works, no formal proof of security is provided and their performance is sometimes akin to maintaining the whole blockchain within the sidechain, limiting any potential scalability gains. There have been several attempts to create various cross-chain transfer mechanisms including Polkadot [30], Cosmos [7], Blockstream’s Liquid [12] and Interledger [28]. These constructions differ in various aspects from our work including in that they focus on proof-of-work or private (Byzantine) blockchains, require federations, are not decentralized and — in all cases — lack a formal security model and analysis. Threshold multi-signatures were considered before, e.g., [22], without the ad-hoc characteristic we consider here. A related primitive that has been considered as potentially useful for enabling proof-of-work (PoW) sidechains (rather than PoS ones) is a (non-interactive) proof of proof-of-work [16], [17]; nevertheless, these works do not give a formal security definition for sidechains, nor provide a complete sidechain construction. We reiterate that while we focus on PoS, our definitions and model are fully relevant for the PoW setting as well.

SECTION II.Preliminaries
A. Our Model
We employ the model from [11], which is in turn based on [18] and [15]. The formalization we use below captures both synchronous and semi-synchronous communication; as well as both semi-adaptive and fully adaptive corruptions.

1) Protocol Execution: We divide time into discrete units called slots. Players are equipped with (roughly) synchronized clocks that indicate the current slot: we assume that any clock drift is subsumed in the slot length. Each slot slr is indexed by an integer r∈{1,2,…}. We consider a UC-style [10] execution of a protocol ⊓, involving an environment Ƶ, a number of parties ∏ functionalities that these parties can access while running the protocol (such as the DDiffuse used for communication, described below), and an adversary A. All these entities are interactive algorithms. The environment controls the execution by activating parties via inputs it provides to them. The parties, unless corrupted, respond to such activations by following the protocol ⊓ and invoking the available functionalities as needed.

2) (Semi-)Adaptive Corruptions: The adversary influences the protocol execution by interacting with the available functionalities, and by corrupting parties. The adversary can only corrupt a party Pi if it is given permission by the environment Z running the protocol execution (captured as a special message from Z to A). Upon receiving permission from the environment, the adversary corrupts Pi after a certain delay of Λ slots, where Λ is a parameter of our model. In particular, if Λ = 0 we talk about fully adaptive corruptions and the corruption is immediate. The model with Λ > 0 is referred to as allowing Λ-semi-adaptive corruptions (as opposed to the static corruptions model, where parties can only be corrupted before the start of the execution). A corrupted party Pi will relinquish its entire state to A; from this point on, the adversary will be activated in place of the party Pi.

3) (Semi-)Synchronous Communication: We employ the “Delayed Diffuse” functionality DDiffus?△ given in [11] to model (semi-)synchronous communication among the parties. It allows each party to diffuse a message once per round, with the guarantee that it will be delivered to all other parties in at most Δ slots (the delay within this interval is under adversarial control). The adversary can also read and reorder all messages that are in transit, as well as inject new messages. We provide a detailed description of the functionality DDiffus?△ in Appendix A for completeness.

We refer to the setting where honest parties communicate via DDiffus?△ as the Δ-semi-synchronous setting and sometimes omit Δ if it is clear from the context. The special case of Δ = 0 is referred to as the synchronous setting.

Clearly, the above model is by itself too strong to allow us to prove any meaningful security guarantees for the executed protocol without further restrictions (as it, for example, does not prevent the adversary from corrupting all the participating parties). Therefore, in what follows, we will consider such additional assumptions, and will only provide security guarantees as long as such assumptions are satisfied. These assumptions will be specific to the protocol in consideration, and will be an explicit part of our statements.4

B. Blockchains and Ledgers
A blockchain (or a chain) (denoted e.g. C) is a sequence of blocks where each one is connected to the previous one by containing its hash.

Blockchains (and in general, any sequences) are indexed using bracket notation. C[i] indicates the ith block, starting from C [0], the genesis block. C[−i] indicates the ith block from the end, with C[−1] being the tip of the blockchain. C[i:j] indicates a subsequence, or subchain of the blockchain starting from block i (inclusive) and ending at block j (exclusive). Any of these two indices can be negative. Omitting one of the two indexes in the range addressing takes the subsequence to the beginning or the end of the blockchain, respectively. Given blocks A and Z in C C{A:Z} denotes the subchain obtained by only keeping the blocks from A (inclusive) to Z (exclusive). Again any of these two blocks can be omitted to indicate a subchain from the beginning or to the end of the blockchain, respectively. In blockchain protocols, each honest party P maintains a currently adopted chain. We denote CP[t] the chain adopted by party P at slot t.

A ledger (denoted in bold-face, e.g. L) is a mechanism for maintaining a sequence of transactions, often stored in the form of a blockchain. In this paper, we slightly abuse the language by letting L (without further qualifiers) interchangeably refer to the algorithms used to maintain the sequence, and all the views of the participants of the state of these algorithms when being executed. For example, the (existing) ledger Bitcoin consists of the set of all transactions that ever took place in the Bitcoin network, the current UTXO set, as well as the local views of all the participants.

In contrast, we call a ledger state a concrete sequence of transactions tx1,tx2,… stored in the stable part of a ledger L, typically as viewed by a particular party. Hence, in every blockchain-based ledger L, every fixed chain C defines a concrete ledger state by applying the interpretation rules given as a part of the description of L (for example, the ledger state is obtained from the blockchain by dropping the last k blocks and serializing the transactions in the remaining blocks). We maintain the typographic convention that a ledger state (e.g. L) always belongs to the bold-face ledger of the same name (e.g. L). We denote by LP[t] the ledger state of a ledger L> as viewed by a party P at the beginning of a time slot t, and by LˇP[t] the complete state of the ledger (at time t) including all pending transactions that are not stable yet. For two ledger states (or, more generally, any sequences), we denote by ⪯ the prefix relation.

Recall the definitions of persistence and liveness of a robust public transaction ledger given in the most recent version of [15]:

Persistence. For any two honest parties P1, P2 and two time slots t1≤t2, it holds LP1[t1]⪯LˇP2[t2].

Liveness. If all honest parties in the system attempt to include a transaction then, at any slot t after u slots (called the liveness parameter), any honest party P, if queried, will report tx∈LP[t],

For a ledger L that satisfies persistence at time t, we denote by L∪[t] (resp. L∩[t]) the sequence of transactions that are seen as included in the ledger by at least one (resp., all) of the honest parties. Finally, length(L) denotes the length of the ledger L, i.e., the number of transactions it contains.

C. Underlying Proof-of-Stake Protocols
For conciseness we present our construction on a generic PoS protoocol based on Ouroboros PoS [18]. As we outline in Appendix C, our construction can be easily adapted to other provably secure proof-of-stake protocols: Ouroboros Praos [11], Ouroboros Genesis [2], Snow White [5], and Algorand [24]. While a full understanding of all details of these protocols is not required to follow our work (and cannot be provided in this limited space), an overview of Ouroboros is helpful to follow the main body of the paper. We provide this high-level overview here, and point an interested reader to Appendix C (or the original papers) for details on the other protocols.

1) Ouroboros: The protocol operates (and was analyzed) in the synchronous model with semi-adaptive corruptions. In each slot, each of the parties can determine whether she qualifies as a so-called slot leader for this slot. The event of a particular party becoming a slot leader occurs with a probability proportional to the stake controlled by that party and is independent for two different slots. It is determined by a public, deterministic computation from the stake distribution and so-called epoch randomness (we will discuss shortly where this randomness comes from) in such a way that for each slot, exactly one leader is elected.

If a party is elected to act as a slot leader for the current slot, she is allowed to create, sign, and broadcast a block (containing transactions that move stake among stakeholders). Parties participating in the protocol are collecting such valid blocks and always update their current state to reflect the longest chain they have seen so far that did not fork from their previous state by too many blocks into the past.

Multiple slots are collected into epochs, each of which contains R∈N slots. The security arguments in [18] require R≥10k for a security parameter k; we will consider R=12k as additional 2k slots in each epoch will be useful for our construction. Each epoch is indexed by an index j∈N. During an epoch j, the stake distribution that is used for slot leader election corresponds to the distribution recorded in the ledger up to a particular slot of epoch j — 1, chosen in a way that guarantees that by the end of epoch j — 1, there is consensus on the chain up to this slot. (More concretely, this is the latest slot of epoch j — 1 that appears in the first 4k out of its total R slots.) Additionally, the epoch randomness ηj for epoch j is derived during the epoch j — 1 via a guaranteed-output delivery coin tossing protocol that is executed by the epoch slot leaders, and is available after 10k slots of epoch j — 1 have passed.

In our treatment, we will refer to the relevant parts of the above-described protocol as follows:

GetDistr(j) returns the stake distribution SDj to be used for epoch j, as recorded in the chain up to slot 4k of epoch j — 1;

GetRandomness(j) returns the randomness ηj for epoch j as derived during epoch j — 1;

ValidateConsensusLevel(C) checks the consensus-level validity of a given chain C: it verifies that all block hashes are correct, signatures are valid and belong to eligible slot leaders;

PickWinningChain(C,C) applies the chain-selection rule: from a set of chains {C}∪C it chooses the longest one that does not fork from the current chain C more than k blocks in the past;

SlotLeader(U,j,sl,SDj,ηj) determines whether a party U is elected a slot leader for the slot si of epoch j, given stake distribution SDj and randomness ηj

Moreover, the function Epochindex (resp. SlotIndex) always returns the index of the current epoch (resp. slot), and the event NewEpoch (resp. NewSlot) denotes the start of a new epoch (resp. slot). Since we use these functions in a blackbox manner, our construction can be readily adapted to PoS protocols with a similar structure that differ in the details of these procedures.

Ouroboros was shown in [18] to achieve both persistence and liveness under the following assumptions: (1) synchronous communication; (2) 2R-semi-adaptive corruptions; (3) majority of stake in the stake distribution for each epoch is always controlled by honest parties during that epoch.

SECTION III.Defining Security of Pegged Ledgers
In this section we give the first formal definition of security desiderata for a system of pegged ledgers (popularly often called sidechains). We start by conveying its intuition and then proceed to the formal treatment.

We consider a setting where a set of parties run a protocol maintaining n ledgers L1,L2,…,Ln, each of the ledgers potentially carrying many different assets. (This protocol might of course be a combination of subprotocols for each of the ledgers.) For each i∈[n], we denote by Ai the security assumption required by Li For example, Ai may denote that there has never been a majority of hashing power (or stake in a particular asset, on this ledger or elsewhere) under the control of the adversary; that a particular entity (in case of a centralized ledger) was not corrupted; and so on. We assume that all Ai are monotone in the sense that once violated, they cannot become true again. Formally, Ai is a monotone predicate (which can only go from true to false) evaluated on the whole execution of the respective ledger protocol.

There is an a priori unlimited number of (types of) assets, each asset representing e.g. a different cryptocurrency. For simplicity we assume that assets of the same type are fungible, but our treatment easily covers also non-fungible assets. We will allow specific rules of behavior for each asset (called validity languages), and each asset behaves according to these rules on each of the ledgers where it is present.

We will fix an operator merge(.) that merges a set of ledger states L={L1,L2,…,Ln} into single ledger state denoted by merge(L). We will discuss concrete instantiations of merge(.) later, for now simply assume that some canonical way of merging all ledger states into one is given.

Informally, at any point during the execution, our security definition only provides guarantees to the subset S of ledgers that have their security assumptions Ai satisfied (and hence are all considered uncorrupted). We require that:

– each ledger in S individually maintains both persistence and liveness;

– for each asset A, when looking at the sequence of all A-transactions σ that occurred on the ledgers in S (sequentialized via the merge operator), there must exist a hypothetical sequence of A-transactions τ that could have happened on the compromised ledgers, such that the merge of σ and τ would be valid according to the validity language of A.

We now proceed to formalize the above intuition.

Definition 1
(Assets, syntactically valid transactions). For an asset A, we denote by TA the valid transaction set of A, f.e., the set of all syntactically valid transactions involving A. For a ledger L we denote by TL the set of transactions that can be included into L. For notational convenience, we define TA,L≜TA∩TL Let Assets(L) denote the set of all assets that are supported by L. Formally,  Assets (L)≜{A:TA,L≠∅}

We assume that each transaction pertains to a particular asset and belongs to a particular ledger, i.e., for distinct A1≠A2 and L1≠L2, we have that TA1∩TA2=∅ and TL1∩TL2=∅. However, our treatment can be easily generalized to alleviate this restriction.

We now generically characterize the validity of a sequence of transactions involving a particular asset. This is captured individually for each asset via a notion of an asset’s validity language, which is simply a set of words over the alphabet of this asset’s transactions. The asset’s validity language is meant to capture how the asset is mandated to behave in the system. Let ϵ denote the empty sequence and || represent concatenation.

Definition 2
(Asset validity language). For an asset A, the asset validity language of A is any language VA⊆T∗A that satisfies the following properties:

Base, ε∈VA

Monotonicity. For any ww′∈T∗A we have w∉VA⇒w∥w′∉VA

Uniqueness of transactions. Words from VA never contain the same transaction twice: for any tx∈TA and any w1,w2,w3∈T∗A we have w1∥tx∥w2∥tx∥w3∉VA

The first condition in the definition above is trivial, the second one mandates the natural property that if a sequence of transactions is invalid, it cannot become valid again by adding further transactions. Finally, the third condition reflects a natural “uniqueness” property of transactions in existing implementations. While not necessary for our treatment, it allows for some simplifications.

The following definition allows us to focus on a particular asset or ledger within a sequence of transactions.

Definition 3
(Ledger state projection). Given a ledger state L, we call a projection of L with respect to a set X (and denote by πX(L)) the ledger state that is obtained from L by removing all transactions not in X. To simplify notation, we will use and πA as a shorthand for πI and πTA and π⋃i∈TTLj, denoting the projection of the transactions of a ledger state with respect to particular asset A or a particular set of individual ledger indices. Naturally, for a language V we define the projected language πX(V):={πX(w):w∈V}, which contains all the sequences of transactions from the original language, each of them projected with respect to X.

The concept of effect transactions below captures ledger interoperability at the syntactic level.

Definition 4
(Effect Transactions). For two ledgers L and L′ the effect mapping is a mapping of the form  effect L→L′:TL→(TL′∪{⊥}) A transaction tx′=effectL→L′(tx)≠⊥ is called the effect transaction of the transaction tx.

Intuitively, for any transaction tx∈TL, the corresponding transaction  effect L→L′(tx)∈TL′∪{⊥} identifies the necessary effect on ledger L′ of the event of the inclusion of the transaction tx into the ledger L. With foresight, in an implementation of a system of ledgers where a “pegging” exists, the transaction  effect L→L′(tx) has to be eventually valid and includable in L′ in response to the inclusion of tx in L. Additionally, throughout the paper we assume that an effect transaction is always clearly identifiable as such, and its corresponding “sending” transaction can be derived from it; our instantiation does have this property.

We use a special symbol ± to indicate that the transaction tx does not necessitate any action on L′ (this will be the case for most transactions). We will now be interested mostly in transactions that do require an action on the other ledger.

Definition 5
(Cross-Ledger Transfers). For two ledgers L and L′ and an effect mapping  effect L→L′(⋅) we refer to a transaction in TL that requires some effect on L′ as a (L,L′)-cross-ledger transfer transaction (or cross-ledger transfer for short). The set of all cross-ledger transfers is denoted by TclL,L′⊆TL formally TclL,L′≜{tx∈TL: effect L→L′(tx)≠⊥}.

Given ledger states L1,L2,…,Ln, we need to consider a joint ordered view of the transactions in all these ledgers. This is provided by the merge operator. Intuitively, merge allows us to create a combined view of multiple ledgers, putting all of the transactions across multiple ledgers into a linear ordering. We expect that even if certain ledgers are missing from its input, merge is still able to produce a global ordering for the remaining ledgers. With foresight, this ability of the merge operator will enable us to reason about the situation when some ledgers fail: In that case, the respective inputs to the merge function will be missing. The merge function definition below depends on the effect mappings, we keep this dependence implicit for simpler notation.

Definition 6
(Merging ledger states). The merge(.) function is any mapping taking a subset of ledger states L⊆{L1,L2,…,Ln} and producing a ledger state merge(L) such that:

1) Partitioning. The ledger states in £ are disjoint subsequences of merge(L) that cover the whole sequence merge(L).

2) Topological soundness. For any i≠j such that Li,Lj∈L and any two transactions tx∈Li and tx′∈Lj, if tx′=effectLi→Lj(tx) then tx precedes tx' in merge (L).

We will require that our validity languages are correct in the following sense.

Definition 7
(Correctness of VA). A validity language VA is correct with respect to a mapping merge(.), if for any ledger states L≜(L1,…,Ln) such that πA(merge(L))∈VA indices i≠j and any cross-ledger transfer tx∈Li∩TclLi,Lj such that  effect Li→Li(tx)=tx′≠⊥ is not in Lj, we have

πA(merge(L1,…,Li,…,Lj∥tx′,…,Ln))∈VA
View Source

The above definition makes sure that if a cross-ledger transfer of an asset A is included into some ledger Li and mandates an effect transaction on Lj, then the inclusion of this effect transaction will be consistent with VA Note that this does not yet guarantee that the effect transaction will indeed be included into Lj, this will be provided by the liveness of Lj required below.

We are now ready to give our main security definition. In what follows, we call a system-of-ledgers protocol any protocol run by a (possibly dynamically changing) set of parties that maintains an evolving state of n ledgers {Li}i∈[n].

Definition 8
(Pegging security). A system-of-ledgers protocol ∏ for {Li}i∈[n] is pegging-secure with liveness parameter u ∈ N with respect to:

– a set of assumptions Ai for ledgers {Li}i∈[n]

– a merge mapping merge(.)

– validity languages VA for each A∈⋃i∈[n]Assets(Li),

if for all PPT adversaries, all slots t and for St≜ {i: Ai is satisfied in slot t} we have that except with negligible probability in the security parameter:

Ledger persistence: For each i∈St, Li satisfies the persistence property.

Ledger liveness: For each i∈St, Li satisfies the liveness property parametrized by u.

Firewall: For all A∈⋃i∈StAsets(Li),

πA(merge({LUi[t]]:i∈St}))∈πSt(VA).
View Source

orithm that takes a messag

Intuitively, the firewall property above gives the following guarantee: If the security assumption of a particular sidechain has been violated, we demand that the sequence of transactions σ that appears in the still uncompromised ledgers is a valid projection of some word from the asset validity language onto these ledgers. This means that there exists a sequence of transactions τ that could have happened on the compromised ledgers, such that it would “justify” the current state of the uncompromised ledgers as a valid state. Of course, we don’t know whether this sequence τ actually occurred on the compromised ledger, however, given that this ledger itself no longer provides any reliable state, this is the best guarantee we can still offer to the uncompromised ledgers.

Looking ahead, when we define a particular validity language for our concrete, fungible, constant-supply asset, we will see that this property will translate into the mainchain maintaining “limited liability” towards the sidechain: the amount of money transferred back from the sidechain can never exceed the amount of money that was previously moved towards the sidechain, because no plausible history of sidechain transactions can exist that would justify such a transfer.

SECTION IV.Implementing Pegged Ledgers
We present a construction for pegged ledgers that is based on Ouroboros PoS [18], but also applicable to other PoS systems such as Snow White [5] and Algorand [24] (for a discussion of such adaptations, see Appendix C). Our protocol will implement a system of ledgers with pegging security according to Definition 8 under an assumption on the relative stake power of the adversary that will be detailed below.

The main challenge in implementing pegged ledgers is to facilitate secure cross-chain transfers. We consider two approaches to such transfers and refer to them as direct observation or cross-chain certification. Consider two pegged ledgers L1 and L2. Direct observation of Lļ means that every node of L1 follows and validates Li; it is easy to see that this enables transfers from L1 to L2. On the other hand, crosschain certification of L2 means that L1 contains appropriate cryptographic information sufficient to validate data issued by the nodes following L2. This allows transfers of assets from L2, as long as they are certified, to be accepted by L1-nodes without following L2. The choice between direct observation and cross-chain certification can be made independently for each direction of transfers between L1 and L2, any of the 4 variants is possible (cf. Figure 1).

Another aspect of implementing pegged ledgers in the PoS context is the choice of stake distribution that underlies the PoS on each of the chains. We again consider two options, which we call independent staking and merged staking. In independent staking, blocks on say L1 are “produced by” coins from L1 (in other words, the block-creating rights on L1 are attributed based on the stake distribution recorded on L1 only). In contrast, with merged staking, blocks on L1 are produced either by coins on L1, or coins on L2 that have, via their staking key, declared support of L1 (but otherwise remain on L1); see Figure 1. Also here, all 4 combinations are possible.

In our construction we choose an exemplary configuration between two ledgers L1 and L2, so that direct observation is applied to L1, cross-chain certification to L2, independentstaking in L1 and merged staking in L2. As a result, all stakeholders in L2 also keep track of chain development on L1 (and hence run a full node for L1) while the opposite is not necessary, i.e., L1 stakeholders can be oblivious of transactions and blocks being added to L2. This illustrates the two basic possibilities of pegging and can be easily adapted to any other of the configurations between two ledgers in Figure 1.

In order to reflect the asymmetry between the two chains in our exemplary construction we will refer to L1 as the “mainchain” MC, and to L2 as the “sidechain” SC. To elaborate further on this concrete asymmetric use case, we also fully specify how the sidechain can be initialized from scratch, assuming that the mainchain already exists.

The pegging with the sidechain will be provided with respect to a specific asset of MC that will be created on MC. Note that MC as well as SC may carry additional assets but for simplicity we will assume that staking and pegging is accomplished only via this single primary asset.

The presentation of the construction is organized as follows. First, in Section IV-A we introduce a novel cryptographic primitive, ad-hoc threshold multisignature (ATMS), which is the fundamental building block for cross-chain certification. Afterwards, in Section IV-C we use it as a black box to build secure pegged ledgers with respect to concrete instantiations of the functions merge and effect and a validity language for asset 21 given in Section IV-B. Finally, we discuss specific instantiations of ATMS in Section V.

A. Implementing Pegged Ledgers
We introduce a new primitive, ad-hoc threshold multisignatures (ATMS), which borrow properties from multi signatures and threshold signatures and are ad-hoc in the sense that signers need to be selected on the fly from an existing key set. In Section IV-C we describe how ATMS are useful for periodically updating the “anchor of trust” that the mainchain parties have w.r.t. the sidechain they are not following.

ATMS are parametrized by a threshold t. On top of the usual digital signatures functionality, ATMS also provide a way to: (1) aggregate the public keys of a subset of these parties into a single aggregate public key avk’, (2) check that a given avk was created using the right sequence of individual public keys; and (3) aggregate t’ t′≥t individual signatures from t’ of the parties into a single aggregate signature that can then be verified using avk, which is impossible if less than t individual signatures are used.

The definition of an ATMS is given below.

Definition 9.
A t-ATMS is a tuple of algorithms Π= (PGen, Gen, Sig, Ver, AKey, ACheck, ASig, AVer) where:

PGen(1κ) is the parameter generation algorithm that takes the security parameter 1\kappa and returns system parameters P.

Gen(P) is the key-generation algorithm that takes P and produces a public/private key pair (vki,ski) for the party invoking it.

Sig(ski, m) is the signature algorithm as in an ordinary signature scheme: it takes a private key and a message and produces a (so-called local) signature σ.

Ver(m,pki, σ) is the verification algorithm that takes a public key, a message and a signature and returns true or false.

AKey(VK) is the key aggregation algorithm that takes a sequence of public keys VK and aggregates them into an aggregate public key avk.

ACheck(VK, avk) is the aggregation-checking algorithm that takes a public key sequence VK and an aggregate public key avk and returns true or false, determining whether VK were used to produce avk.

ASig (m, VK, ⟨(vk1, σ1),⋯, (vkd, σd is the signature-aggregation algorithm that takes a message m, a sequence of public keys VK and a sequence of d pairs {(vk1, σ1), ⋯, (vkd, σd) ⟩ where each σi is a local signature on m verifiable by vki and each vki is in a distinct position within VK, ASig combines these into a multisignature σ that can later be verified with respect to the aggregate public key avk produced from VK (as long as d≥t, see below).

AVer(m, avk, σ) is the aggregate-signature verification algorithm that takes a message m, an aggregate public key avk, and a multisignature σ, and returns true or false.


Fig. 1:
Deployment options for PoS Sidechains.

Show All

Definition 10
(ATMS correctness). Let Π be a t-ATMS scheme initialized with P← PGen (1κ), let (vkl, sk1), ⋯, (vkn, skn) be a sequence of keys generated via Gen (P), let VK be a sequence containing (not necessarily unique) keys from the above and avk be generated by invoking avk← AKey(VK). Let m be any message and let ⟨(vk1, σ1), ⋯, (vkd, σd) ⟩ be any sequence of keylsignature pairs provided that d≥t and every vki appears in a unique position in the sequence VK, where σi is generated as σi=Sjg(ski, m). Let σ← ASjg (m, VK, {(vk1, σ1),⋯, (vkd, σd The scheme Π is correct if for every such message and sequence the following hold.

1) Ver(m, vki, σi) is true for all i;

2) AC[7eck(VK, avk) is true;

3) AVer(m, avk, σ) is true.

We define the security of an ATMS in the definition below, via a cryptographic game given in Algorithm 1.

Definition 11
(Security). A t-ATMS scheme Π= (PGen, Gen, Sig,Ver,AKeγ, ACheck, ASig, AVer) is secure if for any PPT adversary A and any polynomial p there exists some negligible function neg/ such that Pr[ATMSΠ,A(κ,p(κ))=1]<neg/(κ).

Algorithm 1 The Atms Game
function ATMS (κ,p)

:VK←ϵ; SK←ϵ;Qsig←∅;Qcor←∅

:P← PGen (1κ)

(m,σ,avk, keys) ←AOgen,Osig(⋅,),Ocor(⋅)(P)

:q←0

for vk in keys do

if vk∉VK∨vk∈Qs1g[m]∪Qcor then

:q←q+1

end if

end for

return AVer (m, avk, σ)∧ACheck(keys, avk)∧q<t

end function

function Ogen

(vk,sk)←Gen(P))

VK←VK∥vk

SK←SK ∥sk

return vk

end function

function Osig(i, m)

:Qsig[m]←Qsig[m]∪{VK[i]}

return Sig (SK[i], m)

end function

function Ocor(i)

:Qcor←Qcor∪{VK[i]}

return SK[i]

end function

It is straightforward to see that if Π is a secure ATMS, then the tuple (PGen, Gen, Sig, Ver) is a EUF-CMA-secure signature scheme.

Looking ahead, note that since the AKey algorithm is only invoked with the public keys of the participants, it can be invoked by anyone, not just the parties who hold the respective secret keys, as long as the public portion of their keys is published. Furthermore, notice that the above games allow the adversary to generate more public/private key pairs of their own and combine them at will.

Having defined the ATMS primitive, we will now describe a sidechain construction that uses it. Concrete instantiations of the ATMS primitive are presented in Section V.

B. A Concrete Asset A
We now present an example of a simple fungible asset with fixed supply, which we denote A, and describe its validity language VA. This will be the asset (and validity language) considered in our construction and proof. While VA is simple and natural, it allows us to exhibit the main features of our security treatment and illustrate how it can be applied to more complex languages such as those capable of capturing smart contracts; we omit such extensions in this version. Note that our language is account-based, but a UTXO-based validity language can be considered in a similar manner.

Instantiating VA: The validity language VA for the asset A considers two ledgers: the mainchain ledger L0≜MC and the sidechain ledger L1=△ SC. For this asset, every transaction tx ∈TA has the form tx = (txid, lid, (send, sAcc), (rec, rAcc),v,σ), where:

txid is a transaction identifier that prevents replay attacks. We assume that txid contains sufficient information to identify lid by inspection and that this is part of syntactic transaction validation.

lid ∈{0,1} is the ledger index where the transaction belongs.

send ∈{01} is the index of the sender ledger Lsend and sAcc is an account on this ledger, this is the sender account. For simplicity, we assume that sAcc is the public key of the account.

rec∈{0,1} is the index of the recipient ledger Lrec and rAcc is an account (again represented by a public key) on this ledger, this is the recipient account. We allow either Lsend=Lrec, which denotes a local transaction, or Lsend≠Lrec, which denotes a remote transaction (i.e., a cross-ledger transfer).

v is the amount to be transferred.

σ is the signature of the sender, i.e. made with the private key corresponding to the public key sAcc on the plaintext (txid, (send, sAcc), (rec, rAcc),v).

The correctness of lid is enforced by the ledgers, i.e., for both i∈{0,1} the set TA,Li only contains transactions with lid =i. Note that although we sometimes notationally distinguish between an account and the public key that is associated with it, for simplicity we will assume that these are either identical or can always be derived from one another (this assumption is not essential for our construction).

The membership-deciding algorithm for VA (detailed as Algorithm 7 in Appendix B) processes the sequence of transactions (txl,tx2,…,txm) given to it as input in their order. Assuming transactions are syntactically valid, the function verifies for each transaction txi the freshness of txid, validity of the signature, and availability of sufficient funds on the sending account. For an intra-ledger transaction (i.e., one that has send =rec), these are all the performed checks.

More interestingly, VA also allows for cross-ledger transfers. Such transfers are expressed by a pair of transactions in which send ≠rec. The first transaction appears in lid =send, while the second transaction appears in lid = rec. The two transactions are identical except for this change in lid (this is the only exception to the txid-freshness requirement). Every receiving transaction has to be preceded by a matching sending transaction. Cross-chain transactions have to, similarly to intra-ledger transactions, conform to laws of balance conservation.

Note that VA does not require that every “sending” cross-ledger transaction on the sender ledger is matched by a “receiving” transaction on the receiving ledger. Hence, if the asset A is sent from ledger Lsend but has not yet arrived on Lrec then validity for this asset is not violated. All the validity language ensures is that appending the sidechain-receive transaction to the rec will eventually be a valid way to extend the receiving ledger, as long as the sidechain-send transaction has been included in send.

2) Instantiating effectLi→Lj: For the simple asset A outlined above, every cross-ledger transfer is a “sending” transaction tx with Llid=Lsend≠Lrec appearing in Lsend, and its effect transaction is a “receiving” transaction tx′ with Llid=Lrec≠Lsend in Lrec that is otherwise identical (except for the different 1id′=1−lid). Hence, we define effectLsend→Lrec(tx)=tx′ exactly for all these transactions and no other.

3) Instantiating merge It is easy to construct a canonical function merge once we see its inputs not only as ledger states (i.e., sequences of transactions) but we also exploit the additional structure of the blockchains carrying those ledgers. The canonical merge of the set of ledger states L is the lexicographically minimum topologically sound merge, in which transactions of ledger Li are compared favourably to transactions in Lj if i<j. However, note that the construction we provide below will work for any topologically sound merge function.

One can easily observe the following statement.

Proposition 1.
The validity language VA is correct (according to Definition 7) with respect to the merge function defined above.

C. The Sidechain Construction
We now describe the procedures for running a sidechain in the configuration outlined at the beginning of this section: with independent staking on MC and merged staking on SC; direct observation of MC and cross-chain certification of SC. We describe the sidechain's creation, maintenance, and the way assets can be transferred to it and back. The protocol we describe below is quite complex, we hence choose to describe different parts of the protocol in differing levels of detail. This level is always chosen with the intention to allow the reader to easily fill in the details. A graphical depiction of our construction that can serve as a reference is given in Figure 2.

1) Notation: Where applicable, we denote the analogues of the mainchain objects on the sidechain with an additional overline. In our pseudocode, we use the statement “post tx to L” to refer to the action of broadcasting the transaction tx to the maintainers of the ledger L so that they include it in the ledger eventually as prescribed by the protocol. Unless indicated otherwise, we also denote by MC (resp. SC) the current ledger state of the ledger MC (resp. SC) as viewed by the party executing the protocol. Similarly, we denote by CMC (resp. CSC) the currently held chain corresponding to the ledger MC (resp. SC). Hence, for example MC always represents the state stored in the stable part of the chain CMC.


Fig. 2:
Our sidechain construction. Blocks are shown as rectangles. Adjacent blocks connect with straight lines. Squiggly lines indicate some blocks are omitted. MC is at the top, SC at the bottom. Epochs are separated by dashed lines. ejadopt is the epoch of first signalling; ejstart is the activation epoch. Blocks of interest: 1. The first block signalling SC awareness; 2. The SC genesis block; 3. A txsend transaction for a deposit; 4. A txrec transaction for a deposit; 5. A txsend transaction for withdrawal; 6. A sc-cert transaction signalling trust transition within SC and certifying pending withdrawals; 7. A txrec transaction for withdrawal, certified in a sc-cert transaction e.g. in block 6

Show All

2) Helper Transactions and Data: The construction uses a set of helper transactions which can be included in both blockchains, but do not get reported in the respective ledgers. These helper transactions store the appropriate metadata which is implementation-specific and allow the pegging functionality to be maintained. The transaction types sidechain_support, sidechain_certificate, sidechain_success and sidechain_failure, whose nature will be detailed later, are of this kind. Moreover, our concrete implementation of pegged ledgers extends certain transactions with additional information (such as Merkle-tree inclusion proofs) that are, for convenience, understood to be stripped off these transactions when the blockchain is interpreted as a ledger.

3) Initialisation: The creation of a new sidechain SC starts by any of the stakeholders of the mainchain adopting the code that implements the sidechain. This action does not require the stakeholders to put stake on the sidechain but merely to run the code to support it (e.g. by installing a pluggable module into their client software). In the following this is referred to as “adopting the sidechain” and captured by the predicate SidechainAdoption. The adoption is announced at the mainchain by a special transaction detailed below. Each sidechain is identified by a unique identifier idSC.

Let jadopt denote the epoch on MC when the first adoption transaction has appeared; the sidechain SC – if its activation succeeds as discussed below – will start at the beginning of some later epoch jstart and will have its slots and epochs synchronized with MC. The software module implementing the sidechain comes with a set of deterministic rules describing the requirements for the successful activation of the sidechain, as well as for determining jstart. These rules are sidechain-specific and are captured in a predicate ActivationSuccess and a function ActivationEpoch, respectively. One typical such example is the following: the sidechain starts at the beginning of MC-epoch jstart for the smallest jstart that satisfies: (i) jstart jadopt > c1; (ii) at least c2-fraction of stake on MC is controlled by stakeholders that have adopted SC; for some constants c1,c2. Additionally, if such a successful activation does not occur until a failure condition captured by a predicate Activation Failure is met (e.g. until a predetermined period of c3>c1 epochs has passed), the sidechain initialization is aborted.

The activation process then follows the steps outlined below, the detailed description is given in Algorithm 2 in Appendix B. First, every stakeholder Ui of MC (holding a key pair (vk, sk)) that supports the sidechain posts a special transaction (sidechain_support, idSC,vk,vk signed by sk into the mainchain. Here vk′ is a public key from an ATMS key pair freshly generated by Ui; its role is explained in Section IV-C 8 below.

If the sidechain activation succeeds, then during the first slot of epoch jstart the stakeholders of MC that support SC construct the genesis block G¯¯¯¯=(idSC,SD¯¯¯¯¯¯¯jstar,η¯¯¯jstarn≜H(idSC, ηjstart), P,avkjstart) for SC. ηjstart is the randomness for leader election on MC in epoch jstart (derived on MC in epoch jstart−1). It is reused to compute the initial sidechain randomness η¯¯¯jstart as well, further η¯¯¯j′ for j′>jstart are determined independently on SC using the Ouroboros coin-tossing protocol.5 Furthermore, P and avkjstart are public parameters and an aggregated public key of an ATMS scheme; their creation and role is discussed in Section IV-C 8 below. Note that G¯¯¯¯ is defined mostly for notational compatibility, as SD¯¯¯¯¯¯¯jstart is empty at this point anyway. G¯¯¯¯ can be constructed as soon as ηjstart is known and stable.

The stakeholders that adopted SC post into MC a transaction sidechain_sucess(idSC) to signify that SC has been initialized. If the sidechain creation expires, then, after the first block of the next epoch after expiration occurs, the stakeholders of MC that supported SC post the transaction sidechai nfail ure(idSC) to MC. We assume that both predicates ActivationSuccess and ActivationFailure can be evaluated based on the state of MC only, and hence spurious success/failure transactions will be considered invalid.

4) Maintenance: Once the sidechain is created, both the mainchain and the sidechain need to be maintained by their respective set of stakeholders (detailed below) running their respective instance of the Ouroboros protocol.

In the case of the mainchain, the maintenance procedure is given below, with its exact code shown in Appendix B as Algorithm 3. This algorithm is run by all stakeholders controlling stake that is recorded on the mainchain. Each stakeholder, on every new slot, collects all the candidate MC-chains from the network (modelled via the Diffuse functionality) and filters them for both consensus-level validity (using MC.ValidateConsensusLevel and transaction validity (using the VERIFIERMC predicate given in Algorithm 8). Out of the remaining valid chains, he chooses his new state CMC via PickWinningChain. Then the stakeholder evaluates whether he is an eligible leader for this slot, basing its selection on the stake distribution SDj, and randomness ηj, which are determined once per epoch in accordance with the Ouroboros protocol. If the stakeholder finds out he is a slot leader, he creates a new block B by including all transactions currently valid with respect to CMC (as per the predicate VERIFYTXMC given also in Algorithm 8), appends it to the chain CMC and diffuses the result6 for other parties to adopt.

The maintenance procedure for SC is similar, hence we only describe here how it differs from Algorithm 3. Most importantly, it is executed by all stakeholders who have adopted SC, irrespectively of whether they own any stake on SC. Recall that the slots and epochs of the SC-instance of Ouroboros are aligned with the slots and epochs of MC.

The first difference is that all ocurrences of MC and CMC are naturally replaced by SC and CMC, respectively. This also means that the validity of received chains (resp. transactions), determined on line 13 (resp. 21), is decided based on predicate VERIFIERSC(·, CMC) (resp. VERIFYTXSC(·)) instead of the predicate VERIFIERMC(·) (resp. VERIFYTXMC(·)) Additionally, note that VERIFYTXSC must be called with a sequence of transactions containing both the transactions in SC as well as the transactions in MC interspersed and timestamped, similarly to the way done in Line 2 of Algorithm 10. This is straightforward to implement, as the sidechain maintainers also directly observe the mainchain. The predicates VERIFYTXSC and VERIFIERMC are given in Algorithm 10 in Appendix B.

Second, instead of the stake distribution SDj determined on line 6, a different distribution SD¯¯¯¯¯¯¯∗j is determined to be used for slot leader selection in the j-th epoch of the sidechain. The dismbution SD¯¯¯¯¯¯¯∗ contains all stake belonging to stakeholders that have adopted SC, irrespectively of whether this stake is located on MC or SC (we call such stake SC-aware). It can be obtained by combining the distribution SD¯¯¯¯¯¯¯ as recorded in SC with the distribution of SC-aware stake on MC (which is known to SC-maintainers via direct observation of MC). Note that the distribution used for epoch j reflects the stake distribution of SC-aware stake in the past, namely by slot 4k of epoch j-1, just as in MC. Naturally, this also implies that the fourth parameter for the SlotLeader predicate on line 17 is SD¯¯¯¯¯¯¯∗j instead of SDj.

Finally, the block construction procedure on line 23 is adjusted so that in the last 2k slots of each epoch, the created blocks on the sidechain also contain an additional ATMS signature of a so-called sidechain certificate (how this certificate is constructed and used will be described below). Hence, whenever sl mod R < 10k, line 23 is replaced by B ← (prev, tx⃗ valid,σ,σsc−certj+1) where σsc−certj+1=Sigsk(sc−certj+1) and j is the current epoch index.

5) Depositing to SC: Once SC is initialized, cross-chain transfers to it can be made from MC. A cross-chain transfer operation in this case consists of two transactions txsend and txrec that both have send =MC, rec = SC, and all other fields are also identical, except that each txi for i∈ {send, rec} contains lid =i. The sending transaction txsend is meant to be included in MC, while the receiving transaction txrec is meant to be included in SC.

Whenever a stakeholder on MC that has adopted SC wants to transfer funds to SC, she diffuses txsend with the correct receiving account on SC and the desired amount. Honest slot leaders in MC include these transactions into their blocks just like any intra-chain transfer transactions. Maintainers of MC keep account of a variable poo1SC, initially set to zero. Whenever a txsend is included into MC, they increase poo1SC by the amount of this transaction.

When txsend becomes stable in MC (i.e., appears in MC, this happens at most 2k slots after its inclusion), the stake-holder creates and diffuses the corresponding txrec which credits the respective amount of coins to rAcc in SC, to be included into SC. In practice, this is akin to a coinbase transaction, as the money was not transferred from an existing SC account.

Note that depositing from MC to SC is relatively fast; it merely requires a reliable inclusion of txsend into MC and consequently of txrec into SC, as guaranteed by the liveness of the underlying Ouroboros instances. The depositing algorithm code is shown in Algorithm 4 in Appendix B.

6) Withdrawing to MC: The withdrawal operation is more cumbersome than the depositing operation since not all nodes of MC have adopted (i.e., are aware of and follow) the sidechain SC. As transactions, the withdrawals have the same structure as deposits, consisting of txsend and txrec, with the only difference that now they both have send = SC and rec =MC. The sending transaction will be handled in the same way as in the case of deposits, but the receiving transaction requires a different certificate-based treatment, as detailed below.

Whenever a stakeholder in SC wishes to withdraw coins from SC to MC, she creates and diffuses the respective transaction txsend with the correct transfer details as before. If txsend is included in a block that belongs in one of the first R−4k slots of some epoch then let jsend denote the index of this epoch, otherwise let jsend denote the index of the following epoch. The stakeholder then waits for the end of the epoch ejsend to pass and ejsend+1 to begin.

At the beginning of ejsend+1, a special transaction called sidechain certificate sc−certjsend+1 is generated by the maintainers of SC. It contains: (i) a Merkle-tree commitment to all withdrawal transactions txsend that were included into SC during last 4k slots of epoch jsend−1 and the first R-4k slots of epoch jsend (as these all are already stable by slot R−2k of epoch jsend); (ii) other information allowing the maintainers of MC to inductively validate the certificate in every epoch. The construction of sc-cert is detailed below, for now assume that the transaction provides a proof that the included information about withdrawal transactions is correct. The transaction sc-cert is broadcast into the MC network to be included into MC at the beginning of ejsend+1 by the first honest slot leader.

The stakeholder who wishes to withdraw their money into MC now creates and diffuses the transaction txrec to be included in MC. This transaction is only included into MC if it is considered valid, which means: (1) it is properly signed; (2) it contains a Merkle inclusion proof confirming its presence in some already included sidechain certificate; (3) its amount is less or equal to the current value of poo1SC. If included, MC-maintainers decrease the value of poo1SC by the amount of this transaction. The code of the withdrawal algorithm is illustrated in Algorithm 5 in Appendix B.

7) The certificate transaction: We now describe the construction of the sc-cert transaction, also called the sidechain certificate, formally described in Algorithm 6 in Appendix B. The role of the certificate produced by the end of epoch j−1 to be included in MC at the beginning of epoch j (denoted sc−certj) is to attest all the withdrawals that had their sending transactions included into SC in either the last 4k slots of ej−2 or the first R−4k slots of ej−1. To maintain a chain of trust for the MC maintainers that cannot verify these transactions by observing SC, we make use of ad-hoc threshold multisignatures introduced in Section IV-A. Namely, the sc−certj transaction also contains an aggregate key avkj of an ATMS, and is signed by the previous aggregate key avkj−1 included in sc−certj−1.

sc−certj is generated by SC-maintainers and contains:

The epoch index j.

The pending transactions from SC to MC. Let tx⃗  be the sequence of all transactions which are included in SC during either the last 4k slots of ej−2 or the first R−4k slots of ej. All transactions in tx⃗  that have SC = send ≠ rec = MC are picked up and combined into a list pendingj (sorted in the same order as in SC). Let ⟨pending}_j\rangle$ denote a Merkle-tree commitment to this list.

The new ATMS key avkj. The key is created from the public keys of the slot leaders of the last 2k slots of the epoch j, using threshold k +1. Hence, it allows to verify whether a particular signature comes from k + 1 out of these 2k keys.

Signature valid with respect to avkj-1.

The full sc_certj is therefore a tuple (j,⟨pendingj⟩, avkj, σj), where σj is an ATMS signature on the preceding elements that verifies using avkj-1.

The certificate sc−certj+1 is constructed as follows: Both the stake distribution SD¯¯¯¯¯¯¯∗j+1 and the SC-randomness η¯¯¯j+1 (and hence also the slot leader schedule for SC in epoch j + 1) are determined by the states of the blockchains MC and SC by the end of slot 10k of epoch j. Therefore, during the last 2k slots of epoch j, the 2k elected slot leaders for these slots can already include a (local) signature on (their proposal of) sc−certj+1 into the blocks they create. Given the deterministic construction of sc−certj+1, all valid blocks ending up in the part of SC-chain belonging to the last 2k slots of epoch j will contain a local signature on the same sc−certj+1, and by the chain growth property of the underlying blockchain, there will be at least k+1 of them. Therefore, any party observing SC can now combine these signatures into an ATMS that can be later verified using the ATMS key avkj, it can hence create the complete certificate sc−certj+1 and serve it to the maintainers of MC for inclusion.

8) Transitioning trust. As already outlined above, our construction uses ATMS to maintain the authenticity of the sidechain certificates from epoch to epoch. We now describe this inductive process in greater detail.

Initially, during the setup of the sidechain, P← PGen (1κ) is ran. Stakeholders generate their keys by invoking (ski, vki) ←Gen(P). In case Gen is a probabilistic algorithm, it is run in a derandomized fashion with its coins fixed to the output of a PRNG that is seeded by H(ats-init, ηjstart) where “ats_init” is a fixed label and H is a hash function. This ensures that P will be uniquely determined and will still be unpredictable. We note that this process is only suitable for ATMS that employ public-coin parameters; our ATMS constructions in Section V are only of this type.

For the induction base, P is published as part of the Genesis block G¯¯¯¯. Each time an MC stakeholder Ui posts the sidechain-support message to MC, he also includes an ATMS key vki. Subsequently, when the SC is initialised, the stake distribution SD¯¯¯¯¯¯¯∗jstart is known to the MC participants. Hence, based on SD¯¯¯¯¯¯¯∗jstart and η¯¯¯jstart, these can determine the last 2k slot leaders of epoch jstart in SC, we will refer to them as the jstart-th trust committee. (In general, the j-th trust committee for j≥jstart will be the set of last 2k slot leaders in epoch j.) SC-maintainers (that also follow MC) can also determine the jstart-th trust committee and therefore create avkjstart from their public keys and insert it into the genesis block G¯¯¯¯ of SC. They can also serve it as a special transaction to the MC-maintainers to include into the mainchain. The correctness of avkjstart can be readily verified by anyone following the mainchain using the procedure ACheck of the used ATMS.

For the induction step, consider an epoch j>jstart and assume that there exists an ATMS key of the previous epoch avkj−1, known to the mainchain maintainers. Every honest SC slot leader among the last 2k slot leaders of SC epoch j−1 will produce a local signature sji on the message m= (j,⟨pendingj⟩, avkj) using their private key skj−1i by running Sig(skj−1i, m), and include this signature into the block they create. The rest of the SC maintainers will verify that the epoch index, avkj and ⟨pendingj⟩ are correct (by ensuring ACheck(VKj, avkj) is true for VK denoting the public keys of the last 2k slot leaders on SC for epoch j, and by recomputing the Merkle tree commitment ⟨pendingj⟩) and that sji is valid by running Ver(m, vkj−1i, sji), otherwise the block is considered invalid. Thanks to the chain growth property of the underlying Ouroboros protocol, after the last 2k slots of epoch j−1 the honest sidechain maintainers will all observe at least k+1 signatures among the {sji : i∈ [2k]} desired ones. They then combine all of these local signatures into an aggregated ATMS signature σj← ASig (m, {(sji, vkj−1i)}, keysj). This combined signature is then diffused as part of sc−certj on the mainchain network. The mainchain maintainers verify that it has been signed by the sidechain maintainers by checking that AVer (m, avkj−1, σj) evaluates to true and include it in a mainchain block. This effectively hands over control to the new committee.

SECTION V.Constructing Ad-Hoc Threshold Multisignatures
We now present an instantiation of the ATMS primitive based on the multisignature scheme ΠMGS from [6]. Note that other constructions are possible: we defer a discussion of a plain signature-based ATMS, as well as an ATMS based on proofs of knowledge, to the full version of this paper.

We make use of a homomorphic property of ΠMGS: any d individual signatures σ1, …, σd created using secret keys belonging to (not necessarily unique) public keys vk1, …, vkd can be combined into a multisignature σ=∏i=1dσi that can then be verified using an aggregated public key avk=∏i=1dvki.

Our multisignature-based t-ATMS construction works as follows: the procedures PGen, Gen, Sig and Ver work exactly as in ΠMGS. Given a set S, denote by ⟨S⟩ a Merkle-tree commitment to the set S created in some arbitrary, fixed, deterministic way. Procedure AKey, given a sequence of public keys VK={vki}ni=1 returns avk=(∏ni=1vki, ⟨VK⟩). Since AKey is deterministic, A Check (VK, avk) simply recomputes it to verify avk. ASig takes the message m,d pairs of signatures with their respective pu–blic keys {σi, vki}di=1 and n−d additional public keys {vki}n−di=1 and produces an aggregate signature

σ=(∏i=1dσi,{vkˆi}n−di=1,{πvkˆi}n−di=1)(1)
View SourceRight-click on figure for MathML and additional features.

where πvkˆi denotes the (unique) inclusion proof of vkˆi in the Merkle commitment ⟨{vki}di=1∪{vkˆi}n−di=1⟩. Finally, the procedure AVer takes a message m, an aggregate key avk, and an aggregate signature σ parsed as in (1), and does the following: (a) verifies that each of the public keys vki indeed belongs to a different leaf in the commitment ⟨VK⟩ in avk using membership proofs πvkˆ; (b) computes avk′ by dividing the first part of avk by ∏i=1n−dvkˆi;(c) returns true if and only if d≥t and the first part of σ verifies as a ΠMGS-signature under avk′.

Note that the scheme ΠMGS requires vki to be accompanied by a (non-interactive) proof-of-possession (POP) [26] of the respective secret key. This POP can be appended to the public key and verified when the key is communicated in the protocol. For conciseness, we omit these proofs-of-knowledge from the description (but we include them in the size calculation below).

In the optimistic case where each of the 2k committee members create their local signatures, both the aggregate key avk and the aggregate signature σ are linear in the security parameter, which is optimal. If r<k of the keys do not provide their local signatures, the construction falls back to being quadratic in the worst case if r=k−1.

Concrete signature sizes in this scheme for practical parameters could be as follows. We set k=2160 (as is done in the Cardano implementations of [18]) and for the signature of [6] we have in bits: |vki|=272,|σi|=528 (N. Di Prima, V. Hanquez, personal communication, 16 Mar 2018), with |vki+POP|=|vki|+|σi|=800 bits. Assuming 256-bit hash function is used for the Merkle tree construction, the size of the data which needs to be included in MC in the optimistic case during an epoch transition is |avk|+|σ|+|⟨pending⟩|=|vki+POP|+2|H(⋅)|+|σi|=800+512+528=1840 bits per epoch. In a case where 10% of participants fail to sign, the size will be |avk|+|σ|=|vki+POP|+2|H(⋅)|+|σi|+0.1. 2⋅k(|vki+POP| +log(k)|H(⋅))= 800+512+528+432. (500+12. 256)=1544944, or about 190 KB per epoch (which is approximately 5 days).

SECTION VI.Security
Our main theorem below states that under natural assumptions, the construction from Section IV implements a secure 2-way peg according to Definition 8.

Let Ahm(L) denote the honest-majority assumption for an Ouroboros ledger L. Namely, Ahm(L) postulates that in each slot t, the majority of stake in the stake distribution used to sample slot leader for slot t in L is controlled by honest parties (note that the distribution in question is SD and SD¯¯¯¯¯¯¯∗ for MC and SC, respectively). The assumption AMC we consider for MC is precisely Ahm(MC), while the assumption ASC for SC is Ahm(MC)∧Ahm(SC). The reason that ASC⇒AMC is that SC uses merged staking and hence cannot provide any security guarantees if the stake records on MC get corrupted. It is worth noting that it is possible to program SC to wean off MC and switch to independent staking; in such case the assumption for SC will transition to Ahm(SC) (now with respect to SD¯¯¯¯¯¯¯) after the weaning slot and the two chains will become sidechains of each other.

Theorem 1.
Consider the synchronous setting with 2R- semiadaptive corruptions defined in Section II-A. The construction of Section IV, using a secure ATMS and a collision resistant hash function, is pegging secure with liveness parameter u=2k with respect to assumptions AMC and ASC, and merge, effect and VA defined in Section IV-B.

The proof of Theorem 1 is deferred to the full version of the paper.