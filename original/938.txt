We present VerX, the first automated verifier able to prove functional properties of Ethereum smart contracts. VerX addresses an important problem as all real-world contracts must satisfy custom functional specifications.VerX is based on a careful combination of three techniques, enabling it to automatically verify temporal properties of infinite- state smart contracts: (i) reduction of temporal property verification to reachability checking, (ii) a new symbolic execution engine for the Ethereum Virtual Machine that is precise and efficient for a practical fragment of Ethereum contracts, and (iii) delayed predicate abstraction which uses symbolic execution during transactions and abstraction at transaction boundaries.Our extensive experimental evaluation on 83 temporal properties and 12 real-world projects, including popular crowdsales and libraries, demonstrates that VerX is practically effective.
SECTION I.Introduction
Ensuring correctness of smart contracts, programs that run on top of blockchains, is a pressing security concern. Today, billions worth of USD are controlled by smart contracts, and only in the past couple of years, millions of these have been lost by exploiting subtle flaws in the logic of these programs. The issue is exacerbated as the code becomes immutable once placed on the blockchain and hence bugs found after deployment cannot be fixed.

Current audit practice. To mitigate this problem, current audit practices of smart contracts involve checking whether the code is safe against two kinds of vulnerabilities: (i) generic security errors such as reentrancy and overflows, typically achieved by running automated security tools (e.g., Secu- rify [65], Slither [4], and Mythril [50]), and (ii) deeper, custom functional requirements, often done by manual, best-effort code inspection. An example of such a requirement is: "The sum of deposits never exceeds the contract’s balance.". While substantial advances in creating security tools that discover generic errors were made over the last few years, there has been little progress in automating the verification of deeper, more challenging functional properties. This is particularly problematic because manually checking the satisfaction of such deeper requirements often involves non-trivial reasoning, increasing the chance that critical bugs slip in production.

Goal: Formal guarantees for smart contracts. We believe that smart contracts, similarly to any safety-critical system (e.g., controllers deployed in cars and airplanes), must be formally verified before deployment. While this observation is not new, only a handful of smart contract projects (e.g., MakerDAO [7]) have been formally verified so far. Current verification efforts are conducted using heavyweight interactive- theorem provers, such as Isabelle/HOL [9] and Coq [68]. These require non-trivial manual effort and expertise, making the audit process expensive and time-consuming, resulting in limited adoption by the developer and audit communities.


Fig. 1
Usage and verification flow of VerX. A requirement is formalized as a temporal safety property. Then, the contract is instrumented with the property and relevant predicates for verification are automatically extracted. These are fed into VerX, which either verifies the property, outputs a counterexample, or indicates that additional predicates are needed.

Show All

Key challenges. To address this problem and enable developers and auditors to formally certify smart contracts without requiring deep expertise in formal verification, one would ideally create a verifier capable of automatically proving custom, functional properties. However, building such an automated verifier is challenging for at least two reasons.

First, smart contracts often interact with external contracts via function calls. In turn, these external contracts may call back the smart contracts we want to verify in arbitrary ways (since their code is unknown). Automated verification in the presence of such arbitrary and unboundedly many callbacks from external contracts is challenging.

Second, smart contracts process an unbounded number of transactions. Therefore, even though smart contracts are usually loop-free, the verifier needs to soundly handle loops because the contracts’ functions are executed in an implicit infinite loop, processing a single transaction in each iteration.

VerX: Automated verifier for Ethereum contracts. In this work, we introduce VerX, an automated verifier of functional requirements for Ethereum smart contracts, which aims to address the above challenges. The design decisions underpinning VerX were strongly motivated by the practical challenges that arise when auditing real-world smart contracts.

One of our key observations is that most real-world contracts defend against external callbacks by ensuring that these do not introduce new behaviors, i.e., any behavior with external callbacks is equivalent to another behavior without external callbacks; we call these effectively external callback free (EECF) contracts, adapting the earlier notion of effectively callback free contracts [38]. VerX focuses on verifying EECF contracts as they enjoy two important benefits. First, they simplify the formalization of requirements, as auditors can write the specification without explicitly considering all possible external callbacks. Second, the verifier can soundly avoid exploring all possible external callbacks, which facilitates precise and scalable analysis.

In Fig. 1 we depict the high-level steps performed by VerX. As a first step, we formalize the requirements as temporal safety properties in the specification language of VerX. We identify temporal properties as a particularly good fit for capturing contract requirements (also observed by [59]), because contracts process sequences of transactions and temporal properties can specify which sequences of contract states are considered valid. To ease adoption, we use the syntax of Solidity [6] (the most widely used language for Ethereum contracts) and extend it with temporal operators (e.g., always and once) so to enable quantifying over contracts’ states. Fig. 1 shows the formalization of an example requirement for crowdsale contracts. In our evaluation, we illustrate further examples and present common idioms (e.g., access control, state transitions, and multi-contract invariants) of real-world contracts that have been verified using VerX.

Once the property is formalized, VerX reduces the problem of temporal safety verification to that of reachability checking by instrumenting the provided contract with the formalized property. By working with the instrumented instead of the original contract, we can directly leverage state-of-the-art program analysis methods, which typically focus on reachability verification. Such a reduction approach to verification has been shown effective in other settings (e.g., [26], [28]).

Given the instrumented contract, VerX carries out the verification by employing a particular combination of abstraction and symbolic execution, one that is especially effective in the setting of smart contracts. We refer to this combination as delayed predicate abstraction. Concretely, to deal with the unbounded number of transactions processed by the contract, VerX abstracts contract states which arise in-between transactions via a set of abstraction predicates while leveraging symbolic execution for precise analysis within transactions. As we demonstrate with examples later, delaying abstraction until the end of transactions is essential as key invariants often break in the middle of transactions. Moreover, precise reasoning of individual transactions using symbolic execution is possible because contract functions usually have bounded loops and recursion (so to avoid infinite computations on the blockchain).

VerX automatically infers the abstraction predicates from (i) the contract’s code, such as immutable variables and pointers to contracts (e.g., e == Escrow), and (ii) from the property by extracting atomic predicates (e.g, sum(deposits)>= 10000); see Fig. 1. This means that users typically do not need to provide any predicates to VerX and can use it in a pushbutton manner. For example, as we show in our evaluation, 77 out of 83 properties can be automatically verified using the predicates inferred by VerX, leaving only six properties where the user had to provide additional predicates (shown by the backward arrow). Further, because existing symbolic engines for Ethereum are either unsound or inefficient (or both), we introduce a new engine that precisely models nonstandard features of Ethereum’s Virtual Machine (such as hash-based object allocations and gas mechanics) yet scales well for a practical fragment of Solidity.

To demonstrate the effectiveness of VerX, we present an extensive evaluation over 12 real-world projects with 83 relevant temporal properties. Our results show that VerX scales to verifying real-world contracts.

Main Contributions. Our contributions are:

A delayed predicate abstraction approach which combines symbolic execution performed during transaction execution with abstraction done in-between transactions. Delayed abstraction is key to enabling automatic verification of temporal safety properties of smart contracts.

The first end-to-end verification system, called VerX, which can automatically verify functional specifications of real-world contracts. VerX incorporates delayed abstraction, a new symbolic execution engine which avoids the pitfalls of existing tools, as well as sound handling of key Ethereum features.

An extensive experimental evaluation over 12 real-world projects (138 contracts) and 83 safety properties, showing that VerX can verify interesting temporal properties of real-world smart contracts, including popular crowdsales and libraries.

SECTION II.Motivating example and Verification Challenges
We now present a decentralized crowdsale scenario together with relevant requirements and their formalization. We then discuss key challenges when verifying such properties. In the next section we present the verification flow of VerX and how it addresses these issues.


Fig. 2
Crowdsale example: (a) requirements and (c) their formalization, (b) crowdsale contract and (d) escrow contract.

Show All

A. Crowdsale Example
We present a crowdsale use case, one of the most common scenarios implemented on Ethereum. The goal here is to collect 10, 000 ether within 30 days after deployment. It is considered successful if 10, 000 ether has been collected within 30 days, in which case the beneficiary can withdraw the funds. Otherwise, the crowdsale is considered failed and users are allowed to claim a refund. We summarize four key requirements in Fig. 2a showing how users (investors and the beneficiary) can transfer funds. The crowdsale implementation is given in Fig. 2, taken from the widely-used OpenZeppelin library [3], which uses an escrow contract to lock the funds invested during the crowdsale. The contracts’ initial state is defined by their constructors (the escrow is created by the crowdsale’s constructor, at Line 8). In the crowdsale contract, raised tracks the amount of collected funds, goal is set to 10, 000 ether (1 ether = 1018 wei), and closeTime is set to now (time of deployment) plus 30 days. The escrow tracks the funds invested by individual users in the mapping deposits.

B. Challenge 1: Specifications in the Presence of Callbacks
As a first step, we formalize the requirements of the crowdsale and escrow contracts (referred to as a bundle of contracts). This is, however, nontrivial because the bundle does not execute in isolation, but may also interact with external, potentially malicious contracts.

Interactions with external contracts. We illustrate a possible interaction between the escrow and external contracts in Fig. 3. To refund an investor p, the escrow executes Line 26, which calls a designated fallback function in p. Here, p is any account that invested in the crowdsale, and the invoked fallback function can thus have arbitrary behavior. In Fig. 3, we consider a scenario where p calls back ciaimRefund, this time passing address q as an argument. The second call ciaimRefund(q) is nested in ciaimRefund(p). Importantly, the nested call modifies the escrow’s state (changes escrow’s balance) before execution control is returned to ciaimRefund(p). This means the state at the end of claimRefund(p) depends on callbacks initiated by external contracts.

Specification challenge. Requirements typically implicitly assume that the bundle executes without callbacks. For example, requirement R0 stipulates that at the end of claimRefund(p), the escrow’s balance is decreased by p’s deposit. This requirement does not hold if we interpret it directly over executions with callbacks. As illustrated in Fig. 3, there could be multiple calls to the escrow before claimRefund(p) terminates, which may increase the escrow’s balance (via calls to deposit(p)) as well as decrease it (via calls to ciaimRefund(p)). One approach to address this discrepancy is to directly account for all possible callbacks in the formal requirement. Unfortunately, this is complicated and error-prone because external contracts can behave arbitrarily: one would need to accommodate infinitely many additional behaviors. Conceptually, this challenge is analogous to specifying concurrent objects [38], [58].


Fig. 3
Interaction between the escrow and external contracts p and q. Rectangles indicate the active function, dashed lines indicate functions waiting for external calls to return, downward and upward arrows indicate call and return points.

Show All

Effectively external callback free contracts. To address the specification challenge, we mirror a well-established approach to specifying concurrent objects [41]. The idea is to let user requirements implicitly assume no callbacks from external contracts. We then lift those requirements to all possible behaviors in a generic way. We do that by imposing an extra condition that we call effective external callback freedom (EECF), which generalizes [38] to our setting. This extra condition stipulates that any behavior with external callbacks is equivalent to a behavior without. Any two equivalent behaviors are guaranteed to execute the same functions and terminate in an identical state. For example, the behavior in Fig. 3 is equivalent to executing claimRefund(p) and then claimRefund(q) sequentially (without external callbacks).

The EECF condition is satisfied by most real-world contracts. In practice, contracts defer calls to external contracts to the end of transactions, as a generic defense against unexpected state changes due to malicious callbacks in the middle of transactions. Indeed, this best practice provides a sufficient condition to establish EECF. A contract that did not satisfy EECF is the infamous DAO contract [1], which has a function similar to claimRefund with the exception that lines 25 and 26 are switched, meaning that p’s deposit is set to zero only after the call is made. Indeed, this enables an adversary to drain the escrow’s balance (by reclaiming her deposit multiple times).


Fig. 4
Running existing symbolic analyzers for verifying φR1 and finding the violation of φR2.

Show All

Formalizing requirements. We present the formalization of the requirements for our example in Fig. 2c. The properties are interpreted over a sequence of blockchain states that appear in-between transactions, i.e., states that users observe before and after transactions. We deliberately do not define the requirements’ semantics over states that appear within transactions, as such states capture low-level implementation details and transient computations which are not observable by end-users. As mentioned, the EECF condition lifts the requirements to behaviors with callbacks: for any behavior, we impose the given requirements on the equivalent behaviors where the contract’s functions are invoked without callbacks.

Property φR0 formalizes that for any state (captured with the always temporal quantifier, denoted by ) reached after a successful execution of claimRefund(address p), the escrow’s balance (returned by Escrow.balance) equals the previous escrow’s balance (denoted Escrow.balance•) minus the deposit of investor p in the previous state. The property refers to the p’s deposit in the previous state, as it is set to zero after executing claimRefund.

Property φR1 formalizes that if the escrow is not in state success (indicating a successful crowdsale), then the sum of deposits (returned by sum (deposits)) is less than or equal to the escrow’s balance (returned by Escrow.balance).

Properties φR2 and φR3 use the once quantifier (denoted by ♦) to refer to past states, where ♦φ holds if φ holds at any past state of the contract. For example, φR2 formalizes that at no point in time the functions withdraw () and claimRefund () have both been successfully executed by the contract. Property φR3 uses the idiom (φ → ♦ψ) to formalize that once ψ holds at a given state, then φ must never hold in the future of the contract.

C. Challenge 2: Unbounded Verification
Next, we discuss the challenges in verifying the properties of our example.

Precise symbolic execution for Ethereum. We start with φR1, a global invariant of the form □φ with no nested temporal quantifiers. This property is inductive: it holds in the initial blockchain state, and it is also preserved after processing any transaction sent to the contracts at any blockchain state where φR1 holds. To establish this, one can encode all behaviors of the functions using symbolic execution, which is possible due to the limited use of loops/recursion in most contracts, as we discuss in Section VII. However, modeling Ethereum’s Virtual Machine (EVM) both precisely and efficiently has proved challenging. In fact, in Fig. 4, we show that 2 out of the 3 state-of-the-art symbolic execution engines for Ethereum fail to establish our invariant (i.e., to verify property φR1); we note that Manticore [2] is precise, but inefficient for some examples, as we show in our evaluation (Section IX). We address this challenge by designing a new symbolic execution engine for EVM (Section VIII-A) that is both precise and efficient for a practical fragment of Solidity (Section VII).


Fig. 5
Flow of VerX: given a contract C and property φ, VerX instruments C with φ and attempts an inductive check using symbolic execution. If this fails, it performs delayed abstraction using predicates extracted from C and φ.

Show All

Discovering deeper violations. The following sequence of transactions violates property φR2:

call to close () at state now > closeTime and raised < goal, which changes the escrow’s state to refund;

call to claimRefund(p) with any address p;

call to invest () with ether value msg.value ≥ goal;

call to close(), now at state now > closeTime and raised ≥ goal, which changes the escrow’s state to success;

call to withdraw ().

This violation is due to a missing pre-condition in function invest () (Line 15 in Fig. 2b) which would prevent calls after the crowdsale has ended. This shows that counter-examples in stateful contracts can be deep, going beyond the reach of existing symbolic execution tools (with their default depth limit of 2). In fact, in Fig. 4, we see that both Mythril and Manticore (which unroll multiple transactions) fail to discover the violation with a 5 hours timeout limit and a depth limit set to 5. Oyente discovers the bug due to imprecise modeling of EVM and not due to supporting precise exploration up to depth 5 (as shown in the false positive for φR1). VerX correctly fails to verify this property and outputs exactly the sequence of transactions listed above as a possible violation. As we show in our evaluation, once the missing pre-condition is added, VerX successfully verifies φR2.

Inferring invariants using abstraction. Property φR3 is non-inductive. To verify it, VerX needs to infer an invariant that holds over all reachable contract states. In this example, the invariant is constructed out of the following atomic predicates: now > closeiime, raised < goal, and sum (deposits) ≤ raised, where the first two predicates come from function pre-conditions. VerX extracts these and other predicates from the code and the property. To compute the needed invariant, VerX uses delayed abstraction (explained shortly) where the abstraction step is applied only at transaction boundaries. This delay is needed to verify φR3 because the predicate sum (deposits) ≤ raised is violated between Line 16 and Line 17 in the crowdsale contract. That is, standard predicate abstraction would fail to verify φR3 with these predicates, while delayed predicate abstraction succeeds. Delayed predicate abstraction is explained in Section VI.

SECTION III.Verification Flow of VerX
We now describe the verification flow of VerX (illustrated in Fig. 5) and discuss how it addresses key technical challenges. The input to VerX consists of one or more contracts (we call these a bundle of contracts) together with a (temporal) safety property φ. For illustration purposes, we assume we are given one contract C with functions {f1,…, fn}.

Verification by reduction. First, to verify a temporal property of interest φ, VerX processes C and φ so to produce an instrumented contract Cφ' and a new property □ φ', where □ is the always quantifier and φ' is an assertion over the global blockchain state. For example, it converts φR3 = □(claimRefund() → ♦(sum(deposits) > goal)) into □(claimRefund() → pψ), where pψ tracks whether sum (deposits) > goal has been satisfied in the current or the past states of the contract. This approach of reducing temporal property verification to a reachability check was successfully used in prior work (e.g., [26], [28]). A key benefit is that it enables VerX to leverage existing analysis techniques, such as symbolic execution and predicate abstraction (described next) to verify that □ φ' holds on the instrumented contract Cφ' (and as a result that φ holds on the original contract C).

Verification of inductive properties without abstraction.

As stated, the contract’s functions are run in an infinite loop:


Each iteration corresponds to the execution of a single transaction, constructed by any user who decides to run an arbitrary contract function with arbitrary arguments. Since this loop is infinite and the number of transactions that users may initiate is unknown in advance, we cannot directly apply symbolic execution (SE) to verify that φ' holds on the instrumented contract (as SE requires loops to be bounded). That is why we first attempt to verify φ' inductively: assuming φ' holds before fi is invoked (pre-condition) with symbolic arguments and a symbolic user, we check whether φ' holds after fi has completed (post-condition). If the inductive check holds for every function fi and if φ' holds on the initial state then we conclude that φ' holds on Cφ'. If the above check fails, however, φ' may still hold for Cφ'. Conceptually, this means we need to strengthen φ' while ensuring that it overapproximates the reachable states of Cφ'.

Verification with delayed predicate abstraction. To overapproximate the reachable states of Cφ', VerX uses a combination of predicate abstraction and symbolic execution to perform delayed predicate abstraction. The idea is to analyze each transaction fully with symbolic execution and abstract only the states where φ' is meant to hold, namely, those appearing at transaction boundaries. The abstraction is done using the predicates automatically extracted from the contract C and the original property φ.

We iterate this procedure in a classic fixed point iteration loop. First, we initialize the set reach(Cφ') of abstract states reachable at transaction boundaries with the abstraction of the concrete initial state. Then, we simply follow the outer while loop and non-deterministically select a function fi to invoke; we execute fi symbolically (assuming symbolic arguments and a symbolic user) and compute the precise symbolic state s at the end of the transaction. Technically, s is a disjunction of constraints p1 ˅⋯˅pk, each pi capturing a possible path of the function’s k paths. After computing s, VerX abstracts each Pi ∈ s into an abstract state αi. This results in a set of new abstract states α1,…, αm which are added to reach(Cφ'). Note that m ≤ k, as the symbolic states of two paths may become abstracted to the same abstract state.

Despite the infinite outer loop, VerX is guaranteed to reach a fixed point since the predicate abstraction domain is finite (due to the finite number of abstract predicates). The overapproximation of the reachable states of Cφ' is given by the disjunction α1 ˅⋯˅ αt of all abstract states in the fixed point reach(Cφ'). To verify the property, VerX checks whether the fixed point logically implies the desired property φ'. If yes, we conclude that □φ' holds on Cφ'. Otherwise, VerX attempts to construct a counter-example. In doing so, it either succeeds and outputs the counter-example or fails and asks the user to provide additional predicates. We note that one could implement standard abstraction refinement techniques to automate predicate discovery [25].

SECTION IV.System Model
In this section we provide background on the Ethereum blockchain and formalize its behavior. We then formalize the notion of bundle behaviors VerX reasons about.

A. Ethereum Overview
The Ethereum blockchain is a distributed storage that supports two types of accounts: user accounts and contract accounts. User accounts are the entry-points through which users interact with the system by submitting transactions. Contract accounts (or simply contracts) are autonomous objects that process transactions. Every contract is associated with a program that executes incoming transactions, and a private storage for persisting data across transactions.


Fig. 6
An execution is a sequence of external transactions each nesting one or more internal transactions. Each internal transaction starts with a message and proceeds in a sequence of commands. Commands may load or store data from and to the private storage, perform local computations (not affecting the storage), and initiate nested internal transactions.

Show All


Fig. 7
An EVM behavior is a sequence of machine states, represented as pairs holding a blockchain state and a stack of frames, one per nested internal transaction.

Show All

An execution of the Ethereum blockchain is a sequence of external transactions, as defined in Fig. 6. Each transaction is initiated with a message that defines the addresses of the recipient and sender accounts, a value of ether (possibly zero) to be transferred from the sender to the recipient account, (possibly empty) data, and a gas value. If the recipient is a user account then the data is empty and the transaction results in transferring the ether value from the sender to the recipient. Otherwise, the recipient is a contract, and the data identifies a function of the contract’s program together with arguments passed to the function. Upon the reception of such a message, the contract’s program is executed by the Ethereum Virtual Machine (EVM) [66], modifying the contract’s storage accordingly. The execution of each command, such as a storage write, is associated with a gas fee and the execution aborts if the accumulated gas fees exceed the gas value.

A contract’s program can create messages to start transactions on other contracts, which in turn can do the same. These transactions behave like a standard procedure call, meaning the caller waits for the callee to complete. The calls have transactional semantics and are termed internal transactions. Since procedure calls nest, this leads to a nested transactional model: aborting the current internal transaction undoes its effects on the storage, including the effects of all nested (child) internal transactions. The top-level transaction initiated by the user together with all nested transactions form an external transaction. Finally, an execution of the Ethereum blockchain is a sequence of such external transactions.

To illustrate this model, consider that account User calls function close() of the Crowdsale contract in Fig. 2, which in turn calls function close() of the Escrow contract. The corresponding external transaction is given by

 - 
Show All

Here, we omit all non-calls (indicated by⋯). This transaction consists of two messages. The amount of ether in both messages is set to 0, indicating that no ether is transferred when processing the transaction. The value 200 000 in the first message is the amount of gas provided by User for processing the transaction. The gas in the second message (129 275) is lower as reaching the call to the escrow costs 70 725 gas.

B. Ethereum Behaviors
A behavior of the EVM is the sequence of machine states the EVM goes through during execution. The EVM state of the EVM is formalized in [66], of which we provide a schematic description in Fig. 7. A machine state is a pair holding the blockchain state, and a stack of frames, one per active nested internal transaction.

The blockchain state collects all account data and is a mapping from account addresses to account states. The figure shows only contract accounts, whose state consists of the contract’s program, storage, and balance (values).

A frame contains: (1) the message used to activate the call, (2) the next program fragment to be executed (i.e., a program counter), (3) the call’s local scratchpad memory, (4) the remaining gas available for execution.

The EVM operates on 32-byte words. All numeric values (e.g. addresses) are represented as unsigned integer words. Contract storage and frame memory are word-addressed.

C. Bundle Behaviors
The requirements of a bundle C of contracts constrain its EVM behaviors. Given an EVM behavior, we obtain the behavior of the bundle by extracting the sequence of pairs (T, b) where T is a transaction whose recipient is in the bundle C and b is a blockchain state that captures the effects of T. As discussed in Section II-B, we follow the well-established approach in the field of concurrency and extract behaviors of C only from EVM behaviors without external callbacks (i.e., without concurrency). Thus, our specifications do not directly constrain all possible EVM behaviors but only those where transactions run isolated from external callbacks. The remaining EVM behaviors are controlled by imposing a generic correctness criterion [38] on the bundle C.

Definition 1. A C-entry transaction in an EVM behavior is a transaction executed by a contract in C whose parent transaction, if present, is executed by a contract not in C.

For example, in the EVM behavior in Fig. 3 the transactions Escrow.claimRefund(p) and Escrow.claimRefund(q) are C-entry transactions: the first one is an external transaction that executes contract Escrow and does not have a parent transaction; the second one executes contract Escrow and its parent transaction is executed by a contract p ∉ C outside the bundle C = {Escrow, Crowdsale}.

We call an EVM execution C-external callback-free if it contains no C-entry transaction nested in another C-entry transaction. For example, the behavior shown in Fig. 3 is not C-external callback-free because Escrow.claimRefund(q) is nested inside Escrow.claimRefund(p).

Let msg(T) be the message that initiated T, and let post(T) stand for the blockchain state at the point when T finishes.

Definition 2. The bundle behavior of C corresponding to a C-external callback-free EVM execution is the sequence that records the pair
(msg(T),post(T))
View Source

for every C-entry transaction T in the EVM execution.

That is, for every transaction T, the behavior records the transaction message and the blockchain state at the end of T but restricted only to contracts in the bundle C.

Effective external callback freedom. The criterion that we impose on bundles requires that all EVM behaviors are in a certain sense equivalent to C-external callback-free executions. We adapt the effective callback freedom criterion of Grossman et al. [38] to our setting where the internal callbacks within a C-entry transaction are thought of as executing sequentially. Both, our criteria and [38], are variants of conflict-serializability [52]. For brevity, we do not state the actual criterion but a necessary and sufficient condition. As standard, we formalize the condition by first constructing a directed graph (digraph) that captures dependencies between operations and then requiring that the resulting digraph is acyclic.

Definition 3. The C-serialization digraph of an EVM execution has a vertex for every C-entry transaction and an edge (S, T) for all operations s of S and t of T (S ≠ T) such that:

s precedes t in the EVM execution, and

at least one of s and t modifies part of the blockchain state that is read or modified by the other

Intuitively, each edge (S, T) indicates that the blockchain state after T depends on S being executed earlier. C-entry transactions not involved in circular dependencies are not logically interrupted by callbacks outside the bundle.

Definition 4. A bundle C is effectively external callback free if all EVM executions have acyclic C-serialization digraphs.

SECTION V.Property Specification Language
We express properties of bundle behaviors using past linear temporal logic, or Past LTL for short. We provide a brief introduction below, for further details please refer to [48].

Linear temporal logic. A formula in Past LTL is inductively defined as either an atomic formula A, or a logical or temporal connective applied to one or more formulas φ, ψ:
φ,ψ::=A|φ∨ψ|¬φ|∙φ|φSψ
View Source

A formula can be interpreted at any position in a bundle behavior. Atomic formulas directly refer to the message or blockchain at the current position. For example, the formula withdrawn() holds when the current transaction was a call to the withdraw() function. The formula from Fig. 2
sum(deposits)≤Escrow.balance
View Sourceholds when in the current state the sum of values of the deposits mapping is less than or equal to the balance of the Escrow contract. Boolean connectives are interpreted in the standard way. For the temporal connectives

previously ●φ evaluates φ in the previous state if such exists and returns false otherwise;

since φ S ψ looks for a nonfuture moment when ψ holds so that φ holds in all moments after, up to the present.

The since connective can define other useful connectives like once ♦ (is/was true) and still ■ (is/has always been true):
♢ϕψ≜⊤Sψ■ψ≜¬♢¬ψ
View SourceRight-click on figure for MathML and additional features.

Given a Past LTL formula φ, the □φ formula uses the always connective □ and states that φ must hold at all positions of the bundle behavior.

Conversion to non-temporal formulas. Past LTL formulas are sufficiently expressive to capture any safety property, yet they are equivalent to assertions, i.e., non-temporal formulas. This allows us to convert them to assertions and reuse standard safety verification techniques.

To convert a Past LTL formula φ to a non-temporal one, we encode the semantics of past connectives into the behaviors of the contract. That is, we introduce auxiliary variables that track the truth values of temporal subformulas in φ, a well-known method [54].

We demonstrate this method with an example. consider the temporal formula φR3 = □φ from Fig. 2:
φ≡claimRefund()→¬♢(sum( deposits )≥ goal ).
View SourceRight-click on figure for MathML and additional features.

First, we select a subformula whose top-level connective is temporal. only one such subformula is present in our example:
ψ≡♢(sum(deposits) ≥ goal ).
View Source

Then, we introduce a fresh variable pψ that tracks ψ’s truth value, and update it according to the semantic rule of ♦:

Finally, we rewrite φ to the non-temporal formula:
p′ψ≡(sum(deposits )≥ goal )∨pψ.
View Source

Property syntax. To allow auditors and developers to specify properties, we extend Solidity’s syntax with temporal quantifiers. For example, we denote the operators

always □ by always,

once ♦ by once, and

previously ● by prev.

For convenience, we also provide aggregate functions over mappings, denoted by sum (deposits). The properties can further refer to the latest transaction’s data, including its signature and arguments. We use Solidity’s syntax for logical connectives and expressions (e.g., users write & for Λ) and introduce implication (==>) which is often used in properties.

SECTION VI.Delayed Abstraction for Verification
To verify a Past LTL specification of a bundle of contracts C we apply abstract interpretation over a symbolic domain. We employ predicate abstraction [35] but without the usual conversion to boolean programs. Our approach is similar to that of Flanagan and Qadeer [32] where two transformers are alternated: precise symbolic transformers to handle individual commands, and an imprecise transformer to ensure convergence. in contrast, classic abstraction applies an imprecise transformer at every step. Hence, we call the precise/imprecise approach delayed abstraction.

VerX receives a bundle C of contracts (written in Solidity) and a Past LTL specification □φ that should hold for all behaviors of the bundle. First, it converts the Past LTL specification to an assertion (Section V). Thus, at this point, we assume that φ is an assertion. Then, VerX compiles all contracts in C to EVM bytecode [66], and then it performs abstract interpretation on the bytecode. We compile to EVM because it is much simpler than Solidity.

To keep the discussion concise, we assume the bundle C is described by the blockchain address of its contracts together with two programs:

initC—a deterministic program that produces the initial blockchain state in every behavior of the bundle;

stepC—a program that non-deterministically executes a transaction of C starting in a given bundle state.

Given the property φ and the compiled code of C, VerX tries to verify the following program:
initC;assertφ;whiletrue{stepC;assertφ}
View Source

Ignoring the assertions, this program produces all possible behaviors of the given bundle of contracts C.

This verification problem amounts to proving that φ holds for all message-state pairs (m, s) appearing in behaviors of C. Recall that the behaviors of a bundle were defined in Section IV. This set of pairs is called the concrete semantics of C, which we denote with Sem(C). Thus, our goal is to verify:
Sem(C)|=φ.(1)
View Source

A. Abstract Interpretation
As the concrete semantics can be infeasible to compute, establishing (1) directly is not possible except for restricted cases. Abstract interpretation [27] addresses this issue by soundly approximating the concrete semantics with an abstract semantics Sem#(C) for which the verification problem is easier:
Sem#(C)|=φ.(2)
View Source

Sound approximation means that the set γ(Sem#(C)) of all message-state pairs encoded by the abstract semantics extends the concrete semantics:
Sem(C)⊆γ(Sem#(C)).
View SourceRight-click on figure for MathML and additional features.

Then, because of soundness, proving (2) implies that (1) holds.

To compute the abstract semantics by abstract interpretation, one mimics how the concrete semantics is computed as an element of the powerset lattice C=P(S), where S is the set of all possible message-state pairs, including those that do not appear in the behaviors of the bundle C. We reinterpret the two programs that describe the bundle as concrete transformers:
 initC∈C stepC:C→C.
View SourceRight-click on figure for MathML and additional features.

The concrete semantics Sem(C) is simply the least fixed point of the monotone map
S↦ initC∪stepC(S).
View Source

To compute Sem#(C) by abstract interpretation, we first replace the concrete domain C with an abstract domain A, where the two are connected by the concretization function
γ:A→C.
View Source

We then define abstract transformers instead of concrete ones:
init#C∈A step#C:A→A.
View Source

To mimic the concrete computation, we equip the abstract domain A with a lattice structure, that is, a join operation ⊔. This allows us to define the abstract semantics Sem#(C) as a fixed point of the map
A↦init#C⊔step#C(A).
View Source

As a result, we obtain a sound approximation provided the abstract transformers are sound. That is, for all A ∈ A:
initC⊆γ( init#C)stepC(γ(A))⊆γ(step#C(A)).
View Source

Fig. 8 summarizes the abstract interpretation approach. To model non-determinism more precisely, we use a powerset domain A, that is, the elements A ∈ A are sets of elements of another domain. The concretization function then is:
γ(A)=⋃a∈Aγ(a).
View Source


Fig. 8
Verification via a powerset domain.

Show All

B. Delayed Abstraction
We now discuss the particular abstraction used in VerX. We apply what we call a delayed abstraction, an elegant idea which first appeared in [32]. Delayed abstraction addresses imprecision in reasoning about invariants that are broken at intermediate points of the program. For smart contracts this typically occurs when a transaction temporarily breaks its invariant inside and then restores it at the end of its execution.

To deal with imprecision, delayed abstraction simply delays the abstraction step until the end of the transaction, but employs a precise symbolic domain Φ to reason within the transaction. Because fixed point computation in the precise domain might not converge, at the end of the transaction, a switch is made to a less precise predicate abstraction domain A=P(PA) where PA⊆Φ. Thus, the abstract transformer first makes a precise symbolic execution step, and then a predicate abstraction step:
ASE(f)−→−−P(Φ)α→A.
View Source

To perform symbolic execution, the symbolic domain Φ consists of first order formulas with message-state pairs (m, s) for models. That is, for every ψ ∈ Φ
γ(ψ)={(m,s):(m,s)|=ψ}.
View Source

The only restriction to the formulas in Φ is that an SMT solver should be able to handle them. The SE(f) step starts with a set of formulas A ∈ A and for each formula ψ ∈ A, it symbolically executes all feasible program paths in f ∈ { initC, stepC}. The result of processing ψ is a set of formulas {ψ'1,…,ψ'n} (one per feasible program path) that give the strongest postcondition of f with respect to ψ:
γ(∨i=1nψ′i)=f(γ(ψ)).
View SourceRight-click on figure for MathML and additional features.

The result of processing all formulas in A, as described above, is an intermediate set S ∈ P(Φ) of formulas.

For delayed abstraction, we use a set PA of cubes [35] which are conjunctions of literals over a fixed set of basic predicates P = {P1,…, Pn} ⊆ Φ. The abstraction step
α:Φ→PA
View SourceRight-click on figure for MathML and additional features.projects each formula ψ' ∈ S onto PA:
α(ψ′)=∧{L∈Λ:ψ′|=L},
View SourceRight-click on figure for MathML and additional features.where Λ is the set of all literals over the set P. The result of processing the set S results in a set of cubes that is an element in the domain A.

An important part of predicate abstraction is choosing the set P of basic predicates. If one does not find the right set P, the computed abstract element will be sound, but might be too imprecise to prove the desired specification φ. Typically, one seeds P with all atomic subformulas of the specification. If verification fails with this set, we increase P automatically by extracting predicates that appear in the program. We define the types of predicates we extract from the program and give examples where they bring sufficient precision to prove realistic properties in Section IX-C. If verification still fails, we ask the user to provide additional predicates (in principle, one could extend the system to perform standard abstraction refinement so to automatically discover predicates).

SECTION VII.Practical Solidity Fragment
The effectiveness of delayed abstraction relies on a precise symbolic execution engine that scales to realistic contracts. Building such an engine for arbitrary Solidity contracts is, however, challenging due to the Turing-completeness of the language. In this section, we define a practical fragment of Solidity that covers a wide range of real-world contracts yet enables precise and scalable symbolic execution. We summarize the restrictions in Fig. 9 and explain them in detail below.

A. Loops and Recursion
Symbolic execution fails to terminate when a program contains unbounded loops or recursion. In Ethereum, however, long transaction executions are costly (since they consume more gas) and moreover cannot exceed the block’s gas limit, which imposes a hard bound on the gas budget of transactions. Because of this, unbounded loops and recursion are considered anti-patterns.

In our fragment, we consider Solidity contracts without recursion and where loops are bounded. Such contracts have finitely many paths which can be fully analyzed symbolically. To further extend our fragment, we also support the following common loop pattern in Solidity:


We call this loop pattern packed-calls, as the loop is merely used to group multiple independent calls to the function f in a single transaction. For the purpose of verification, such loops can be eliminated without changing the semantics of the bundle. That is, any transaction invoked with multiple elements in args can be split into multiple transactions to pm:
pm([a1,…,an])≃pm([a1])…pm([an]).(3)
View Source

VerX automatically detects and soundly bounds such loops.


Fig. 9
Solidity fragment supported by VerX

Show All

B. Calls to External Contracts
The Ethereum blockchain permits a bundle contract c1 to call an external contract d, and then contract d to call back some bundle contract c2 :
c1∈C→d∉C→c2∈C(4)
View Source

The external contract d can potentially make an unbounded number of callbacks to the bundle (until all gas is depleted), making it infeasible to fully analyze with symbolic execution.

To address this challenge, we consider only contracts that satisfy the effective external callback freedom condition defined in Section IV-C. This condition implies that any behavior of the contracts with external callbacks is equivalent to a behavior without external callbacks. We defined the check used to determine whether a smart contract satisfies this condition in Section VIII.

C. Gas Exception Propagation
If an internal transaction consumes all gas allocated to it, then it terminates with an "out of gas" exception, undoing all changes to the shared storage. After that, execution resumes in the parent transaction. Since the amount of gas can be arbitrary, the above behavior implies that most calls are a potential branching point where the call can be omitted. These branching points explode the number of program paths to be symbolically executed.

We avoid this explosion by requiring contracts to propagate all exceptions up the call stack, effectively reverting the current bundle transaction. This means that the transaction will not appear in the blockchain execution and can be ignored.

D. Storage Access
As mentioned in Section VI, we do not analyze Solidity directly but the EVM bytecode obtained by compiling Solidity code. The challenge with EVM bytecode is that it is low- level and important information is lost during compilation. The major challenge comes when reasoning about compound objects such as structures, arrays, and maps. The EVM lacks primitives for such objects, and consequently, all arrays and maps are spliced together into a single flat array of 2256 words. Therefore, to reason about compound objects, we need to reason about the specific hash-based allocation scheme used by the Solidity compiler.

To illustrate the scheme, consider an array a that holds objects of size n. The array gets a unique identifier id(a), and its elements are distributed according to1:
a[i]↦SHA−3(id(a))+n∗i.
View SourceRight-click on figure for MathML and additional features.

That is, the array is allocated at the address that equals the SHA-3 hash of its identifier and spans the subsequent words.

The allocation scheme must be valid in the sense that distinct objects are allocated disjoint storage. This validity rests on two conditions, which are required to model in order to analyze array and map accesses precisely:

There are no SHA-3 collisions to guarantee that distinct objects and map elements start at distinct addresses.

SHA-3 hashes are sufficiently spread apart so that distinct objects do not overlap.

These two conditions are assumed to hold for any Solidity contract. They can, however, be violated if a contract directly accesses storage using inlined assembly. To this end, we restrict the use of inlined assembly in bundle contracts.

E. Unsupported Instructions
Finally, in our fragment we ignore contracts that:

Execute external code in the context of the bundle contracts (instructions callcode or delegatecall).

Destroy bundle contracts or create new ones (instructions create and suicide).

Execution of external code is known to entail a security risk. For example, attackers can execute arbitrary code if they gain control over the destination address of a delegatecall instruction. Due to these security risks, these instructions are considered a bad practice and are excluded from new bytecode proposals that aim to improve the security of the EVM [44]. Creation and destruction of contracts can be supported but is less common and we omit these behaviors for simplicity.

SECTION VIII.The VerX System
We now present details on our VerX system: the new symbolic execution engine, the types of predicates extracted from contracts, and optimizations used to scale verification.

A. Symbolic Execution Engine
VerX uses a new symbolic execution engine for EVM, which avoids the pitfalls of existing engines, as detailed in our evaluation (Section IX-D). Our symbolic execution engine extends standard techniques [19], [45] with the following unique features of Solidity: (i) object allocation in Solidity (determined by hash functions), (ii) contract calls, and (iii) sound approximation of gas mechanics. We also model sums of arrays and mappings, which although not part of Solidity are needed for verifying relevant properties.

Symbolic state. We perform symbolic execution with Z3 [31]. Machine words in the symbolic state are encoded precisely as 256-bit vectors. EVM storage and memory are encoded in the theory of arrays. Calls to external contracts are modeled with uninterpreted constants.

Checking effective external callback freedom (EECF). We check that all contracts in the bundle satisfy EECF through a proxy pattern. The pattern forbids:

Writing to the bundle’s blockchain state after calls to external contracts. Example writes include transferring ether or writing values to storage variables;

Reading the bundle’s blockchain state after calls to external contracts with ≥ 5000 gas. Example reads include accessing a contract’s balance or storage variables.

The latter condition allows reads for calls to external contracts with < 5000 gas since such calls guarantee that the callee cannot, due to the limited gas budget, modify the bundle’s blockchain state. We note that such calls are common because Solidty’s statements send and transfer are frequently used by developers to transfer ether to other contracts and these provide 2300 gas to the callee.

Checking exception propagation. Standard function invocations in Solidity automatically propagate exceptions. Only low-level calls such as send and call do not propagate them. To check that the caller propagates exceptions, we perform dataflow analysis to verify that the contract always reverts the state when such a call fails.

Modeling object allocation. As mentioned, a unique aspect of Solidity/EVM is the hash-based allocation scheme used to determine the location of an object in the storage by applying the SHA-3 hash function. The challenge here is that SHA-3 is a rather complex function and if we model it precisely with SMT constraints, we would cripple the symbolic execution.

To this end, we interpret SHA–3 as a different, much simpler function, that still ensures the two assumptions mentioned above, namely no hash collisions and sufficiently spread-out hashes. This approach is sound provided that the smart contracts we verify always access memory through Solidity’s primitives, that is, they never access raw memory directly. We ensure this memory access by forbidding the use of inline assembly in the Solidity source.

We encode the simpler function with the function symbols
SHA−3n:{0,1}n→{0,1}256,
View SourceRight-click on figure for MathML and additional features.one per input size n to a SHA–3 invocation in the bytecode. We encode the expected behavior of the function with extra SMT constraints. Importantly, the constraints do not specify the function completely. That is, we assume little about the function, and the VerX verification results hold for any function that satisfies those weak assumptions.

(i) The first set of constraints ensures that no collisions occur. No collisions in principle means that the union of all the functions SHA–3n is one-to-one. This is, of course, impossible since the domain of the function is larger than its codomain. That is why we do not ensure injectivity on its whole domain. Instead, we consider each symbolic execution separately and ensure injectivity only on the (possibly symbolic) arguments that appear in the execution. To do that, let Xn be the arguments applied to SHA–3n. We add the constraints:

No collisions within each Xn:
∧x∈XnSHA−3−1n(SHA−3n(x))=x.(5)
View SourceRight-click on figure for MathML and additional features.

Here, SHA−3−1n is a function symbol that represents a pseudo-inverse function of SHA–3n.

No collisions between each Xm and Xn, for sufficiently many pairs m ≠ n of distinct input sizes:
∧x∈XnLn≤SHA−3n(x)≤Rn.(6)
View Source

The numbers Li ≤ Ri divide the address space into disjoint intervals [Lm, Rm] ∩ [Ln, Rn] = ∅.

In our experiments, we set concrete bounds Li, Ri that are far apart from each other, giving intervals of length 2100.

We used the above constraints instead of the prosaic
x≠y⇒SHA−3m(x)≠SHA−3n(y).
View Sourcebecause they are linearly many in the size of the union ∪iX i instead of quadratic. In our experience, this reduced the load on the SMT solver significantly.

(ii) The second set of constraints ensures that hashes are spread apart. For every set Xn we add the constraints
∧x∈XnSHA−3n(x)≡0(modS),(7)
View Sourcewhere S is sufficiently large (64 in our experiments).

Calls. When the engine reaches a call, it checks whether the address being called is concrete or symbolic. If it is concrete, the execution continues by transferring the given (possibly symbolic) value of ether and then checks whether the address is in the bundle. If so, this is a contract account, and we model the call precisely, activating the contract’s program in a new frame. If the concrete account is external, then we treat it as a user account, meaning no further action beyond a transfer is taken (as mentioned, this treatment is sound when the bundle contracts satisfy effective external callback freedom).

In the case where the address being called is symbolic, the execution first non-deterministically selects the address of a bundle contract or treats the symbolic address as an external user account. After that, the execution proceeds as before.

Gas mechanics. The engine implements gas mechanics to terminate symbolic execution along infeasible paths, where an out-of-gas exception is guaranteed. Concretely, the engine tracks a lower-bound glower on the gas cost of each symbolic path. We note that we cannot track the precise gas cost simply because the gas fees for some operations depend on their arguments, and therefore the concrete executions that follow a symbolic path may have different gas costs. The engine also tracks the gas budget gbudget specified in the message initiating the call. There are two common cases for the gas budget: (1) it is often unbounded, as it is specified by the user, and (2) it is a constant, for calls initiated by send and transfer which always provide 2, 300 gas to the callee. Finally, our engine considers any paths where glower > gbudget as infeasible, as they are guaranteed to revert due to an out-of-gas exception.

Tracking sums. Another feature of our engine is to track the sums of arrays and mappings with numeric values. Although these sums are not a feature of the EVM, they enable to specify important properties (e.g., Fig. 2). The sum of an object a is kept in a designated variable sum (a) in the symbolic store. For each write a' = a[x ↦ y], the sum changes as:
sum(a′)=sum(a)−a[x]+y.
View SourceRight-click on figure for MathML and additional features.

B. Extracting Predicates
Delayed abstraction needs a sufficient set of predicates to successfully verify properties. Based on our experience in verifying contracts (see Section IX), we identify five important kinds of predicates:

Property: atomic formulas from the property. For example, φR1 (Fig. 2) has two atomic formulas: state = success and sum (deposits) ≤ Escrow.balance.

Points-to: encode pointers to contract instances. For our motivating example, we extract predicates that capture that escrow points to the escrow instance, and its field owner points to the crowdsale instance.

Enum/Bool: encode values of boolean and enumerated fields. For our motivating example, we extract three predicates to encode the value of variable state.

Constant: encode values of constant variables. For our motivating example, we extract goal = 10000 × 1018.

Other: predicates defined by users.

VerX automatically extracts all predicates, except those classified as Constant and Other, by traversing the contract’s abstract syntax tree (AST) to detect contract fields of type boolean, enum, or contract, and defining predicates to capture their values. For a boolean field b, VerX adds the predicate b = True. For an enum field e, VerX finds its size n and adds the predicates e = 0,…, e = n – 1. For example, for variable state from Fig. 2(d), VerX adds the predicates state = 0, state = 1, and state = 2. For a contract field c of type t, VerX adds the predicate c = t. This predicate captures the type of c, and also serves as a points-to predicate: in our benchmarks, there is one instance per contract type, and thus if the predicate c = t holds, then VerX infers the exact instance of c. In the future, we plan to extend VerX with points-to analysis to improve precision for more complex cases.

C. Abstraction of non-linear arithmetic
To further scale the analysis, VerX supports abstraction of non-linear arithmetic. Non-linear arithmetic poses a challenge to SMT solvers, yet it is unnecessary to prove many real-world properties. That is why VerX has the option to abstract non-linear computations (e.g., multiplication) by substituting them with uninterpreted functions. The user of the system can disable or enable the abstraction whenever needed, speeding up the analysis for the majority of cases.

SECTION IX.Evaluation of VerX
We now present our evaluation of VerX on real-world Ethereum projects. We focus on three key questions:

What types of safety properties are common for real-world contracts?

How effective is VerX in verifying safety properties of these smart contracts?

How precise is the symbolic execution engine of VerX compared to existing symbolic tools for Ethereum?

All of our experiments were run on a server with Intel i7-6700 CPU with 4 cores at 3.4 GHz, 64 GB memory, running Ubuntu 18.04.2 and Python 3.6.

A. Benchmarks and Properties
We now report on our benchmarks and the common types of requirements that we formalized. All our benchmarks are available at https://github.com/eth-sri/verx-benchmarks.

Benchmarks. Our benchmarks consist of the overview example (Fig. 2) and 12 real-world Ethereum projects. Most of these projects are deployed on Ethereum and have over 500 lines of Solidity code. We provide relevant statistics in Table I. The prevalence of crowdsales and tokens in the benchmarks reflects that many of the real-world deployed Ethereum contracts are of these types. We note that some of the verified contracts hold a significant amount of funds (> 100M worth of USD).

For each project, we wrote a deployment contract to define the initial state of the project’s contracts. As mentioned, some of these projects have been professionally audited by experts where any property violations have been fixed. our results use the fixed versions where all properties verify.

Properties. The typical process to elicit properties is to inspect the documentation and to formalize key requirements. To provide an insight into the types of common requirements, we classify them into five distinct categories and show these in Table II, along with concrete examples from our benchmarks:

User-based access control requirements define which users can invoke critical functions. The example in Table II, taken from the Crowdsale project (part of Zeppelin’s projects), stipulates that only the primary (a specific user address) can invoke function deposit. We note that attribute-based authorizations, such as "only users with more than 1000 tokens can calls function foo" are also supported and common.

State-based properties define at which states certain authorizations and invariants must hold. The example in Table II, taken from the VUToken project, permits calls to function withdrawTokens after the closing time.

State machine requirements define which state transitions of the contracts are allowed. To track state, contracts often have explicit state variables. These properties often involve temporal quantifiers (e.g., once). The example in Table II, taken from the ICO project, stipulates that once the contract is in state Refund, it cannot transition to state Finalized, and vice versa.

Invariants over aggregates: Contracts often store state in mappings. Since Solidity does not allow contracts to iterate over the keys of a mapping, contracts often store state in auxiliary variables to track aggregate information. Invariants over these help establish their correctness. The invariant in Table II, taken from the MRV contract, states that the sum of balances always equals the total supply of tokens, a common token requirement.

Multi-contract invariants: Finally, contracts often impose invariants over the bundle of contracts in the project. The example in Table II, taken from the MANA project, states that if the continuous sale has not started, the owner of the token is the crowdsale contract.

TABLE I Statistics on Ethereum projects.

B. Verifying Contracts using VerX
We now report on the effectiveness of VerX in verifying our benchmarks. We present our results in Table III. VerX successfully verified all 83 properties we considered.

To present our results, we split the properties based on whether they are verified inductively or using abstraction. For each property type, we show the number of verified properties, the average number of symbolic states, and the average execution time in seconds. For properties verified with abstraction, we show the total number of predicates required to verify all properties. For example, the 3 properties of project Brickblock are verified with abstraction, and we report 3 Enum/Bool predicates because each property required 1 boolean predicate.

Our results illustrate several important points. First, 20% of properties can be verified inductively.

Second, the average verification time is 114 seconds for inductive properties and 1296 seconds (≈ 20 minutes) for non-inductive ones. Two outliers are the Mana and PolicyPal projects, which took hours to verify some properties due to complex constraints. To speed up VerX, one can implement standard optimizations, such as slicing program paths that are guaranteed to not change the abstract predicates’ truth values.

Third, the number of symbolic states demonstrates the complexity of the analysis. For some properties, VerX explores over a hundred abstract states to verify the property.

TABLE II Common types of properties encountered during audits and concrete examples taken from the benchmarks.
Table II- 
Common types of properties encountered during audits and concrete examples taken from the benchmarks.
TABLE III Experimental results of VerX’s property verification using inductive reasoning and delayed abstraction.
Table III- 
Experimental results of VerX’s property verification using inductive reasoning and delayed abstraction.
TABLE IV Comparison of VerX’s symbolic execution engine with state-of-the-art symbolic tools.
Table IV- 
Comparison of VerX’s symbolic execution engine with state-of-the-art symbolic tools.
Finally, 10 of the projects do not require any custom predicates to verify all their properties. This indicates that most properties can be verified with few extra predicates which are extracted automatically. The remaining 3 projects do require few predicates classified as Other. Example predicates are Crowdsale.raised < Crowdsale.goal and sum (Escrow.deposits)== Crowdsale.raised. We note that such predicates often appear in function preconditions (defined in require statements), indicating that they can be easily extracted automatically.

C. Importance of Derived Predicates
Most of the properties in our benchmarks are non-inductive and therefore require additional predicates to verify. We inspected the relevance of the predicates derived automatically by VerX and report our findings below.

Points-to predicates. Points-to predicates are essential to prove that the bundle contracts are effectively external callback free (EECF). Calls to bundle contracts are often followed by changes to storage and thus do not satisfy the first condition imposed by VerX on external calls (see Section VIII). For example, consider function invest () of the crowdsale (Fig. 2) which calls the escrow contract. Without additional predicates, the variable escrow is abstracted away, meaning that it can store the address of any (including an external) contract. Under this abstraction, VerX fails to verify the specification because the function writes to variable raised after the call. To avoid this false alarm, VerX automatically adds the points-to predicate: Crowdsale.escrow == Escrow and proves that variable escrow always points to the escrow (a bundle contract), and by doing so avoids aborting the verification process.

Boolean/enumerated predicates. For our overview example, VerX also adds the three predicates
{ Escrow.state = = X|X∈{ OPEN, SUCCESS, REFUND }}.
View SourceRight-click on figure for MathML and additional features.

These predicates are needed to capture the possible state transitions of the escrow. Without them, VerX analyzes spurious traces which violate the properties. Concretely, VerX fails to prove that the escrow cannot transition from a state where Escrow.state == refund holds to a state where Escrow. state == success holds (and vice versa) and, in turn, fails to verify property φR2.

D. VerX’s Symbolic Execution Engine
Finally, we compare VerX’s symbolic execution engine to three other state-of-the-art engines: Oyente [47], Mythril v0.19.3 [50], and Manticore v0.1.9 [2]. We collected 41 tests from the smart contract security project [5], where security experts maintain a collection of vulnerable smart contracts. Our benchmark consists of two kinds of tests: assertions and arithmetic, where the tests check for failed assertions and, respectively, over- and under-flows.

Table IV shows the results. For each of the four systems, we report: detected (TP), missed (FN), falsely reported (FP), and correctly unreported (TN) violations. In our tests, we used a timeout (T/O) of one hour.

Results indicate that VerX outperforms other symbolic execution tools in terms of precision. VerX has no false negatives and only 1 false positive. The test for which VerX reports a FP is a synthetic example that checks if the remaining gas decreases during execution, and VerX over-approximates gas-mechanics, which is sound for verification.

SECTION X.Related Work
We now describe the works that are closely related to ours.

Predicate abstraction. Predicate abstraction [35] has been shown successful to verify safety properties. SLAM [14], [15] automatically constructs a boolean program from a C program to verify properties. BLAST [39], [40] increases precision by adding predicates derived from the proofs of infeasible traces. SatAbs [17], MAGIC [23], Murphy [30], and Java PathFinder [29] also build on predicate abstraction for verification and differ mostly in the properties and programs analyzed. Other works show how to apply refinement during abstraction, e.g., the authors of [49] describe refinement by partitioning traces. Our work is inspired by the above approaches. In contrast, it is tailored to contracts and applies abstraction only at the end of transactions.

Symbolic execution. Symbolic execution has been shown successful in finding property violations of programs [12], [22], [45], [53], [63], [67]. To mitigate path explosion due to loops and recursive calls, different heuristics have been suggested: favoring paths that may lead to uncovered code [22], constraining search depth [53], using fitness functions [67], chopping functions [63], function and loop summaries to reuse repetitive computations [10], [33], [34], and using concrete inputs to select symbolic paths [11], [56], [57], [60], [70]. The authors of [69] use symbolic execution to prune paths irrelevant when verifying regular properties, which is sound under input independency assumptions. To reduce paths via subsumption, the authors of [13] combine symbolic execution with abstraction to analyze programs that manipulate arrays and lists. In the context of contracts, there are different symbolic engines for Ethereum [2], [24], [46], [47], [50], [51]. Some of these support multiple transactions and employ heuristics to guide the path exploration. In contrast, our symbolic engine is more precise, as shown in our evaluation, and handles hash collisions more efficiently.

Analysis of temporal properties. Many works have studied analysis of temporal properties. In [55], the authors show an approach to test for violations to past LTL formulas. In [16], the authors show a verification of LTL formulas for UML models. T2 [21] is a system to verify temporal properties over LLVM which supports linear integer arithmetic programs. E-HSF [18] verifies existential CTL formulas by representing them as existentially quantified Horn-like clauses, and using a counterexample-guided approach to solve the clauses. Typestates [61] enable one to express correct usage rules of class operations or protocols. Some of our evaluated properties can be expressed as typestates.

Static analysis and verification of smart contracts. Declarative static analysis tools [20], [36], [64], [65] use Datalog to identify generic security vulnerabilities in Ethereum contracts. These tools focus on data-flow and gas-related vulnerabilities. Slither [4] and SmartCheck [62] identify vulnerabilities on the abstract-syntax tree of the contract's source code. The analysis of Grossman et al. [38] targets vulnerabilities due to callbacks in contracts. In contrast to our work, these approaches do not support the verification of temporal properties. In [43], Hirai defines a formal model for EVM in the Lem language. Formal EVM semantics have been defined also defined for F* [37], the K framework [42], and Isabelle/HOL [9]. These approaches provide formal guarantees while being precise (no false positives). Some of these frameworks are non-trivial to automate. In contrast, we target automated verification of temporal properties. Analysis of temporal properties of smart contracts has also been considered in [59], where authors show how to manually encode such properties and verify them with Coq. In contrast, we show an automatic approach and provide an end-to-end tool to analyze temporal safety properties.

SECTION XI.Conclusion
We presented VerX, the first verifier that can automatically prove temporal safety properties of Ethereum smart contracts. The verifier is based on a careful combination of three ideas: reduction of temporal safety verification to reachability checking, an efficient symbolic execution engine used to compute precise symbolic states within a transaction, and delayed abstraction which approximates symbolic states at the end of transactions into abstract states. Delayed abstraction allows the verifier to reduce the potentially unbounded concrete state space of the contact into a finite, bounded representation, while still maintaining precision (thanks to employing precise reasoning during transactions). We demonstrated that VerX is practical and automatically proves 83 properties over 12 real-world Ethereum projects. Based on these experiments, we believe VerX is an effective system for verifying custom functional properties of smart contracts.