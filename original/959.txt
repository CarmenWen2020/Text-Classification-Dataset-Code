One existing challenge associated with large scale skyline queries on cloud services, particularly when dealing with private information such as biomedical data, is supporting multi-party queries with curious-but-honest parties on encrypted data. In addition, existing solutions designed for performing secure skyline queries incur significant communication and computation costs due to ciphertext calculation. Thus, in this paper, we demonstrate the potential of supporting privacy-preserving multi-party skyline queries on encrypted data using additive homomorphic and proxy re-encryption cryptosystems. However, the secure computation based on these cryptosystems will further slow down query efficiency. To improve the efficiency of comparison on encrypted data, we redesign two lightweight secure comparison protocols. Meanwhile, we present an efficient method named “blind-reading” to securely obtain the skyline point. We also propose a novel method, Privacy Matrix, designed to reduce the scale of the dataset so that the computational cost is significantly decreased without privacy leakage. Then, we construct our secure skyline query protocol by integrating lightweight secure comparison protocols, “blind-reading” and Privacy Matrix techniques. Finally, we evaluate the security of our protocol, where we show it is secure without leaking information. The performance evaluation also shows that our proposed approach significantly improves the efficiency (at least ×4.5 faster) compared to the-state-of-art and has the scalability of query processing under large datasets.
SECTION I.Introduction
A common method to protect data confidentiality from the cloud is to use encryption [1]–[2][3][4]. Concretely, the outsourced data is encrypted by the data owner prior to uploading to the cloud. When authorized data users query the data on the cloud server, (s)he will send a request with an encrypted query, then obtain the relevant results through decoding some encrypted set from the cloud. While such an approach is generally designed to gain none of the privacy from the outsourced data, queries, intermediate results, and query results, it is challenging to perform advanced queries over encrypted datasets.

In this paper, we study the problem of secure skyline query, which is a major type of query and fundamental building block for various scenarios, such as location-based systems [5], multi-objective decisions [6], etc. For instance, suppose that a data medical institution wishes to outsource its electronic liver cancer records to the public cloud service and the data is encrypted to ensure data confidentiality because of privacy concerns. Let P denote a liver cancer dataset with attributes ID, age, T-BIL (total bilirubin), ALB (albumin), etc. For ease of illustration, we sample four patient records p1,…,p4 with two attributes T-BIL and ALB (as shown in Fig. 1). Consider a physician who is treating a liver disease patient q=(30,29) and wishes to retrieve similar patients to enhance and personalize the treatment. However, due to the subjective preferences of different users, it is usually difficult to uniformly define weights for all the attributes to process k NN query and return the nearest neighbor [7]. For example, p1 is the nearest if only T-BIL is involved while p2 and p4 are the nearest if only ALB is involved. To this end, skyline queries can obtain all possible 1NN records by involving all possible relative attribute weights so that it can act as a filter for disease diagnosis [8], [9]. Next, we map the data points to a new space using the function ti[υ]=|pi[υ]−q[υ]| for each dimension υ . If a tuple ti cannot be dominated by any other tuple (i.e., ti is better than tj in at least one dimension and not worse in every other dimensions), this tuple is one of the skyline points. Hence, it is easy to identify the skyline points as t1 and t2 (i.e., p1 and p2 ). Notably, in the above example, it is essential to protect the privacy, which involves the four universally adopted aspects: 1) data privacy, i.e., the dataset P ; 2) query privacy, i.e., the query q ; 3) skyline result privacy, i.e., the result R ; 4) indirect privacy, i.e., the dominance relationship (i.e., locations of dominated points).

Fig. 1. - A sample of the skyline query.
Fig. 1.
A sample of the skyline query.

Show All

Recently, the privacy-preserving techniques based on encrypted data have been demonstrated, such as private information retrieval (PIR) [10], asymmetric-scalar-product-preserving encryption (ASPE) [11], searchable symmetric encryption (SSE) [12], Intel Software Guard Extensions (SGX) [13], and order preserving encryption (OPE) [14]. However, the PIR does not support secure skyline queries (query is private while data is public). The ASPE are vulnerable to the chosen-plaintext attack. The SSE cannot be applicable directly to deal with skyline queries. The SGX brings a promising alternative, but still has a limitation that needs fixed hardware support. The OPE exposes the order of the ciphertext. As for secure multi-party computation (SMC) [15], it is different from our scenario, where the party owns the encrypted data. To achieve strong security, other techniques such as fully homomorphic encryption (FHE) can be used to encrypted data [16]–[17][18], but its computation cost is too expensive to be practical [19]. To this end, approaches based on partial homomorphic encryption (PHE) named Paillier [20] have lower computation overhead (e.g., see [7], [21], [22]), but these schemes allow one data owner to outsource his encrypted dataset to the cloud. Actually, in most cases, data is respectively observed and collected by multiple data owners without a concrete aggregator. A naive idea is that all data owners encrypt/decrypt the outsourced data using the same keys (pk,sk) of Paillier, which allows calculations to be performed on the ciphertext domain of all data (see Fig. 2). However, as data owners, they cannot use the same public key to encrypt their data due to security guarantees. Moreover, this is not secure enough for curious-but-honest data owners because encrypted data Epk(data2) is easily eavesdropped and decrypted by other data owners in public channels, where Epk(⋅) denotes a secure encryption function. Similarly, the encrypted query Epk(q) is also eavesdropped and decrypted by other data owners. Therefore, Paillier, as a single-user system, does not support secure multi-party (i.e., multiple curious-but-honest data owners and clients) skyline queries when adversaries1 can eavesdrop all communication channels to access any encrypted data.


Fig. 2.
Limitations of using Paillier to encrypt data under multi-party setting.

Show All

To support the secure multi-party skyline query (SMSQ) on encrypted data, we introduce proxy re-encryption and additive homomorphic encryption technologies to encrypt the outsourced data, queries, and results. An unsophisticated method is to directly replace the Paillier algorithm with a homomorphic re-encryption scheme (HRES) from [23] to implement the secure skyline query protocol in [7]. Concretely, data owners utilize HRES to encrypt the raw data into homomorphic ciphertext, which cannot be decrypted by any single party including itself. Then, the ciphertext is uploaded to the cloud. Given two “honest-but-curious” cloud servers (since major cloud service providers have a commercial interest to achieve high level of security), the ciphertext can be transferred into another ciphertext to be decrypted by a corresponding and authorized party like the client or the other server. In this way, the data leakage caused by eavesdropping in public channels can be addressed under multi-party scenarios. However, this simple combination of the two exposes some fatal flaws.

The core of the secure dominance protocol is a secure comparison algorithm, which needs to be executed frequently. But the integer comparison algorithms in [23] and [7] are complex. Moreover, this comparison requires more time for the conversion of ciphertext in the HRES cryptosystem. It also incurs much computation overhead to calculate vector comparisons due to the lack of a well-designed vector comparison protocol.

In order to prevent the privacy of the positions of the skyline result (indirect privacy), each skyline point needs to be calculated by the cloud from the complete dataset in this unsophisticated method, which drags down the efficiency of the query.

The key of the secure skyline queries is the secure dominance protocol, which takes up most of the query time. Meanwhile, whenever a skyline point is obtained, the cloud needs to mark the dominated point over the complete dataset, which is to avoid leaking the position of the dominated point (indirect privacy). Obviously, this is also a huge computational overhead.

Therefore, one ongoing challenge is to design an efficient solution that guarantees all privacy requirements (especially indirect privacy) to process secure skyline queries. This is the gap that we seek to address in this paper. There are several key technical challenges that need to be addressed.

How do we accelerate the efficiency of the secure dominance protocol? To do this, we propose a lightweight secure integer comparison protocol (LSCPint ). Based on it, we devise a lightweight secure vector comparison protocol (LSCPvec ) to improve the efficiency of comparison between two points, which is the core of the efficient secure dominance protocol (ESDP).

How do we securely and efficiently obtain the skyline point and eliminate it from the dataset? To reveal no information regarding about the skyline point, we propose a novel method named “blind-reading”, which can blindly “read” the skyline point from the dataset.

How do we reduce the number of ESDP calls without revealing the dominance relationship (indirect privacy)? That is, ESDP is executed on a smaller dataset in each iteration. A naive method is to directly eliminate the points dominated by the skyline point in the dataset (applied to basic multi-party skyline query protocol (BMSQ)), which will leak indirect privacy, such as the positions of dominated points. To handle this scenario, we develop a novel and efficient method, hereafter referred to as Privacy Matrix, which is a crucial step to reduce the scale of the dataset so that the computational cost of secure skyline query processing is significantly decreased without leaking any privacy and loss of query accuracy. Note that SMSQ is at least ×4.5 faster than the state-of-the-art scheme2 [7] that is the only solution for secure skyline query considering indirect privacy.

To summarize, our major contributions are listed as follows.

Based on analysis of the literature, we propose a common, practical and flexible system model since it involves multiple semi-honest data owners and clients. We also present a security model.

We design LSCPvec (LSCPint ), which can support the comparison between encrypted tuples (integers) and return the encrypted results. Then, we rebuild ESDP.

We present two secure multi-party skyline query protocols (i.e., BMSQ and SMSQ). BMSQ, an efficient solution, not adequately secure due to potential indirect privacy leakage. By integrating LSCPvec (LSCPint ), “blind-reading” and Privacy Matrix methods, SMSQ handles skyline queries without privacy leakage.

The rest of this paper is organized as follows. Section II introduces relevant background materials and presents models. Basic secure subprotocols and SMSQ (BMSQ) are respectively presented in Sections III and IV. In Sections V and VI, we demonstrate the security analysis and performance evaluation, respectively. In Section VII, we review the related literature. Finally, we conclude this paper.

SECTION II.Preliminaries and Models
A. Skyline Definitions
Definition 1 (Skyline [24]):
Given a dataset P={p1,…,pn} in d -dimensional space. Let pa and pb be two different tuples in P . We say pa dominates pb , referred to as pa≺pb , if for all υ , pa [υ]≤pb [υ] , and if there is at least one dimension υ , pa [υ]<pb [υ] , where 1≤υ≤d . The skyline points are tuples that are not dominated by any point. And the skyline result of P is called SKY(P) .

Definition 2 (Dynamic Skyline [25]):
Given a dataset P={p1,…,pn} and a query vector q in the d -dimensional space. Let pa and pb be two different tuples in P . A vector pa dominates another pb with respect to q , referred to as pa≺pb , if for all υ , |pa[υ]−q[υ]|≤|pb[υ]−q[υ]| , and if there is at least one υ , |pa[υ]−q[υ]|<|pb[υ]−q[υ]| , where 1≤υ≤d . The skyline points are tuples that are not dynamically dominated by any point. With respect to q , the skyline result of P is called SKYq(P) .

Definition 3 (Additivity of Skyline [24]):
Let a dataset be P=P1∪…Pi…∪Pχ , and Pi is the i -th subdataset, where χ is the number of subdatasets. The skyline result of P is: SKY(P)=SKY(SKY(P1)∪…∪SKY(Pχ)) . By the same logic, with respect to q , SKYq(P) is: SKYq(P)=SKYq(SKYq(P1)∪…∪SKYq(Pχ)) .

If for all υ , pa [υ]≤pb [υ] , it is denoted by pa⪯pb . We also find that Definition 1 is a special case of Definition 2. Thus, we can transfer the dynamic skyline computation to the conventional one using the mapping function ti[υ]=|pi[υ]−q[υ]| . For references, a summary of notations is presented in Table I.

TABLE I Summary of Notations
Table I- 
Summary of Notations
B. HRES Cryptosystem
The HRES cryptosystem [23], [26] enjoys an additive homomorphic property (similarly to the Paillier’s scheme [20]), which is semantically secure with the assumption of Decisional Diffie-Hellman (DDH) [27] problem. In general, the HRES cryptosystem consists of the following functions.

KeyGen. Given two large primes p1 , p2 , we obtain N=p1×p2 and choose a generator g with maximal order. Two clouds (i.e., the data service provider (DSP) and the data assistance provider (DAP) illustrated in Section II-C) respectively generate key pairs (skDSP=a,pkDSP=ga) and (skDAP=b,pkDAP=gb) , and their Diffie-Hellman key is PK=pkDSPskDAP=pkDAPskDSP=ga×bmodN2 . A client also generates a pair of keys (skq,pkq) . The public system parameters include {g,N,PK} .

Encryption with PK (Enc). Given message m , the data owner chooses random number r∈ [1,N/4] and encrypts it with PK ,
EPK(m)={(1+m×N)×PKr,gr}(modN2),(1)
View Sourcewhere r is conducive to the probabilistic property of HRES. Then, the data owner sends [ [m]] to the DSP, where [ [⋅]] denotes EPK(⋅) .

Partial Decryption with skDSP (PDec1). When the DSP receives [ [m]] , PDec1 will be executed to transfer [ [m]] into EpkDAP(m) as follows:
EpkDAP(m)==={C(1),(C′)(1)}={C,(C′)skDSP}{(1+m×N)PKr,gr×a}modN2{(1+m×N)(pkDAP)a×r,gr×a}modN2,(2)
View Sourcewhere EpkDAP(m) is also denoted as [ [m]]pkDAP .

Partial Decryption with skDAP (PDec2). When the DAP receives [ [m]]pkDAP , PDec2 will be executed to decrypt [ [m]]pkDAP with its own secret key skDAP as follows:
C′(2)=m=(C′(1))skDAP=gr×a×b=PKrmodN2,L(C(1)/C′(2)modN2),(3)(4)
View Sourcewhere L(u)=(u−1)/N .

Re-Encryption (REnc). Suppose a client who has a pair of keys (skq,pkq) wishes to obtain m . Unlike the algorithm presented above, REnc allows one to transfer [ [m]] to [ [m]]pkq through the cooperation of the DSP and the DAP, where [ [⋅]]pkq denotes Epkq(⋅) .

Decryption (Dec). Upon receiving [ [m]]pkq , the user can decrypt it to m .

Moreover, the encrypted data in HRES cryptosystem under any public key pkq has the following properties:
Epkq(m1)×Epkq(m2)=Epkq(m)t=Epkq(m)N−1=Epkq(m1+m2),Epkq(t×m),Epkq(−m).(5)(6)(7)
View Source

C. System Model
Inspired by the setting of two collusion-resistant clouds [7], [21], we devise our system model based on HRES as shown in Fig. 3. It consists of the following four entity types:

Data Owners (DOs): Let χ be the number of DOs. The DOi locally encrypt its dataset Pi using the HRES cryptosystem with the Diffie-Hellman key PK , where 1≤i≤χ . When EPK(Pi) is uploaded to the cloud by each data owner, a new encrypted dataset EPK(P) is generated. The encrypted dataset EPK(P) can be used for secure skyline queries through the collaboration of the DSP and the DAP.

Queries Requesters (QRs): Let o be the number of QRs. The q -th authorized client QRq with a pair of keys (pk_{q},sk_{q}) intends to obtain the skyline set with respect to a query tuple {\mathbf{q}}_{q}=({\mathbf{q}}_{q}[{1}],\ldots, {\mathbf{q}}_{q}[{d}]) , where 1\leq q \leq o . To protect the privacy of {\mathbf{q}}_{q} , the QRq uses the Diffie-Hellman key PK to encrypt {\mathbf{q}}_{q} and sends E_{PK}({\mathbf{q}}_{q})=(E_{PK}({\mathbf{q}}_{q}[{1}]),\ldots,E_{PK}({\mathbf{q}}_{q}[{d}])) to the DSP. Therefore, the DSP and the DAP cannot individually decrypt E_{PK}({\mathbf{q}}_{q}) .

Two cloud servers: The data service provider (DSP), one cloud server, with a pair of keys (pk_{DSP},sk_{DSP}) can store encrypted data and provide the service of skyline queries processing, which is served on a cloud service. We utilize the homomorphic property of HRES to calculate the ciphertext. Moreover, DSP can transfer the encrypted message [\![m]\!] by PDec1 into [\![m]\!]_{pk_{DAP}} that can be decrypted by the data assistance provider (DAP). DAP is another cloud server, which holds its own pair of keys (pk_{DAP}, sk_{DAP}) and assists with the computation. That is, DAP uses PDec2 to decrypt [\![m]\!]_{pk_{DAP}} and returns the intermediate message [\![m]\!] to DSP, which continues to process secure skyline queries. When the protocol finishes, the DAP will return the encrypted results E_{pk_{q}}(R_{q}) to the client QRq.


Fig. 3.
System model.

Show All

D. Security Model
All entities are assumed to be curious-but-honest. That is, they strictly follow all protocols but are also curious about the data belonging to other entities. They may also eavesdrop on all communication channels to obtain any encrypted data. However, the DSP and the DAP would never collude with each other due to conflict of interests. We give our simulation-based notion of security for our protocols. Intuitively, based on the simulation paradigm [28], [29], it requires that the view of each party participating in a protocol can be simulated relying on its input and output, which implies that the parties can capture nothing from the protocol.

According to the composition theory [29] (see V-B), the security of SMSQ is subject to the security of each protocol. Hence, we formally give the following security definition of each protocol involved in SMSQ.

Definition 4 (Security):
Let \epsilon be a security parameter and \Pi be each protocol involved in SMSQ. Let \mathcal {S} be a simulator and \mathcal {L} be the leakage collection. We define two games \textsf {Real}_{\mathcal {A}} and \textsf {Ideal}_{\mathcal {A},\mathcal {S}} as follows.

\textsf {Real}_{\mathcal {A}}(\lambda) : \mathcal {A} chooses the original input O . The game generates key pairs (sk_{DSP},pk_{DSP}) , (sk_{DAP},pk_{DAP}) , and their Diffie-Hellman key PK by KeyGen. Then it calculates and gives I=E_{PK}(O) to \mathcal {A} . Next, \mathcal {A} takes I as input to get the encrypted results by running \Pi . Finally, \mathcal {A} returns a bit b \in \{0,1\} that is output by the game.

\textsf {Ideal}_{\mathcal {A},\mathcal {S}}(\lambda) : Given \mathcal {L} , \mathcal {S} simulates an encrypted dataset I^{*} and sends it to \mathcal {A} . After that, \mathcal {A} obtains the encrypted results by running \Pi . Finally, \mathcal {A} returns b \in \{0,1\} that is output by the game.

\Pi is \mathcal {L} -secure if for all probabilistic polynomial time (PPT) adversaries \mathcal {A} , there exists a PPT simulator \mathcal {S} such that \begin{equation*}{\rm \left |{ {\mathrm{ Pr}}[\mathsf {Real}_{\mathcal {A}}(\lambda)=1] - {\mathrm{ Pr}}[\mathsf {Ideal}_{\mathcal {A},\mathcal {S}}(\lambda)=1]}\right | \leq negl(\lambda),}\end{equation*}
View Sourcewhere negl(\lambda) denotes a negligible function.

The security model guarantees that each protocol does not leak more than the output of the leakage collection \mathcal {L} . We present the concrete leakage collection in Section V.

Remark:
Let {\mathbf{p}}_{sky} be a skyline point and \mathcal {L}_{P}(\cdot) be the indirect privacy w.r.t. P . For positions of the dominated points, given {\mathbf{p}}_{sky} \prec {\mathbf{p}}_{i} and {\mathbf{p}}_{i} denotes the i -th tuple in {P} , we say that the location of {\mathbf{p}}_{i} is leaked, which means that the dominance relationship between {\mathbf{p}}_{sky} and {\mathbf{p}}_{i} is exposed, which is denoted as \mathcal {L}_{P}({\mathbf{p}}_{sky} \prec {\mathbf{p}}_{i}) . Furthermore, let P' = \mathcal {T}(P) and \mathcal {T}(\cdot) be a transformation function. Given {\mathbf{p}}_{sky} \prec \hat {\mathbf{p}}_{j} and \hat {\mathbf{p}}_{j} denotes the j -th tuple in {P}' . If \mathcal {T}^{-1}(\cdot) is known, \mathcal {L}_{P}({\mathbf{p}}_{sky} \prec \hat {\mathbf{p}}_{j}) , otherwise, \mathcal {L}_{P}({\mathbf{p}}_{sky} \prec \hat {\mathbf{p}}_{j}) does not hold, where \mathcal {T}^{-1}(\cdot) is an inverse transformation.

E. Some Subprotocols
Based on the additive homomorphic property similar to the Paillier’s scheme, we introduce the secure multiplication (SM) protocol [21], the secure bit-and (SAND) protocol, the secure squared Euclidean distance (SSED) protocol [30] and the data packing (DP) [30].

Suppose a cloud server DSP with encrypted input E_{PK}(a) , E_{PK}(b) and a pair of keys (sk_{DSP},pk_{DSP}) , and a cloud server DAP with his own a pair of keys (sk_{DAP},pk_{DAP}) , where a and b are hidden from the DSP and the DAP. The Secure Multiplication (SM) protocol [21] securely calculates encrypted result of multiplication of a , b , E_{PK}(a \times b) , such as only the DSP knows E_{PK}(a \times b) and no information related to a , b is revealed to the DSP or the DAP.

The secure multiplication protocol is easily used on the two bits to implement SAND, which reveals no information regarding the two bits to the clouds DSP and DAP.

Based on homomorphism, the DSP securely computes the ciphertext of squared Euclidean distance E_{PK}(Dist({\mathbf{t}}_{0})) = E_{PK}(\left |{ {\mathbf{t}}_{0}[{1}]-0}\right |^{2}+\ldots +\left |{ {\mathbf{t}}_{0}[d]-0}\right |^{2}) , which reveals no information regarding {\mathbf{t}}_{0} to the clouds DSP and DAP.

In order to reduce the number of times of the encryption and decryption, the data packing (DP) of fully leveraging message space is proposed. Intuitively, the message is 512-bits, and it contains a mass of unoccupied bits. Therefore, this method packs \lambda ~\sigma -bits integers x_{1},\ldots,x_{\lambda } into one value \langle x_{1}|\ldots |x_{\lambda }\rangle , and this value can be computed as follows:\begin{equation*} \langle x_{1}|\ldots |x_{\lambda } \rangle = \sum _{i=1}^{\lambda } x_{i}2^{\sigma (\lambda -i)}.\tag{8}\end{equation*}
View Source

Notice that, in the aspect of ciphertext under the public key pk_{i} , this packed value can be computed as follows:\begin{equation*} E_{pk_{i}}(x_{1}|\ldots |x_{\lambda }) = \prod _{i=1}^{\lambda } E_{pk_{i}}(x_{i})^{2^{\sigma (\lambda -i)}}.\tag{9}\end{equation*}
View Source

SECTION III.Basic Secure Subprotocols
In this section, we devise the efficient secure integer comparison protocol (LSCP_{int} ) and the efficient secure vector comparison protocol (LSCP_{vec} ) under the HRES Cryptosystem. Based on these protocols, we propose ESDP. It is worth noting that the input integers x, y (or elements in the vectors {\mathbf{a}},~{\mathbf{b}} ) involved in our basic secure subprotocols can be positive, zero and negative,3 and restricted in the range of [-R_{g},R_{g}] , where ||R_{g}|| < ||N||/4-1 and ||\cdot || indicates the bit length of “\cdot ”. If we need a larger plaintext range, the larger N can be used. Actually, the data for encryption is usually far less than 512 bits (||N|| = 512 and the data does not exceed 25 bits in our experiment). In our design, we interpret the pseudo-random function (PRF) f that is used to generate the random value r_{\upsilon } \in \mathbb {Z}_{N}^{*} (1 \leq \upsilon \leq d ) with the key K_{prf} , that is r_{\upsilon } \gets f(\upsilon) .\begin{equation*} f: \{0,1\}^{*}\times K_{prf} \rightarrow \{0,1\}^{\left \|{ N}\right \|},\tag{10}\end{equation*}
View Sourcewhere \left \|{ N }\right \| denotes the bitsize of N .

A. Secure Integer Comparison Protocol
In the LSCP_{int} , the DSP with input ([\!~[x] \!],[\!~[y] \!]) and its own keys (sk_{DSP},pk_{DSP}) , the DAP with (sk_{DAP},pk_{DAP}) , both of them securely compute the encrypted Boolean result E_{PK}(Bool(x \le y)) , i.e., if x \le y , the DSP gets E_{PK} (1) , otherwise, the DSP gets E_{PK} (0) . The requirement of privacy is to avoid revealing any information about x and y to the DSP and the DAP.

Step-1 (@DSP): [\!~[x] \!] and [\!~[y] \!] should be transformed into x' and y' so as to avoid exposing the equivalence relation if x is equal to y . Note that transformed x' and y' will not change their relative numerical relationship and is also called order preservation. Concretely, the DSP computes {x}' = 2 \times x and {y}' = 2 \times y+1 based on the additive homomorphic property through the following equations:\begin{align*} \mathcal {X}=&~[\!~[x] \!]^{2}\bmod N^{2}, \tag{11}\\ \mathcal {Y}=&E_{PK}(1) \times \,\,[\!~[y] \!]^{2}\bmod N^{2}.\tag{12}\end{align*}
View Source

Next, the DSP chooses the random functionality F through flipping a coin. Then, depending on F , the DSP proceeds as follows:

F: coin = 1 , compute z = \mathcal {X} \times \mathcal {Y}^{N - 1}\bmod N^{2} .

F: coin = 0 , compute z = \mathcal {Y} \times \mathcal {X}^{N - 1}\bmod N^{2} .

The processing above shows the way to compute \mathcal {X}-\mathcal {Y} or \mathcal {Y}-\mathcal {X} under the ciphertext state. To hide the numerical relationship regarding \mathcal {X} and \mathcal {Y} from the DAP, the DSP can randomly choose the functionality F that cannot be revealed to the DAP. Moreover, the DSP adds a random noise r to z and gets z'=z^{r} \bmod N^{2} that needs to be transferred into another ciphertext c through the equation 13, where r is generated by f . Note that r \neq 0 and ||r||< ||N||/4 . Then, c is sent to DAP. \begin{equation*} c=PDec1(z ',sk_{DSP})\tag{13}\end{equation*}
View Source

Step-2 (@DAP): Once c is received, DAP can decrypt it, thus m' is:\begin{equation*} m' =PDec2(c,sk_{DAP}).\tag{14}\end{equation*}
View SourceRight-click on figure for MathML and additional features.

If ||m'|| > ||N||/2 , the DAP sends u=E_{PK}(1) to the DSP, otherwise, sends u=E_{PK}(0) . It is worth noting that although the DAP knows m' , it does not know the numerical relationship between [\!~[x] \!] and [\!~[y] \!] due to F unknown.

Step-3 (@DSP): When u is received, the DSP directly obtains u with F: coin = 1 . If F is coin = 0 , the DSP calculates (1-u) as:\begin{equation*} u = E_{PK}(1) \times u^{N-1}.\tag{15}\end{equation*}
View SourceRight-click on figure for MathML and additional features.

Correctness of {\mathrm{ LSCP}}_{int} . For the ease of explanation, we only consider the case of coin=1 . If x > y , 2x > 2y+1 . Since x,y \in R_{g} , || 2(x-y)-1|| < ||N||/4 . We know that ||r||< ||N||/4 , so ||m'|| < ||N||/2 . Similarly, when x \leq y , ||m'|| > ||N||/2 .

Secure Minimum Computation (SMIN). Inspired by [7], we devise SMIN based on our secure comparison protocol. First, we set [\!~[out] \!] as the result of LSCP_{int} . Then, the DSP can obtain {\mathrm{ SMIN}}([\!~[x] \!],[\!~[y] \!]) by computing [\!\,\,[x \times out+y \times \neg out] \!] . Based on this thought, the DSP computes the minimum number between [\!~[x] \!] and [\!~[y] \!] as Eq. 16. Concretely, the DSP utilizes the SM protocol to calculate [\!\,\,[x \times out] \!] and [\!\,\,[y \times \neg out] \!] . Next, the DSP calculates [\!\,\,[x \times out+y \times \neg out] \!] based on the additive homomorphic property. This process reveals no information regarding [\!~[x] \!] and [\!~[y] \!] to the clouds DSP and DAP. \begin{align*}&\hspace {-2pc}{\mathrm{ SMIN}}([\!~[x] \!],[\!~[y] \!]) \\=&E_{PK}(x \times out+y \times \neg out) \\=&{\mathrm{ SM}}([\!~[x] \!],[\!~[out] \!]) \times {\mathrm{ SM}}([\!~[y] \!],~[\!~[{1}] \!] \times \,\,[\!~[out] \!]^{N-1})\quad \tag{16}\end{align*}
View Source

SMIN out of n Numbers (SMIN{_{n}} ). In order to compute the minimum privately from dist_{1},\ldots,dist_{n} without revealing any information to the clouds, we present a hybrid approach SMINn by integrating a hierarchical binary execution tree and LSCP_{int} through parallelism. As shown in Fig. 4, the DSP first obtains four smaller values from the leaf nodes of the tree using LSCP_{int} through parallelism. Similarly, the DSP finally gets the minimum value Dist_{2} .


Fig. 4.
The illustration of SMINn.

Show All

B. Secure Vector Comparison Protocol
In order to reduce communication overhead and the number of times of the decryption, using the DP technology, the LSCP_{int} is extended to the comparison of multi-dimensional data, called LSCP_{vec} . Intuitively, the DSP with E_{PK}({\mathbf{a}}) and E_{PK}({\mathbf{b}}) gets {\mathbf{z}}[i]=E_{PK} (1) if {\mathbf{a}}[i] \le {\mathbf{b}}[i] , otherwise, gets {\mathbf{z}}[i]=E_{PK} (0) . Furthermore, both the DSP and the DAP know nothing about the information of {\mathbf{a}} and {\mathbf{b}} .

The steps of LSCP_{vec} are illustrated as follows:

Step-1 (@DSP): The DSP also does operations of order preservation to avoid the equivalence relation in each dimension corresponding to {\mathbf{a}} and {\mathbf{b}} . Thus, the DSP obtains the transformed {\mathbf{a}}'[i] and {\mathbf{b}}'[i] . Then, the DSP randomly generates a binary array \bf {v} , which cannot be revealed to the DAP. If {\mathbf{v}}[i]=1 , the DSP computes \alpha [i] =\,\,[\!\,\,[{\mathbf{a}}'[i]] \!] \times \,\,[\!\,\,[{\mathbf{b}}'[i]] \!]^{N - 1}\bmod N^{2} . Otherwise, if {\mathbf{v}}[i]=0 , the DSP computes \alpha [i] =\,\,[\!\,\,[{\mathbf{b}}'[i]] \!] \times \,\,[\!\,\,[{\mathbf{a}}'[i]] \!]^{N - 1}\bmod N^{2} . Next, the DSP adds a random noise r_{i} to \alpha [i] through Eq. 17 (r_{i} \in {\mathbb {Z}}_{N}^ {*} , ||r_{i}|| < \varrho and ||R_{g}||+\varrho < \left \lfloor{ ||N||/d }\right \rfloor ), where r_{i} is generated by f(i) .\begin{equation*} \alpha '[i] = \alpha ~[i]^{r_{i} } \bmod N^{2} \tag{17}\end{equation*}
View Source

In order to prevent the DAP from guessing the positions of the elements in \alpha ' , a permuted list \gamma =\pi _{1}(\alpha ') is calculated through a random permutation function \pi _{1} .

Then, to reduce the number of times of the decryption and conserve network bandwidths, the DSP packs \gamma to \bar \gamma as follows:\begin{equation*} \bar \gamma = \prod _{i=1}^{d} (\gamma [i])^{2^{\bar {\sigma }(d-i)}},\tag{18}\end{equation*}
View Sourcewhere \bar {\sigma } = ||R_{g}||+\varrho .

Next, the DSP decrypts it by \widehat \gamma =PDec1(\bar \gamma,sk_{DSP}) and sends \widehat \gamma to the DAP.

Step-2 (@DAP): Once \widehat \gamma is received, the DAP decrypts it by \widehat \beta _{1} =PDec2(\widehat \gamma,sk_{DAP}) and unpacks it to \beta as follows:\begin{equation*} \beta [i] = \left \lfloor{ {\frac {\widehat \beta _{i}}{2^{\bar {\sigma }(d-i)}}} }\right \rfloor,\tag{19}\end{equation*}
View Sourcewhere \widehat \beta _{i} = \widehat \beta _{i-1} - \beta [i-1]\times 2^{\bar {\sigma }(d-i-1)} and 1 \leq i \leq d .

Then, the DSP determines \bf {u} returned to the DSP by the following rules. If ||\beta \,\,[i]|| < ||N||/4+\varrho , the DAP computes {\mathbf{u}}[i]=E_{PK}(0) . Otherwise, the DAP computes {\mathbf{u}}[i]=E_{PK}(1) . Subsequently, {\mathbf{u}} = ({\mathbf{u}}[{1}],\ldots, {\mathbf{u}}[d]) is transferred to the DSP.

Step-3 (@DSP): After receiving the encrypted permuted bit list {\mathbf{u}} , the DSP applies a reverse permutation, and directly obtains {\mathbf{u}}'[i] with {\mathbf{v}}[i]=1 . Otherwise, if {\mathbf{v}}[i]=0 , the DSP calculates (1-{\mathbf{u}}'[i]) by {\mathbf{z}}[i] =E_{PK}(1) \times {\mathbf{u}}'[i]^{N-1} .

C. Efficient Secure Dominance Protocol
The purpose of ESDP is to calculate the dominance relationship among two points. Suppose the DSP with encrypted tuples E_{PK} ({\mathbf{a}}) , E_{PK}(\bf {b}) , its own key pair (sk_{DSP},pk_{DSP}) and the DAP with its own key pair (sk_{DAP},pk_{DAP}) , where \bf {a} and \bf {b} are not revealed to both servers. The basic thought of ESDP is similar to that of the dominance protocol in [7]. However, they differ in concrete implementations. That is, we calculate whether {\mathbf{a}} \preceq {\mathbf{b}} through LSCP_{vec} , then check whether {\mathbf{a}} is equal to {\mathbf{b}} through LSCP_{int} . The ESDP finally returns E_{PK}({\mathbf{a}} \prec {\mathbf{b}}) only when the DSP knows E_{PK}(1) if {\mathbf{a}} \prec {\mathbf{b}} , if not, E_{PK}(0) is calculated.

Concretely, the DSP and DAP cooperatively use LSCP_{vec} protocol to compute whether {\mathbf{a}} \preceq {\mathbf{b}} . Next, they cooperatively compute {\delta _{1} }={\mathbf{c}}[{1}] \wedge \ldots \wedge {\mathbf{c}}[{d}] through SAND. If {\delta _{1} }=1 , it indicates {\mathbf{a}} \preceq {\mathbf{b}} , otherwise {\mathbf{a}} \npreceq {\mathbf{b}} . Then, to check whether {\mathbf{a}}={\mathbf{b}} , the DSP computes the sum of all dimensions s_{a}=E_{PK}\left({\sum _{k=1}^{d} {\mathbf{a}}[{i}]}\right) and s_{b}=E_{PK}\left({\sum _{k=1}^{d} {\mathbf{b}}[{i}]}\right) using the additive homomorphic property. Next, the DSP uses LSCP_{int} to compare s_{a} with s_{b} , then obtains [\![u_{1}] \!] . After that, the DSP exchanges s_{a} and s_{b} for comparison, and gets [\![u_{2}] \!] . Only if \sum _{k=1}^{d} {\mathbf{a}}[{i}]=\sum _{k=1}^{d} {\mathbf{b}}[{i}] , then u_{1}=u_{2}=1 . Therefore, based on the idea of u_{1} \otimes u_{2}=u_{1}+u_{2}-2(u_{1} \times u_{2}) , the DSP obtains \delta _{2} by computing \delta _{2}=[\![u_{1}] \!] \times \,\,[\![u_{2}] \!] \times {\mathrm{ SM}}([\![u_{1}] \!],[\![u_{2}] \!])^{N-2} . Finally, they cooperatively calculate the dominance relationship \Phi =\delta _{1} \wedge \delta _{2} by SAND, which is only stored by the DSP in ciphertext. Thus, they gain nothing about the dominance relationship among {\mathbf{a}} and {\mathbf{b}} .

SECTION IV.Secure Multi-Party Skyline Query
First, we give an overview of our schemes, then demonstrate BMSQ that is an efficient method but not adequately secure. Next, we demonstrate SMSQ that perfectly satisfies our security primitives expounded in Section II-D.

A. Overview
Our SMSQ protocol aims to process the secure dynamic skyline queries over the encrypted data. An overview of how SMSQ works is as follows:

First, when a query E_{PK}(\boldsymbol{ -q}_{q}) is received from RQq, the DSP needs to map E_{PK}(P) to a new space (i.e., E_{PK}(T)=\{{\mathbf{t}}_{1},\ldots, {\mathbf{t}}_{i},.., {\mathbf{t}}_{n}\} ) according to E_{PK}(\boldsymbol{ -q }_{q}) .

After that, the DSP primarily calculates the Euclidean distance between E_{PK}({\mathbf{t}}_{i}) and the origin by SSED during the initialization phase.

Next, we propose a novel solution named “blind-read”, which supports secure access to a skyline tuple. Moreover, two clouds cannot obtain the content of skyline tuples and know which tuples are skyline points.

Upon owning this skyline tuple [\!~[{\mathbf{t}}_{sky}] \!] , the DSP obtains the dominance relationship DR_{m} between [\!~[{\mathbf{t}}_{sky}] \!] and other tuples by using ESDP. If DR_{m} is directly decrypted, this method is an efficient solution to prune dominated tuples, which is the step of our basic protocol named BMSQ. Obviously, the location of the dominated tuple is leaked to the DSP. To this end, we present the Find Possible Skyline Set algorithm that is a key component of SMSQ. Next, the DSP returns to step 3) to get the next skyline tuple.

Once the DSP has final skyline results, two clouds transfer them to ciphertexts under the public key of the RQq by REnc. Finally, they are returned to the client.

B. Preprocessing and Returning
1) Preprocessing:
Given a query point {\mathbf{q}}_{q} , the RQq encrypts it with the Diffie-Hellman key PK . Then, the requester sends E_{PK}(\boldsymbol{ -q }_{q})=(E_{PK}(-{\mathbf{q}}_{q}[{1}]),\ldots,E_{PK}(-{\mathbf{q}}_{q}[d])) to the DSP.4 Furthermore, the raw data E_{PK} (P) is mapped to a new space with the mapping function {\mathbf{t}}_{i}[\upsilon]=\left |{ {{\mathbf{p}}_{i}\,\,[\upsilon]-{\mathbf{q}}_{q}[\upsilon]} }\right | . According to the mapping function, the DSP calculates the different E_{PK}(tmp_{i}[\upsilon]) between {\mathbf{p}}_{i}[\upsilon] and {\mathbf{q}}_{q}[\upsilon] as:\begin{equation*} [\!~[tmp_{i}[\upsilon]] \!]=E_{PK}({{\mathbf{p}}_{i}~[\upsilon]) \times E_{PK}(-{\mathbf{q}}_{q}[\upsilon]})\bmod N^{2}.\tag{20}\end{equation*}
View SourceRight-click on figure for MathML and additional features.

In order to facilitate calculation, we use ({{\mathbf{p}}_{i}\,\,[\upsilon]-{\mathbf{q}}_{q}[\upsilon]})^{2} instead of \left |{ {{\mathbf{p}}_{i}\,\,[\upsilon]-{\mathbf{q}}_{q}[\upsilon]} }\right | . Hence, E_{PK}(T)=\{{\mathbf{t}}_{1},\ldots, {\mathbf{t}}_{i},.., {\mathbf{t}}_{n}\} , where {\mathbf{t}}_{i}=(E_{PK}({\mathbf{t}}_{i}[{1}]),\ldots,E_{PK}({\mathbf{t}}_{i}[d])) and [\!\,\,[{\mathbf{t}}_{i}[\upsilon]] \!]=SM([\!\,\,[tmp_{i}[\upsilon]] \!],\,\,[\!\,\,[tmp_{i}[\upsilon]] \!]) by using the SM protocol. Finally, the DSP gets E_{PK} (P) and E_{PK} (T) , which are only known by it in the ciphertext.

2) Returning:
We also show a method of returning the skyline result E_{PK}(R_{q}) to the RQq. Upon obtaining E_{PK}(R_{q}) , the DSP and the DAP can transfer it to the ciphertext E_{pk_{q}}(R_{q}) under the public key of the RQq through REnc. Then, the RQq can decrypt it through sk_{q} and obtain {R_{q}} as the final result when E_{pk_{q}}(R_{q}) is received.

C. Basic Multi-Party Skyline Query Protocol
At the beginning, we summarize the following differences between our BMSQ and the basic secure skyline protocol (BSSP) in [7].

In our BMSQ, the DSP searches the skyline tuple according to the squared Euclidean of the tuple instead of a simple sum of dimensions.

We devise a novel method named “blind-reading”, which enables the DSP to securely calculate the skyline points without revealing which tuples are skyline points.

As shown in Algorithm 1, we relax some security requirements to improve efficiency. The basic idea is to choose a skyline tuple and eliminate the tuples that can be dominated by it to further reduce the dataset size. When no tuple exists in T' that is assigned by E_{PK}(T) , the protocol returns skyline results to the client; otherwise, the protocol proceeds as follows.


Algorithm 1
Basic Multi-Party Skyline Query

Show All

1) Initialization:
The DSP first assigns E_{PK}(P) to P' and E_{PK}(T) to T' respectively. These assignment operations are mainly to avoid directly operating on the raw data. Moreover, based on experimental analysis, we observe that the closer the selected tuple is to the query point, the more tuples will be dominated by it, thereby reducing the size of the dataset faster and avoiding more dominating operations. Hence, the DSP calculates the Euclidean distance between E_{PK}({\mathbf{t}}_{i}) and the origin through SSED.

2) Select One Skyline Tuple From T' :
In order to avoid revealing which tuple is [\!~[{\mathbf{t}}_{sky}] \!] ([\!~[{\mathbf{p}}_{sky}] \!] ), it has two following key points: i ) how to securely obtain [\!~[{\mathbf{t}}_{sky}] \!] ([\!~[{\mathbf{p}}_{sky}] \!] ) from T' (P' ); ii ) how to blindly eliminate [\!~[{\mathbf{t}}_{sky}] \!] ([\!~[{\mathbf{p}}_{sky}] \!] ) from T' (P' ). To do this, we propose a novel method named “blind-reading”. Concretely, the DSP and the DAP firstly use SMINn protocol such that the DSP obtains [\!~[Dist({\mathbf{t}}_{min})] \!] . Subsequently, the DSP and the DAP compare [\!~[Dist({\mathbf{t}}_{min})] \!] with each [\!~[Dist({\mathbf{t}}_{i})] \!] . Only when \varphi is 1 (i.e., Dist({\mathbf{t}}_{min}) is found), the DSP assigns [\!~[{\mathbf{t}}_{i}] \!] ([\!~[{\mathbf{p}}_{i}] \!] ) to [\!~[{\mathbf{t}}_{sky}] \!] ([\!~[{\mathbf{p}}_{sky}] \!] ), which is shown in Line 15 and 16 of Algorithm 1. Note that {\mathbf{p}}_{i}\circ {\mathbf{p}}_{j} denotes ({\mathbf{p}}_{i}[{1}]\times {\mathbf{p}}_{j}[{1}],\ldots, {\mathbf{p}}_{i}[d]\times {\mathbf{p}}_{j}[d]) .

After that, the DSP secretly adds 1 to {\mathbf{t}}_{i}[{1}] using the additive homomorphic property if Dist({\mathbf{t}}_{i}) is equal to Dist({\mathbf{t}}_{min}) (Line 17) such that ‘{\mathbf{t}}_{sky} ’ can be blindly eliminated by itself in the next stage. However, a potential issue is that multiple tuples may have the same minimum distance. If this happens, not only is the dataset tampered with, but also the skyline tuple cannot be selected (computed) correctly, since there are multiple cases \varphi = 1 . To address this, we use \varpi instead of \varphi such that \varpi is 1 if and only if Dist({\mathbf{t}}_{min}) is found for the first time (Line 13 to 14). The generation of [\!~[\varpi] \!] is based on the following ideas. 1) We set a state parameter [\!\,\,[\varphi '] \!] = E_{PK}(0) . 2) Let [\!\,\,[\varphi '] \!]=\,\,[\!\,\,[\varphi] \!] \times \,\,[\!\,\,[\varphi '] \!] , i.e., if \varphi =1 , then \varphi ' = 1 +\varphi ' , otherwise, if \varphi =0 , then \varphi ' = \varphi ' . Therefore, only when \varphi =1 for the first time, [\!\,\,[{ 1}] \!] \times {\mathrm{ LSCP}}_{int}([\!\,\,[{ 1}] \!],[\!\,\,[\varphi '] \!])^{N-1} is [\!~[{ 1}] \!] , i.e., [\!\,\,[\varpi] \!] = E_{PK}(1) . Finally, the DSP adds the skyline tuple E_{PK}({\mathbf{p}}_{sky}) to the encrypted skyline set E_{PK}(R_{q}) .

3) Eliminate Dominated Tuples:
Upon choosing one skyline tuple, the DSP and the DAP cooperatively calculate whether E_{PK}({\mathbf{t}}_{sky}) dominates other tuples by using the ESDP protocol. If dominated by E_{PK}({\mathbf{t}}_{sky}) , those tuples will be deleted. One simple but a weak secure method to delete those tuples is to cooperate to decrypt the dominance relationship results DR_{m} of the ESDP protocol. Then, the DAP returns the indexes DR_{c} of tuples that are dominated in T' . The DSP can delete these tuples on the basis of DR_{c} . The algorithm continues back to step 2) until there are no tuples left.

D. Secure Multi-Party Skyline Query Protocol
Some privacy is easily discovered by the DSP and the DAP in the BMSQ. In the first iteration, since \mathcal {T}^{-1}(\cdot) is known through DR_{c} , the DSP can recover E_{PK}(P)\!=\! \mathcal {T}^{-1}(P') . Hence, \mathcal {L}_{P}(\tilde {\mathbf{p}}_{sky} \prec \tilde {\mathbf{p}}_{i}) is discovered by the DSP. Similarly, in the next iteration, the DSP infers the \mathcal {T}^{-1}(\cdot) according to DR_{c} , so \mathcal {L}_{P}(\tilde {\mathbf{p}}_{sky} \prec \tilde {\mathbf{p}}_{i}) is still leaked to the DSP.

In order to address privacy leakage, each skyline point is calculated by traversing the entire dataset in the fully secure skyline protocol (FSSP) [7]. Obviously, the computational time of FSSP is huge. Therefore, we demonstrate the SMSQ that attempts to obtain the skyline results on a smaller dataset without leaking any privacy and loss of query accuracy. As shown in Algorithm 2, the steps of data preprocessing and initialization, selecting one skyline tuple, and returning the results to the client are exactly the same as those of the BMSQ, so we omit the description. The following steps are dedicated to addressing privacy leakage.

Algorithm 2 - Secure Multi-Party Skyline Query
Algorithm 2
Secure Multi-Party Skyline Query

Show All

Once the DSP gets E_{PK}({\mathbf{t}}_{sky}) , the next step is to how to blindly eliminate dominated tuples such that the scale of P' (T' ) is reduced and both of two cloud servers know nothing about \mathcal {T}^{-1}(\cdot) . To handle this problem, we present the Find Possible Skyline Set (DEET) algorithm, as shown in Algorithm 3.


Algorithm 3
Find Possible Skyline Set

Show All

Concretely, given E_{PK} (E) for T' , E_{PK}(S) for P' and E_{PK}({\mathbf{t}}_{sky}) for one skyline tuple, the DSP and the DAP cooperatively use the ESDP to calculate whether E_{PK}({\mathbf{t}}_{sky}) dominates other tuples. However, since we focus on the tuples that cannot be dominated by E_{PK}({\mathbf{t}}_{sky}) , results of the ESDP protocol need to be reversed, i.e., if E_{PK}({\mathbf{t}}) dominates one tuple, V[i]=E_{PK}(0) , if not, V[i]=E_{PK}(1) . Then, the DSP runs PDec1 to transfer V[i] into DAP’s ciphertext V'[i] that can be decrypted by the DAP. Then, a permuted list \Psi = \pi _{2}({V'}) is sent to the DAP through a random permutation function \pi _{2} .

Upon receiving \Psi , the DAP decrypts it by PDec2 and obtains the plaintext dominance relationship W . In order to help DSP eliminate the dominated tuples to obtain a smaller dataset P' (T' ) without privacy leakage, the DAP constructs a matrix K , named Privacy Matrix, that is returned to the DSP.

Next, we explain the meaning of K . A vector K_{k} in K corresponds to one E_{PK}(\bf e) (E_{PK}(\bf s) ). This vector K_{k} is composed of E_{PK}(1) , E_{PK}(0) and 0, where K_{k}[i]=E_{PK}(1) means the i -th tuple in E_{PK}(E) (E_{PK}(S) ) will be added to D (D' ). Therefore, in order to hide the position of the tuple, there are at least two encrypted values in each K_{k} . Moreover, there is at least one encrypted value in each column of K , which means that any tuple in E_{PK}(E) (E_{PK}(S) ) may be located in D (D' ). We also give the formal definition of Privacy Matrix (see Definition 5).

Definition 5 (Privacy Matrix):
Given dominance relationship W , for K_{k}[i] , if W[i]=1 , K[k][i]=E_{PK}(1) ,5 and K[k][j]=E_{PK}(0) or K[k][j]=0 , where i, j \in ~[1,size(W)] and j \neq i as well as k is only the serial number. For privacy requirements, it satisfies the following conditions: (1) let K(:,i) be the i -th column of K , for 1 \leq i\leq size(W) , there is at least one E_{PK}(\cdot) in K(:,i) ; (2) let K(k,:) be the k -th row of K , for 1 \leq k \leq size(K) , there is at least one E_{PK}(1) and E_{PK}(0) in K(k,:) .

Subsequently, we illustrate how to generate the Privacy Matrix K according to Definition 5. The DAP first counts the number of 0 and the number of 1 in W , denoted as Num(0) and Num(1) respectively. Then we divide the process into the following four cases:

Num(0)>Num(1) illustrates that the dataset size is reduced by more than half. W is randomly divided into multiple groups, and the size of each group (GP ) is \left \lfloor{ \frac {Num(0)}{Num(1) } }\right \rfloor +1 . Note that the size of the last group is \left({\left \lfloor{ \frac {Num(0)}{Num(1) } }\right \rfloor +1}\right)+(Num(0) \bmod Num(1)) . In GP_\vartheta , if W[i]=1 , K_{\vartheta }[i]=E_{PK}(1) . And dimensions in K_{\vartheta } corresponding to dimensions in GP_\vartheta (excluding the dimension i ) are set to E_{PK}(0) . The remaining dimensions in K_{\vartheta } are set to 0.

Num(0)< Num(1) illustrates that the dataset size is reduced by less than half. W is randomly divided into multiple groups, and the size of each group is \left \lfloor{ \frac {Num(1) }{Num(0)} }\right \rfloor +1 (the size of the last group is \left({\left \lfloor{ \frac {Num(1) }{Num(0)} }\right \rfloor +1}\right)+(Num(1) \bmod Num(0)) ). In GP_\vartheta , if W[i]=1 , K_{k}[i]=E_{PK}(1) . And dimensions in K_{\vartheta } corresponding to dimensions in GP_\vartheta (excluding the dimension i ) are set to E_{PK}(0) . The remaining dimensions in K_{\vartheta } are set to 0. Note that since multiple W[i]=1 exist in each group, there will be multiple K_{\vartheta } .

Num(0)=0 illustrates that the size of the dataset has not changed. The processing steps are similar to the above. Moreover, this case generally occurs less frequently in the first few iterations.

Num(1) =0 illustrates that the size of the dataset is zero. In this case, return \bot .

To further protect privacy, it is emphasized that the order of K_{k} in K is random, which can disturb the order of T' and P' . Moreover, we also need to add noise data to K . The purpose is to make the DSP unable to determine the number of dominated tuples. If some noise is not added to K , the DSP can know the reduction of T' according to size(K) , so as to obtain the number of dominated tuples. A potential issue is that the number of K_{noise} will also increase with continuous iterations. If this happens, not only the execution efficiency will be affected, but also some K_{noise} will cause the “noise” tuples to be treated as skyline tuples. In order to address it, the “noise” tuples should be set to a crafted value to be eliminated in the future process. Thus, more than \boldsymbol {\varsigma } dimensions (\boldsymbol {\varsigma }\geq 2 ) in K_{\vartheta } are randomly set to E_{PK}(1) (the selected dimension i satisfies W[i]=1 unless there are no \boldsymbol {\varsigma }\,\,W[j]=1 in W , where 1 \leq j \leq size(W) ). Then, the DAP randomly selects \left({\left \lfloor{ \frac {Num(0)}{Num(1) } }\right \rfloor +1+(Num(0) \bmod Num(1))-\boldsymbol {\varsigma }}\right) dimensions in K_{\vartheta } are set to E_{PK}(0) if Num(0)>Num(1) . Otherwise, if Num(0)< Num(1) , the DAP randomly selects \left({\left \lfloor{ \frac {Num(1) }{Num(0)} }\right \rfloor +1+(Num(1) \bmod Num(0))-\boldsymbol {\varsigma }}\right) dimensions in K_{\vartheta } are set to E_{PK}(0) . The remaining dimensions in K_{k} are set to 0. The constituted K_{noise} has the following advantages: i ) the tuple generated by K_{noise} will be dominated by one tuple; ii ) according to the dimension of K , the DSP and DAP cannot infer the number6 of dominated tuples by E_{PK}({\mathbf{t}}_{sky}) ; iii)~(D,D') can be directly used as the input of BMSQ without exposing the number of dominated tuples because the DSP and the DAP cannot determine \mathcal {T}^{-1}(\cdot) and how many noise tuples are included. We also provide Fig. 5(a), 5(b), 5(c) for vivid illustrations. Note that we add one noise tuple to K in Fig. 5, which is concealed from the DSP.


Fig. 5.
Examples of the Privacy Matrix. (a) shows decrypted W=array(0,1,0,1,0,0,0) . According the above rules, the size of the first group is 3 and the size of last one is 4. Since W[{4}]=1 , K_{1}[{4}]=E_{PK}(1) . And W[{3}]=0 , W[{7}]=0 in GP_{1} , so K_{1}[{3}]=E_{PK}(0) and K_{1}[{7}]=E_{PK}(0) . The remaining dimensions in K_{1} are 0. K_{2} is produced by the same way. For K_{noise} , the DAP sets K_{noise}[{2}] and K_{noise}[{4}] to E_{PK}(1) due to W[{2}]=1 and W[{4}]=1 . Then, the DAP randomly chooses dimensions (1 and 6) to set K_{noise}[{1}]=E_{PK}(0) and K_{noise}[{6}]=E_{PK}(0) . The remaining dimensions in K_{noise} are 0. Since the principles are similar, the procedures of (b) and (c) are carried out in the same method.

Show All

After receiving a permuted vector K_{k} from the DAP, the DSP applies a reverse permutation, and gets a vector K_{k}' with [\!~[{1}] \!] , [\!~[{0}] \!] as well as 0, where K_{k}'[i] =\,\,[\!\,\,[{1}] \!] indicates that the i -th tuple in E_{PK}(E) (E_{PK}(S) ) should be added to D (D' ). To achieve the dimension values of the tuple, SM is employed to calculate encrypted product between K_{k}' and the dimension values, E_{PK} ({\mathbf{e}}_{i}~[j]) and E_{PK} ({\mathbf{s}}_{i}~[j]) . Since all other tuples except the one that may be a skyline tuple will be [\!~[{0}] \!] , we can sum all E_{PK} ({\mathbf{e}}_{i}~[j]) and E_{PK} ({\mathbf{s}}_{i}~[j]) on each dimension and the DSP can obtain possible skyline tuple E_{PK} ({\mathbf{e}}[j]') and E_{PK} ({\mathbf{s}}[j]') , and then add them to D and D' , respectively.

Through DEET, the DSP and the DAP cooperate to generate the new (T', P') to overwrite the old dataset. Meanwhile, for the trade-off between efficiency and privacy, we control the number of iterations by the parameter \kappa . When the threshold \kappa is reached, BMSQ is called, and E_{PK}(R_{q}) is obtained by the DSP. Note that (D,D') is directly used as the input of BMSQ without exposing the dominance relationship among tuples in T or P because the order of tuples in T or P has been obscured and nobody infers \mathcal {T}^{-1}(\cdot) . Meanwhile, since there are noise tuples in (D,D') , the number of dominated tuples is not accurate. Hence, the larger \kappa is, the better the order of tuples in T (P ) and the number of dominated tuples are masked.

Example 1:
Table II shows how does SMSQ work with \kappa = 1 in accordance with Fig. 1. Given the mapping data tuples {\mathbf{t}}_{i} , the DSP first computes the distance Dist({\mathbf{t}}_{i}) by SSED and the minimum distance Dist({\mathbf{t}}_{min}) \!= \!5 by SMINn. After that, the DSP securely obtains {\mathbf{t}}_{sky}/{\mathbf{p}}_{sky} through Line 10 to 17 of the Algorithm 1. {\mathbf{t}}_{sky} cannot dominate {\mathbf{t}}_{1} , so V=[{1,0,0,0}] . Assume the permutation function \pi _{2}=(4,3,2,1) , the DSP sends the encrypted permuted vector \Psi to the DAP. After decrypting \Psi , the DAP gets W (omitted) and then sends K (excluding the noise vector) to the DSP. The DSP computes K_{1}' by applying a reverse permutation, where K_{1}' includes one encypted 1 and one encypted 0. By employing SM with K_{1}' , the DSP obtains D/D' . After that, (D,D') is assigned to (T',P') . The protocol now turns back to BMSQ due to \kappa = 0 . The protocol continues until T'=\emptyset .

TABLE II Example of Algorithm 2. All Column Values Are Encrypted

SECTION V.Security Analysis
The semantic security of HRES has been proved under the attack model in [26]. Here, we first give the security analysis of sub-protocols, then demonstrate the security of SMSQ.

A. The Security of Subprotocols
To elaborate the security of our protocols, we first define the leakage collection \mathcal {L}(P, {\mathbf{q}})=(\textsf {cmp},\textsf {dim},\textsf {siz},\textsf {loc}) , where \textsf {cmp} , \textsf {dim} , \textsf {siz} and \textsf {loc} are formally defined as follows:

Comparison value (\textsf {cmp} ). In LSCP_{int} , \textsf {cmp}=1 if ||m'|| > ||N||/2 , otherwise, \textsf {cmp}=0 . In LSCP_{vec} , if ||\beta \,\,[i]|| < ||N||/4+\varrho , \textsf {cmp}_{i}=0 . Otherwise, \textsf {cmp}_{i}=1 .

Dimension of a tuple (\textsf {dim} ). \textsf {Dim} = |{\mathbf{p}}| , where {\mathbf{p}} \in P and |x| is denoted as the length of x .

Size of a dataset (\textsf {siz} ). \textsf {siz}=|T'|=|P'| after the DEET is run.

Positions of “1” in K (\textsf {loc} ). \textsf {loc} is a matrix such that for i=1,\ldots,|K| and j=1,\ldots, |K_{i}| , \textsf {loc}_{i}[j]=1 if K_{i}[j] = 1 , otherwise, \textsf {loc}_{i}[j]=0 .

In order to analyze security, we follow the framework of the simulation paradigm [28], [29]. For the ease of explanation, we demonstrate the LSCP_{int} protocol for illustration.

Theorem 1:
The LSCP_{int} protocol is \mathcal {L} -secure if f and F are pseudo-random and HRES is semantically secure.

Proof:
We describe a polynomial-time simulator \mathcal {S} such that for any probability polynomial time (PPT) adversary \mathcal {A} , the outputs of \textsf {Real}_{\mathcal {A}}(\epsilon) and \textsf {Ideal}_{\mathcal {A,S}}(\epsilon) are computationally indistinguishable. Hence, we build the real view \textsf {Real}_{\mathcal {A}}(\epsilon) and the simulated view \textsf {Ideal}_{\mathcal {A,S}}(\epsilon) as follows.

In the game \textsf {Real}_{\mathcal {A}}(\epsilon) , given the inputs E_{PK}(x) and E_{PK}(y) , during the protocol, the DSP calculates the difference between E_{PK}(x) and E_{PK}(y) , and sends the obfuscated difference z' to the DAP. The DAP decrypts it and sends the intermediate result to the DSP. Finally, the DSP outputs the encrypted Boolean result E_{PK}(s) by the experiment.

In the game \textsf {Ideal}_{\mathcal {A,S}}(\lambda) , given \textsf {cmp} , \mathcal {S} simulates the input (E_{PK}({x}^{*}),E_{PK}({y}^{*})) such that E_{PK}({x}^{*}) =[\![r_{1}]\!] and E_{PK}({y}^{*}) =[\![r_{1}+r_{2}]\!] if \textsf {cmp}=1 , otherwise, if \textsf {cmp}=0 , E_{PK}({x}^{*}) =[\![r_{1}]\!] and E_{PK}({y}^{*}) =[\![r_{1}-r_{2}]\!] , where r_{1} and r_{2} are random numbers (r_{1} > r_{2} > 0 ), and (r_{1}+r_{2}) \in (0,R_{g}] . After that, \mathcal {S} forms the simulated input (E_{PK}({x}^{*}),E_{PK}({y}^{*})) . It runs the LSCP_{int} protocol with coin = 1 to output the result E_{PK}(s^{*}) by the experiment.

Based on the simulator \mathcal {S} , no probability polynomial-time (PPT) adversary can distinguish the output of \textsf {Ideal}_{\mathcal {A,S}}(\epsilon) from that of \textsf {Real}_{\mathcal {A}}(\epsilon) since the outputs of them are encrypted by the HRES cryptosystem that is semantically secure. Meanwhile, since f and F are pseudo-random, the intermediate result in LSCP_{int} is obscured and indistinguishable to \mathcal {A} .

To summarize, \mathcal {A} cannot distinguish the views in games \textsf {Real} and \textsf {Ideal} . That is, \begin{equation*}{\rm \left |{ {\mathrm{ Pr}}[\textsf {Real}_{\mathcal {A}}(\epsilon)=1] \!- \!{\mathrm{ Pr}}[\textsf {Ideal}_{\mathcal {A},\mathcal {S}}(\epsilon)=1]}\right | \! \leq \! negl(\epsilon).}\end{equation*}
View Source

Similarly, LSCP_{vec} , ESDP and DEET protocols are proven to be secure under semi-honest (non-colluding) adversaries.

B. The Security of SMSQ
Theorem 2 (Composition Theorem [29]):
Given a protocol \mho consists of some sub-protocols, if all the sub-protocols are secure and all the intermediate results are random or pseudo-random, then we say that the protocol \mho is secure.

Next, the security of SMSQ can be guaranteed by the following theorems.

Theorem 3:
The SMSQ protocol is secure in the presence of semi-honest adversaries \mathcal {A} .

Proof:
Based on the Theorem 1, we can conclude that each sub-protocol involved in the SMSQ protocol is secure. Simultaneously, according to Theorem 2, it is easy to prove the SMSQ protocol is secure.

SECTION VI.Performance Evaluation
Here, the complexity analysis of SMSQ is given. Then, we introduce the experimental setup. To highlight our strengths, we have implemented the basic multi-party skyline query (BMSQ) protocol and the secure multi-party skyline query (SMSQ) protocol, and shown their performance by comparison with the fully secure skyline protocol (FSSP) [7], [22], which is the only approach for secure skyline query without leaking privacy (including indirect privacy).

A. Complexity Analysis of SMSQ
1) Computational Complexity:
in Algorithm 3, Line 9 requires \mathcal {O}(size(E)) decryption. Besides, for the convenience of calculation, noise data in the Privacy Matrix is not considered. If Num(0)>Num(1) , the number of non-zeros in K is size(E) . So Line 18 and 20 actually require \mathcal {O}(size(E) d) encryption and decryption. If Num(0)< Num(1) , the number of non-zeros in K is \left({\left \lfloor{ \frac {Num(1) }{Num(0)} }\right \rfloor size(E)}\right) . Hence, Line 18 and 20 require \mathcal {O}\left({\left \lfloor{ \frac {Num(1) }{Num(0)} }\right \rfloor size(E) d}\right)~\vphantom {^{\int ^{\int ^{R}}}} encryption and decryption. If Num(0)=0 , the number of non-zeros in K is (2size(E)) . Hence, Line 18 and 20 actually require \mathcal {O}(2size(E) d) encryption and decryption. For simplicity, we assume that \bf {t}_{sky} can dominate half the number of tuples in T' in each iteration, so Algorithm 3 requires \mathcal {O}(size(T')d) , where E_{PK}(E)=T' . In Algorithm 2, according to parameter \kappa , DEET requires to execute \kappa times, i.e., \mathcal {O}(size(T{'})\kappa d) . If \kappa =1 , Algorithm 3 requires nd encryption and decryption. Based the above assumption, our protocol requires \mathcal {O}\left({2nd\left({1-\frac {1}{2^{\kappa }}}\right)}\right) encryption and decryption in total. Compared to the complexity of FSSP, (i.e., \mathcal {O}(\xi (l+\left \lceil{ {\log n} }\right \rceil)n+\xi nd) [7], where \xi is number of skyline tuples as well as l is bits number), our SMSQ is much more efficient.

2) Communication Complexity:
in ESDP, the communication cost of LSCP_{vec} is \mathcal {O}(1) . LSCP_{int} also requires \mathcal {O}(1) communication. In Algorithm 3, Line 3 requires \mathcal {O}(size(E)) communication. Assume that \bf {t}_{sky} dominates half the number of tuples in T' on average in each iteration, so SMSQ requires 2n\left({1-\frac {1}{2^{\kappa }}}\right)\big) communication without considering noise tuples.

B. Experimental Setup
The BMSQ and SMSQ are implemented with Java on a PC (Intel Core I5-8400 2.8GHz, Windows 10) and ||N||=512 . In our experiments, both DSP and DAP run on the same machine, and we use threads to simulate the DSP and DAP. Moreover, to observe the efficiency that the SMSQ sacrifices for security, we use the BMSQ as a baseline, which is efficient and protects the privacy of data, queries, and query results except for indirect privacy. To ensure fairness, we implemented the unoptimized FSSP with Java on the same platform. Moreover, the query points used in our setup are randomly chosen. The reported computation time unless otherwise noted is the total computation time of the DSP and DAP.

We produced correlated (CORR), independent (INDE), and anti-correlated (ANTI) datasets similar to work [31]. Then, the real-world dataset about NBA players statistics is generated from the version of Kaggle.7 We extracted six attributes such as Minutes, Points, Rebounds, Assists, Blocks, and Steals.

C. Efficiency
1) Efficiency of LSCP_{vec} :
In order to highlight the contribution of LSCP_{vec} , we evaluated ESDP through respectively varying the parameter tuples’ number (n ) and dimensions ’ number (d ) on testing datasets. For comparison purposes, we also implemented the Secure Dominance Protocol (SDOM) [7]. Notice that the ideas of ESDP and SDOM are similar, except that the comparison protocols are different. Therefore, it is reasonable and fair to reflect the efficiency of the LSCP_{vec} by comparing the efficiency among ESDP and SDOM. We also simulated a real network environment and arranged the DSP and the DAP to run on different physical machines with the same configuration.

Fig. 6(a) illustrates the overall time cost (ms) on the testing data by varying n . We observe that ESDP more efficient than SDOM, which reflects the advantages of LSCP_{vec} . The reason is that SDOM needs communication complexity \mathcal {O}(d) to calculate the numerical relationship of corresponding dimensions about two tuples, while ESDP only requires communication complexity \mathcal {O}(1) with LSCP_{vec} . For comparing an integer, the comparison protocol in SDOM involves two cryptosystems, i.e., Paillier [20] and DGK [32], which appears very heavy for frequent comparison operations. Moreover, as n increases, the efficiency gap becomes more pronounced. Fig. 6(b) confirms similar conclusions with varying d .

Fig. 6. - The efficiency of subroutine ESDP.
Fig. 6.
The efficiency of subroutine ESDP.

Show All

2) Efficiency of Communication:
In order to reflect the real communication overhead, both DSP and DAP also ran on different physical machines. We measured the overall time, which includes computation time and communication time. Fig. 7 shows the computation and communication time of SMSQ with different n on CORR dataset. We observe that communication time is slightly more than half of the total time in this setting.

Fig. 7. - Overall time cost of different 
$n$
 (
$d=2$
, 
$\kappa = 1$
).
Fig. 7.
Overall time cost of different n (d=2 , \kappa = 1 ).

Show All

We also provide communication overhead of the SMSQ in terms of memory, which includes memory overhead of LSCP_{vec} (It costs most of its memory in communication). As Table III shows, S_{0} represents the memory occupied by CORR dataset (as a reference), and S_{1} represents the memory overhead required for communication. We observe that as n increases, its memory overhead increases. Although we use data packaging technology, its memory communication overhead is still higher than the memory occupied by CORR dataset. Also, as the dimensions are higher, the more obvious the memory overhead gap becomes. Furthermore, we provide the number of skyline points (a.k.a. “S_{2} ”) in CORR dataset. According to our observation, the computational time overhead is not related to the number of skyline points, which supports our complexity analysis. Meanwhile, the results of skyline queries should be sparse with regard to the original data.

TABLE III Communication Overhead in Terms of Memory andNumber of Skyline Points
Table III- 
Communication Overhead in Terms of Memory andNumber of Skyline Points
3) Efficiency of Computation:
By respectively varying the parameters n , d and \kappa (the number of iterations), we focus on comparing SMSQ with FSSP.

Fig. 8 illustrates the computation time overhead ({s} ) on different datasets by varying n . We believe that BMSQ is very efficient but not secure. While SMSQ is more secure than BMSQ, the efficiency of it is close to that of BMSQ. Under the identical security level, FSSP incurs more computational overhead than SMSQ. Due to the constant iteration, the data size of SMSQ continues to decrease, resulting in less time overhead for ciphertext calculations. Moreover, the computation time overhead of SMSQ rises roughly linearly for all datasets by increasing n , which is consistent with our complexity analysis. Note that the time overhead of protocols on the NBA dataset is low because the range of n is only 1000 to 2500.

Fig. 8. - The effect of 
$n$
 (
$d=2$
, 
$\kappa = 1$
).
Fig. 8.
The effect of n (d=2 , \kappa = 1 ).

Show All

Fig. 9 illustrates the computation time overhead ({s} ) on different datasets by varying d . From these figures, we observe that SMSQ is more efficiency than FSSP due to the elimination of dominated tuples during the iterative process. Moreover, the same as our complexity analysis is that the computation time overhead of SMSQ rises roughly linearly with the increase of d . We also observe that the NBA dataset has a higher computation time cost than the protocol running on the CORR dataset. This is because the NBA dataset shows weaker correlated than code generated dataset CORR.


Fig. 9.
The effect of d (n=1000 , \kappa = 1 ).

Show All

Fig. 10 illustrates the computation time overhead ({s} ) on different datasets by varying \kappa . Observe that as \kappa increases, the computation time overhead of SMSQ is infinitely close to FSSP but lower than it. Moreover, with rising \kappa , size(T') will shrink, and when \kappa is greater than a certain value, the increase in computation time cost will be moderate. Note that \kappa is unique to SMSQ, so the computation time cost of BMSQ stays the same, as does FSSP.


Fig. 10.
The effect of \kappa (n=1000 , d = 4 ).

Show All

D. Parallelism
Here, to corroborate the scalability of SMSQ and further reduce the computation time cost, we implement it with parallelism based on the optimization methods of data partitioning [7]. Based on Definition 3, we divide dataset P into \chi sub-datasets (P_{1},\ldots,P_\chi) . In general, \chi is consistent with the threads’ number. Furthermore, each P_{i} is assigned to a thread to calculate SKY_{\mathbf{q}}(P_{i}) . Upon receiving skyline results from two threads, the main thread merges them into a new dataset P_{new} that is assigned to an unoccupied thread to calculate SKY_{\mathbf{q}}(P_{new}) . When the last merged dataset is assigned to a thread to calculate, the result of this thread is SKY_{\mathbf{q}}(P) . And this parallel scheme is implemented through multi-threading.

To further corroborate the scalability of SMSQ, we also implemented a distributed version, which employs a manager-worker model. The manager node (one physical machine) plays the role of distributing data to worker nodes, while worker nodes (physical machines) compute skylines on the dataset allocated by the manager node and return them to it. Furthermore, each worker node also implements the multi-threading version above. Notice that the manager node could implement a sophisticated load balancing strategy to fully utilize the computation resources of manager nodes.

We choose the dataset ANTI and ran DSP and DAP on the same machine by varying the number of threads \chi . Fig. 11 shows that as \chi increases, the computation time cost drastically decreases with d=2 and \kappa =1 . Moreover, it indicates that when \chi increases to a certain degree, the computation time cost will no longer decrease or even increase. This is because the machine has only six threads (one is for the DAP). Another reason is that the large \chi will incur more merging overhead. Fig. 12 confirms similar conclusions with n=1000 and \kappa =1 . As for the distributed version, we tested it on the dataset ANTI with 1, 2, 4, 8, 16, 32 worker nodes. As shown in Fig. 13, SMSQ can be further promoted through implementing a fully distributed version. We observe that it is very effective in reducing computation time when scaling to large datasets. Furthermore, it shows a sub-linear time increase with respect to the number of worker nodes.

Fig. 11. - Serial vs. multi-threading (
$d=2$
, 
$\kappa =1$
).
Fig. 11.
Serial vs. multi-threading (d=2 , \kappa =1 ).

Show All


Fig. 12.
Serial vs. multi-threading (n=1000 , \kappa =1 ).

Show All

Fig. 13. - Distributed parallel implementation.
Fig. 13.
Distributed parallel implementation.

Show All

SECTION VII.Related Work
Börzsönyi et al. [31] first presented the skyline query with an algorithm known as block nested loop. The authors of [33] proposed an improved method based on bit operation by encoding the original data into a bitmap. Kossmann et al. [34] demonstrated using the nearest neighbor (NN) for skyline computation, which returned the first results immediately and produced more and more results continuously. Papadias et al. [35] analyzed the deficiencies of the NN method in terms of I/O and storage, and proposed the BBS algorithm. The latter has good efficiency and scalability in terms of space, input and output. Approaches for skyline on data steams [36], uncertain skyline [37], skyline in the distributed scenario [38] and group-based skyline [39], [40], etc., have also been studied, although the privacy is generally understudied.

In the distributed scenario, a data user wishes to obtain the skyline result from different cloud servers. Liu et al. [41] proposed the privacy-preserving skyline computation (EPSC) framework. However, the performance of the 0-encoding and 1-encoding method to obtain two private vector dominance relationship is inversely related to the binary bit-length of the attribute value. Liu et al. [42] presented a privacy-preserving skyline computation methods over multiple encrypted databases (i.e., PUSC). However, it is not sufficiently efficient, since it incurs significant time for skyline query processing. Hua et al. demonstrated an online medical diagnosis method, CINEMA [9], for secure skyline computation. In a later work, Hua et al. [8] proposed a medical primary diagnosis framework (CAMPS), which uses the Paillier additive homomorphic cryptosystem. As previously discussed, the Paillier cryptosystem cannot support secure multi-party skyline queries. Zaman et al. [43] presented a secure distributed computation on MapReduce to process skyline queries. However, due to the significant communication time, this approach cannot bring about greater efficiency of the skyline computation. Qaosar at al. [44] proposed another approach for skyline queries based on the secure multi-party computation scenario. However, the approach does not focus on query privacy, and the query tuple is exposed to all participating parties.

In the centralized scenario, a data user wishes to obtain the skyline result from a single cloud that may be composed of multiple servers, but for the user as a whole. Bothe et al. [45], [46] presented approaches to support the skyline query over the encrypted database, but no formal security guarantee was provided. Also, privacy-preserving skyline queries processing is another area that is relatively understudied. In [47], since the cloud server is not trustworthy enough, the approaches on how to verify any skyline query about the location are demonstrated. Liu et al. [7] focused on the secure skyline problem and demonstrated a secure skyline query protocol (FSSP) on the encrypted data. We observe that their approach comprises a secure dominance protocol for expensive calculation and complex communication. In addition, each skyline point is calculated by traversing the entire dataset. Therefore, these schemes are either not efficient enough or not concerned about the secure multi-party skyline query on encrypted data.

SECTION VIII.Conclusion
In this paper, we thoroughly study the secure multi-party skyline query processing on homomorphic ciphertext data. Subsequently, we proposed a secure multi-party skyline query protocol (SMSQ) with two non-colluding cloud servers under the semi-honest model. It can guarantee semantic security in that the cloud is able to gain none of the privacy of the outsourced data, queries, skyline results, and indirect information. Most importantly though, to improve the performance of the protocol, we proposed a newly designed method named “blind-reading” to securely and efficiently obtain the skyline point. Then, we presented the Privacy Matrix method, which can minimize the time cost of computation in the iteration. We also devised the lightweight secure vector comparison protocol (LSCP_{vec} ) (secure integer comparison (LSCP_{int} )) to boost efficiency of comparison. Finally, we implemented our protocols, then evaluated the security and performance of them to demonstrate utility.