As an immutable append-only distributed ledger, blockchain allows a group of participants to reach a consensus in an untrustworthy ecosystem. Immutability is a blockchain feature that persists data forever, but it is no longer legal in reality. Blockchain has unchangeable improper contents that violate laws. Moreover, data regulation toward “the right to be forgotten” requires blockchain must be modifiable. To address this problem, redactable blockchain has been introduced to relax immutability in a controlled way. However, once a participant is authorized, she/he can rewrite any content and no penalty for the malicious behavior that hinders the wide deployment of redactable blockchain in practice. In this paper, we introduce a new notion, dubbed k-time modifiable and epoch-based redactable blockchain (KERB) with a monetary penalty to control rewriting privileges and penalize malicious behaviors. Our solution is built up from simple building blocks: digital signatures and chameleon hashes. We give a formal definition and security models of KERB, and present a generic construction along with formal proofs. The extensive comparison and experimental analysis illustrate that our solution enjoys superior functionalities and performances than the state-of-the-art solutions.
SECTION I.Introduction
Since Bitcoin [1] was introduced by a pseudonymous author Satoshi Nakamoto, blockchain has attracted extensive attention. With the continuous development of blockchain technology, it has been widely used in digital currency [2]–[3][4][5], supply chain [6], [7], insurance [8], [9], energy [10], [11], and many other application domains [12], [13]. In a nutshell, blockchain is an immutable append-only ledger whose state is agreed upon via a decentralized consensus protocol run among peer nodes. Usually, the structure of a blockchain relies on a hash chain that links multiple blocks together. Each block contains multiple transactions that record monetary information or any other auxiliary information. Any transaction modification influences the corresponding block and all the subsequent blocks. If any transaction in the block changes, it will be inconsistent with the original block and will not be recognized by the next block. Since most blockchain systems allow forks, to preserve immutability they rely on a heuristics, where a block is confirmed by a number of subsequent blocks, such as 6 confirmations (about 1 hour) for Bitcoin and 30 confirmations (about 6 minutes) for Ethereum [14]. Unfortunately, the immutability property becomes an obstacle that limits the development of blockchain due to a variety of issues. In the following, we elaborate on two of the most critical reasons.

Nowadays, the storage of blockchain has been abused. For example, many improper contents (e.g., child pornography and material that infringes on intellectual rights) are in Bitcoin. The chain’s participants may help the spread of improper contents unintentionally [15]–[16][17] since they may not have the qualifications and capabilities to identify illegal or improper information. Therefore, the chain’s participants may be unwilling to participate and download the chain because of the fear of being prosecuted for possession of illegal or improper content.

Blockchain immutability violates “the right to be forgotten” data regulation, which is the right to remove personal private information from Internet searches and other directories under several circumstances. This data regulation has been discussed and put into practice in both the European Union and Argentina since 2006 [18], [19]. For example, a “right to be forgotten” case has stalled after the European Court of Justice found that a Dutch man’s identity information was uploaded onto Bitcoin [20]. Moreover, the General Data Protection Regulation (GDPR) by the European Union [21] points out that anyone has the right to request any organization to delete personal information. The privacy violation will lead to hefty fines: 4% of a company’s annual revenue or €20 million, whichever is larger.

To address the above issues, several specific blockchain structures [22], [23] and redactable blockchain [24]–[25][26] were introduced. They aim to relax the blockchain immutability without affecting subsequent blocks in a controlled way.

A. Related Work
Puddu et al. [22] introduced a novel structure called μ chain that is a voting-like approach via dynamic proactive secret sharing dealing with secret shared keys in permissionless blockchain. However, this approach is impractical due to large overheads and multiple interactions among the chain’s participants. Florian et al. [23] introduced a novel data erasing approach that allows the chain participants to eliminate arbitrary content in each transaction locally, but the original transaction is immutable and full nodes keep all the original blocks.

To rewrite block data globally, the concept of redactable blockchain was first introduced by Ateniese et al. [24]. The proposed redactable blockchain is in a permissioned setting that requires a central authority (CA) to grant rewriting privileges via secret keys to a particular party, called modifier. It offers a block-level rewriting controlled at a coarse-grained level via an enhanced collision-resistance chameleon hash (CH) [27] and public key infrastructure (PKI) technologies. To manage rewriting privileges flexibly, Derler et al. [25] proposed a redactable blockchain in a permissioned setting with transaction-level rewriting controlled at a fine-grained level via chameleon hashes with ephemeral trapdoors (CHET) [28] and attribute-based encryption (ABE) [29].

To eliminate the trusted CA, Deuber et al. [26] proposed a block-level redactable blockchain in a permissionless setting via consensus-based voting. It allows chain participants to make rewriting proposals into a candidate block pool, and enables the new block finder to accept rewriting proposals by voting. The original block is replaced if the rewriting proposal has enough votes. However, it has several security threats. Dishonest and rational miners may not check the candidate block pool for more opportunities to be a new block finder. Moreover, every chain participant is allowed to make rewriting proposals, which is vulnerable to denial-of-service attacks if the cost of applying for an amendment is not high enough.

From the above, redactable blockchain with a transaction-level rewriting in a permissioned setting could be a state-of-the-art solution and we will concrete on this concept in this paper. We list several issues in terms of practicality and security in current solutions, as shown in Table I, which are becoming a development bottleneck of redactable blockchain. In the following, we focus on practicality and security among current redactable blockchains [24]–[25][26]. The details of the notations in Table I, and the importance of them in redactable blockchain will be explained in Section II.A.

TABLE I Comparison Among Current Redactable Blockchain Solutions and Ours
Table I- 
Comparison Among Current Redactable Blockchain Solutions and Ours
Efficiency is an important criterion for the practicality of redactable blockchain. In permissioned redactable blockchain solutions [24], [25], CA must maintain secret channels for each authorized user to issue secret keys for granting rewriting privileges in a controlled way. In a nutshell, chain participants utilize chameleon hashes to generate a hash result with a trapdoor, where the trapdoor is used for finding a hash collision without modifying the hash result. To control rewriting privileges, the trapdoor is encrypted that can be revealed by modifiers only. Although [24] applied PKI that has modest costs, [25] employed ABE incurs large overheads such that the space complexity of each ciphertext is linear to the associated policy and the computational cost of revealing the trapdoor is linear to the attributes specified in each secret key. Fortunately, the permissionless redactable blockchain [26] does not require encryption mechanisms. However, dishonest and rational miners may pursue a higher efficiency by skipping or random voting without verifying the candidate block is reasonable or not to gain more mining opportunities. Hence, it is desirable to design an efficient redactable blockchain under a standard security model with dishonest, rational and honest chain participants.

Redactable blockchain relaxes the immutability of the blockchain. The privilege of rewriting must be controlled, especially in the permissioned redactable blockchain. Current solutions [24], [25] only concrete on what blocks or transactions can be redacted by modifiers rather than the strategy to prevent possible malicious behaviors. In reality, the modification privilege can be compromised due to a variety of reasons, such as no-paid leave, retirement, and even selling the secret key to gain monetary profits. Besides, the approach to penalizing malicious behaviors is missing in current solutions. Regardless of functionality improvement requirements, the attribute-based redactable blockchain solution [25] faces collusion attacks. The collusion of chain participants and unauthorized modifiers should not be able to launch transaction rewriting since they do not have rewriting privileges from CA. However, in [25], the collusion of them can be launched to process transaction rewriting, where unauthorized modifiers are the modifiers who have an attribute-based secret key but the associated attributes are not satisfied with the policy specified in transactions. The details of this attack will be explained in Section II.B.

B. Contributions
To limit rewriting privileges of modifiers and penalize malicious behaviors, we introduce a k -time modifiable and epoch-based redactable blockchain (KERB) with monetary penalty [30] against collusion attacks. Specifically, this paper makes the following contributions.

K-time modification. To mitigate malicious behaviors, the rewriting privilege is limited at most k times defined by CA, where the secret signing key can be extracted when more than k -time transaction rewriting operations happen. The extracted secret key enables CA to process monetary penalty.

Epoch-based redaction. To penalize malicious behaviors, each modifier is required to make a time-locked deposit in the chain. This deposit can be spent before the expiration date t with the signatures signed by CA and the modifier. After the expiration date t , the deposit can be drawn by the modifier individually. The modifier has rewriting privileges before the expiration date t . During the authorization period, CA can draw the deposit by using his/her secret key and the extracted secret key of the modifier if any malicious behavior happens. Hence, the modifier has no intention to be malicious if the penalty is severe.

Strong security model. We refine the security models introduced in [24], [25] by allowing the collusion between transaction owners and modifiers (without specifying attributes to satisfy the policy associated with redactable transaction). In contrast, the previous solution in [25] cannot prevent such a collusion attack. Besides, our security model considers a variety of attacks in the real world. Please refer to Section III.C threat model and Section III.IV security model for more details.

We conduct extensive experiments to demonstrate that our solution has superior performances than the previous solutions [24], [25] in terms of the following four aspects.

We apply more generic chameleon hashes, where it only requires the basic adaption property rather than enhanced collision-resistance [24], and even CHET [25].

Our solution has no trapdoor correctness checking requirement, while the previous solutions [24], [25] may require trapdoor correctness checking since malicious chain participants may seal the incorrect trapdoor.

We apply digital signatures to endorse rewriting privileges rather than encryption mechanisms for optimal performance. Digital signatures have no costly key encapsulation mechanism. Moreover, no expensive secret channel is needed to distribute secret keys in the blockchain environment.

Our solution is suitable for a large-scale setting. The increment of attributes and redaction times has far less influence on the cost of our solution, as shown in Section V.

C. Outline
Section II formulates the problems in current redactable blockchain solutions and gives a technical overview. Section III introduces preliminaries of our proposed redactable blockchain, including digital signatures, chameleon hashes, and collision-resistant hashes. Section IV presents the details of our KERB system, including formal definition, system model, threat model, security model, and generic construction with security proofs. Section V gives the performance analysis. The paper is summarized in Section VI.

SECTION II.Problem Formulation & Technical Overview
In this section, we formulate the problems in current redactable blockchain solutions in terms of functionality challenges and security challenges. After that, we give a technical sketch of our solution to explain how our solution solves these challenges.

A. Functionality Challenges
Table I illustrates several functionalities in redactable blockchain. Here, we introduce the importance of these functionalities and why some of them are challenges in current solutions.

K -time modification and epoch-based modification are two novel properties we introduced. K -time modification is helpful to reduce the loss when key leakage or faulty operation happens. Epoch-based modification limits the validation period of rewriting privileges. The combination of these two properties is used to limit modifiers and penalize their malicious behaviors. Although k -time modification can be realized via secret sharing schemes, epoch-based modification is quite challenging in current redactable blockchains. One possible solution is to use revocable ABE (RABE) [31], [32] to replace the ABE component in [25]. However, this trivial solution cannot be applied in the blockchain environment because of the following issues.

RABE requires a semi-trusted third party (e.g., cloud) to update the ciphertext in each epoch so that the revoked user cannot reveal the ciphertext which the revoked user can access before they are revoked. In a blockchain environment, it is infeasible to find a semi-trusted third party to process ciphertext updates.

The auxiliary information (e.g., updated ciphertext) is changed in each epoch. It is costly to synchronize them in all the distributed ledgers each time.

The content in the blockchain is public. The revoked users are easy to find historical information that contains the ciphertexts generated before they are revoked. These ciphertexts can be decrypted by the revoked users.

Hence, RABE is a possible solution in a cloud-based application but the blockchain environment. Accountability is to locate malicious modifier. Although [25] applies ABE to improve the expression of the privilege control, it is hard to identify malicious modifier since a single attribute could be shared with multiple users. Transparency is to identify the transaction is redacted or not. Without this property, several redactable blockchain solutions [24], [25] are vulnerable from framing attacks (e.g., the transaction owner is framed to upload illegal contents). The malicious chain participants can deny the transaction by declaring the transaction is redacted by the modifier and vice versa.
B. Security Challenges
The rewriting privilege in the seminal work [24] is at a coarse-grained level via PKI and CH. To enrich expression, [25] provides a solution with rewriting privileges at a fine-grained level via ABE and CHET. CHET includes two trapdoors: a long-term trapdoor is specified by CA, and an ephemeral trapdoor is generated by the transaction owner. Anyone who has these two trapdoors can rewrite the redactable transaction. Rewriting privileges of modifiers are from two secret keys: a long-term trapdoor of CHET, and a secret key of ABE. The secret key of ABE is used to reveal the ephemeral trapdoor sealed by the transaction owner. Hence, it has a security threat, where modifiers have the long-term trapdoor and the transaction owner has the ephemeral trapdoor. The collusion of unauthorized modifiers (who have a long-term trapdoor but an invalid ABE secret key) and transaction owners to launch transaction rewriting to be possible, and it should be resisted in redactable blockchain. Therefore, the state-of-the-art permissioned solution [25] suffers from such a collusion attack.

C. Technical Overview
To eliminate the costly encryption mechanism, we apply digital signatures to release the trapdoor of chameleon hashes. However, it is insecure to directly release the trapdoor of chameleon hashes. To preserve system security, we require that a valid redactable transaction must have a valid hash value, a valid signature signed by a modifier, and a credential of this modifier issued by CA. Hence, leasing the trapdoor of chameleon hashes allows anyone to operate transaction rewriting, but only the rewriting from the authorized modifier can pass the verification.

Inspired by double-authentication-preventing signatures [33]–[34][35] and Schnorr signature [36], we apply the secret sharing scheme and digital signatures to realize k -time modification. Double-authentication-preventing signatures are a variety of digital signatures equipped with a self-enforcement mechanism. Messages consist of an address and a payload component, and a signer is penalized if two messages with the same addresses but different payloads are signed. We use Schnorr signature rather than costly zero-knowledge proof systems to improve efficiency. Moreover, to reduce the computational cost, we use 1-degree polynomial to realize secret sharing. Specifically, we apply 1-degree polynomial with k instantiations rather than k -degree polynomial to prevent more than k times transaction rewriting.

Inspired by revocable proxy signatures [37], we apply digital signatures rather than encryption mechanisms to privilege delegation for epoch-based modification. In proxy signatures, the original signer delegates signing privilege to proxy signers. In our solution, we follow this concept, CA delegates rewriting privilege to modifiers.

The attribute-based rewriting policy is an important property introduced by Derler et al. [25]. Each modifier is tagged by a set of attributes and there are policies that express boolean formulas over attributes. The access decision is made by evaluating the respective access policies on the set of attributes associated with a modifier. For instance, the modifier associated attributes “{Admin,Finance} ” can rewrite the transaction protected by a policy “Admin AND Finance ” but cannot rewrite the transaction specified by a policy “Admin AND Healthcare ”. Besides, the attribute set can also directly describe user’s identities and the boolean formula is restricted to the OR gate only. For example, each modifier has a unique identifier such as {user1,user2,…} , transaction protected by a policy “user1 OR user2 ” can be rewritten by the modifiers with identifier either user1 or user2 . To offer the attribute-based rewriting policy, in our solution, CA issues the rewriting privileges by signing the attribute set of the modifier (and the public key of this modifier). If a transaction associated access policy complies with the attribute set, the modifier can rewrite this transaction.

The realizing of other properties (e.g., accountability and transparency) is based on digital signatures. We suggest readers to our generic construction in Section IV.E for more details.

SECTION III.Preliminaries
A. Notation
Let N denote the set of all natural numbers. For n∈N , we define [n]:={1,…,n} . If A is a probabilistic algorithm, then ‘‘y←A(x;r)′′ denotes that A computes y as output by taking x as input and using r as randomness, and we just write ‘‘y←A(x)′′ if we do not need to make the randomness used by A explicit. Let the Greek character λ denote a security parameter. A function ϵ(λ):N→[0,1] is said to be negligible if for all positive polynomials p(λ) and all sufficiently large λ∈N , we have ϵ(λ)<1/p(λ) . We use S⊨A to denote that the attribute set S satisfies the access structure A , and S⊭A to represent that the attribute set S does not satisfy the access structure A .

B. Digital Signatures
Definition 1 (Digital Signatures):
A digital signature DS with a message space M consists of four algorithms {Setup,KeyGen,Sign,Verify }:

DS.Setup(1λ)→pp : On input a security parameter λ∈N , and output a public parameter pp , where pp is implicit input to all other algorithms.

DS.KeyGen(pp)→(sk,pk) : On input a public parameter pp , and output a secret key sk and a public key pk .

DS.Sign(sk,m)→σ : On input a secret key sk and a message m∈M , and output a signature σ .

DS.Verify(pk,σ,m)→b : On input a public key pk , a signature σ and a message m∈M , and output a decision bit b∈{0,1} .

Definition 2 (Correctness):
A digital signature DS is called correct, if for all security parameters λ∈N , for all pp←DS.Setup(1λ) , for all (sk,pk)←DS.KeyGen(pp) , for all m∈M , DS.Verify(pk,DS.Sign(sk,m),m)=1 is always true.

A secure digital signature should be unforgeable, which requires that any adversary A cannot (except with negligible probability) come up with a signature for a message m∗ for which the adversary never see before. In the following, we give the security model called existential unforgeability under a chosen message attack (EUF−CMA security) to specify the security requirement for the digital signature in multi-user settings.

Definition 3 (EUF−CMA Security):
The EUF−CMA security definition of a digital signature DS is based on the following experiment.


We say that a digital signature scheme DS is EUF−CMA secure, if for any probabilistic polynomial-time adversary A , the following advantage is negligible:
 AdvEUF−CMAA,DS(1λ)=∣∣Pr[ ExpEUF−CMAA,DS(1λ)=1]∣∣.
View Source

C. Chameleon Hashes
Definition 4 (Chameleon Hashes):
A chameleon hash CH with a message space M consists of five algorithms {Setup,KeyGen,Hash,Verify,Adapt }:

CH.Setup(1λ)→pp : On input a security parameter λ∈N , and output a public parameter pp , where pp is implicit input to all other algorithms.

CH.KeyGen(pp)→(sk,pk) : On input a public parameter pp , and output a secret key sk and a public key pk .

CH.Hash(pk,m;r)→h : On input a public key pk , a message m∈M and a randomness r , and output a hash value h .

CH.Verify(pk,m,h,r)→b : On input a public key pk , a message m∈M , a hash value h and a randomness r , and output a decision bit b∈{0,1} .

CH.Adapt(sk,m,h,r,m′)→r′ : On input a secret key sk , a message m∈M , a hash value h , a randomness r and a message m′∈M , and output a randomness r′ .

Definition 5 (Correctness):
A chameleon hash CH is called correct, if for all security parameter λ∈N , for all pp←CH.Setup(1λ) , for all (sk,pk)←CH.KeyGen(pp) , for all m′∈M , we have for all r′←CH.Adapt(sk,m,h,r,m′) , that CH.Verify(pk,m,h,r)=CH.Verify(pk,m′,h,r′)=1 is always true.

The security of our proposed solution depends on the security of the underlying digital signature rather than chameleon hashes. Specifically, transactions can be redacted by anyone who has a value token key and the security of this token key can be reduced to the security of the underlying digital signature. The chameleon hash provides the modifiability for preserving the consistency of the Merkle tree after redaction. Therefore, we omit the security definition of chameleon hashes.

D. Collision-Resistant Hashes
Definition 6 (Collision-Resistant Hashes):
A collision-resistant hash H satisfies the property: For all probabilistic polynomial-time adversary A , the following probability is negligible: Pr[(m0,m1)←A(1λ,h):m0≠m1∧h(m0)=h(m1)] .

SECTION IV.K -Time Modifiable and Epoch-Based Redactable Blockchain
A. Formal Definition
Definition 7 (KERB):
A k -time modifiable and epoch-based redactable blockchain KERB involves four types of parties: CA, users, modifiers, and miners. It consists of the following eight algorithms:

KERB.Setup(1λ)→(pp,msk,mpk) : The probabilistic setup algorithm is run by CA. It takes a security parameter λ∈N as input, and outputs a public parameter pp , a master secret key msk and a master public key mpk , where pp and mpk are implicit input to all other algorithms.

KERB.Setupm(pp,n)→(skm,pkm) : The probabilistic modifier setup algorithm is run by each modifier. It takes a public parameter pp and a number n∈N as input, and outputs a secret key skm and a public key pkm , where n is the maximum number of redaction operations associated with the key pair (skm,pkm) .

KERB.Setupu(pp)→(sku,pku) : The probabilistic user setup algorithm is run by each user. It takes a public parameter pp as input, and outputs a secret key sku and a public key pku .

KERB.TKGen(msk,pkm,k,S,t)→tk : The probabilistic token key generation algorithm is run by CA. It takes a master secret key msk , a public key pkm , a number k∈N , a set of attributes S and a timestamp t , and outputs a token key tk , where k is maximum number of redaction operations for the public key pkm permitted by CA and t is the expiration date of the modification privilege.

KERB.Hash(mpk,sku,(ID,txID),A)→(h,r,σID) : The probabilistic hash algorithm is run by each user. It takes a master public key mpk , a secret key sku , a message including a transaction identity ID and its content txID , and an access structure A as input, and outputs a hash value h , a randomness r and a signature σID .

KERB.Adapt(mpk,skm,(ID,txID),h,r,σID,(ID,tx′ID)) →(r′,σ′ID) : The probabilistic adaption algorithm is run by each modifier. It takes a master public key mpk , a secret key skm , a message including a transaction identity ID and its content txID , a hash value h , a randomness r , a signature σID and a message including a transaction identity ID and its content tx′ID as input, and outputs a randomness r′ and a signature σ′ID .

KERB.Verify(mpk,pk,(ID,txID),h,r,σID,t′)→b : The deterministic verification algorithm is run by miners. It takes a master public key mpk , a public key pk , a message including a transaction identity ID and its content txID , a hash value h , a randomness r , a signature σID and a current timestamp t′ as input, and outputs a decision bit b∈{0,1} indicating whether the transaction (ID,txID) is valid or not, where the input public key pk is either the public key of the user pku (if the message has not been redacted) or the public key of the user and modifier implicitly associated with the token key (pku,pkm,tk) (if the message has been redacted).

KERB.Ex(pkm,(i,ID,r,A),(i′,ID′,r′,A′),σID,σID′) → sk′m : The deterministic extraction algorithm is run by any party. It takes a public key pkm , a message including an index i , a transaction identity ID , a randomness r and an access structure A , a message including an index i′ , a transaction identity ID′ , a randomness r′ and an access structure A′ , and two signatures (σID,σID′) as input. It outputs a secret key sk′m , where sk′m is the secret signing key of the modifier.

Definition 8 (Colliding Redaction):
We say that a signature σID on the message (i,ID,r,A) and a signature σID′ on the message (i′,ID′,r′,A′) are a colliding redaction if i=i′ , but (ID,r,A)≠(ID′,r′,A′) .

B. System Model
Our KEBR system consists of CA, users, modifiers, and miners, as shown in Fig. 1. These components are explained as below.

CA represents a blockchain administrator who has three responsibilities:

CA needs to initialize the KEBR system and broadcasts system parameters to other parties (see ①).

After receiving a key issuing request from a modifier (from ③), CA checks the validation of this modifier’s time-locked deposit (see ②) and issues k -time rewriting privileges, where the number of redaction operations k and the expiration date of the issued rewriting privileges depend on the deposit (see ①).

If any modifier violates the k -time rewriting privileges, CA can reveal the secret key of that modifier and draw the time-locked deposit before the expiration date.

Users are chain participants who are allowed to make two types of transactions (see ⑤). One is immutable transactions that cannot be rewritten. Another is redactable transactions that allow the specified modifier to rewrite.

Modifiers are chain participants who make the time-locked deposit (see ②) and have rewriting privileges issued by CA (see ④). After the expiration date, modifiers can draw the time-locked deposit. However, if any misbehavior is found, modifiers will lose the deposit.

Miners are chain participants who verify and add transactions (see ②, ⑤ and ⑥) to global public ledger of past transactions. In the ledgers, blocks are secured by miners and are connected to each other forming a chain.


Fig. 1.
System model.

Show All

The workflow of KEBR includes four phases: system initialization, transaction making, transaction verification, and malicious punishment.

1) System Initialization:
Fig. 2 shows the KEBR system initialization. This phase can be further classified into system setup (see ①), modifier setup (see ②-④) and user setup.

System setup: CA generates a public parameter pp , a master secret key msk and a master public key mpk by running the setup algorithm KERB.Setup(1λ) . Then, CA broadcasts the public parameter pp and the master public key mpk to other parties (see ①).

Modifier setup: After receiving the public parameter pp and the master public key mpk from CA, each modifier runs the modifier setup algorithm KERB.Setupm(pp,n) to generate a secret key skm and a public key pkm . Then, the modifier makes a time-locked deposit in which the deposit can be spent with the signatures signed by CA and the modifier before the expiration date t (see ②). Next, the modifier sends the public key pkm to CA (see ③). CA specifies the number of rewriting operations k and the attribute set S of the modifier, and runs the token key generation algorithm KERB.TKGen(msk,pkm,k,S,t) to generate a token key tk , then sends tk to the modifier (see ④). After the expiration date, modifiers can renew their rewriting privileges by making a time-locked deposit with new expiration date. Hence, modification privileges are issued periodically.

User setup: After receiving the public parameter pp and the master public key mpk from CA, each user runs the user setup algorithm KERB.Setupu(pp) to generate a secret key sku and a public key pku .


Fig. 2.
System initialization in KEBR.

Show All

2) Transaction Making:
Fig. 3 shows the transaction making in the KEBR system. As we mentioned before, each user is allowed to make two types of transactions and the redactable transaction can be rewritten by the specified modifier. Hence, this phase can be further classified into immutable transaction making, redactable transaction making (see ⑤) and transaction rewriting (see ⑥).

Immutable transaction making: Each user is allowed to make the immutable transaction as in the traditional immutable blockchain. The user uses her/his secret key sku with traditional hash function to generate a transaction tx and its signature σtx . Then, the user propagates the public key pkm , the transaction tx and the signature σtx to the blockchain ecosystem.

Redactable transaction making: Each user is allowed to make the redactable transaction by running the hash algorithm KERB.Hash(mpk,sku,(ID,txID),A) with a specified access structure A to generate a hash value h , a randomness r and a signature σID . The user propagates the public key pkm , the transaction (ID,txID) and the signature (h,r,σID) to the blockchain ecosystem (See ⑤).

Transaction rewriting: The modifier with the attribute set S with S⊨A is allowed to make transaction rewriting. The modifier runs the adaption algorithm KERB.Adapt(mpk,skm,(ID,txID),h,r,σID,(ID,tx′ID)) to generate a randomness r′ and a signature σ′ID . The modifier then broadcasts the transaction with the public key pk=(pku,pkm,tk) , the transaction (ID,tx′ID) and the signature (h,r′,σ′ID) to blockchain ecosystem (See ⑥).

Fig. 3. - Transaction making in KEBR.
Fig. 3.
Transaction making in KEBR.

Show All

3) Transaction Verification:
Fig. 4 shows the transaction verifications in the KEBR system. As we mentioned before, two types of transaction are propagated in the blockchain ecosystem. Hence, there are two types of verification we consider in this phase: immutable transaction verification and redactable transaction verification. Note that the time-locked deposit is an immutable transaction, where the deposit can be drawn by using the user signing key sk′m (defined in the user secret key skm ) and the signing key of CA skca (defined in the master public key mpk ).

Immutable transaction verification: After receiving an immutable transaction associated a user public key pku , a transaction tx and a signature σtx , the miner verifies this transaction by running the immutable blockchain verification process. If the transaction is valid, the miner will append this transaction into a block; otherwise, the miner rejects this transaction.

Redactable transaction verification: After receiving a redactable transaction associated a public key pk=(pku , pkm,tk ), a transaction (ID,txID) and a signature (h,r,σID) , the miner verifies this transaction by running the verification algorithm KERB.Verify(mpk,pk,(ID,txID),h,r,σID,t′) , where t′ is a current timestamp. If the transaction is valid, the miner will rewrite the local copy of this transaction; otherwise, the miner rejects this transaction.

Fig. 4. - Transaction verification in KEBR.
Fig. 4.
Transaction verification in KEBR.

Show All

4) Malicious Punishment:
Fig. 5 shows the malicious punishment in the KEBR system. This phase consists of two sub-phases: signing key extraction and monetary penalty.

Signing key extraction: For simplicity, we assume that a miner detects a malicious behavior of a modifier (e.g., the colliding redactions are found). The miner runs the extraction algorithm KERB.Ex(pkm,(i,ID,r,A),(i′,ID′,r′,A′) , σID,σID′ ) to obtain the secret signing key sk′m . The miner sends the secret signing key sk′m and the miner’s public key pkminer to CA.

Monetary Penalty: After receiving a secret signing key sk′m and a miner’s public key pkminer , CA generates a transaction to draw the time-locked deposit and sends the reward to the miner. Note that CA has the secret key skca and the secret signing key sk′m from the miner, who can draw the time-locked deposit before the expiration date. Hence, the malicious modifier losses the time-locked deposit as the monetary penalty.


Fig. 5.
Malicious punishment in KEBR.

Show All

C. Threat Model
We assume CA is fully trusted. Miners are majority trusted as the normal blockchain ecosystem. Users and modifiers are untrusted and they can get together to launch collusion attacks. They may try to generate valid transactions without valid secret keys, rewrite unauthorized transactions, operate more than k -time transaction rewriting operations without any punishment, and frame other modifiers with more than k -time transaction rewriting operations.

The previous threat model [25] has not taken the following collusion attack into consideration. The malicious modifier can gain the ephemeral trapdoor from users to operate transaction rewriting without a valid secret key, such that the attribute set does not satisfy the access structure S⊭A . In our solution, the security is reduced to the underlying digital signatures, which means that any transaction rewriting will be invalid without the valid token key from CA. In other words, our system is secure if the secret signing key of CA remains secret. To simplicity, we present two security models to capture all the possible attacks in our threat model as shown in the next subsection.

D. Security Model
The purpose of our proposed system is to use digital signatures to prevent any unauthorized transaction rewriting. Specifically, the trapdoor of chameleon hashes is public and the security of our system relies on the security of the underlying digital signatures and collision-resistant hashes. Hence, we need not consider the security notations about chameleon hashes, such as indistinguishability, outsider collision-resistance, and insider collision-resistance. Therefore, we give the formal definition of the EUF−CMA security for our proposed scheme.

Definition 9 (EUF−CMA Security):
Let O denote a set of oracles: a modifier setup oracle OSetupm(⋅,⋅) , a modifier corrupt oracle OCorruptm(⋅) , a user setup oracle OSetupu(⋅) , a user corrupt oracle OCorruptu(⋅) , a token key generation oracle OTKGen(⋅,⋅,⋅,⋅) , a hash oracle OHash(⋅,⋅,⋅) , and an adaption oracle OAdapt(⋅,⋅,⋅,⋅,⋅,⋅) . The EUF−CMA security definition of a KERB is based on the experiment in Fig. 6. We say that a KERB is EUF−CMA secure, if for any probabilistic polynomial-time adversary A , the following advantage is negligible:  AdvEUF−CMA(1λ)=Pr[ ExpEUF−CMAA,KERB(1λ)=1] .

Fig. 6. - Experiment of 
$\sf{EUF-CMA}$
 security in 
$\mathcal {KERB}$
.
Fig. 6.
Experiment of EUF−CMA security in KERB .

Show All

An interesting property of the KERB is k -time modification. It requires that whenever one obtains the messages about colliding redaction, as shown in Definition IV-A, one should be able to extract the secret signing key using the extraction algorithm. Hence, we give the security model called weak key extraction (w−KE security). The adversary wins the game if the extraction algorithm cannot extract the secret signing key from the colliding messages. Compared to the EUF−CMA security model, the w−KE security model allows A to corrupt all users and modifiers. Therefore, several oracles including modifier setup, modifier corrupt, user setup, and user corrupt oracles are not requested in the w−KE security model.

Definition 10 (w−KE Security):
The w−KE security definition of a KERB is based on the experiment in Fig. 7. We say that a KERB is w−KE security, if for any probabilistic polynomial-time adversary A , the following advantage is negligible:  Advw−KEA,KERB(1λ)=Pr[ Expw−KEA,KERB(1λ)=1] .

Fig. 7. - Experiment of 
$\sf{w-KE}$
 security in 
$\mathcal {KERB}$
.
Fig. 7.
Experiment of w−KE security in KERB .

Show All

Our w−KE security model only extracts the secret signing key rather than the whole secret key since monetary penalty only requires the secret signing key in the blockchain setting. Specifically, the leakage of the secret signing key represents the loss of the time-locked deposit. The strong security notation for extracting the whole secret key is an interesting work, but it may influence performance. Hence, w−KE security is enough for the efficient KERB system.

E. Proposed Scheme
Let DS={Setup,KeyGen,Sign,Verify} be an EUF−CMA secure digital signature, and CH={Setup,KeyGen , Hash,Adapt} be any chameleon hash. Following is the construction of KERB :

KERB.Setup(1λ)→(pp,msk,mpk) : The setup algorithm initializes public parameters of a digital signature ppDS←DS.Setup(1λ) , a chameleon hash ppCH←CH.Setup(1λ) , a key-pair (ska,pka)←DS.KeyGen(ppDS) for a digital signature and a key-pair (skh,pkh)←CH.KeyGen(ppCH) for a chameleon hash. Then, it picks a collision-resistant hash function H:{0,1}∗→Zp . The algorithm returns a public parameter pp=(ppDS,ppCH) , a master secret key msk=ska and a master public key mpk=(skh,pka,pkh,H) .

KERB.Setupm(pp,n)→(skm,pkm) : The modifier setup algorithm initializes a signature key-pair (sk′m , pk′m)←DS.KeyGen(ppDS) . It then randomly chooses terms α,ρ1,ρ2,…,ρn,r1,r2,…,rn∈Zp , computes c0=gα and for each i∈[n]:ci=(c1,i,c2,i)=(gri,cri0gρi) . The algorithm returns a secret key skm=(sk′m,{ri,ρi}i∈[n]) and a public key pkm=(pk′m,c0,{ci}i∈[n]) .

KERB.Setupu(pp)→(sku,pku) : The user setup algorithm initializes a signature key-pair (sku,pku)←DS.KeyGen(ppDS) . The algorithm returns a secret key sku and a public key pku .

KERB.TKGen(msk,pkm,k,S,t)→tk : Parse pkm=(pk′m , c0,{ci}i∈[n] ), where n is the size of ci . The token key generation algorithm returns a failure symbol ⊥ if no time-locked deposit that can only be spent before time t if valid signatures signed by ska and sk′m ; otherwise, it sets pkm=(pk′m,c0,{ci}i∈[k]) if n≥k . The algorithm returns a token key tk←DS.Sign(ska,(pkm,S,t)) .

KERB.Hash(mpk,sku,(ID,txID),A)→(h,r,σID) : The hash algorithm picks a randomness r in the chameleon hash randomness domain and generates a hash value h←CH.Hash(pkh,(ID,txID);r) . It then defines the access policy A of redaction by generating a signature σID←DS.Sign(sku,(ID,r,A)) . Note that

h and σID are linked via the transaction identity ID , and

σID excludes the transaction information txID to prevent anyone to infer the previous transaction from the redacted transaction.

The algorithm returns a hash value h , a randomness r and a signature σID .
KERB.Adapt(mpk,skm,(ID,txID),h,r,σID,(ID,tx′ID)) →(r′,σ′ID) : The adaption algorithm generates a randomness r′←CH.Adapt(skh,(ID,txID),h,r,(ID,tx′ID)) and picks an index i that is never used before to generate a signature σ′←DS.Sign(sk′m,(ID,r′,A)) . To convince no more than k -time redaction, it computes z=ρi⋅H(i,ID,r′,A)+sk′m , c′2,i=c2,i⋅(pkm⋅g−z)1/H(i,ID,r′,A) , randomly picks v∈Zp and calculates s=v−ric and c=H(g,c0,gv,cv0,pkm,c1,i,c′2,i,σ′) . The algorithm returns a randomness r′ and a signature σ′ID=(σ′,z,π) , where π=(i,s,gv,cv0) .

KERB.Verify(mpk,pk,(ID,txID),h,r,σID,t′)→b : Let r′ be the part of messages signed in the signature σID . If r and r′ are equal, the transaction txID has not been redacted and the input public key pk comes from the user pku , the verifier returns 0 if anyone of the following conditions is not true:

CH.Verify(pkh,(ID,txID),h,r)=1 ;

DS.Verify(pku,σID,(ID,r,A))=1 .

If r and r′ are not equal, the transaction txID has been redacted and the input public key of the user and modifier pk including the public keys (pku,pkm) and the token key tk of the modifier, the verifier returns 0 if anyone of the following conditions is not true:
CH.Verify(pkh,(ID,txID),h,r)=1 ;

DS.Verify(pku,σID,(ID,r,A))=1 ;

DS.Verify(pk′m,σ′,(i,ID,r′,A))=1 ;

DS.Verify(pka,tk,(pkm,S,t))=1 ;

S⊨A and t′<t & gv=gscc1,i and cv0=cs0c′c2,i .

The algorithm returns 1 if there is no any failure during the above verifications; otherwise, returns 0.
KERB.Ex(pkm,(i,ID,r,A),(i′,ID′,r′,A′),σID,σID′) → sk′m : The extraction algorithm returns a failure symbol ⊥ if anyone of the following conditions is false:

i=i′ and (ID,r,A)≠(ID′,r′,A′) ;

DS.Verify(pk′m,σ,(i,ID,r,A))=1 ;

DS.Verify(pk′m,σ′,(i′,ID′,r′,A′))=1 .

The algorithm returns sk′m=z⋅H(i′,ID′,r′,A′)−z′⋅H(i,ID,r,A)H(i′,ID′,r′,A′)⋅H(i,ID,r,A) .
F. Security Proof
Theorem 1:
Suppose the underlying digital signature scheme DS is \sf{EUF-CMA} secure, then the proposed semi-generic construction \mathcal {KERB} is \sf{EUF-CMA} secure with the following advantage: {\textbf { Adv}}_{\mathcal {A,KERB}}^{\sf {EUF{-}CMA}}(1^\lambda)= {\textbf { Adv}}_{\mathcal {A,DS}}^{\sf {EUF{-}CMA}}(1^\lambda) .

Theorem 2:
Suppose the soundness of DDH assumption holds and the underlying hash function is collision-resistant, then the proposed semi-generic construction \mathcal {KERB} is w-KE secure with the following advantage: {\textbf { Adv}}_{\mathcal {A,KERB}}^{\sf w{-}KE}(1^\lambda)=\epsilon _{\sf s_{DDH}} \text {and }{\textbf { Adv}}_{\mathcal {A,KERB}}^{\sf w{-}KE}(1^\lambda)=\epsilon _{\sf h} , where \epsilon _{\sf s_{DDH}} and \epsilon _{\sf h} are the advantages of breaking the soundness of DDH and the collision-resistance of hash functions.

See Appendix A for correctness of the scheme, Appendix B sand C for proof details.

SECTION V.Performance Analysis
To instantiate our proposed KERB system, we apply the elliptic curve digital signature algorithm (ECDSA) [38] and the chameleon hash [27] as the basic building blocks, where the details refer to Appendix D and E. Our experiential simulation was performed on a PC running 64-bit Windows 10 with 2.90 GHz Intel(R) Core(TM) i7-7820HK CPU and 16 GB RAM 2333 MHz. Our implementation is in Java using the JPBC library with type A pairings. In particular, we use the pairing on the curve y^{2}=x^{3}+x over the field \mathbb {F}_{p} for a prime number p with 512-bit length, which is equivalent to 80-bit security [39]. The experimental performances are presented in Fig. 8, where the performances are from the different number of maximum data rewriting times k=4 and k=64 as well as increasing the size of attribute sets or the length of policies.

Fig. 8. - Experimental performances.
Fig. 8.
Experimental performances.

Show All

The experimental performances demonstrate that system setup, user setup, token key generation, hash, adaption, verification, and key extraction are almost stable, regardless of how many attributes and times of data rewriting are involved. The reason is that we apply signature schemes to verify rewriting operations rather than encryption mechanisms to seal chameleon hash trapdoors, and policies are a string expression rather than multiple individual strings. However, things change for modifier setup as shown in Fig. 8b, which grows linearly with the number of attributes. This, however, is easily explainable due to the attributes are in the form of a string collection, the size of this collection is increasing depending on the user’s attributes.

SECTION VI.Conclusion
In this work, we investigated the issues of redactable blockchain and presented a k -time modifiable and epoch-based redactable blockchain with monetary penalty. We gave the formal definition and security models of the proposed scheme, and presented a generic construction with formal security proofs. We believe our system is a promising solution that can be extended to many blockchain systems to achieve efficient and secure transaction rewriting.