With the increasingly powerful and extensive deployment of edge devices, edge/fog computing enables customers to manage and analyze data locally, and extends computing power and data analysis applications to network edges. Meanwhile, as the next generation of the power grid, the smart grid can achieve the goal of efficiency, economy, security, reliability, use safety and environmental friendliness for the power grid. However, privacy and secure issues in fog-based smart grid communications are challenging. Without proper protection, customers’ privacy will be readily violated. This article presents a smart and practical Privacy-preserving Data Aggregation (PDA) scheme with smart pricing and packing method for fog-based smart grids, which achieves diversified tariffs, multifunctional statistics and efficiency. Especially, we first propose a smart PDA scheme with Smart Pricing (PDA-SP). With PDA-SP, the Control Center (CC) can compute more complex and higher-order aggregation statistics to provide various services, provide diversiform pricing strategies and choose a double-winning strategy. Subsequently, we put forward a practical PDA scheme with Packing Method (PDA-PM), which is able to reduce the size of encrypted data and improve performance in performing various secure computations. Moreover, we extend our original packing method and present a more useful packing method, which can handle general vectors with large entries. The security analysis shows that our proposed scheme is secure against many threats. The performance evaluation reveals that the computation and communication overheads of our proposed scheme are effectively reduced by employing the Somewhat Homomorphic Encryption (SHE), and our packing method can further significantly reduce these overheads.
SECTION I.Introduction
Fog/edge computing extends from cloud computing and has been booming in recent years [1]. Fog/edge computing enables customers to realize computation, communication and storage locally, and extends functions of cloud computing to network edges [2]. In the big data era, users have higher expectations for service quality and network performance [3], [4]. Traditional cloud computing has a significant shortage of storage capacity and computing power while handling a large number of user queries and reports [5]. Therefore, it is beneficial to transfer some of the cloud’s functionalities to the fog node.

Fog/edge computing has the advantages of fast response, low delay, fog volatility, large position perception, and enhanced safety and reliability in comparison with cloud computing [6]. The above fascinating advantages have contributed to spatial crowdsourcing [7], the fog-based smart grids [8], and other Industrial Internet of Things. As the next generation of the power grid, the smart grid can achieve the goal of efficiency, economy, security, reliability, use safety and environmental friendliness for the power grid [9]. The fog node enables the utility company to provide various services by the service query and command control between customers and the CC, such as adjusting the price of electricity, obtaining the overall power consumption, charging the customer for electricity and providing additional power according to customers’ requirements. However, it’s very challenging for privacy and security in the fog-based smart grid communication [10]. Because electricity usage data involve customers’ energy usage patterns, which are closely related to their private lives, improper handling of these data may cause the disclosure of customers’ privacy [11].

In addition, diversified tariffs, multifunctional statistics and efficiency also should be taken into careful consideration. First, traditional tariffs are usually using the fixed pricing to calculate customers’ electricity bills and considering a limited pricing strategies. With the development of fog-based smart grids and power grids, these traditional tariffs are insufficient to meet the requirements of fair pricing and intelligent electronic devices. Therefore, a diversiform PDA scheme (which can achieve diversified tariffs) is urgent to be put forward. Second, with the ever increasing demands from power consumers, for providing various services, the CC needs to calculate more complex and higher-order statistic functions. However, many previous works are only supporting one-depth homomorphic multiplication, which are not powerful enough. Therefore, a multifunctional PDA scheme (which supports the CC to calculate statistic functions whose degree is larger than 2) is critical to be proposed. Third, the CC, fog nodes and customers should spend as low as possible on computations and communications. However, the bilinear pairing technology is employed in a lot of previous works, which poses a heavy burden on the CC and fog nodes. It is urgent to present an efficient PDA scheme for fog-based smart grids.

For achieving diversified tariffs, multifunctional statistics and efficiency, in this article, we propose a smart and practical PDA scheme for fog-based smart grids with smart pricing and packing method. We conclude our contributions as follows:

Almost all the previous works are only taking fixed pricing into consideration or the alternative pricing strategies are limited, and traditional tariffs are insufficient to meet the requirements of fair pricing. In response to such needs, we introduce smart pricing into the fog-based smart grid. Thanks to its peculiar features, the CC can provide diversiform pricing strategies, and indirectly guide customers to dynamically adjust their energy usage patterns based on changes in electricity prices. In addition, our proposed scheme also can perform one-way analysis of variance (ANOVA) to evaluate whether these pricing strategies have an impact on customers’ electricity usage behavior, and choose a double-winning strategy.

As the CC may need to compute more complex and higher-order statistic functions to provide various services, we introduce a multifunctional PDA scheme, which not only supports multifunctional additive and non-additive aggregations, but also supports the CC to calculate statistic functions whose degree is larger than 2. In addition, we also present two types of min aggregation protocols for fog-based smart grids, and compare the computation and communication overheads of them.

For reducing the size of encrypted data and improving performance when performing various secure computations, we come up with a new packing method for our PDA scheme. Our new packing method provides four types of packed ciphertexts for vectors, which is different from the message encoding technique presented by Lauter, Naehrig and Vaikuntanathan [12], and makes our proposed scheme efficient in both ciphertext size and performance. In addition, we present a more useful packing method, which can handle general vectors with large entries.

We introduce SHE into the fog-based smart grid, compared with previous works that utilizing bilinear pairing and homomorphic encryption, the computation and communication overheads are effectively reduced. Furthermore, the performance evaluation reveals that our packing method can further significantly reduce these overheads, which means our scheme is lightweight and efficient.

The following structure of our paper is presented below: We overview related works in section II. Section III describes the problem formalization including the proposed system model, threat model, design goals and preliminary. In section IV and V, we propose our PDA schemes for fog-based smart grids. Then in the next two sections, we do some security analyses and experiments. Finally, section VIII concludes the paper.

SECTION II.Related Work
Our scheme is to achieve multifunctional and efficient PDA, which is similar to a lot of related works published in recent literatures. Generally, there are two groups of PDA schemes: statistic-oriented PDA which is designed to perform various statistical analyses on remote sensing data, and efficiency-oriented PDA which focuses on raising efficiency.

Concerning statistic-oriented PDA, Shi et al. [13] present a PDA scheme, which uses data mixing and slicing to support max/min and additive aggregations. Subsequently, Li et al. [14] provide an efficient sum and min aggregation over ciphertexts by employing additive homomorphic encryption and key management. For ensuring data integrity and user privacy, Zhang et al. [15] come up with a new method to verify PDA, which achieves multifunctional additive and non-additive aggregations, i.e. sum, variance, max/min, median, percentile, histogram and count. In [16], Chen et al. present a PDA scheme with diversiform statistical functions. In addition to average aggregation, their scheme also realizes differential privacy of one-way ANOVA and variance aggregations. In order to achieve non-additive aggregation and differential privacy, Han et al. [17] propose a scheme, which realizes multifunctional additive and non-additive aggregation simultaneously. Sun et al. [18] present a scheme named PriStream, which enables privacy-preserving and communication-efficient distributed stream monitoring of thresholded percentile aggregates. A privacy-aware data aggregation and task allocation scheme is put forward by Wu et al. [19]. Their scheme achieves basic statistics (i.e. sum, variance and min) and efficient data update in a privacy-preserving way.

Concerning efficiency-oriented PDA, traditional schemes are mostly based on homomorphic encryption technology. Traditional homomorphic encryption scheme allows meaningful calculation over ciphertexts and improves computational efficiency, it can be categorized into three types: 1) Paillier-based PDA schemes [20]–[21][22][23][24][25], which employ Paillier encryption system [26] to provide either adding or multiplying encrypted ciphertexts, but not both operations at the same time. 2) BGN-based PDA schemes [16], [17], [27], [28], which use BGN encryption system [29] to construct a scheme that can perform addition and multiplication simultaneously. These schemes handle any number of additions and just one multiplication. 3) The other pairing-based PDA schemes [30]–[31][32][33][34], which utilize bilinear pairing and homomorphic encryption to achieve efficient PDA. However, these pairing-based schemes can perform arbitrarily number of additions, but also only allow one-depth homomorphic multiplication, which are not really expanded. In 2009, Gentry [35] makes an important breakthrough. He presented the Fully Homomorphic Encryption (FHE) scheme for the first time, which is based on the problems of hard lattice and handles any number of additions and multiplications, so that it enables to calculate arbitrary statistics securely. Unfortunately, this scheme is too complicated to be used in practice. Interestingly, some FHE schemes are associated with more practical SHE schemes that support any number of additions but allow for a limited number of multiplications. In this article, we will use SHE to achieve privacy-preserving encryption and decryption.

More importantly, we note that the above researches have two crucial flaws. On one hand, in the statistic-oriented PDA schemes, most works are utilizing bilinear pairing and homomorphic encryption to realize multifunctional addition and non-addition aggregations. However, these works are only supporting one-depth homomorphic multiplication over ciphertexts, which means that the aggregator can not aggregate the users’ data in a privacy-preserving way for any given statistic function whose degree is larger than 2. On the other hand, in the efficiency-oriented PDA schemes, a lot of works are based on the bilinear pairing technology, which inevitably poses a heavy burden on the aggregator and servers and does not efficiently adapt to fog-based smart grid scenarios.

SECTION III.Problem Formalization
A. System Model
The fog-based smart grid system consists of a trusted authority (TA), a utility company and a CC, some substations and some fog nodes, some communities and each community contains a number of customers, which are equipped with smart meters. Figure 1 describes our system model.

Trusted Authority: The TA takes charge of entity registration and it is a powerful third party. It will go off-line after booting the whole system.

Control Center and Utility Company: The CC collects, processes and analyzes real-time smart meter data and issues grid commands to smart meters and substations to provide customers with reliable grid services. The utility company is responsible for electrical power generation, storage and distribution.

Fog Node and Substation: The flows of information between customers’ smart meters and the CC, which contain smart meter readings, requests and commands, are preserved, processed and forwarded by the fog node. The substation waits for the utility company’s commands and stores the electricity and transmits the electricity power to customers’ houses.

Customer: Each customer’s house with a smart meter, which gathers electricity usage data in real-time, relays these data and requests of grid service to the CC.

Fig. 1. - The system model of our fog-based smart grid.
Fig. 1.
The system model of our fog-based smart grid.

Show All

B. Threat Model
In this article, we assume that the TA and CC are two trusted entities. We consider an adversary A in our threat model. Specifically, we take three attack models into consideration: i) Chosen Plaintext Attack (CPA) model: A can choose some plaintexts and obtain corresponding ciphertexts. ii) Known Plaintext Attack (KPA) model: A can obtain some plaintexts and corresponding ciphertexts. iii) Ciphertext Only Attack (COA) model: A only knows some ciphertexts. In addition, we consider that all participants are following the honest-but-curious adversary model [36], [37], all participants will perform the protocol honestly, but they are also curious about other customers’ privacy data independently. A can also do the following attacks: i) A can eavesdrop on communication flows. ii) A can compromise a customer directly. iii) A can intrude into the databases of the CC and fog nodes to steal the stored data. Note that, this article primarily focuses on the privacy of electricity usage data, other attacks (except for privacy disclosure) are beyond the scope of this article.

C. Design Goal
Our design goal is to present a multifunctional, diversiform and efficient PDA scheme for fog-based smart grids. Specifically, we should realize the following three goals.

The proposed scheme should guarantee diversified tariffs. For meeting the requirements of fair pricing and providing diversiform pricing strategies, the proposed scheme should guarantee diversified tariffs, so that the CC can guide customers to dynamically adjust their energy usage patterns based on changes in electricity prices.

The proposed scheme should support multifunctional statistics. Although many previous works have realized multifunctional addition and non-addition aggregations, these works are only supporting one-depth homomorphic multiplication. With the ever increasing demands from power consumers, the proposed scheme should support the CC to aggregate the customer’s electricity usage data in a privacy-preserving way for any given statistic function whose degree is larger than 2. By this way, the CC can compute more complex and higher-order statistic functions to provide various services. Specially, the proposed scheme should support diversiform statistical functions of customers’ electricity usage data, such as sum, inner product, one-way ANOVA, max and min.

The proposed scheme should achieve efficiency. Although a lot of previous works have employed bilinear pairing and homomorphic encryption to realize efficient PDA, these works involve bilinear pairing operations and pose a heavy burden on the CC and fog nodes. Thus, the proposed scheme should achieve PDA in an efficient way.

D. Preliminary: Somewhat Homomorphic Encryption
We briefly recall the system parameters, construction and correctness of SHE scheme presented in literature [12], which is slightly modified from literature [38]. The security of the scheme [12] is based on the Polynomial Learning With Errors (PLWE) assumption [38], which is a simplified version of the Ring Learning With Errors (RLWE) assumption [39], [40].

System Parameters: we need four parameters:

N : is referred to as the lattice dimension. We define R=Z[x]/(f(x)) as the base ring and f(x)=xN+1 as a cyclotomic polynomial with degree N [41]. It is a 2-power integer.

q : satisfies q≡1 mod 2N and represents a ciphertext space with the base ring Rq=R/qR=Zq[x]/(f(x)) , which is often defined as a prime number.

t : meets the condition t<q and determines a plaintext space Rt=Zt[x]/(f(x)) , which is an integer.

σ : denotes a discrete Gaussian error distribution χ=DZN,σ where σ is standard deviation. It is an integer and we often sample σ=4∼8 in practice.

Construction: Here, we briefly describe the construction of SHE scheme as below, and κ is the security parameter.

Key Generation (SHE.KG(κ) ): We sample an element R∋s←χ , take R∋e←χ as an error and a1∈Rq as a random element, then compute a0=−(a1⋅s+t⋅e) . Let sk=s be the private key, pk=(a0,a1) be the public key.

Encryption (SHE.Enc(m,pk) ): For a plaintext m∈Rt and pk=(a0,a1) , we choose three elements R∋u,f,g←χ , then calculate Enc(m,pk)=(c0,c1)=(a0u+tg+m,a1u+tf) as the ciphertext, and Enc(m,pk)∈(Rq)2 .

Homomorphic Operations: We define two any length ciphertexts as ct=(c0,…,cη) and ct′=(c′0,…,c′ξ) . Then, we compute the homomorphic addition ”⊕ ” by ct⊕ct′=(c0+c′0,…,cmax(η,ξ)+c′max(η,ξ))∈Rmax(η,ξ)+1q , which is calculated by component-wise addition of ciphertexts and pads with zero if neccessary. Similarly, we compute the homomorphic multiplication ”⊗ ” by ct⊗ct′=(c^0,…,c^η+ξ) . We set x as a symbolic variable and ct , ct′ as elements of Rq[x] , then an embedding map is computed by (Rq)u∋(v0,…,vu−1)↦∑u−1i=0vixi∈Rq[x] for any u≥1 . Therefore, all elements c^i are calculated by ∑η+ξi=0c^ixi=(∑ηi=0cixi)⋅(∑ξi=0c′ixi)∈Rq[x] . Note that, the ciphertext length will be longer after the homomorphic multiplication, as the previous encryption produces two ring elements for a ciphertext in Rq .

Decryption (SHE.Dec(ct,sk) ): We let sk=s be the private key and ct=(c0,…,cη)∈(Rq)η+1 be a ciphertext, then we compute m~=∑ηi=0cisi∈Rq and Dec(ct,sk)=[m~]qmodt∈Rt . If s⃗ =(1,s,s2,…) denotes the private key vector, then it can also be written as Dec(ct,sk)=[⟨ct,s⃗ ⟩]qmodt .

Correctness: For correctness, we mean that upon a number of homomorphic operations on ciphertexts, decryption can restore the operated result on plaintexts. As homomorphic operations on ciphertexts corresponding to the ring structure of Rt (refer to the proof of [12] Lemma 3.3), for plaintexts m , m′ corresponding to ciphertexts ct , ct′ , respectively, we have
{Dec(ct⊕ct′,sk)=m+m′∈RtDec(ct⊗ct′,sk)=m×m′∈Rt
View SourceNevertheless, as described in Section III(D), instead of a FHE scheme, the above only gives a SHE scheme, whose correctness should satisfy the following Lemma [12]:

Lemma 1 (Condition for correct decryption):
With regard to a ciphertext ct , if ⟨ct,s⃗ ⟩∈Rq is not winding mod q , the decryption Dec(ct,sk) can output the correct result. Namely, decryption is able to restore the correct result, if it satisfies the condition ||⟨ct,s⃗ ⟩||∞<q/2 , in which the ∞ -norm of its coefficient representation is defined as ||a||∞=max0≤i≤N−1|ai| for a=∑N−1i=0aixi∈Rq .

SECTION IV.PDA-SP: Privacy-Preserving Data Aggregation Scheme With Smart Pricing
Here, we propose a smart PDA scheme with smart pricing, which works in the following four phases: system initialization SI , customer report generation CRG , privacy-preserving report aggregation PRA and secure report reading SRR .

A. System Initialization
At the beginning, the whole system is bootstrapped by the TA and it generates private key and public key for the CC. In particular, the TA picks an element s←χ , chooses a1∈Rq as a random element and e←χ as an error. We assume that sk=s is the private key, computing a0=−(a1⋅s+t⋅e) , and pk=(a0,a1) is the public key.

B. Aggregation Protocol for sum
In the fog-based smart grid, the temporal aggregation means that the CC can aggregate a customer’s electricity usage data at different points in time (such as calculating customer’s electricity bill). Below, we mainly focus on privacy-preserving temporal aggregation, and which can be easily extended to achieve privacy-preserving spacial aggregation.

1) Customer Report Generation:
We assume that there are z time points in a temporal aggregation cycle, for example, from tp0 to tpz−1 , from tpz to tp2z−1 , etc. For simplicity, we show the temporal aggregation as follows by choosing the first cycle as an example and set z≤t . Let smart meter report its electricity usage to the fog node every 15 minutes. Thus, there are z=96 time points of one day in the temporal aggregation cycle. Specifically, a customer U gathers its electricity usage data mγ∈Rt at time point tpγ and performs steps as follows:

U chooses R∋u,f,g←χ , and computes
ctγ==Enc(mγ,pk)=(c0,γ,c1,γ)(a0u+tg+mγ,a1u+tf).(1)
View SourceU

reports ctγ∈(Rq)2 to the fog node.

2) Privacy-Preserving Report Aggregation:
On the basis of the CC’s requirement, the fog node can aggregate customer’s electricity usage data while protecting the privacy of him, after receiving z encrypted electricity usage data ctγ . Specially, the fog node calculates the aggregation as follows:

The fog node first utilizes ctγ to compute CTsum as
CTsum=⨁γ=0z−1ctγ=ct0⊕…⊕ctz−1.(2)
View Source

For further calculation, the fog node sends the aggregation result CTsum to the CC.

3) Secure Report Reading:
After receiving the corresponding aggregation result, the CC can compute sum statistic easily without exposing individual customer’s privacy. In particular, the CC makes the following computation to get the sum of electricity usage for U .
Msum=Dec(CTsum,sk)=∑γ=0z−1mγ.(3)
View Source

C. Aggregation Protocol for Electricity Bill or Inner Product
1) Smart Pricing Schemes:
The tariff is defined as the amount of electricity per Kilo Watt hour that each power consumer has to bear. With the advancement of the smart grid and the distributed generation is introduced into the grid system, traditional tariffs can no longer meet the requirements of fair pricing and intelligent electronic devices. In response to these requirements, smart pricing schemes are designed in recent years [42]. These efficient time-based pricing schemes consist of Time of Use (ToU) pricing [43], Critical Peak Pricing (CPP) [44], Real Time Pricing (RTP) [45] and so on, which provide customers with different electricity prices at different times. According to those information, when the prices of electricity are high, customers will naturally reduce the amount of electricity usage, thereby reducing the electricity demand during peak periods. In other words, these schemes indirectly guide customers to dynamically adjust their energy usage patterns on the basis of changes in electricity prices, instead of directly controlling their loads [46].

Note that, designing a new smart pricing scheme is beyond the scope of this article. Here, we only focus on designing a diversiform PDA scheme to suitable for diversiform pricing strategies. Specially, we choose one of these smart pricing schemes to generate electricity price priceγ every 15 minutes for customer U . The fog node can obtain the ciphertext of electricity bill for U , by simply multiplying the ciphertexts of electricity price priceγ to those of electricity usage mγ , and then sum them. The process of calculating the electricity bill is the same as that of computing inner product aggregation.

2) The Inner Product Aggregation Protocol:
For the fog-based smart grid, the information flows of inner product aggregation are shown in Figure 2. When the CC wants to get the electricity bill (inner product aggregation) of a customer, it should send an electricity bill request to the fog node first. Then, this customer generates smart meter reports and sends these reports to the fog node. After receiving the ciphertexts of smart meter readings from this customer, the fog node will employ smart pricing to get the corresponding electricity prices, which will be encrypted by using public key for further calculation. Furthermore, the fog node carries out privacy-preserving aggregation on the ciphertexts according to the CC’s requirement, and forward the aggregation result to the CC. After obtaining the aggregation result from the fog node, the CC recovers the electricity bill of this customer.


Fig. 2.
Information flows of inner product aggregation.

Show All

Especially, if the CC wants to calculate the electricity bill of U in a temporal aggregation cycle, it should send the electricity bill request to the fog node. The customer report generation phase of inner product aggregation is the same as that of sum aggregation. Subsequently, the fog node first employs a selected smart pricing scheme to obtain the corresponding electricity prices priceγ (γ=0,1,…,z−1 ) and utilizes public key to get the ciphertexts of them. Specially, the fog node picks R∋u′,f′,g′←χ and computes
ct′γ==Enc(priceγ,pk)=(c′0,γ,c′1,γ)(a0u′+tg′+priceγ,a1u′+tf′).(4)
View SourceIn the phase of privacy-preserving report aggregation, when all ciphertexts of smart meter readings and that of corresponding electricity prices are received, the encrypted aggregation result is calculated by the fog node as the following steps:

The fog node uses ctγ and ct′γ to calculate
CTinner==⨁γ=0z−1(ctγ⊗ct′γ)(ct0⊗ct′0)⊕…⊕(ctz−1⊗ct′z−1).(5)
View Source

The fog node sends CTinner to the CC.

In the secure report reading phase, when the CC receives the corresponding encrypted aggregation result, it will make the following calculation to obtain the electricity bill of U .
Minner=Dec(CTinner,sk)=∑γ=0z−1(mγ⋅priceγ).(6)
View Source

D. Aggregation Protocol for One-Way ANOVA
The CC will send an one-way ANOVA request to the fog node while it wants to calculate one-way ANOVA of customer’s electricity usage. We assume the utility company has k≥3 pricing strategies. The CC can perform one-way ANOVA on customers’ electricity usage data to test whether these usages are significant impacted by the k strategies. Based on one-way ANOVA, the null hypothesis is that different pricing strategies have no significant impact on customers’ electricity usage, the between group variance is
SSB=1z∑j=0k−1(∑γ=0z−1mj,γ)2−1zk(∑j=0k−1∑γ=0z−1mj,γ)2,(7)
View Sourceand the within group variance is
SSW=∑j=0k−1∑γ=0z−1m2j,γ−1z∑j=0k−1(∑γ=0z−1mj,γ)2,(8)
View SourceRight-click on figure for MathML and additional features.where mj,γ represents U ’s electricity usage data with the (j+1) -th pricing strategy at time point tpγ . Then, let encryption of mj,γ be ctj,γ=Enc(mj,γ,pk) .

The customer report generation phase of one-way ANOVA aggregation is same as that of sum aggregation. In the phase of privacy-preserving report aggregation, when the fog node receives all customer U ’s electricity usage data, it will calculate the aggregation results as follows:

The fog node utilizes ctj,γ to get CT1 , CT2 , CT3 as
CT1=CT2=CT3=⨁j=0k−1[(⨁γ=0z−1ctj,γ)⊗(⨁γ=0z−1ctj,γ)],(⨁j=0k−1⨁γ=0z−1ctj,γ)⊗(⨁j=0k−1⨁γ=0z−1ctj,γ),⨁j=0k−1⨁γ=0z−1(ctj,γ⊗ctj,γ).(9)(10)(11)
View Source

Eventually, for further calculation, the fog node sends aggregation results CT1 , CT2 and CT3 to the CC.

In the secure report reading phase, the CC will make the following calculations to obtain the one-way ANOVA.
M1=M2=M3=Dec(CT1,sk)=∑j=0k−1(∑γ=0z−1mj,γ)2,Dec(CT2,sk)=(∑j=0k−1∑γ=0z−1mj,γ)2,Dec(CT3,sk)=∑j=0k−1∑γ=0z−1m2j,γ.(12)(13)(14)
View SourceRight-click on figure for MathML and additional features.Therefore, equation (7) and (8) can be simply described as:
SSB=SSW=1zM1−1zkM2,M3−1zM1.(15)(16)
View SourceRight-click on figure for MathML and additional features.

The CC can calculate the F value of F -test as F=SSB/(k−1)SSW/(z−k) . For the z−k denominator and k−1 numerator degrees of freedom, the null hypothesis will be accepted by the CC if the F critical value is larger than the F value, which represents that customer’s electricity usages are significant impacted by no pricing strategy; otherwise, the null hypothesis will be refused, which represents that customer’s electricity usages are significant impacted by at least one pricing strategy.

E. Aggregation Protocol for max/min
Since max is the opposite of min, for the sake of simplicity, we will only illustrate min below. We define the min aggregation as the minimum value of U ’s electricity usage data in a temporal aggregation cycle. This subsection presents two types of protocols, which employ sum aggregation and Hamming distance computation to get min aggregation. As shown in Section III(D), t is an integer to determine a plaintext space, generally, we assume t is a power of two and t≥z .

1) The Sum-Based min Aggregation Protocol:
We present two sum-based min aggregation protocols in this subsection.

The basic protocol (B-SUM) is as follows. We let d be a 1-bit derivative data, U produces d[0],d[1],…,d[t] as t+1 derivative data for each time point. If the electricity usage data value of U is not equal to j , then 0 will be assigned to d[j] (j∈[0,t] ), and 1 otherwise [14], which means that in the plaintext space, every derivative data denotes a possible electricity usage data value. The fog node can employ the sum aggregation protocol (which is proposed in Section IV(B)) to get the sum aggregation of d[j] (j∈[0,t] ). Then, the smallest j (which returns a positive sum) is the desired min. In the basic protocol, we find that for each time point, there are t+1 derivative data involved in U , and the fog node needs to perform the sum aggregation protocol t+1 times. Note that, in the sum aggregation protocol, U employs SHE to encrypt his t+1 derivative data at each time point, which is inefficient. Therefore, we employ a more efficient technique below by concatenating together multiple derivative data and encrypting them as a whole, as these derivative data are independent.

The extended protocol (E-SUM) is as follows. By appending ⌈log(z+1)⌉−10 ’s to the left, the efficient technique expands every derivative data from 1 bit to ⌈log(z+1)⌉ bits. Then, we obtain a single bit-string by concatenating all expanded derivative data. After that, we get the sum of these concatenated strings by employing the sum aggregation protocol. The sum result can be regarded as a bit string, which can be split in t+1 substrings with ⌈log(z+1)⌉ length. Moreover, if each substring is regarded as an integer, the sum result of them denotes the sum of a derivative data. Note that, as each derivative data’s sum is less than z , there is no carries among these substrings and they will not affect each other. Figure 3 displays an instance of the extended protocol. Clearly, in the extend protocol, there is (t+1)⌈log(z+1)⌉ bits for the concatenated data, which is larger than t . We can split the concatenated data into ⌈log(z+1)⌉+1 groups and utilize the efficient technique in parallel to each group. Therefore, the fog node needs to perform ⌈log(z+1)⌉+1 sum aggregation protocols in parallel. For example, the fog node needs to perform 8 sum aggregation protocols in parallel, when z=96 . Correctness: As we assume that z≤t , we have
=≤⌈(t+1)⌈log(z+1)⌉t⌉⌈⌈log(z+1)⌉+⌈log(z+1)⌉t⌉<⌈⌈log(z+1)⌉+zt⌉⌈⌈log(z+1)⌉+1⌉=⌈log(z+1)⌉+1.
View Source


Fig. 3.
An example of the extended protocol.

Show All

2) The Hamming-Distance-Based min Aggregation Protocol:
In this subsection, we will combine the prefix membership verification scheme with binary search (see [17], Section V(A)) to realize the basic and extended Hamming-distance-based min aggregation (B-HDB and E-HDB, respectively). Our B-HDB and E-HDB protocols can be considered as a security enhanced version of their min aggregation protocol. In their protocol, the cloud server needs to decrypt the encrypted data and then carries out the Algorithm 1 to acquire mmin . However, in our B-HDB and E-HDB protocols, the CC only needs to carry the slightly modified Algorithm 1 to get mmin over ciphertexts, which makes our protocols more safer for customers. In addition, for two strings of same length, the Hamming distance between them is defined as the number of positions where the corresponding symbols are different, and it is often employed for similar words search. In our protocols, the Hamming distance computation is employed for private equality test. Especially, we have two w+1 bits integers A=(A0,…,Aw) and B=(B0,…,Bw) , the Hamming distance is calculated by
dH(A,B)=∑l=0w|Al−Bl|=∑l=0w(Al+Bl−2AlBl).(17)
View SourceHere, the equality of two w+1 bits integers can be found out from the Hamming distance between them. Then, we say that they are equal, if dH(A,B)=0 for two integers comparison.

Algorithm 1 The Hamming-Distance-Based min Aggregation
CTFMγ−→−−−=(ctFMγ,0,…,ctFMγ,w) , γ∈[0,z−1] .

mmin

BOT=0,TOP=2w−1,Mid=⌊BOT+TOP2⌋ ;

for j=1 to w do

countj=0 ;

for γ=0 to z−1 do

We assume Γ(R([BOT,Mid]))=(R0,…,Rη−1) , then

Enc(Γ(R([BOT,Mid])),pk)=(ctR0,…,ctRη−1) ,

where ctRi=Enc(Ri,pk) , (0≤i≤η−1 ).

Therefore, let CTR−→−=(ctR0,…,ctRη−1) .

if A2(CTFMγ−→−−−,CTR−→−)–––––––––––––––––=0 then

countj=countj+1 ;

else

countj=countj ;

end if

end for

if countj≥1 then

TOP=Mid,Mid=⌊BOT+TOP2⌋ ;

else

BOT=Mid+1,Mid=⌊BOT+TOP2⌋ ;

end if

if BOT=TOP=Mid or j=w then

mmin=BOT=TOP=Mid ;

break;

end if

end for

return mmin ;

End Procedure;

According to the Section V(A) of [17], we assume a customer’s electricity usage data mγ (γ∈[0,z−1] ) of at most w bits, the result vector of numericalized prefixes Γ(F(mγ))=(FMγ,0,…,FMγ,w) with length w+1 . If the CC wants to compute the minimum of electricity usage of U , it sends a min aggregation request to the fog node. In the customer report generation phase, U will generate Γ(F(mγ)) and compute Enc(Γ(F(mγ)),pk)=CTFMγ−→−−−=(ctFMγ,0,…,ctFMγ,w) , where ctFMγ,l=Enc(FMγ,l,pk) (l∈[0,w] ). Then, U reports Enc(Γ(F(mγ)),pk) to the fog node, and forwards to the CC. In the secure report reading phase, upon receiving all encrypted data Enc(Γ(F(mγ)),pk) , the CC carries out the modified Algorithm 1, Algorithm 2 (A2 ) and Algorithm 3 (A3 ) to obtain mmin=min{m0,m1,…,mz−1} .

Algorithm 2 The Hamming-Distance-Based Comparison
CTFMγ−→−−−=(ctFMγ,0,…,ctFMγ,w) of length w+1 , CTR−→−=(ctR0,…,ctRη−1) of length η .

0 or 1.

The basic version:

CTcmp=∏j=0w∏i=0η−1A3(ctFMγ,j,ctRi)––––––––––––––– ;

if CTcmp=0 then

return 0;

else

return 1;

end if

End Procedure;

The extended version:

for j=0 to w do

for i=0 to \eta -1 do

if \underline {A_{3}(ct_{FM_{\gamma,j}},ct_{R_{i}})}=0 then

return 0;

end if

end for

end for

return 1;

End Procedure;

Algorithm 3 The Secure Hamming Distance Computation
ct_{FM_{\gamma,j}} and ct_{R_{i}} .

0 or 1.

Let \overrightarrow {FM_{\gamma,j}}=(FM_{\gamma,j,0},\ldots,FM_{\gamma,j,w}) , then ct_{FM_{\gamma,j}}=Enc(\overrightarrow {FM_{\gamma,j}},pk)=(ct_{FM_{\gamma,j,0}},\ldots,ct_{FM_{\gamma,j,w}}) , where ct_{FM_{\gamma,j,l}}=Enc(FM_{\gamma,j,l},pk) (0\leq l\leq w );

Let \overrightarrow {R_{i}}=(R_{i,0},\ldots,R_{i,w}) , then ct_{R_{i,l}}=Enc(R_{i,l},pk) (0\leq l\leq w ), ct_{R_{i}}=Enc(\overrightarrow {R_{i}},pk)=(ct_{R_{i,0}},\ldots,ct_{R_{i,w}}) ;

CT_{HM}=\bigoplus \limits _{l=0}^{w}ct_{FM_{\gamma,j,l}}\oplus \bigoplus \limits _{l=0}^{w}ct_{R_{i,l}}\oplus (-2)\bigoplus \limits _{l=0}^{w}(ct_{FM_{\gamma,j,l}}\otimes ct_{R_{i,l}}) ;

Dec(CT_{HM},sk)=\sum \limits _{l=0}^{w}FM_{\gamma,j,l}+\sum \limits _{l=0}^{w}R_{i,l}-2\sum \limits _{l=0}^{w}FM_{\gamma,j,l}\cdot R_{i,l} ;

if Dec(CT_{HM},sk)=0 then

return 0;

else

return 1;

end if

End Procedure;

The key idea of Algorithm 1 can be referred to the Section V(B) of [17]. The key idea of A_{2} is as follows. In the basic version, after receiving the encrypted result vectors of numericalized prefixes \overrightarrow {CT_{FM_{\gamma }}} and \overrightarrow {CT_{R}} , the CC first carries out A_{3} to verify whether ct_{FM_{\gamma,j}} and ct_{R_{i}} are equal, if those are equal, A_{3} returns 0, otherwise, returns 1. Then, if at least one returns 0, the CT_{cmp} is equal to 0, and A_{2} will return 0, which means \Gamma (F(m_{\gamma }))\cap \Gamma (R([BOT,Mid]))\neq \emptyset . In the extended version, for 0\leq j\leq w and 0\leq i\leq \eta -1 , the CC carries out A_{3} directly, if ct_{FM_{\gamma,j}} and ct_{R_{i}} are equal, A_{3} returns 0, and then A_{2} returns 0 and ends the procedure. By this way, the average computation overhead of extended version has been cut in half comparing to that of basic version.

SECTION V.PDA-PM: Privacy-Preserving Data Aggregation Scheme With Packing Method
We have employed the SHE to achieve PDA protocols for sum, inner product, one-way ANOVA and max/min in Section IV. However, these protocols require a lot of computations and encryptions, which is quite a bit inefficient (see Section VII for detailed comparisons). The packing method provides an alternative, which can encode many bits in a single polynomial and then homomorphically calculate on these polynomials. When performing meaningful secure computations, it can reduce ciphertext size and improve performance. We can effectively calculate the sum and product of the integers by simply encoding integers into a single ciphertext (see [12] Section 4.1). Specially, for an integer B with at most N bits, the packing method can partition it into a binary vector (B_{0},\ldots,B_{N-1}) , and build a (N-1) degree polynomial as \begin{equation*} pm(\overrightarrow {B})=\sum _{i=0}^{N-1}B_{i}x^{i}.\tag{18}\end{equation*}
View SourceFor example, consider an integer B=171=(10101011)_{B} with 8 bits, the corresponding binary vector is \overrightarrow {B}=(1,1,0,1,0,1,0,1) , which is encoded as pm(\overrightarrow {B})=1+x+x^{3}+x^{5}+x^{7}\in R_{t} using the packing method. At last, it encrypts the integer B by ct_{pack}(B)=Enc(pm(\overrightarrow {B}),pk) . We set pm(\overrightarrow {B})|_{x=2} as the value of polynomial pm(\overrightarrow {B})\in R_{t} when we substitute x by 2, and we have pm(\overrightarrow {B})|_{x=2}=B . Moreover, for two N -bits integers B , B' , ct_{pack}(B)\oplus ct_{pack}(B') presents the polynomial addition pm(\overrightarrow {B})+pm(\overrightarrow {B'}) over encrypted data, which is based on the correctness described in Section III(D). As pm(\overrightarrow {B})+pm(\overrightarrow {B'})|_{x=2}=B+B' , we obtain the integer addition B+B' . However, the polynomial multiplication pm(\overrightarrow {B})\cdot pm(\overrightarrow {B'}) will cause a larger degree than N . Therefore, if we want to perform homomorphic multiplication \beta times, we should generate integers with at most N/\beta bits, which is acceptable in calculating low-order multiplications, i.e., sum and variance [12].

A. Definition of Our Packing Method
The above packing method can only support secure sum and variance computations over integers, however, in the below, we will propose a new packing method, which enables efficient secure computations such as inner products, one-way ANOVA and max/min over vectors, and it is an extension of the above packing method. Different from the above packing method, for taking advantage of the plaintext space R_{t} ’s ring structure and richer computations over packed ciphertexts, we provide four types of packed ciphertexts. Then, we define our new packing method as follows.

Definition 1 (Four types of packed ciphertexts):
Towards an integer vector \overrightarrow {B_{j}}=(b_{j,0},\ldots,b_{j,z-1})\in R_{t} of length z , where 0\leq j\leq k-1 . Then we form another integer vector \overrightarrow {B}=(b_{0,0},\ldots,b_{0,z-1},\ldots,b_{k-1,0},\ldots,b_{k-1,z-1})\in R_{t} of length zk . We define the following four types of polynomials in the ring R=\mathbb {Z}[x]/(x^{N}+1) and set N\geq 2zk , where N is the degree parameter:\begin{align*} \begin{cases} pm_{1}(\overrightarrow {B_{j}})=\sum \limits _{i=0}^{z-1}b_{j,i}x^{i}\\ pm_{2}(\overrightarrow {B_{j}})=-\sum \limits _{i=0}^{z-1}b_{j,i}x^{N-i}\\ pm_{3}(\overrightarrow {B})=\sum \limits _{j=0}^{k-1}\sum \limits _{i=0}^{z-1}b_{j,i}x^{i+jz}\\ pm_{4}(\overrightarrow {B})=-\sum \limits _{j=0}^{k-1}\sum \limits _{i=0}^{z-1}b_{j,i}x^{N-(i+jz)} \end{cases}\tag{19}\end{align*}
View SourceThese four polynomials are considered as four elements of R_{t} for sufficiently large t , and then we define \begin{align*} \begin{cases} ct_{pack}^{(i)}(\overrightarrow {B_{j}})=Enc(pm_{i}(\overrightarrow {B_{j}}),pk) & {for}~{i=1,2}\\ ct_{pack}^{(i)}(\overrightarrow {B})=Enc(pm_{i}(\overrightarrow {B}),pk) & {for}~{i=3,4} \end{cases}\end{align*}
View SourceRight-click on figure for MathML and additional features.as packed ciphertexts of the four types of polynomials.

The above definition shows that we can pack vectors \overrightarrow {B_{j}} and \overrightarrow {B} of less than \frac {N}{\beta } length into four ciphertexts ct_{pack}^{(i)}(\overrightarrow {B_{j}}) for i=1,2 and ct_{pack}^{(i)}(\overrightarrow {B}) for i=3,4 , when we want to perform homomorphic multiplication \beta times. Therefore, our new packaging method can significantly reduce the size of encrypted data comparing to the component-wise encryption. In addition, our four types of packed ciphertexts can be freely combined to provide various efficient secure computations.

B. Secure Computations Over Packed Ciphertexts
The above subsection shows that we can effectively carry out some secure computations over packed ciphertexts through our new packing method. In the below, we’ll describe secure computations discussed in Section IV and exhibition how to calculate them over packed ciphertexts, which are all performed in R=\mathbb {Z}[x]/(x^{N}+1) .

1) Secure sum Computation:
We begin with an efficient secure computation for sum as follows:

Theorem 1 (Secure sum):
Let \overrightarrow {M_{j}}=(m_{j,0},\ldots,m_{j,z-1}) and \overrightarrow {V_{z}}=(1,\ldots,1) be two integer vectors with length z . We assume ct=ct_{pack}^{(1) }(\overrightarrow {M_{j}})\otimes ct_{pack}^{(2) }(\overrightarrow {V_{z}}) and the constant term of Dec(ct,sk)\in R_{t} is denoted as M_{con} . Then, we have M_{con}\equiv \sum _{i=0}^{z-1}m_{j,i}\,\,mod\,\,t , if ct satisfies the condition of Lemma 1. Namely, for sufficiently large t , the decryption result’s constant term corresponds to the sum of m_{j,i}\,\,(i\in [{0,z-1}]) .

Proof:
The ct_{pack}^{(1) }(\overrightarrow {M_{j}})\otimes ct_{pack}^{(2) }(\overrightarrow {V_{z}}) corresponds to pm_{1}(\overrightarrow {M_{j}})\cdot pm_{2}(\overrightarrow {V_{z}}) in the ring R_{t} , as the homomorphic operations on ciphertexts corresponding to the ring structure of R_{t} . Because x^{N}=-1 in R_{t} [41], the polynomial homomorphic multiplication pm_{1}(\overrightarrow {M_{j}})\cdot pm_{2}(\overrightarrow {V_{z}}) is equal to \begin{align*}&\left({\sum _{i=0}^{z-1}m_{j,i}x^{i}}\right)\cdot \left({-\sum _{i=0}^{z-1}x^{N-i}}\right)\\=&-\sum _{i=0}^{z-1}m_{j,i}x^{N}+(the~other~terms)\\=&\sum _{i=0}^{z-1}m_{j,i}+(non-constant~terms).\end{align*}
View SourceRight-click on figure for MathML and additional features.The previous equation represents that the constant term of the polynomial pm_{1}(\overrightarrow {M_{j}})\cdot pm_{2}(\overrightarrow {V_{z}}) is equal to the sum of m_{j,i}\,\,(i\in [{0,z-1}]) . Thus, if ct is correct, the Theorem 1 holds.

Theorem 1 reveals that only one time homomorphic multiplication of packed ciphertexts is needed for us to compute the sum of m_{j,i}\,\,(i\in [{0,z-1}]) by our new packing method. In fact, the result of Theorem 1 holds if we take our new packing method’s first two types in Definition 1.

2) Secure Inner Product Computation:
We represent an efficient secure computation for inner product as follows:

Theorem 2 (Secure inner product):
We assume two integral vectors of length z be \overrightarrow {M_{j}}=(m_{j,0},\ldots,m_{j,z-1}) and \overrightarrow {P_{j}}=(price_{j,0},\ldots,price_{j,z-1}) . Given two packed ciphertexts ct_{pack}^{(1) }(\overrightarrow {M_{j}}) and ct_{pack}^{(2) }(\overrightarrow {P_{j}}) , they follow from Theorem 1 that for sufficiently large t , the constant term of the decryption result gives the inner product \langle \overrightarrow {M_{j}},\overrightarrow {P_{j}}\rangle .

Proof:
Similar to the discussion in the proof of Theorem 1, because x^{N}=-1 in R_{t} [41], the polynomial homomorphic multiplication pm_{1}(\overrightarrow {M_{j}})\cdot pm_{2}(\overrightarrow {P_{j}}) is equal to \begin{align*}&\left({\sum _{i=0}^{z-1}m_{j,i}x^{i}}\right)\cdot \left({-\sum _{i=0}^{z-1}price_{j,i}x^{N-i}}\right)\\=&-\sum _{i=0}^{z-1}m_{j,i}\cdot price_{j,i}x^{N}+(the~other~terms)\\=&\langle \overrightarrow {M_{j}},\overrightarrow {P_{j}}\rangle +(non-constant~terms).\end{align*}
View SourceThe previous equation shows that the constant term of the polynomial pm_{1}(\overrightarrow {M_{j}})\cdot pm_{2}(\overrightarrow {P_{j}}) is equal to the inner product \langle \overrightarrow {M_{j}},\overrightarrow {P_{j}}\rangle . Thus if ct is correct, the Theorem 2 holds.

Theorem 2 shows that only one time homomorphic multiplication of packed ciphertexts is needed for us to calculate the inner product between \overrightarrow {M_{j}} and \overrightarrow {P_{j}} with length z by our new packing method. In fact, the result of Theorem 2 holds if we take our new packing method’s first two types in Definition 1.

3) Secure one-way ANOVA Computation:
We show an efficient secure computation for one-way ANOVA as follows:

Theorem 3 (Secure one-way ANOVA):
We assume two integer vectors with length z be \overrightarrow {M_{j}}=(m_{j,0},\ldots,m_{j,z-1}) and \overrightarrow {V_{z}}=(1,\ldots,1) , where 0\leq j\leq k-1 , and let \overrightarrow {M}=(m_{0,0},\ldots,m_{0,z-1},\ldots,m_{k-1,0},\ldots,m_{k-1,z-1}) and \overrightarrow {V_{zk}}=(1,\ldots,1) be two integer vectors with length zk . Given three coupled packed ciphertexts ct_{pack}^{(1) }(\overrightarrow {M_{j}}) and ct_{pack}^{(2) }(\overrightarrow {V_{z}}) , ct_{pack}^{(3) }(\overrightarrow {M}) and ct_{pack}^{(4) }(\overrightarrow {V_{zk}}) , ct_{pack}^{(3) }(\overrightarrow {M}) and ct_{pack}^{(4) }(\overrightarrow {M}) , they follow from Theorem 1 that for sufficiently large t , the constant terms of the decryption results give the \sum _{i=0}^{z-1}m_{j,i} , \sum _{j=0}^{k-1}\sum _{i=0}^{z-1}m_{j,i} and \sum _{j=0}^{k-1}\sum _{i=0}^{z-1}m_{j,i}^{2} . Then, we can derive SS_{B} and SS_{W} from the Equation (7) and (8) over plaintexts. At last, we compute the F value of F -test as F=\frac {SS_{B}/(k-1)}{SS_{W}/(z-k)} .

Proof:
Similar to the discussion in the proof of Theorem 1, as x^{N}=-1 in R_{t} [41], pm_{3}(\overrightarrow {M})\cdot pm_{4}(\overrightarrow {V_{zk}}) is equal to \begin{align*}&\left({\sum _{j=0}^{k-1}\sum _{i=0}^{z-1}m_{j,i}x^{i+jz}}\right)\cdot \left({-\sum _{j=0}^{k-1}\sum _{i=0}^{z-1}x^{N-(i+jz)}}\right)\\=&-\sum _{j=0}^{k-1}\sum _{i=0}^{z-1}m_{j,i}x^{N}+(the~other~terms)\\=&\sum _{j=0}^{k-1}\sum _{i=0}^{z-1}m_{j,i}+(non-constant~terms).\end{align*}
View SourceThe polynomial pm_{3}(\overrightarrow {M})\cdot pm_{4}(\overrightarrow {M}) is equal to \begin{align*}&\left({\sum _{j=0}^{k-1}\sum _{i=0}^{z-1}m_{j,i}x^{i+jz}}\right)\cdot \left({-\sum _{j=0}^{k-1}\sum _{i=0}^{z-1}m_{j,i}x^{N-(i+jz)}}\right)\\=&-\sum _{j=0}^{k-1}\sum _{i=0}^{z-1}m_{j,i}^{2}x^{N}+(the~other~terms)\\=&\sum _{j=0}^{k-1}\sum _{i=0}^{z-1}m_{j,i}^{2}+(non-constant~terms).\end{align*}
View SourceThe previous equations shows that the constant terms of the polynomials pm_{3}(\overrightarrow {M})\cdot pm_{4}(\overrightarrow {V_{zk}}) and pm_{3}(\overrightarrow {M})\cdot pm_{4}(\overrightarrow {M}) are equal to the \sum _{j=0}^{k-1}\sum _{i=0}^{z-1}m_{j,i} and \sum _{j=0}^{k-1}\sum _{i=0}^{z-1}m_{j,i}^{2} respectively. According to the Theorem 1, the constant term of the polynomial pm_{1}(\overrightarrow {M_{j}})\cdot pm_{2}(\overrightarrow {V_{z}}) is equal to \sum _{i=0}^{z-1}m_{j,i} (j\in [{0,k-1}] ), we can get \sum _{j=0}^{k-1}\left({\sum _{i=0}^{z-1}m_{j,i}}\right)^{2} over plaintexts. And then, we derive SS_{B} and SS_{W} by computing the Equation (7) and (8) over plaintexts. At last, we compute the F value of F -test as F=\frac {SS_{B}/(k-1)}{SS_{W}/(z-k)} . Thus, if ct_{1,j} , ct_{2} and ct_{3} are correct, the Theorem 3 holds.

Theorem 3 shows that only k+2 times homomorphic multiplication of packed ciphertexts are needed for us to compute the one-way ANOVA by our new packing method. In fact, the result of Theorem 3 holds if we take our new packing method’s four types in Definition 1.

4) Secure min Computation:
From Section IV(E), we can get min aggregation by the sum aggregation. According to the Theorem 1, we can calculate the sum aggregation by only one time homomorphic multiplication of packed ciphertexts by our packing method. Thus, by our packing method, the sum-based min aggregation protocol is efficient. For the Hamming-distance-based min aggregation protocol, we show an efficient secure Hamming distance computation as follows:

Theorem 4 (Secure Hamming distance computation):
We assume three vectors of length w+1 be \overrightarrow {V_{w+1}}=(1,\ldots,1) , \overrightarrow {FM}=(FM_{0},\ldots,FM_{w}) and \overrightarrow {R}=(R_{0},\ldots,R_{w}) . Given three coupled packed ciphertexts ct_{pack}^{(1) }(\overrightarrow {FM}) and ct_{pack}^{(2) }(\overrightarrow {V_{w+1}}) , ct_{pack}^{(1) }(\overrightarrow {R}) and ct_{pack}^{(2) }(\overrightarrow {V_{w+1}}) , ct_{pack}^{(1) }(\overrightarrow {FM}) and ct_{pack}^{(2) }(\overrightarrow {R}) , they follow from Theorem 1 that for sufficiently large t , the constant terms of the decryption results give the \sum _{l=0}^{w}FM_{l} , \sum _{l=0}^{w}R_{l} and \sum _{l=0}^{w}FM_{l}\cdot R_{l} . And then, we can derive d_{H}(\overrightarrow {FM},\overrightarrow {R}) from the Equation (17) over plaintexts.

Proof:
Similar to the discussion in the proof of Theorem 1, the constant terms of the polynomials pm_{1}(\overrightarrow {FM})\cdot pm_{2}(\overrightarrow {V_{w+1}}) and pm_{1}(\overrightarrow {R})\cdot pm_{2}(\overrightarrow {V_{w+1}}) are equal to \sum _{l=0}^{w}FM_{l} and \sum _{l=0}^{w}R_{l} . According to the Theorem 2, the constant term of the polynomial pm_{1}(\overrightarrow {FM})\cdot pm_{2}(\overrightarrow {R}) is equal to \sum _{l=0}^{w}FM_{l}\cdot R_{l} . And then, we can derive d_{H}(\overrightarrow {FM},\overrightarrow {R}) by computing the Equation (17) over plaintexts. Thus, if ct_{1} , ct_{2} and ct_{3} are correct, the Theorem 4 holds.

Theorem 4 shows that only three times homomorphic multiplication of packed ciphertexts are needed for us to compute the Hamming distance by our new packing method. In fact, the result of Theorem 4 holds if we take our new packing method’s first two types in Definition 1. Therefore, the Hamming-distance-based min aggregation protocol is also efficient by our packing method.

C. Improving Packing Method
From the Definition 1, our new packing method is only applicable to process vectors with small entries. And large entries in vectors will lead the parameter t to be considerably large in our new packing method, which would cause the performance of encryption scheme to slow down [47], as we enforced to set parameters N and q to be considerably large for security and correctness [12]. For example, for secure inner product in Theorem 2, we should take \begin{equation*} \langle \overrightarrow {M_{j}},\overrightarrow {P_{j}}\rangle =\sum _{i=0}^{z-1}m_{j,i}\cdot price_{j,i}\leq t.\tag{20}\end{equation*}
View SourceAs m_{j,i} and price_{j,i} are two integers with w bits, the parameter t must to be taken at least 2^{w}\cdot 2^{w}\cdot z . In the below, we will improve our new packing method for vectors with large entries, especially, it will be practical for secure one-way ANOVA, where vectors with large entries.

1) Definition of our Improved Packing Method:
Our improved packing method is defined as follows.

Definition 2 (Two types of improved packed ciphertexts):
We set \overrightarrow {B}=(B_{0},\ldots,B_{z-1})\in R_{t} be an integer vector of length z , where each B_{i} is at most w bits. And then each integer entry B_{i} will be wrote in the r -based representation, where r\geq 2 is a chosen integer and we set r equal to 2 in general. In other word, we have \begin{equation*} B_{i}=\sum _{u=0}^{l-1}b_{i,u}r^{u},\tag{21}\end{equation*}
View SourceRight-click on figure for MathML and additional features.where l=\lceil log_{r}2^{w}\rceil and b_{i,u}\in [{0,r-1}] . By this way, the above integer vector will be transformed into \overrightarrow {B}=(b_{0,0},\ldots,b_{0,l-1},\ldots,b_{z-1,0},\ldots,b_{z-1,l-1})\in R_{t} of length lz . Different from Definition 1, in the ring R=\mathbb {Z}[x]/(x^{N}+1) , two types of polynomials are defined as follows and N\geq 2lz , where N is the degree parameter:\begin{align*} \begin{cases} pm_{1,r}(\overrightarrow {B})=\sum \limits _{i=0}^{z-1}\left({\sum \limits _{u=0}^{l-1}b_{i,u}x^{u}}\right)x^{i\cdot l}\\ pm_{2,r}(\overrightarrow {B})=-\sum \limits _{i=0}^{z-1}\left({\sum \limits _{u=0}^{l-1}b_{i,u}x^{u}}\right)x^{N-i\cdot l} \end{cases}\tag{22}\end{align*}
View SourceThese two polynomials are considered as two elements of R_{t} for sufficiently large t , and then for i=1,2 , we define \begin{equation*} ct_{pack}^{(i,r)}(\overrightarrow {B})=Enc(pm_{i,r}(\overrightarrow {B}),pk)\end{equation*}
View Sourceas the two types of improved packed ciphertexts.

Note that, from the Equation (21), if we substitute x by r , we know that \sum _{u=0}^{l-1}b_{i,u}x^{u} is equal to the integer B_{i} . And then, in Definition 2, the two polynomials are correspond to \begin{equation*} \sum _{i=0}^{z-1}B_{i}x^{i\cdot l}~and\,\,-\sum _{i=0}^{z-1}B_{i}x^{N-i\cdot l},\end{equation*}
View Sourcerespectively, and which are very similar to the ones in Definition 1. In other word, for the first two polynomials of Definition 1, the l -th power of x is our main trick, and the efficiency of which will be shown in Section V(C) 3).

2) Secure Inner Product Computation Using Improved Packing Method:
Similarly, the secure inner product computation is achieved by improved packing method as follows. Let \overrightarrow {M_{j}}=(m_{j,0},\ldots,m_{j,z-1}) and \overrightarrow {P_{j}}=(price_{j,0},\ldots,price_{j,z-1}) be two integer vectors with length z , where entries m_{j,i} , price_{j,i} of at most w bits. We set m_{j,i}(x)=\sum _{u=0}^{l-1}m_{j,i,u}x^{u} and price_{j,i}(x)=\sum _{u=0}^{l-1}price_{j,i,u}x^{u} , and N\geq 2zl . Because x^{N}=-1 in R_{t} [41], pm_{1,r}(\overrightarrow {M_{j}})\cdot pm_{2,r}(\overrightarrow {P_{j}}) is equal to \begin{align*}&\left({\sum _{i=0}^{z-1}m_{j,i}(x)x^{i\cdot l}}\right)\cdot \left({-\sum _{i=0}^{z-1}price_{j,i}(x)x^{N-i\cdot l}}\right)\\=&\sum _{i=0}^{z-1}m_{j,i}(x)\cdot price_{j,i}(x)+(the~other~terms)\\ \mathop {=}^{x=r}&\sum _{i=0}^{z-1}m_{j,i}(r)\cdot price_{j,i}(r)+(the~other~terms)\\=&\langle \overrightarrow {M_{j}},\overrightarrow {P_{j}}\rangle +(non-constant~terms).\end{align*}
View SourceCorrectness: If we substitute x by r for the polynomial \sum _{i=0}^{z-1}m_{j,i}(x)\cdot price_{j,i}(x) , and it is corresponding to \begin{align*}&\sum _{i=0}^{z-1}m_{j,i}(r)\cdot price_{j,i}(r)\\=&\sum _{i=0}^{z-1}\left({\sum _{u=0}^{l-1}m_{j,i,u}r^{u}}\right)\cdot \left({\sum _{u=0}^{l-1}price_{j,i,u}r^{u}}\right)\\=&\sum _{i=0}^{z-1}m_{j,i}\cdot price_{j,i}=\langle \overrightarrow {M_{j}},\overrightarrow {P_{j}}\rangle\end{align*}
View SourceRight-click on figure for MathML and additional features.by the Equation (21) in the r -based representation.

Therefore, only one time homomorphic multiplication between pm_{1,r}(\overrightarrow {M_{j}}) and pm_{2,r}(\overrightarrow {P_{j}}) is needed for us to compute the inner product \langle \overrightarrow {M_{j}},\overrightarrow {P_{j}}\rangle by our improved packing method.

3) The Efficiency of Our Improved Packing Method:
For acquiring the desired secure inner product computation in Section V(C) 2), we should take \begin{equation*} \sum _{i=0}^{z-1}\sum _{u=0}^{l-1}m_{j,i,u}\cdot price_{j,i,u}\leq (r-1)^{2}\cdot l\cdot z\leq t,\tag{23}\end{equation*}
View SourceRight-click on figure for MathML and additional features.where l=\lceil log_{r}2^{w}\rceil , and m_{j,i,u} , price_{j,i,u}\in [{0,r-1}] . And then, the strength of our improved packing method is that regardless of the size of each entry w , we only need to choose the parameter r to control the size of the parameter t . As the inner product \langle \overrightarrow {M_{j}},\overrightarrow {P_{j}}\rangle in Section V(C) 2) can be obtained under the condition of Equation (23), the parameter t can be controlled to be considerably small, if we choose a small parameter r (r\geq 2 ). Specially, we can always choose r=2 , and then t\geq w\cdot z . Therefore, our improved packing method is very suitable for vectors with large entries.

SECTION VI.Security Analysis
As described in Section III(D), our proposed PDA scheme is based on the PLWE assumption [38]. Here, we first define the PLWE assumption [47]. Then, we prove that our proposed PDA scheme is secure under our attack models by presenting three Theorems. At last, we analyze some security issues involved in our proposed scheme.

Definition 3 (The PLWE Assumption):
For given parameters (\kappa,N,q,t,\sigma) , the PLWE assumption PLWE_{\kappa,N,q,t,\chi } (in the noise-scaled Hermite normal form) states that the following two distributions are infeasible to distinguish:

One draws (a_{i},b_{i}) uniformly from (R_{q})^{2} .

One first samples s\leftarrow \chi =D_{\mathbb {Z}^{N},\sigma } uniformly, and then picks (a_{i},b_{i})\in (R_{q})^{2} by drawing b_{i}\leftarrow R_{q} uniformly, t\leftarrow \mathbb {Z}_{q}^{*} (t and q are relatively prime), e_{i}\leftarrow \chi and calculating a_{i}=-(b_{i}\cdot s+t\cdot e_{i}) .

Theorem 5 (Defense against CPA):
For given parameters (\kappa,N,q,t,\sigma) , our proposed PDA scheme is semantic secure against CPA under the PLWE assumption.

Proof:
For given parameters (\kappa,N,q,t,\sigma) , and \tilde {b}\in \{0,1\} . If \tilde {b}=0 , one draws (a_{i},b_{i}) uniformly from (R_{q})^{2} . While if \tilde {b}=1 , one first samples s\leftarrow \chi =D_{\mathbb {Z}^{N},\sigma } uniformly, and then picks (a_{i},b_{i})\in (R_{q})^{2} by drawing b_{i}\leftarrow R_{q} uniformly, t\leftarrow \mathbb {Z}_{q}^{*} , e_{i}\leftarrow \chi and calculating a_{i}=-(b_{i}\cdot s+t\cdot e_{i}) . Therefore, given (\kappa,N,q,t,\sigma) and (a_{i},b_{i}) , the PLWE problem is to guess \tilde {b} . We assume that the semantic security of ct=Enc(m,pk) in our proposed PDA scheme can be broken by a polynomial-time adversary \mathscr {A} with a non-negligible advantage \epsilon . Moreover, another adversary \mathscr {B} will be structured, which can break the PLWE problem with a non-negligible advantage and has access to \mathscr {A} .

At first, for given parameters (\kappa,N,q,t,\sigma) , when \tilde {b}=1 , the \mathscr {B} picks an element s\leftarrow \chi , chooses a_{1}\leftarrow R_{q} as a random element and e\leftarrow \chi as an error. Then, sk=s is the private key, computing a_{0}=-(a_{1}\cdot s+t\cdot e) , and pk=(a_{0},a_{1}) is the public key. When \tilde {b}=0 , the \mathscr {B} draws pk=(a_{0},a_{1}) uniformly from (R_{q})^{2} . Here, in the view of \mathscr {A} , the simulated pk is indistinguishable from the real pk .

Secondly, after receiving pk=(a_{0},a_{1}) , the \mathscr {A} chooses two plaintexts m_{0},m_{1}\in R_{t} and returns them to \mathscr {B} . Subsequently, the \mathscr {B} first chooses three elements u,f,g\leftarrow \chi and picks b^{*}\in \{0,1\} , then sends ciphertext ct\leftarrow Enc(m_{b^{*}},pk) to \mathscr {A} .

Finally, upon receiving ct , the \mathscr {A} sends b'\in \{0,1\} to \mathscr {B} as the guess of b^{*} . If b'=b^{*} , the \mathscr {B} then guesses \tilde {b}=1 . Obviously, when \tilde {b}=1 , ct becomes a valid ciphertext, the \mathscr {A} has the probability \frac {1}{2}+\epsilon to guess b^{*} correctly, and Pr[\mathscr {B}\,\,success|\tilde {b}=1]=\frac {1}{2}+\epsilon . While if \tilde {b}=0 , ct is independent with b^{*} due to the public key pk=(a_{0},a_{1}) draws uniformly from (R_{q})^{2} . Therefore, Pr[\mathscr {B}\,\, success|\tilde {b}=0]=\frac {1}{2} . Combining the above two situations, we obtain \begin{equation*} Pr[\mathscr {B}~ success]=\frac {1}{2}\cdot \frac {1}{2}+\frac {1}{2}\cdot \left({\frac {1}{2}+\epsilon }\right)=\frac {1}{2}+\frac {\epsilon }{2}.\end{equation*}
View SourceThe above result conflicts with the assumption that PLWE problem is hard, since \epsilon is non-negligible. As a consequence, our proposed PDA scheme is semantic secure against CPA under the PLWE assumption.

We will first define some useful symbols, and formally describing the specific proof process later. In this article, the view of an entity is defined as all messages obtained from other entities and its internal state (such as randomness and inputs). In particular, for given parameters N , q , t and \chi , the real view can be denoted as VIEW_{REAL}^{N,q,t,\chi }(\mathbb {INF},\mathbb {SI},\mathbb {CRG},\mathbb {PRA},\mathbb {SRR}) , where \mathbb {INF} represents information that can be accessed. We also use \mathbb {U} to indicate the whole customer set, \mathbb {U}_{know}\subseteq \mathbb {U} to denote those customers, whose plaintexts and corresponding ciphertexts have been known in the KPA model. Next we will come up with two Theorems as follows.

Theorem 6 (Defense against KPA):
For given parameters (N,q,t,\chi) , pk , m_{i} and ct_{i} (i\in \mathbb {U}_{know}\subseteq \mathbb {U} ), there is a polynomial-time simulator SIM whose output is indistinguishable from the output of real view.\begin{align*}&VIEW_{SIM}^{N,q,t,\chi }(pk,m_{i},ct_{i},\mathbb {SI},\mathbb {CRG},\mathbb {PRA},\mathbb {SRR})\\&\approx \\&VIEW_{REAL}^{N,q,t,\chi }(pk,m_{i},ct_{i},\mathbb {SI},\mathbb {CRG},\mathbb {PRA},\mathbb {SRR})\end{align*}
View SourceRight-click on figure for MathML and additional features.

Proof:
In the KPA model, the SIM can access a lot of pairs of plaintexts (customers’ electricity usage data) and their corresponding ciphertexts, and also know the public key pk=(a_{0},a_{1}) . Then, the SIM will try to recover the encryption algorithm, other customers’ plaintexts m_{i} (i\in \mathbb {U}/\mathbb {U}_{know} ), private key s , and random factors u , f , g . As proved in Theorem 5, our proposed PDA scheme is semantically secure under the PLWE assumption. Moreover, s , u , f , g are all chosen from the discrete Gaussian error distribution \chi , recovering those random factors is equivalent to solving the PLWE problem. Without those random factors, the SIM is unable to expose other customers’ plaintexts, which means that customers’ privacy data are protected in our proposed PDA scheme. Therefore, in the KPA model, the SIM is infeasible to extract any additional information, and the simulated view of SIM is indistinguishable from the output of real view.

Theorem 7 (Defense against COA):
For given parameters (N,q,t,\chi) , pk and ct_{i} (i\in \mathbb {U} ), there is a simulator SIM whose output is indistinguishable from the output of real view.\begin{align*}&VIEW_{SIM}^{N,q,t,\chi }(pk,ct_{i},\mathbb {SI},\mathbb {CRG},\mathbb {PRA},\mathbb {SRR})\\&\approx \\&VIEW_{REAL}^{N,q,t,\chi }(pk,ct_{i},\mathbb {SI},\mathbb {CRG},\mathbb {PRA},\mathbb {SRR})\end{align*}
View SourceRight-click on figure for MathML and additional features.

Proof:
Different from CPA and KPA models, the SIM can only access to some ciphertexts and the public key pk=(a_{0},a_{1}) in the COA model. Then, the SIM will try to recover the encryption algorithm, customers’ plaintexts m_{i} (i\in \mathbb {U} ), private key s , and random factors u , f , g . As shown in Theorem 5 and 6, our proposed PDA scheme can defense against both CPA and KPA, therefore, defense against COA is also satisfied. Since the proof process is similar to Theorem 6, the detailed proof process will be omitted here.

At last, we analyze some security issues involved in our proposed scheme. In order to preserve customer’s private electricity usage data from being leaked by \mathscr {A} .

\mathscr {A} cannot disclose electricity usage data of customers, even if he can eavesdrop on communication flows. As shown in Section III(B), \mathscr {A} may eavesdrop on communication flows from customers to fog nodes. Particularly, even if \mathscr {A} can wiretap the ciphertext ct_{\gamma } of customer U at the time point tp_{\gamma } and know the corresponding public key pk , he cannot obtain U ’s private electricity usage data m_{\gamma } , as our proposed PDA scheme is secure against CPA and COA according to Theorem 5 and Theorem 7 respectively. Therefore, even if \mathscr {A} may eavesdrop on communication flows from customers to fog nodes, he cannot disclose electricity usage data of customers.

\mathscr {A} cannot deduce electricity usage data of uncompromised customers, even if he can compromise some customers by illegal means. In our threat model, \mathscr {A} can compromise some customers directly and breach their privacy. However, since there are a lot of customers in the fog-based smart grid, it is unlikely for \mathscr {A} to choose this method. In addition, after acquiring the privacy (i.e. private keys and electricity usage data) from the compromised customers, \mathscr {A} may try to deduce the privacy of uncompromised customers. Nevertheless, this attempt will not be succeed, as our proposed PDA scheme is secure against KPA according to Theorem 6, each customer’s private key and electricity usage data are generated independently and learning one customer’s privacy reveal nothing about others. Specially, if there are n customers and \mathscr {A} have obtained n-1 customers’ privacy, the last customer’s privacy still cannot be breached, since the sum of n customers’ private keys and electricity usage data are transparent to \mathscr {A} . Therefore, even if \mathscr {A} can compromise some customers directly, the electricity usage data of uncompromised customers will not be deduced.

\mathscr {A} cannot expose customers’ electricity usage data, even if he can intrude into the databases of the CC and fog nodes to steal the stored data. The fog node will receive a lot of ciphertexts from customers at one time point, in the privacy-preserving report aggregation phase. Then, he aggregates them directly instead of decrypts them, and reports the aggregated ciphertext to the CC for further calculation. Even though \mathscr {A} can intrude into the database of the fog node to steal the stored data, he can only obtain customers’ ciphertexts and the aggregated ciphertext. Any customers’ private electricity usage data will not be revealed, as our proposed PDA scheme is secure against CPA and COA according to Theorem 5 and Theorem 7 respectively. Similarly, even though \mathscr {A} can intrude into the database of the CC, he can only get aggregations of customers’ electricity usage data, which do not expose individual customer’s electricity usage data at all. Above all, even if \mathscr {A} can intrude into the databases of the CC and fog nodes to steal the stored data, he cannot expose customers’ electricity usage data.

SECTION VII.Performance Evaluation
In this section, we analyze the performance of our proposed scheme in terms of computation, communication and storage overheads. We compare our sum, inner product and one-way ANOVA aggregation protocols with PPM-HDA [17] and PPMA [20] in the computation overhead. Then we compare our min aggregation protocols with PPM-HDA [17], PDMDA [6] and PTAA [19] in the communication and storage overheads.

A. The Computation Overhead Comparison
As the computation overhead of our proposed scheme is intuitively the same as that of PPM-HDA [17] and PPMA [20] in term of individual customer. Therefore, in this subsection, we focus on comparing the computation overheads of sum, inner product and one-way ANOVA aggregation protocols with that of PPM-HDA and PPMA in term of the fog node. Then, we compare the computation overheads of our four min aggregation protocols in term of the fog node. Let T_{pair} be the time of a bilinear map operation, T_{mul} be the time of homomorphic multiplication operation, T_{add} be the time of homomorphic addition operation.

Computation overhead of sum aggregation protocol: For our PDA-SP, in the privacy-preserving report aggregation phase, the fog node needs to calculate the encrypted sum aggregation with (z-1)T_{add} . For our PDA-PM, with the help of packing method, the fog node only needs T_{mul} according to Theorem 1. For PPM-HDA and PPMA, the fog node needs (z-1)T_{mul} .

Computation overhead of inner produce aggregation protocol: For our PDA-SP, in the privacy-preserving report aggregation phase, the fog node needs to calculate the encrypted inner product aggregation with (z-1)T_{add} and zT_{mul} . For our PDA-PM, the fog node only needs T_{mul} according to Theorem 2. For PPM-HDA and PPMA, the fog node needs (z-1)T_{mul} and zT_{pair} .

Computation overhead of one-way ANOVA aggregation protocol: For our PDA-SP, in the privacy-preserving report aggregation phase, the fog node needs to calculate the Equation (9) with (z+k-2)T_{add} and kT_{mul} , compute the Equation (10) with (zk-1)T_{add} and T_{mul} , calculate Equation (11) with (zk-1)T_{add} and kzT_{mul} . Therefore, the fog node needs (z+k+2zk-4)T_{add}+(k+zk+1)T_{mul} in total. For our PDA-PM, the fog node only needs (k+2)T_{mul} according to Theorem 3. For PPM-HDA and PPMA, the fog node needs (z+zk-2)T_{mul} and (k+zk)T_{pair} .

Computation overhead of min aggregation protocol: In Section IV(E), we propose four min aggregation protocols, including the basic sum-based min aggregation protocol (B-SUM), the extended sum-based min aggregation protocol (E-SUM), the basic Hamming-distance-based min aggregation protocol (B-HDB) and the extended Hamming-distance-based min aggregation protocol (E-HDB). For B-SUM, the fog node needs to use the sum aggregation protocol t+1 times, thus it takes (t+1)(z-1)T_{add} in our PDA-SP, and takes (t+1)T_{mul} in our PDA-PM. For E-SUM, the fog node needs to use the sum aggregation protocol \lceil log(z+1)\rceil +1 times, thus it takes (\lceil log(z+1)\rceil +1)(z-1)T_{add} in our PDA-SP, and takes (\lceil log(z+1)\rceil +1)T_{mul} in our PDA-PM. For B-HDB and E-HDB, Algorithm 3 takes (3w+2)T_{add}+(w+1)T_{mul} in our PDA-SP, and takes 3T_{mul} in our PDA-PM according to the Theorem 4. According to the Algorithm 2, the fog node needs to calculate Algorithm 3\,\,\eta (w+1) times on average for one loop in B-HDB (and \frac {\eta (w+1)}{2} times on average for one loop in E-HDB), and there is zw loops in Algorithm 1. Furthermore, the average of \eta is equal to \frac {w+1}{w} according to the Algorithm 1. Therefore, for B-HDB, the fog node takes zw\eta (w+1)(3w+2)T_{add}+zw\eta (w+1)(w+1)T_{mul}=z(w+1)^{2}(3w+2)T_{add}+z(w+1)^{3}T_{mul} on average in our PDA-SP, and takes 3z(w+1)^{2}T_{mul} on average in our PDA-PM. For E-HDB, the fog node takes \frac {z}{2}(w+1)^{2}(3w+2)T_{add}+\frac {z}{2}(w+1)^{3}T_{mul} on average in our PDA-SP, and takes \frac {3}{2}z(w+1)^{2}T_{mul} on average in our PDA-PM.

The computation overheads of PDA-SP, PDA-PM, PPM-HDA and PPMA are depicted in Table I. The computation overheads of our four min aggregation protocols are shown in Table II. Furthermore, we use the jPBC encryption library [48] running on an environment with an eclipse, macOS Sierra OS, 1.6 GHz Intel Core i7 processor, 8G RAM and 1600 MHz DDR3 to evaluate the time of every operation and implement our framework in Java. The experimental results indicate that T_{pair}=49.25ms , T_{mul}=0.19ms and T_{add}=0.014ms .

TABLE I The Comparison of Computation Overhead for PDA-SP, PDA-PM, PPM-HDA and PPMA
Table I- 
The Comparison of Computation Overhead for PDA-SP, PDA-PM, PPM-HDA and PPMA
TABLE II The Computation Overhead of our min Aggregation
Table II- 
The Computation Overhead of our min Aggregation
After obtaining the computation overheads of T_{pair} , T_{mul} and T_{add} , we first assume that k=3 . Let T_{PDA-SP} be the computation overhead of PDA-SP, T_{PDA-PM} be the computation overhead of PDA-PM, RR=\frac {T_{PDA-SP}-T_{PDA-PM}}{T_{PDA-SP}} be the reduction rate. As shown in Figure 4, the computation overheads of sum, inner product and one-way ANOVA aggregation protocols in our PDA-SP and PDA-PM are lower than that in PPM-HDA and PPMA. In addition, the reduction rates RR_{sum} , RR_{inner~product} and RR_{one-way\,\,ANOVA} reveal that the computation overheads of sum, inner product and one-way ANOVA aggregation protocols in PDA-SP are significantly reduced by using our packing method.

Fig. 4. - The variation of computation overheads for PPM-HDA, PPMA, PDA-SP and PDA-PM in terms of 
$z$
.
Fig. 4.
The variation of computation overheads for PPM-HDA, PPMA, PDA-SP and PDA-PM in terms of z .

Show All

Then, we let t=2048 and w=9 bits. Figure 5 demonstrates that the computation overheads of our sum-based min aggregation protocols are lower than that of our Hamming-distance-based min aggregation protocols, which means that our sum-based min aggregation protocols are more efficient.

Fig. 5. - The variation of computation overheads for our min aggregation protocols in terms of 
$z$
.
Fig. 5.
The variation of computation overheads for our min aggregation protocols in terms of z .

Show All

At last, Figure 6 implies that the reduction rate of inner product aggregation protocol is the highest of all the others. Moreover, the reduction rates of sum, inner product, one-way ANOVA, B-SUM and E-SUM increase as z increases, and with the increase of z , that of B-HDB and E-HDB are invariable. Therefore, our packing method gives an efficient computation of sum, inner product, one-way ANOVA and min aggregation protocols, especially for inner product and one-way ANOVA aggregation protocols.


Fig. 6.
Variation of reduction rates of sum, inner product, one-way ANOVA and min aggregation protocols in terms of z .

Show All

B. The Communication and Storage Overheads Comparison
As the communication and storage overheads of our sum, inner product and one-way ANOVA aggregation protocols are the same as that of PPM-HDA [17], PDMDA [6] and PTAA [19] in term of all z time points. Therefore, in this subsection, we focus on comparing the communication and storage overheads of our min aggregation protocols with that of PPM-HDA, PDMDA and PTAA in term of all z time points. We assume that the size of customer’s report is |ct_{\gamma }|=|Enc(m_{\gamma },pk)|=\tau =31\,\,KB (see [47] Section 4.2) at time point tp_{\gamma } . The comparisons of communication and storage overheads are shown in Table III.

TABLE III The Communication and Storage Overheads
Table III- 
The Communication and Storage Overheads
Communication and storage overheads: For B-SUM, after the customer report generation phase, each time point will report t+1 encrypted ciphertexts to the fog node, where each plaintext takes up 1 bit. Therefore, in our PDA-SP and PDA-PM, the total communication overheads of all z time points are z(t+1)\tau and (t+1)\tau respectively, the total storage overhead is z(t+1) . While for E-SUM, each time point will report \lceil log(z+1)\rceil +1 encrypted ciphertexts to the fog node, and each plaintext takes up \frac {\lceil log(z+1)\rceil (t+1)}{\lceil log(z+1)\rceil +1} bits. Therefore, in our PDA-SP and PDA-PM, the total communication overheads of all z time points are z(\lceil log(z+1)\rceil +1)\tau and (\lceil log(z+1)\rceil +1)\tau respectively, the total storage overhead is z\lceil log(z+1)\rceil (t+1) . For B-HDB/E-HDB of our PDA-SP, PPM-HDA and PDMDA, each time point will report w+1 encrypted ciphertexts to the fog node and each plaintext takes up w+1 bits. While for B-HDB/E-HDB of our PDA-PM, each time point will report 1 packed ciphertext to the fog node. Therefore, in B-HDB/E-HDB of our PDA-SP, PPM-HDA and PDMDA, the total communication overheads of all z time points are z(w+1)\tau , the total storage overheads are z(w+1)^{2} . While in B-HDB/E-HDB of our PDA-PM, the total communication overhead of all z time points is z\tau . At lastly, for PTAA, each time point will report 2 encrypted ciphertexts to the fog node and each plaintext takes up w bits. Therefore, the total communication overhead of all z time points is 2z\tau , the total storage overhead is 2zw .

On one hand, we set t=2048 , z=96 , \tau =31\,\,KB . We depict the communication overheads for our PDA-SP and PPM-HDA/DPMDA in Figure 7, and depict the communication overheads for our PDA-PM and PTAA in Figure 8. From Figure 7, it is obvious that the communication overhead of B-SUM of our PDA-SP is the highest, that of E-SUM of our PDA-SP is the lowest, that of PPM-HDA/DPMDA is higher than that of E-SUM of our PDA-SP. Figure 8 implies that the communication overhead of B-SUM of our PDA-PM is the highest, but that of E-SUM and B-HDB/E-HDB of our PDA-PM are lower than that of PTAA.

Fig. 7. - Comparison of our PDA-SP and PPM-HDA/DPMDA.
Fig. 7.
Comparison of our PDA-SP and PPM-HDA/DPMDA.

Show All

Fig. 8. - Comparison of our PDA-PM and PTAA.
Fig. 8.
Comparison of our PDA-PM and PTAA.

Show All

On the other hand, we assume that t=2048 , z=96 . We depict the storage overheads for B-SUM, E-SUM, B-HDB/E-HDB, PPM-HDA/DPMDA and PTAA in Figure 9. From Figure 9, we can conclude that the storage overheads of B-SUM and E-SUM are higher than that of B-HDB/E-HDB, PPM-HDA/DPMDA and PTAA. Especially, that of E-SUM is the highest. Thus, in E-SUM, we reduce the computation and communication overheads by increasing storage overhead, that is trading off the storage overhead for computation and communication overheads.

Fig. 9. - The comparison of storage overheads.
Fig. 9.
The comparison of storage overheads.

Show All

SECTION VIII.Conclusion
In this article, we have proposed a smart and practical PDA scheme with smart pricing and packing method for fog-based smart grids, which achieved multifunctional statistics, diversified tariffs and efficiency. At first, we have presented a scheme named PDA-SP. With PDA-SP, the CC could provide diversiform pricing strategies, choose a double-winning strategy, and compute more complex and higher-order statistic functions to provide various services. Second, we have presented a scheme named PDA-PM, which could reduce the size of encrypted data and improve performance in performing various secure computations. Moreover, the improved version also could handle general vectors with large entries. At last, the security analysis showed that our proposed scheme was secure against many threats, and the performance evaluation revealed that our proposed scheme was lightweight and efficient.

For our future work, we will employ multiple hamming distances and batch comparisons to further reduce the computation overheads of our min aggregation protocols. In addition, we will explore how to use other packing methods to perform secure computations.